<?xml version="1.0"?>
<doc>
    <assembly>
        "Rhino_DotNet"
    </assembly>
    <members>
        <member name="M:RMA.Rhino.MRhinoUtilityPlugIn.SetPointers(CRhinoUtilityPlugIn!System.Runtime.CompilerServices.IsConst*,CRhinoUtilityPlugIn*)">
MRhinoUtilityPlugIn
</member>
        <member name="M:RMA.Rhino.MRhinoFileExportPlugIn.SetPointers(CRhinoFileExportPlugIn!System.Runtime.CompilerServices.IsConst*,CRhinoFileExportPlugIn*)">
MRhinoFileExportPlugIn
</member>
        <member name="M:RMA.Rhino.MRhinoFileImportPlugIn.SetPointers(CRhinoFileImportPlugIn!System.Runtime.CompilerServices.IsConst*,CRhinoFileImportPlugIn*)">
MRhinoFileImportPlugIn
</member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.RestoreDepthBuffer">
            <returns>true if a saved depth buffer was successfully restored to the engine depth buffer</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.SaveDepthBuffer">
            <returns>
true is this engine successfully saved the depth buffer information to a location
that can be retrieved at a later time
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.CanSaveDepthBuffer">
            <returns>true if this engine can save depth buffer information</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.RestoreBackBuffer">
            <returns>true if a saved back buffer was successfully restored to the back buffer</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.SaveBackBuffer">
            <returns>
true if this engine successfully saved back buffer color information to a location
that can be retrieved at a later time
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.CanSaveBackBuffer">
            <returns>true if this engine can save back buffer information</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.ShowBackBuffer(System.Drawing.IDeviceContext)">
            <summary>Display the contents of the back buffer on to the front buffer</summary>
            <param name="dc">[in] device context to draw the back buffer colors to</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.CopyBackBufferFrom(RMA.UI.IRhinoUiDib)">
            <summary>Copy color information from a bitmap into the back buffer</summary>
            <param name="dib">[in] bitmap that contains the color information</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.CopyBackBufferTo(RMA.UI.MRhinoUiDib@)">
            <summary>Copy color information in back buffer to a bitmap</summary>
            <param name="dib">[out] bitmap that is created with color information from back buffer</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.CopyBackBufferFrom(System.Drawing.IDeviceContext)">
            <summary>Copy color information from a device context into the back buffer</summary>
            <param name="dc">[in] device context that contains the color information</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.CopyBackBufferTo(System.Drawing.IDeviceContext)">
            <summary>Copy color information in back buffer to a device context</summary>
            <param name="dc">[in] device context that will get color information blitted into it</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.GetDepthBuffer(System.Single[]@,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Read depth values into an array</summary>
            <param name="buffer">
[out] array large enough to hold width * height elements
This array will hold the depth values
</param>
            <param name="left">[in] defines rectangle on viewport to get information from</param>
            <param name="top">[in] defines rectangle on viewport to get information from</param>
            <param name="width">[in] defines rectangle on viewport to get information from</param>
            <param name="height">[in] defines rectangle on viewport to get information from</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.GetBackBuffer(RMA.UI.MRhinoUiDib@)">
            <summary>copy the color information in the back buffer to a bitmap</summary>
            <param name="dib">[out] the bitmap that is created and holds the back buffer's values</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.HasBackBuffer">
            <returns>
true if this engine uses more than one buffer for drawing operations. All default
engines in Rhino use double buffered drawing and will return true
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.CopyDepthToBackBuffer">
            <summary>
Copy depth information into color values in the back buffer
</summary>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.CopyDepthBufferFrom(RMA.UI.IRhinoUiDib)">
            <summary>
Set all of the depth values for the frame buffer to values stored in a bitmap
</summary>
            <param name="dib">
[in] bitmap with depth information. This was probably created using CopyDepthBufferTo
with bConvertToImage=false
</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.CopyDepthBufferTo(RMA.UI.MRhinoUiDib@)">
            <summary>
Copy the depth buffer information to a bitmap
</summary>
            <param name="dib">[out] the bitmap that is created with depth buffer information</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.CopyDepthBufferTo(RMA.UI.MRhinoUiDib@,System.Boolean)">
            <summary>
Copy the depth buffer information to a bitmap
</summary>
            <param name="dib">[out] the bitmap that is created with depth buffer information</param>
            <param name="bConvertToImage">
[in] if true, the depth information is converted into a grey scale image
if false, each byte in the dib contains a depth value
</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.CopyDepthBufferTo(RMA.UI.MRhinoUiDib@,System.Boolean,System.Boolean)">
            <summary>
Copy the depth buffer information to a bitmap
</summary>
            <param name="dib">[out] the bitmap that is created with depth buffer information</param>
            <param name="bConvertToImage">
[in] if true, the depth information is converted into a grey scale image
if false, each byte in the dib contains a depth value
</param>
            <param name="bInvertDepthValues">
[in] if true, the values in the dib are flipped where a byte used to be 0 will
now be 255 and a byte that used to be 255 will now be 0
</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.CopyDepthBufferTo(RMA.UI.MRhinoUiDib@,System.Boolean,System.Boolean,RMA.UI.MRhinoUiDib)">
            <summary>
Copy the depth buffer information to a bitmap
</summary>
            <param name="dib">[out] the bitmap that is created with depth buffer information</param>
            <param name="bConvertToImage">
[in] if true, the depth information is converted into a grey scale image
if false, each byte in the dib contains a depth value
</param>
            <param name="bInvertDepthValues">
[in] if true, the values in the dib are flipped where a byte used to be 0 will
now be 255 and a byte that used to be 255 will now be 0
</param>
            <param name="pBackground">
[in] If not NULL, this image will be place in the background of dib where no depth
information was written to
</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.HasDepthBuffer">
            <returns>
true if this engine can use a depth buffer (z-buffer)
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.NotifyFrameSizeChanged(System.Int32,System.Int32)">
            <summary>
The the engine that the size of the rectangle that it draws to has changed.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.PopProjection">
            <summary>
Restore the viewport that was pushed on to a stack with a call to PushProjection.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.PushProjection(RMA.OpenNURBS.IOnViewport)">
            <summary>
Save the current viewport on a stack and set the current viewport to a given viewport
</summary>
            <param name="viewport">
[in] the viewport to make the current viewport for the engine.
DO NOT DELETE THIS VIEWPORT WHILE THE ENGINE IS USING IT
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.NotifyProjectionChanged">
            <summary>
This routine is normally called by the pipeline framework because the
current display's viewport projection has changed...This means that
all of the commonly used engine attributes need to be updated.

Note: this routine should never be called haphazardly since it can be
     somewhat expensive performance-wise. However, if you or your
     display pipeline ever change the projection other than by through
     the standard pipeline mechanisms, then you must ensure that this
     routine gets called AFTER the changes, or update these attributes
     manually on an as-needed basis. Also, if your engine overrides 
     this routine, then it is best that your implementation also call
     the derived class's implementation.
</summary>
            <returns>true on success</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.Make4dGradient(RMA.UI.MRhinoUiDib@,System.Int32,System.Int32,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>Save a 4 color gradient to a dib</summary>
            <param name="dib">[out] the dib to store the color gradient in</param>
            <param name="width">[in] width of dib to create</param>
            <param name="height">[in] height of dib to create</param>
            <param name="color_topleft">[in] color at top left corner of dib</param>
            <param name="color_topright">[in] color at top right corner of dib</param>
            <param name="color_bottomright">[in] color at bottom right corner of dib</param>
            <param name="color_bottomleft">[in] color at bottom left corner of dib</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.Make2dGradient(RMA.UI.MRhinoUiDib@,System.Int32,System.Int32,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>Save a 2 color vertical gradient to a dib</summary>
            <param name="dib">[out] the dib to store the color gradient in</param>
            <param name="width">[in] width of dib to create</param>
            <param name="height">[in] height of dib to create</param>
            <param name="color_top">[in] color at top of dib</param>
            <param name="color_bottom">[in] color at bottom of dib</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.FrustumToScreen(RMA.OpenNURBS.IOn2dPoint)">
            <summary>
Convert a point on the frustum near plane to a screen space coordinate
</summary>
            <param name="point">[in] the location to convert</param>
            <returns>the screen position for the given frustum point</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.ScreenToFrustum(RMA.OpenNURBS.IOn2dPoint)">
            <summary>
Convert a point in 2d screen space to its equivalent view frutum near plane positioin
</summary>
            <param name="point">[in] the location in screen space coordinates to convert</param>
            <returns>the frustum position for the given screen point</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.WorldToClippingPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Convert a point in 3d world space coordinates to 4d clipping coordinates
</summary>
            <param name="point">[in] the location in world coordinates to convert</param>
            <returns>the equivalent clipping coordinates to the world coordinate with the current viewport projection</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.ClippingToScreenPoint(RMA.OpenNURBS.IOn4dPoint)">
            <summary>
Convert a point in 4d clipping coordinates to 2d screen space coordinates
</summary>
            <param name="point">[in] the location in clipping coordinates to convert</param>
            <returns>the screen space coordinate where the clipping coordinate would be drawn</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.WorldToScreenPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Convert a point in 3d world space coordinates to 2d screen space coordinates
</summary>
            <param name="point">[in] the location in world coordinates to convert</param>
            <returns>the screen space coordinate where the world coordinate would be drawn</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DeleteCache(System.UInt32)">
            <summary>Delete a cached drawing sequence</summary>
            <param name="nCache">[in] cache id that was returned from EndCachingMode call</param>
            <returns>true if the cache was successfully deleted</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.CacheExists(System.UInt32)">
            <summary>
Check to see if a cached drawing sequence exists for a given cache id
</summary>
            <param name="nCache">[in] cache id that was returned from EndCachingMode call</param>
            <returns>true if the cache exists</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawCache(System.UInt32)">
            <summary>
Draw a cached sequece previously defined using StartCachingMode and EndCachingMode
</summary>
            <param name="nCache">[in] cache id that was returned from EndCachingMode call</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.EndCachingMode">
            <summary>Stop a caching sequence.</summary>
            <returns>Cache id if successful. 0 if not successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.StartCachingMode">
            <summary>
Attempt to put the engine in a "caching" mode where it can attempt to cache
and optimize drawing routines
Subclasses that implement this function should call this base class version
first and check the result
</summary>
            <returns>
true if the engine was able to start a caching mode.
false if the engine is already in a caching mode.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.FlushPointBuffers">
            <summary>
Have all the points in the point buffer drawn and empty the point buffer
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.FlushLineBuffers">
            <summary>
Have all the lines in the line buffer drawn and empty the line buffer
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawBufferedLine(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32)">
            <summary>
Add a line to the line buffer that will be later drawn when the buffer is
flushed. The base class DrawLine calls just function so you should not have
to typically think about when it is appropriate to call DrawLine and when to
call DrawBufferedLine (typically just call DrawLine)
</summary>
            <param name="from">[in] start position of line in 3D-world space</param>
            <param name="to">[in] end position of line in 3D-world space</param>
            <param name="color">[in] line color</param>
            <param name="thickness">[in] line thickness in screen space</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawBufferedLine(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32,System.UInt32)">
            <summary>
Add a line to the line buffer that will be later drawn when the buffer is
flushed. The base class DrawLine calls just function so you should not have
to typically think about when it is appropriate to call DrawLine and when to
call DrawBufferedLine (typically just call DrawLine)
</summary>
            <param name="from">[in] start position of line in 3D-world space</param>
            <param name="to">[in] end position of line in 3D-world space</param>
            <param name="color">[in] line color</param>
            <param name="thickness">[in] line thickness in screen space</param>
            <param name="pattern">[in] stipple pattern</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawBufferedPoint(RMA.OpenNURBS.IOn3dPoint,System.Int32,RMA.Rhino.eRhinoPointStyle,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Add a point to the point buffer that will be later drawn when the buffer is
flushed. The base class DrawPoint calls just function so you should not have
to typically think about when it is appropriate to call DrawPoint and when to
call DrawBufferedPoint (typically just call DrawPoint)
</summary>
            <param name="point">[in] position in 3D-world space</param>
            <param name="size">[in] size in screen space pixels</param>
            <param name="style">[in] style used for drawing</param>
            <param name="color">[in] point color</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.SetCurveAttributes(RMA.Rhino.IRhCurveAttributes)">
            <summary>
Set the current curve attributes that are being used by the engine
</summary>
            <param name="attributes">[in] the engine's current curve attributes are set to these values</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.GetCurveAttributes(RMA.Rhino.MRhCurveAttributes@)">
            <summary>
Get the current curve attributes that are being used by the engine
</summary>
            <param name="attributes">[out] the current curve attributes</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.SetClipRegion(System.Int32)">
            <summary>
Clip region defines an area on the framebuffer where drawing can occur
Note - This function has not been implemented for V4 and serves as a virtual function
      placeholder for future versions of Rhino
</summary>
            <param name="region_id">[in] id returned from CreateClipRegion function</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DestroyClipRegion(System.Int32)">
            <summary>
Clip region defines an area on the framebuffer where drawing can occur
Note - This function has not been implemented for V4 and serves as a virtual function
      placeholder for future versions of Rhino
</summary>
            <param name="region_id">[in] id returned from CreateClipRegion function</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.CreateClipRegion(RMA.OpenNURBS.IOnCurve)">
            <summary>
Clip region defines an area on the framebuffer where drawing can occur
Note - This function has not been implemented for V4 and serves as a virtual function
      placeholder for future versions of Rhino
</summary>
            <param name="boundary">[in] a closed 2d curve used to define area where drawing can occur</param>
            <returns>id for an engine defined clip region. -1 if a clip region could not be created</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.SetRenderTarget(System.Windows.Forms.IWin32Window)">
            <summary>Set the window that this engine draws on</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.SetProjection(RMA.OpenNURBS.IOnViewport)">
            <summary>
Set the viewport that this engine uses to define it's view projection information
DO NOT DELETE THIS VIEWPORT WHILE THE ENGINE IS USING IT
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.ClearTextureCache">
            <summary>
Remove all cached texture information that may be stored locally or on the graphics card
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.EnableClipPlanes(System.Boolean)">
            <summary>Enable/Disable all user defined clipping planes</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.EnableClipPlanes(System.Boolean,System.Int32)">
            <summary>Enable/Disable user defined clipping planes</summary>
            <param name="plane">
[in] index for plane to enable/diable. If -1, all planes
will be enabled or disabled
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.EnableLineSmoothing(System.Boolean)">
            <summary>
Turn on/off line smoothing for curve drawing
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DepthBufferBitDepth">
            <returns>Number of bits per pixel used to describe the depth value</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.FrameBufferChannelDepth(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
Gets the number of bits used to define each color channel for an individual pixel
</summary>
            <param name="red_bits">[out] number of bits dedicated to describing red level in pixel</param>
            <param name="green_bits">[out] number of bits dedicated to describing green level in pixel</param>
            <param name="blue_bits">[out] number of bits dedicated to describing blue level in pixel</param>
            <param name="alpha_bits">[out] number of bits dedicated to describing alpha level in pixel</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.FrameBufferBitDepth">
            <returns>Number of bits per pixel for the frame buffer color values</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.SetZBiasMode(System.Int32)">
            <returns>previous zbias mode value</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.PopCullFaceMode">
            <summary>
Restore mode of face culling that was saved by calling PushCullFaceMode
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.PushCullFaceMode(System.Int32)">
            <summary>
Save the current state of face culling on a stack and set a new face culling mode
</summary>
            <param name="nMode">
[in] 0 = Draw BOTH front and back faces
    1 = Draw front faces not back faces
    2 = Draw back faces not front faces
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.PopColorWriting">
            <summary>
Restore state of color writing that was saved by calling PushColorWriting
</summary>
            <returns>previous state of color writing</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.PushColorWriting(System.Boolean)">
            <summary>
Save the current state of color writing on a stack and turn on/off color writing
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.PopDepthWriting">
            <summary>
Restore state of depth writing that was saved by calling PushDepthWriting
</summary>
            <returns>previous state of depth writing</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.PushDepthWriting(System.Boolean)">
            <summary>
Save the current state of depth writing on a stack and turn on/off depth writing
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.PopDepthTesting">
            <summary>
Restore state of depth testing that was saved by calling PushDepthTesting
</summary>
            <returns>previous state of depth testing</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.PushDepthTesting(System.Boolean)">
            <summary>
Save the current state of depth testing on a stack and turn on/off depth testing
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.EnableLighting">
            <summary>
Turn on/off use of lighting calculations for engines that support shading
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.EnableLighting(System.Boolean)">
            <summary>
Turn on/off use of lighting calculations for engines that support shading
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.EnableColorWriting">
            <summary>
Turn on/off writing of information to the color buffer
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.EnableColorWriting(System.Boolean)">
            <summary>
Turn on/off writing of information to the color buffer
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.EnableDepthWriting">
            <summary>
Turn on/off writing of information to the depth buffer for engines
that support depth buffers
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.EnableDepthWriting(System.Boolean)">
            <summary>
Turn on/off writing of information to the depth buffer for engines
that support depth buffers
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.EnableDepthTesting">
            <summary>Turn of/off depth testing for engines that support depth buffers</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.EnableDepthTesting(System.Boolean)">
            <summary>Turn of/off depth testing for engines that support depth buffers</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.PopState">
            <summary>Restore all matrix adn attribute states stored from calling PushState</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.PushState">
            <summary>Push all matrix and attribute states onto a stack.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.FlushAll">
            <summary>Flushes any and all buffers used by the engine.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.FillSolidRect(System.Int32,System.Int32,System.Int32,System.Int32,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>Draw a filled 2D rectangle defined in screen coordinates</summary>
            <param name="nX">[in] left screen coordinate of rectangle</param>
            <param name="nY">[in] top screen coordinate of rectangle</param>
            <param name="nW">[in] screen coordinate width of rectangle</param>
            <param name="nH">[in] screen coordinate height of rectangle</param>
            <param name="color">[in] color to used for drawing</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.FillSolidRect(System.Int32,System.Int32,System.Int32,System.Int32,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32)">
            <summary>Draw a filled 2D rectangle defined in screen coordinates</summary>
            <param name="nX">[in] left screen coordinate of rectangle</param>
            <param name="nY">[in] top screen coordinate of rectangle</param>
            <param name="nW">[in] screen coordinate width of rectangle</param>
            <param name="nH">[in] screen coordinate height of rectangle</param>
            <param name="color">[in] color to used for drawing</param>
            <param name="nTrans">[in] transparency level (0=opaque, 255=completely transparent)</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawBitmap(RMA.UI.IRhinoUiDib,System.Int32,System.Int32)">
            <summary>Draw a bitmap</summary>
            <param name="dib">[in] the bitmap to draw</param>
            <param name="nX">[in] screen coordinate left location to draw top-left corner of dib</param>
            <param name="nY">[in] screen coordinate top location to draw top-left corner of dib</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawBitmap(RMA.UI.IRhinoUiDib,System.Int32,System.Int32,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>Draw a bitmap</summary>
            <param name="dib">[in] the bitmap to draw</param>
            <param name="nX">[in] screen coordinate left location to draw top-left corner of dib</param>
            <param name="nY">[in] screen coordinate top location to draw top-left corner of dib</param>
            <param name="mask">[in] if set to a color, the dib is drawn using a color mask for transparency</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawTriangle(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOnColor)">
            <summary>
Draw a filled triangle
Note - If not implemented by deriving engine class, this routine will
      just call "DrawPolygon" method
</summary>
            <param name="p0">[in] corner of triangle in world coordinates</param>
            <param name="p1">[in] corner of triangle in world coordinates</param>
            <param name="p2">[in] corner of triangle in world coordinates</param>
            <param name="color">[in] triangle color</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawPolygon(RMA.OpenNURBS.IArrayOn3dPoint,RMA.OpenNURBS.IOnColor,System.Boolean)">
            <summary>Draw a polygon using a set of points for the polygon border</summary>
            <param name="points">[in] array of points in world coordinates to use for polygon border</param>
            <param name="color">[in] draw color</param>
            <param name="bFilled">
[in] true = draw the polygon as a filled shape
false = just draw the polygon border
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawString(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.IOnColor,RMA.Rhino.IRhinoText)">
            <summary>Draw text used in annotation objects.</summary>
            <param name="plane">[in] 3d world coordinate plane that the text is on</param>
            <param name="color">[in] drawing color.</param>
            <param name="text">
[in] Text. The 2d location information in this class applies
to is in the coordinate system of the plane.  That is,
the 3d world location of text coordinates (s,t) is
(plane.origin + s*plane.xaxis + t*plane.yaxis).
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.MeasureString(System.Drawing.Rectangle@,System.String,RMA.OpenNURBS.IOn2dPoint)">
            <summary>
Determine screen rectangle that would be drawn to using the DrawString(..) function
with the same parameters.
</summary>
            <param name="rect">[out] rectangle in the viewport's screen coordinates on success</param>
            <param name="text">[in] text to measure</param>
            <param name="point">[in] definition point, either lower-left or middle</param>
            <returns>true on success, false on failure</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.MeasureString(System.Drawing.Rectangle@,System.String,RMA.OpenNURBS.IOn2dPoint,System.Boolean)">
            <summary>
Determine screen rectangle that would be drawn to using the DrawString(..) function
with the same parameters.
</summary>
            <param name="rect">[out] rectangle in the viewport's screen coordinates on success</param>
            <param name="text">[in] text to measure</param>
            <param name="point">[in] definition point, either lower-left or middle</param>
            <param name="bMiddle">
[in] if true, text is centered on point, (default false)
if false, point defines lower left corner of text
</param>
            <returns>true on success, false on failure</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.MeasureString(System.Drawing.Rectangle@,System.String,RMA.OpenNURBS.IOn2dPoint,System.Boolean,System.Int32)">
            <summary>
Determine screen rectangle that would be drawn to using the DrawString(..) function
with the same parameters.
</summary>
            <param name="rect">[out] rectangle in the viewport's screen coordinates on success</param>
            <param name="text">[in] text to measure</param>
            <param name="point">[in] definition point, either lower-left or middle</param>
            <param name="bMiddle">
[in] if true, text is centered on point, (default false)
if false, point defines lower left corner of text
</param>
            <param name="rotation">[in] Text rotation in 1/10 degrees (default 0)</param>
            <returns>true on success, false on failure</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.MeasureString(System.Drawing.Rectangle@,System.String,RMA.OpenNURBS.IOn2dPoint,System.Boolean,System.Int32,System.Int32)">
            <summary>
Determine screen rectangle that would be drawn to using the DrawString(..) function
with the same parameters.
</summary>
            <param name="rect">[out] rectangle in the viewport's screen coordinates on success</param>
            <param name="text">[in] text to measure</param>
            <param name="point">[in] definition point, either lower-left or middle</param>
            <param name="bMiddle">
[in] if true, text is centered on point, (default false)
if false, point defines lower left corner of text
</param>
            <param name="rotation">[in] Text rotation in 1/10 degrees (default 0)</param>
            <param name="height">[in] height in pixels (default 12)</param>
            <returns>true on success, false on failure</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.MeasureString(System.Drawing.Rectangle@,System.String,RMA.OpenNURBS.IOn2dPoint,System.Boolean,System.Int32,System.Int32,System.String)">
            <summary>
Determine screen rectangle that would be drawn to using the DrawString(..) function
with the same parameters.
</summary>
            <param name="rect">[out] rectangle in the viewport's screen coordinates on success</param>
            <param name="text">[in] text to measure</param>
            <param name="point">[in] definition point, either lower-left or middle</param>
            <param name="bMiddle">
[in] if true, text is centered on point, (default false)
if false, point defines lower left corner of text
</param>
            <param name="rotation">[in] Text rotation in 1/10 degrees (default 0)</param>
            <param name="height">[in] height in pixels (default 12)</param>
            <param name="fontface">[in] font to use for text (default Arial)</param>
            <returns>true on success, false on failure</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawString(System.String,RMA.OpenNURBS.IOnColor,RMA.OpenNURBS.IOn2dPoint)">
            <summary>Draws text with specified color, font and height</summary>
            <param name="text">[in] string to draw</param>
            <param name="color">[in] text color</param>
            <param name="point">[in] definition point, either lower-left or middle based on value in bMiddle</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawString(System.String,RMA.OpenNURBS.IOnColor,RMA.OpenNURBS.IOn2dPoint,System.Boolean)">
            <summary>Draws text with specified color, font and height</summary>
            <param name="text">[in] string to draw</param>
            <param name="color">[in] text color</param>
            <param name="point">[in] definition point, either lower-left or middle based on value in bMiddle</param>
            <param name="bMiddle">[in] TRUE: middle justified, FALSE: lower-left justified</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawString(System.String,RMA.OpenNURBS.IOnColor,RMA.OpenNURBS.IOn2dPoint,System.Boolean,System.Int32)">
            <summary>Draws text with specified color, font and height</summary>
            <param name="text">[in] string to draw</param>
            <param name="color">[in] text color</param>
            <param name="point">[in] definition point, either lower-left or middle based on value in bMiddle</param>
            <param name="bMiddle">[in] TRUE: middle justified, FALSE: lower-left justified</param>
            <param name="rotation">[in] Text rotation in 1/10 degrees</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawString(System.String,RMA.OpenNURBS.IOnColor,RMA.OpenNURBS.IOn2dPoint,System.Boolean,System.Int32,System.Int32)">
            <summary>Draws text with specified color, font and height</summary>
            <param name="text">[in] string to draw</param>
            <param name="color">[in] text color</param>
            <param name="point">[in] definition point, either lower-left or middle based on value in bMiddle</param>
            <param name="bMiddle">[in] TRUE: middle justified, FALSE: lower-left justified</param>
            <param name="rotation">[in] Text rotation in 1/10 degrees</param>
            <param name="height">[in] height in screen pixels</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawString(System.String,RMA.OpenNURBS.IOnColor,RMA.OpenNURBS.IOn2dPoint,System.Boolean,System.Int32,System.Int32,System.String)">
            <summary>Draws text with specified color, font and height</summary>
            <param name="text">[in] string to draw</param>
            <param name="color">[in] text color</param>
            <param name="point">[in] definition point, either lower-left or middle based on value in bMiddle</param>
            <param name="bMiddle">[in] TRUE: middle justified, FALSE: lower-left justified</param>
            <param name="rotation">[in] Text rotation in 1/10 degrees</param>
            <param name="height">[in] height in screen pixels</param>
            <param name="fontface">[in] face name to use for font selection</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawDot(RMA.OpenNURBS.IOn3dPoint,System.Drawing.Font)">
            <summary>
Draws a round or oval dot with the text in the middle.
This tool is used for things like the "A", "B", "C", "D"
in the NetworkSrf dialog and the the "1", "2", ... in
the PerspectiveMatch command.
</summary>
            <param name="point">[in] 3d world location of the dot</param>
            <param name="font">[in] font to be used to draw text in dot.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawDot(RMA.OpenNURBS.IOn3dPoint,System.Drawing.Font,System.String)">
            <summary>
Draws a round or oval dot with the text in the middle.
This tool is used for things like the "A", "B", "C", "D"
in the NetworkSrf dialog and the the "1", "2", ... in
the PerspectiveMatch command.
</summary>
            <param name="point">[in] 3d world location of the dot</param>
            <param name="text">[in] NULL for an empty dot or a short (generally 1 character or number) string.</param>
            <param name="font">[in] font to be used to draw text in dot.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawDot(RMA.OpenNURBS.IOn3dPoint,System.Drawing.Font,System.String,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Draws a round or oval dot with the text in the middle.
This tool is used for things like the "A", "B", "C", "D"
in the NetworkSrf dialog and the the "1", "2", ... in
the PerspectiveMatch command.
</summary>
            <param name="point">[in] 3d world location of the dot</param>
            <param name="text">[in] NULL for an empty dot or a short (generally 1 character or number) string.</param>
            <param name="font">[in] font to be used to draw text in dot.</param>
            <param name="dot_color">[in] color of dot</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawDot(RMA.OpenNURBS.IOn3dPoint,System.Drawing.Font,System.String,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Draws a round or oval dot with the text in the middle.
This tool is used for things like the "A", "B", "C", "D"
in the NetworkSrf dialog and the the "1", "2", ... in
the PerspectiveMatch command.
</summary>
            <param name="point">[in] 3d world location of the dot</param>
            <param name="text">[in] NULL for an empty dot or a short (generally 1 character or number) string.</param>
            <param name="font">[in] font to be used to draw text in dot.</param>
            <param name="dot_color">[in] color of dot</param>
            <param name="text_color">
[in] text color. If text_color is ON_unset_color, then white is used if the dot_color is dark and
black is used if the dot_color is light.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawDot(RMA.OpenNURBS.IOn3dPoint,System.Drawing.Font,System.String,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Draws a round or oval dot with the text in the middle.
This tool is used for things like the "A", "B", "C", "D"
in the NetworkSrf dialog and the the "1", "2", ... in
the PerspectiveMatch command.
</summary>
            <param name="point">[in] 3d world location of the dot</param>
            <param name="text">[in] NULL for an empty dot or a short (generally 1 character or number) string.</param>
            <param name="font">[in] font to be used to draw text in dot.</param>
            <param name="dot_color">[in] color of dot</param>
            <param name="text_color">
[in] text color. If text_color is ON_unset_color, then white is used if the dot_color is dark and
black is used if the dot_color is light.
</param>
            <param name="border_color">[in] outline color</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawDot(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Draws a round or oval dot with the text in the middle.
This tool is used for things like the "A", "B", "C", "D"
in the NetworkSrf dialog and the the "1", "2", ... in
the PerspectiveMatch command.
</summary>
            <param name="point">[in] 3d world location of the dot</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawDot(RMA.OpenNURBS.IOn3dPoint,System.String)">
            <summary>
Draws a round or oval dot with the text in the middle.
This tool is used for things like the "A", "B", "C", "D"
in the NetworkSrf dialog and the the "1", "2", ... in
the PerspectiveMatch command.
</summary>
            <param name="point">[in] 3d world location of the dot</param>
            <param name="text">[in] NULL for an empty dot or a short (generally 1 character or number) string.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawDot(RMA.OpenNURBS.IOn3dPoint,System.String,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Draws a round or oval dot with the text in the middle.
This tool is used for things like the "A", "B", "C", "D"
in the NetworkSrf dialog and the the "1", "2", ... in
the PerspectiveMatch command.
</summary>
            <param name="point">[in] 3d world location of the dot</param>
            <param name="text">[in] NULL for an empty dot or a short (generally 1 character or number) string.</param>
            <param name="dot_color">[in] color of dot</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawDot(RMA.OpenNURBS.IOn3dPoint,System.String,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Draws a round or oval dot with the text in the middle.
This tool is used for things like the "A", "B", "C", "D"
in the NetworkSrf dialog and the the "1", "2", ... in
the PerspectiveMatch command.
</summary>
            <param name="point">[in] 3d world location of the dot</param>
            <param name="text">[in] NULL for an empty dot or a short (generally 1 character or number) string.</param>
            <param name="dot_color">[in] color of dot</param>
            <param name="text_color">
[in] text color. If text_color is ON_unset_color, then white is used if the dot_color is dark and
black is used if the dot_color is light.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawDot(RMA.OpenNURBS.IOn3dPoint,System.String,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Draws a round or oval dot with the text in the middle.
This tool is used for things like the "A", "B", "C", "D"
in the NetworkSrf dialog and the the "1", "2", ... in
the PerspectiveMatch command.
</summary>
            <param name="point">[in] 3d world location of the dot</param>
            <param name="text">[in] NULL for an empty dot or a short (generally 1 character or number) string.</param>
            <param name="dot_color">[in] color of dot</param>
            <param name="text_color">
[in] text color. If text_color is ON_unset_color, then white is used if the dot_color is dark and
black is used if the dot_color is light.
</param>
            <param name="border_color">[in] outline color</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawDot(System.Int32,System.Int32,System.Drawing.Font)">
            <summary>
Draws a round or oval dot with the text in the middle.
This tool is used for things like the "A", "B", "C", "D"
in the NetworkSrf dialog and the the "1", "2", ... in
the PerspectiveMatch command.
</summary>
            <param name="screen_x">[in] client window screen horizontal coordinate (0 = screen left)</param>
            <param name="screen_y">[in] client window screen vertical coordinate (0 = screen top)</param>
            <param name="font">[in] font to be used to draw text in dot.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawDot(System.Int32,System.Int32,System.Drawing.Font,System.String)">
            <summary>
Draws a round or oval dot with the text in the middle.
This tool is used for things like the "A", "B", "C", "D"
in the NetworkSrf dialog and the the "1", "2", ... in
the PerspectiveMatch command.
</summary>
            <param name="screen_x">[in] client window screen horizontal coordinate (0 = screen left)</param>
            <param name="screen_y">[in] client window screen vertical coordinate (0 = screen top)</param>
            <param name="font">[in] font to be used to draw text in dot.</param>
            <param name="text">[in] NULL for an empty dot or a short (generally 1 character or number) string.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawDot(System.Int32,System.Int32,System.Drawing.Font,System.String,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Draws a round or oval dot with the text in the middle.
This tool is used for things like the "A", "B", "C", "D"
in the NetworkSrf dialog and the the "1", "2", ... in
the PerspectiveMatch command.
</summary>
            <param name="screen_x">[in] client window screen horizontal coordinate (0 = screen left)</param>
            <param name="screen_y">[in] client window screen vertical coordinate (0 = screen top)</param>
            <param name="font">[in] font to be used to draw text in dot.</param>
            <param name="text">[in] NULL for an empty dot or a short (generally 1 character or number) string.</param>
            <param name="dot_color">[in] color of dot</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawDot(System.Int32,System.Int32,System.Drawing.Font,System.String,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Draws a round or oval dot with the text in the middle.
This tool is used for things like the "A", "B", "C", "D"
in the NetworkSrf dialog and the the "1", "2", ... in
the PerspectiveMatch command.
</summary>
            <param name="screen_x">[in] client window screen horizontal coordinate (0 = screen left)</param>
            <param name="screen_y">[in] client window screen vertical coordinate (0 = screen top)</param>
            <param name="font">[in] font to be used to draw text in dot.</param>
            <param name="text">[in] NULL for an empty dot or a short (generally 1 character or number) string.</param>
            <param name="dot_color">[in] color of dot</param>
            <param name="text_color">
[in] text color. If text_color is ON_unset_color, then white is used if the dot_color is dark and
black is used if the dot_color is light.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawDot(System.Int32,System.Int32,System.Drawing.Font,System.String,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Draws a round or oval dot with the text in the middle.
This tool is used for things like the "A", "B", "C", "D"
in the NetworkSrf dialog and the the "1", "2", ... in
the PerspectiveMatch command.
</summary>
            <param name="screen_x">[in] client window screen horizontal coordinate (0 = screen left)</param>
            <param name="screen_y">[in] client window screen vertical coordinate (0 = screen top)</param>
            <param name="font">[in] font to be used to draw text in dot.</param>
            <param name="text">[in] NULL for an empty dot or a short (generally 1 character or number) string.</param>
            <param name="dot_color">[in] color of dot</param>
            <param name="text_color">
[in] text color. If text_color is ON_unset_color, then white is used if the dot_color is dark and
black is used if the dot_color is light.
</param>
            <param name="border_color">[in] outline color</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawDot(System.Int32,System.Int32)">
            <summary>
Draws a round or oval dot with the text in the middle.
This tool is used for things like the "A", "B", "C", "D"
in the NetworkSrf dialog and the the "1", "2", ... in
the PerspectiveMatch command.
</summary>
            <param name="screen_x">[in] client window screen horizontal coordinate (0 = screen left)</param>
            <param name="screen_y">[in] client window screen vertical coordinate (0 = screen top)</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawDot(System.Int32,System.Int32,System.String)">
            <summary>
Draws a round or oval dot with the text in the middle.
This tool is used for things like the "A", "B", "C", "D"
in the NetworkSrf dialog and the the "1", "2", ... in
the PerspectiveMatch command.
</summary>
            <param name="screen_x">[in] client window screen horizontal coordinate (0 = screen left)</param>
            <param name="screen_y">[in] client window screen vertical coordinate (0 = screen top)</param>
            <param name="text">[in] NULL for an empty dot or a short (generally 1 character or number) string.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawDot(System.Int32,System.Int32,System.String,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Draws a round or oval dot with the text in the middle.
This tool is used for things like the "A", "B", "C", "D"
in the NetworkSrf dialog and the the "1", "2", ... in
the PerspectiveMatch command.
</summary>
            <param name="screen_x">[in] client window screen horizontal coordinate (0 = screen left)</param>
            <param name="screen_y">[in] client window screen vertical coordinate (0 = screen top)</param>
            <param name="text">[in] NULL for an empty dot or a short (generally 1 character or number) string.</param>
            <param name="dot_color">[in] color of dot</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawDot(System.Int32,System.Int32,System.String,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Draws a round or oval dot with the text in the middle.
This tool is used for things like the "A", "B", "C", "D"
in the NetworkSrf dialog and the the "1", "2", ... in
the PerspectiveMatch command.
</summary>
            <param name="screen_x">[in] client window screen horizontal coordinate (0 = screen left)</param>
            <param name="screen_y">[in] client window screen vertical coordinate (0 = screen top)</param>
            <param name="text">[in] NULL for an empty dot or a short (generally 1 character or number) string.</param>
            <param name="dot_color">[in] color of dot</param>
            <param name="text_color">
[in] text color. If text_color is ON_unset_color, then white is used if the dot_color is dark and
black is used if the dot_color is light.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawDot(System.Int32,System.Int32,System.String,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Draws a round or oval dot with the text in the middle.
This tool is used for things like the "A", "B", "C", "D"
in the NetworkSrf dialog and the the "1", "2", ... in
the PerspectiveMatch command.
</summary>
            <param name="screen_x">[in] client window screen horizontal coordinate (0 = screen left)</param>
            <param name="screen_y">[in] client window screen vertical coordinate (0 = screen top)</param>
            <param name="text">[in] NULL for an empty dot or a short (generally 1 character or number) string.</param>
            <param name="dot_color">[in] color of dot</param>
            <param name="text_color">
[in] text color. If text_color is ON_unset_color, then white is used if the dot_color is dark and
black is used if the dot_color is light.
</param>
            <param name="border_color">[in] outline color.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawLine(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32)">
            <summary>
Draws a solid line at specified locations, using specified thickness, color and pattern.
Note - If not implemented by deriving engine class, this routine will
      just call "DrawBufferedLine" method.
</summary>
            <param name="from">[in] start point of line</param>
            <param name="to">[in] end point of line</param>
            <param name="color">[in] color to draw line</param>
            <param name="thickness">[in] thickness in screen pixels</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawLine(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32,System.UInt32)">
            <summary>
Draws a line at specified locations, using specified thickness, color and pattern.
Note - If not implemented by deriving engine class, this routine will
      just call "DrawBufferedLine" method.
</summary>
            <param name="from">[in] start point of line</param>
            <param name="to">[in] end point of line</param>
            <param name="color">[in] color to draw line</param>
            <param name="thickness">[in] thickness in screen pixels</param>
            <param name="pattern">[in] bit pattern to use for drawing. All bits set to 1 means draw a solid line</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawPoint(RMA.OpenNURBS.IOn3dPoint,System.Int32,RMA.Rhino.eRhinoPointStyle,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Draws a point at specified location, using specified radius, style and color.
Note - If not implemented by deriving engine class, this routine will
      just call "DrawBufferedPoint" method.
</summary>
            <param name="point">[in] the location to draw the point</param>
            <param name="radius">[in] point size in screen pixels</param>
            <param name="style">[in] style used for how the point should be drawn</param>
            <param name="color">[in] color used to draw the point</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.ClearDepthBuffer">
            <summary>
Clear the depth buffer for this engine. If the engine does not support depth buffered
drawing, then nothing is done.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.ClearFrameBuffer(RMA.UI.IRhinoUiDib)">
            <summary>
Fill the frame buffer with a bitmap image
This function also clears the depth buffer for engines that support
depth buffered drawing.
</summary>
            <param name="dib">[in] the image to draw into the frame buffer</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.ClearFrameBuffer(System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Fill the frame buffer with a gradient between four corner colors
This function also clears the depth buffer for engines that support
depth buffered drawing.
</summary>
            <param name="color_topleft">[in] the color in the top-left corner of the frame buffer</param>
            <param name="color_bottomleft">[in] the color in the bottom-left corner of the frame buffer</param>
            <param name="color_topright">[in] the color in the top-right corner of the frame buffer</param>
            <param name="color_bottomright">[in] the color in the bottom-right corner of the frame buffer</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.ClearFrameBuffer(System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Fill the frame buffer with a vertical gradient between two colors
This function also clears the depth buffer for engines that support
depth buffered drawing.
</summary>
            <param name="color_top">[in] the color on the top line of the frame buffer</param>
            <param name="color_bottom">[in] the color on the bottom line of the frame buffer</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.ClearFrameBuffer(System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Fill the frame buffer with a single color
This function also clears the depth buffer for engines that support
depth buffered drawing.
</summary>
            <param name="color">[in] the color to fill the frame buffer with</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.ClipPlaneCount">
            <returns>
Number of user defined clipping planes currently set up for this engine.
This does not include the standard view frustum clipping planes
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.ClearClipPlanes">
            <summary>
Remove all the user defined clipping planes that may have been added through
the AddClipPlane function
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.AddClipPlane(RMA.OpenNURBS.IOnClippingPlaneInfo)">
            <summary>
Add a user defined clipping plane that the engine should use to display only portions of the geometry drawn
</summary>
            <param name="clipplane">[in] the user defined clipping plane</param>
            <returns>
true if the clipping plane could successfully be added.
false if this engine does not support user defined clipping planes or a maximum
number of clipping plane has been hit for the installed graphics card.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.LightCount">
            <returns>Number of lights this engine is currently using for drawing shaded geometry</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.AddLight(RMA.OpenNURBS.IOnLight)">
            <summary>
Add a light to the list of lights that the engine should use when displaying shaded geometry.
</summary>
            <param name="light">
[in] the light information the engine should use to set up an graphics technology specific light
</param>
            <returns>
true if successful. Returns false if the engine does not support shading
or already has enough lights to match the maximum supported light count
for the current graphics card.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawMeshFaces(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.IArrayint,RMA.Rhino.IDisplayPipelineAttributes)">
            <summary>Draw a set of faces from a mesh</summary>
            <param name="mesh">[in] the mesh that contains the faces to draw</param>
            <param name="faces">[in] list of indices into the mesh's m_F array for the faces</param>
            <param name="da">
[in] Display attributes to use for drawing. This is required. Passing NULL will not draw anything
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawMeshFace(RMA.OpenNURBS.IOnMesh,System.Int32,RMA.Rhino.IDisplayPipelineAttributes)">
            <summary>Draw a single face from a mesh</summary>
            <param name="mesh">[in] the mesh that contains the face to draw</param>
            <param name="face_index">[in] the index into the mesh's m_F array for the face</param>
            <param name="da">
[in] Display attributes to use for drawing. This is required. Passing NULL will not draw anything
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawMesh(RMA.OpenNURBS.IOnMesh,RMA.Rhino.IDisplayPipelineAttributes)">
            <summary>Draw a mesh with a given set of display attributes</summary>
            <param name="mesh">[in] Mesh to draw</param>
            <param name="da">
[in] Display attributes to use for drawing. This is required. Passing
NULL will not draw anything
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawConstructionPlane(RMA.OpenNURBS.IOn3dmConstructionPlane,System.Boolean,System.Boolean,System.Boolean,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32,System.Int32)">
            <summary>Draws construction plane lines and axes for the given cplane object.</summary>
            <param name="bShowGrid">[in] true to draw cplane grid</param>
            <param name="bShowGridAxes">[in] true to draw cplane grid axes</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawConstructionPlane(RMA.OpenNURBS.IOn3dmConstructionPlane,System.Boolean,System.Boolean,System.Boolean,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32,System.Int32,System.Int32)">
            <summary>Draws construction plane lines and axes for the given cplane object.</summary>
            <param name="bShowGrid">[in] true to draw cplane grid</param>
            <param name="bShowGridAxes">[in] true to draw cplane grid axes</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawConstructionPlane(RMA.OpenNURBS.IOn3dmConstructionPlane,System.Boolean,System.Boolean,System.Boolean,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>Draws construction plane lines and axes for the given cplane object.</summary>
            <param name="bShowGrid">[in] true to draw cplane grid</param>
            <param name="bShowGridAxes">[in] true to draw cplane grid axes</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.DrawWorldAxes(System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>Draws world axes icon in lower left corner of viewport.</summary>
            <param name="xaxis_color">[in] X axis color</param>
            <param name="yaxis_color">[in] Y axis color</param>
            <param name="zaxis_color">[in] Z axis color</param>
            <param name="axes_length">[in] length in pixels (25 works well)</param>
            <param name="label_offset">in] distance in pixels lables are placed from axes</param>
            <param name="letter_size">[in] label font size (in points, 14 works well)</param>
            <param name="bLabelsMove">
[in] TRUE means the letters move so they are not covered by the axes lines.
FALSE means the letters always appear to the right of the axes end.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.PopModelTransform">
            <summary>
Restore a model transform that was pushed on to a stack of transforms using
the PushModelTransform function
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.PopModelTransform(RMA.OpenNURBS.OnXform)">
            <summary>
Restore a model transform that was pushed on to a stack of transforms using
the PushModelTransform function
</summary>
            <param name="previous_mt">
[out] if the stack contained transforms and a pop was successful
this parameter contains the value of the previous model transform
before the pop occured
This parameter can be NULL
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.PushModelTransform(RMA.OpenNURBS.IOnXform)">
            <summary>
Save the current model transform on a stack and set a new model transform
</summary>
            <param name="mt">[in] the transform that the engine's model transform will be set to.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.SetModelTransform(RMA.OpenNURBS.IOnXform)">
            <summary>
Set a model transformation that will be applied to all future drawing
operations. All line and point buffers are always flushed in ths function
before the transformation is set.
</summary>
            <param name="mt">[in] the transform that the engine's model transform will be set to.</param>
            <returns>previous transformation used for the model transform</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.ModelTransform">
            <returns>
The model transformation that is currently being applied to geometry
for drawing.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.ActiveStereoProjection">
            <returns>0 = left, 1 = right...</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.ShutdownEngine">
            <summary>
Should completely shutdown and destroy everything associated with this engine...
This includes any runtime buffers, dibs, or rendering contexts
</summary>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.ResetEngine">
            <summary>
Should reset the engine back to some initial state...but at the same time
try to maintain current state (ie. opened or closed).
Typically this means saving the current state, shutting down the engine and then
restarting the engine with the saved state
This is typically only used for things like changing the multisampling modes for an engine
</summary>
            <returns>true if the reset operation was successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.StopEngine">
            <summary>
Near the end of drawing a frame the display pipeline will call StopEngine to tell
the engine that it should flush any remaining buffers and perform and other task
that must occur just prior to displaying the frame.
</summary>
            <returns>
true if the engine was successfully stopped. This is pretty much always true
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.StartEngine">
            <summary>
At the very beginning of drawing each frame the pipeline will call StartEngine
to allow the engine to perform any required initializaion or context enabling
All subclasses that override this function should call this base class version
of the function.
</summary>
            <returns>
True if the engine was successfully "started". False if something went wrong.
If the function returns false, the pipeline will not be able to draw a frame.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.GetMultiSampleMode">
            <returns>
The current multi-sample mode for this engine or -1 if multisampling is not supported
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.SetMultiSampleMode(System.Int32)">
            <summary>Set the current multisampling mode for this engine</summary>
            <param name="mode">[in] one of the modes retrieved from GetMultiSampleModes function</param>
            <returns>
true on success. If the engine does not support multisampling the return value
will always be false
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.GetMultiSampleModes(RMA.OpenNURBS.Arrayint@)">
            <summary>
If this engine supports multisampling, this function retrieves a list of the
multisampling modes available
</summary>
            <param name="modes">[out] list of multi-sample modes available</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.SupportsMultiSampling">
            <returns>
True if the underlying engine technology support multisampling modes. This
is used for anti-aliasing purposes and depends on the installed graphics card.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.SupportsMultiTexturing">
            <returns>
True if multiple blended textures can be applied to triangles.
Basically this is false for GDI and true for OpenGL and DirectX
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.SupportsShading">
            <returns>
True if the display engine support drawing triangles with lighting effects.
Basically this is false for GDI and true for OpenGL and DirectX
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.MaxClipPlanesSupported">
            <returns>
The maximum number of user defined clipping planes supported. This does not
include the standard view frustum clipping planes. OpenGL and Direct3D will
support different numbers of clipping planes based on the installed graphics card.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.MaxLightsSupported">
            <returns>
The maximum number of lights supported for shading. OpenGL and Direct3D
will support different numbers of lights based on the installed graphics card.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.IsAccelerated">
            <summary>Is this engine drawing using hardware acceleration?</summary>
            <returns>true if the engine is using hardware accelerated OpenGL or Direct3D</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.VP">
            <summary>
Get the viewport that this engine draws the contents of
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayEngine.GetDC">
            <summary>
Get the device context that this engine works with.
</summary>
        </member>
        <member name="P:RMA.Rhino.MRhinoDisplayEngine.m_PointBufferSize">
            <value>
Points are placed into engine maintained buffers and drawn all at once
when the buffer if full or the engine is told to flush the point buffer
m_PointBufferSize is the maximum number of elements in the point buffer
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoDisplayEngine.m_LineBufferSize">
            <value>
Lines are placed into engine maintained buffers and drawn all at once
when the buffer if full or the engine is told to flush the line buffer
m_LineBufferSize is the maximum number of elements in the line buffer
</value>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayEngine.GetCurveAttributes(RMA.Rhino.MRhCurveAttributes@)">
            <summary>
Get the current curve attributes that are being used by the engine
</summary>
            <param name="attributes">[out] the current curve attributes</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayEngine.MeasureString(System.Drawing.Rectangle@,System.String,RMA.OpenNURBS.IOn2dPoint)">
            <summary>
Determine screen rectangle that would be drawn to using the DrawString(..) function
with the same parameters.
</summary>
            <param name="rect">[out] rectangle in the viewport's screen coordinates on success</param>
            <param name="text">[in] text to measure</param>
            <param name="point">[in] definition point, either lower-left or middle</param>
            <returns>true on success, false on failure</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayEngine.MeasureString(System.Drawing.Rectangle@,System.String,RMA.OpenNURBS.IOn2dPoint,System.Boolean)">
            <summary>
Determine screen rectangle that would be drawn to using the DrawString(..) function
with the same parameters.
</summary>
            <param name="rect">[out] rectangle in the viewport's screen coordinates on success</param>
            <param name="text">[in] text to measure</param>
            <param name="point">[in] definition point, either lower-left or middle</param>
            <param name="bMiddle">
[in] if true, text is centered on point, (default false)
if false, point defines lower left corner of text
</param>
            <returns>true on success, false on failure</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayEngine.MeasureString(System.Drawing.Rectangle@,System.String,RMA.OpenNURBS.IOn2dPoint,System.Boolean,System.Int32)">
            <summary>
Determine screen rectangle that would be drawn to using the DrawString(..) function
with the same parameters.
</summary>
            <param name="rect">[out] rectangle in the viewport's screen coordinates on success</param>
            <param name="text">[in] text to measure</param>
            <param name="point">[in] definition point, either lower-left or middle</param>
            <param name="bMiddle">
[in] if true, text is centered on point, (default false)
if false, point defines lower left corner of text
</param>
            <param name="rotation">[in] Text rotation in 1/10 degrees (default 0)</param>
            <returns>true on success, false on failure</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayEngine.MeasureString(System.Drawing.Rectangle@,System.String,RMA.OpenNURBS.IOn2dPoint,System.Boolean,System.Int32,System.Int32)">
            <summary>
Determine screen rectangle that would be drawn to using the DrawString(..) function
with the same parameters.
</summary>
            <param name="rect">[out] rectangle in the viewport's screen coordinates on success</param>
            <param name="text">[in] text to measure</param>
            <param name="point">[in] definition point, either lower-left or middle</param>
            <param name="bMiddle">
[in] if true, text is centered on point, (default false)
if false, point defines lower left corner of text
</param>
            <param name="rotation">[in] Text rotation in 1/10 degrees (default 0)</param>
            <param name="height">[in] height in pixels (default 12)</param>
            <returns>true on success, false on failure</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayEngine.MeasureString(System.Drawing.Rectangle@,System.String,RMA.OpenNURBS.IOn2dPoint,System.Boolean,System.Int32,System.Int32,System.String)">
            <summary>
Determine screen rectangle that would be drawn to using the DrawString(..) function
with the same parameters.
</summary>
            <param name="rect">[out] rectangle in the viewport's screen coordinates on success</param>
            <param name="text">[in] text to measure</param>
            <param name="point">[in] definition point, either lower-left or middle</param>
            <param name="bMiddle">
[in] if true, text is centered on point, (default false)
if false, point defines lower left corner of text
</param>
            <param name="rotation">[in] Text rotation in 1/10 degrees (default 0)</param>
            <param name="height">[in] height in pixels (default 12)</param>
            <param name="fontface">[in] font to use for text (default Arial)</param>
            <returns>true on success, false on failure</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayEngine.LightCount">
            <returns>Number of lights this engine is currently using for drawing shaded geometry</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayEngine.ActiveStereoProjection">
            <returns>0 = left, 1 = right...</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayEngine.GetMultiSampleMode">
            <returns>
The current multi-sample mode for this engine or -1 if multisampling is not supported
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayEngine.GetMultiSampleModes(RMA.OpenNURBS.Arrayint@)">
            <summary>
If this engine supports multisampling, this function retrieves a list of the
multisampling modes available
</summary>
            <param name="modes">[out] list of multi-sample modes available</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayEngine.SupportsMultiSampling">
            <returns>
True if the underlying engine technology support multisampling modes. This
is used for anti-aliasing purposes and depends on the installed graphics card.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayEngine.SupportsMultiTexturing">
            <returns>
True if multiple blended textures can be applied to triangles.
Basically this is false for GDI and true for OpenGL and DirectX
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayEngine.SupportsShading">
            <returns>
True if the display engine support drawing triangles with lighting effects.
Basically this is false for GDI and true for OpenGL and DirectX
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayEngine.MaxClipPlanesSupported">
            <returns>
The maximum number of user defined clipping planes supported. This does not
include the standard view frustum clipping planes. OpenGL and Direct3D will
support different numbers of clipping planes based on the installed graphics card.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayEngine.MaxLightsSupported">
            <returns>
The maximum number of lights supported for shading. OpenGL and Direct3D
will support different numbers of lights based on the installed graphics card.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayEngine.IsAccelerated">
            <returns>
The maximum number of lights supported for shading. OpenGL and Direct3D
will support different numbers of lights based on the installed graphics card.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayEngine.VP">
            <summary>
Get the viewport that this engine draws the contents of
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoClippingPlaneObject.ClipsViewport(System.Guid)">
            <returns>
true if the viewport_id is in the list of viewports that this object clips
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoClippingPlaneObject.RemoveClipViewport(System.Guid)">
            <summary>
A clipping plane object maintains a list of viewports that it clips against.
This is stored in ON_ClippingPlane::m_viewport_ids
</summary>
            <param name="viewport_id">[in] the viewport that should no longer be clipped by this object</param>
            <returns>
true if successful
false if this object did not already clip the viewport (the viewport id was not in the object's list)
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoClippingPlaneObject.AddClipViewport(System.Guid)">
            <summary>
A clipping plane object maintains a list of viewports that it clips against.
This is stored in ON_ClippingPlane::m_viewport_ids
</summary>
            <param name="viewport_id">[in] the viewport that should be clipped by this object</param>
            <returns>
true if successful
false if this object already clips the viewport (the viewport id is already in the object's list)
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoClippingPlaneObject.ClippingPlane">
            <summary>
copies source object UUID
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoClippingPlaneObject.#ctor(RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <summary>
assigns a new object UUID
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoClippingPlaneObject.#ctor">
            <summary>
assigns a new object UUID
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoClippingPlaneObject.ClipsViewport(System.Guid)">
            <returns>
true if the viewport_id is in the list of viewports that this object clips
</returns>
        </member>
        <member name="M:RMA.UI.MRhinoObjectPropertiesDialogPage.SelectedObjectCount">
            <summary>Access to selected objects list</summary>
        </member>
        <member name="M:RMA.UI.MRhinoObjectPropertiesDialogPage.PageType">
            <summary>
This defaults to custom_page.  Override and return the system page you want to replace.  Values of material_page and
light_page are only meaningfull if this page was added by a CRhinoRenderPlugIn and the plug-in is the current renderer.
</summary>
        </member>
        <member name="M:RMA.UI.MRhinoStackedDialogPage.SetIsPageModified(System.Boolean)">
            <summary>
This method gets called by the main dialog when deciding if it should call the pages
OnApply() method.  If the dialog page has not been created and IsPageModified() returns
false OnApply() is not called.  If the dialog page has been created or IsPageModified()
returns true then OnApply() is called.
</summary>
            <param name="b">[in] New value</param>
            <returns>Returns previous state</returns>
        </member>
        <member name="M:RMA.UI.MRhinoStackedDialogPage.IsPageModified">
            <summary>
This method gets called by the main dialog when deciding if it should call the pages
OnApply() method.  If the dialog page has not been created and IsPageModified() returns
false OnApply() is not called.  If the dialog page has been created or IsPageModified()
returns true then OnApply() is called.
</summary>
            <returns>Returns the modified state of this page</returns>
        </member>
        <member name="M:RMA.UI.MRhinoStackedDialogPage.GetPageCount">
            <summary>Call this method to get the number of first level sub pages associated with this page.</summary>
            <returns>the number of child pages which were associated with this page by calling AddPage()</returns>
        </member>
        <member name="M:RMA.UI.MRhinoStackedDialogPage.IndexFromPage(RMA.UI.MRhinoStackedDialogPage)">
            <summary>Call this method to get the page index associated with sub-page which was added by calling AddPage()</summary>
            <returns>a zero based index used to reference the page if found otherwise returns -1</returns>
        </member>
        <member name="M:RMA.UI.MRhinoStackedDialogPage.GetPage(System.Int32)">
            <summary>Get child page from a given index</summary>
            <param name="nPage">Index for child page to retrieve</param>
        </member>
        <member name="M:RMA.UI.MRhinoStackedDialogPage.OnDefaults">
            <summary>Called when stacked dialog Defaults button is pressed (see ShowDefaultsButton).</summary>
        </member>
        <member name="M:RMA.UI.MRhinoStackedDialogPage.ShowDefaultsButton">
            <summary>Called when this page is activated.</summary>
            <returns>
true  : if the page wants the "Defaults" button to appear.
false : if the page does not want the "Defaults" button to appear.

Default returns false
Note: returning false implies that OnDefaults() method will never get called.
</returns>
        </member>
        <member name="M:RMA.UI.MRhinoStackedDialogPage.OnActivate(System.Boolean)">
            <summary>Called when this page is activated/deactivated.</summary>
            <param name="bActive">If true then this page is on top otherwise it is about to be hidden.</param>
            <returns>
If true then the page is hidden and the requested page is not
activated otherwise will not allow you to change the current page.
Default returns true
</returns>
        </member>
        <member name="M:RMA.UI.MRhinoStackedDialogPage.OnCancel">
            <summary>Called when stacked dialog Cancel button is pressed.</summary>
        </member>
        <member name="M:RMA.UI.MRhinoStackedDialogPage.OnApply">
            <summary>Called when stacked dialog OK button is pressed.</summary>
            <returns>
If return value is non zero then the dialog will be closed otherwise assumes
there was an error and dialog remains open so page can be properly updated.
</returns>
        </member>
        <member name="M:RMA.UI.MRhinoStackedDialogPage.SetShowFirstSubPage(System.Boolean)">
            <summary>
Display first branch instead of this dialog. This allows for a top
level object to be present in a tree control but display the first sub page.
</summary>
            <returns>previous ShowFirstSubPage value</returns>
        </member>
        <member name="M:RMA.UI.MRhinoStackedDialogPage.ShowFirstSubPage">
            <summary>
Display first branch instead of this dialog. This allows for a top
level object to be present in a tree control but display the first sub page.
</summary>
        </member>
        <member name="M:RMA.UI.MRhinoStackedDialogPage.AddPage(RMA.UI.MRhinoStackedDialogPage)">
            <summary>
Add a branch to this page. Stacked dialogs allow for page nesting. This method is called to add pages to this page.
</summary>
            <returns>Return the sub page index or -1 on error.</returns>
        </member>
        <member name="M:RMA.UI.MRhinoStackedDialogPage.GetPageControl">
            <summary>Return the control that represents this page. This will typically be a custom user control.</summary>
        </member>
        <member name="M:RMA.UI.MRhinoStackedDialogPage.LocalPageTitle">
            <summary>Called by stacked dialog to add page title to some kind of list/tree control.</summary>
            <returns>Display string for this page. This string is also used when calling command is scripted.</returns>
        </member>
        <member name="M:RMA.UI.MRhinoStackedDialogPage.EnglishPageTitle">
            <summary>Called by stacked dialog to add page title to some kind of list/tree control.</summary>
            <returns>Display string for this page. This string is also used when calling command is scripted.</returns>
        </member>
        <member name="M:RMA.UI.MRhinoUiToolBarManager.CloseCollection(System.Int32)">
            <summary>Close specified collection file.</summary>
            <param name="index">[in] - Zero based collection index.</param>
            <returns>
IDYES = Changes saved and collection closed
IDNO = Closed but changes not saved 
IDCANCEL = User pressed cancel when prompted for save so collection not saved or closed
IDABORT = Name or index is invalid, nothing happened
</returns>
        </member>
        <member name="M:RMA.UI.MRhinoUiToolBarManager.CloseCollection(System.Int32,System.Boolean)">
            <summary>Close specified collection file.</summary>
            <param name="index">[in] - Zero based collection index.</param>
            <param name="bPromptForSaveIfModified">
[in] - If true then will prompt user to save collection file if it has been modified prior to closing.
If FALSE then file is closed without saving.
</param>
            <returns>
IDYES = Changes saved and collection closed
IDNO = Closed but changes not saved 
IDCANCEL = User pressed cancel when prompted for save so collection not saved or closed
IDABORT = Name or index is invalid, nothing happened
</returns>
        </member>
        <member name="M:RMA.UI.MRhinoUiToolBarManager.CloseCollection(System.String)">
            <summary>Close specified collection file.</summary>
            <param name="lpsName">[in] - Name of collection file to close.</param>
            <returns>
IDYES = Changes saved and collection closed
IDNO = Closed but changes not saved
IDCANCEL = User pressed cancel when prompted for save so collection not saved or closed
IDABORT = Name or index is invalid, nothing happened
</returns>
        </member>
        <member name="M:RMA.UI.MRhinoUiToolBarManager.CloseCollection(System.String,System.Boolean)">
            <summary>Close specified collection file.</summary>
            <param name="lpsName">[in] - Name of collection file to close.</param>
            <param name="bPromptForSaveIfModified">
[in] - If true then will prompt user to save collection file if it has been modified prior to closing.
If FALSE then file is closed without saving.
</param>
            <returns>
IDYES = Changes saved and collection closed
IDNO = Closed but changes not saved
IDCANCEL = User pressed cancel when prompted for save so collection not saved or closed
IDABORT = Name or index is invalid, nothing happened
</returns>
        </member>
        <member name="M:RMA.UI.MRhinoUiToolBarManager.CloseCollection(System.String,System.Boolean,System.Boolean)">
            <summary>Close specified collection file.</summary>
            <param name="lpsName">[in] - Name of collection file to close.</param>
            <param name="bPromptForSaveIfModified">
[in] - If true then will prompt user to save collection file if it has been modified prior to closing.
If FALSE then file is closed without saving.
</param>
            <returns>
IDYES = Changes saved and collection closed
IDNO = Closed but changes not saved
IDCANCEL = User pressed cancel when prompted for save so collection not saved or closed
IDABORT = Name or index is invalid, nothing happened
</returns>
        </member>
        <member name="M:RMA.UI.MRhinoUiToolBarManager.NewEmptyCollection(System.String)">
            <summary>Create new collection file with no toolbars.</summary>
            <param name="lpsFileName">[in] - Full path, including file extension to collection file you wish to create.</param>
            <returns>If collection is created then valid pointer to new collection is returned; otherwise NULL.</returns>
        </member>
        <member name="M:RMA.UI.MRhinoUiToolBarManager.NewEmptyCollection(System.Windows.Forms.IWin32Window)">
            <summary>Prompt for a new collection file name and create new, empty, collection.</summary>
            <param name="hWndParent">[in] - Handle of window to own file dialog box.</param>
            <returns>If collection is created then valid pointer to new collection is returned; otherwise NULL.</returns>
        </member>
        <member name="M:RMA.UI.MRhinoUiToolBarManager.CollectionIndex(System.String)">
            <summary>
Convert collection file name or alias into a index useable by CRhinoToolBarManager::Collection(...)
</summary>
            <param name="lpsName">[in] - Collection file name or alias.</param>
            <returns>-1 If name not found otherwise a zero based index for collection</returns>
        </member>
        <member name="M:RMA.UI.MRhinoUiToolBarManager.CollectionIndex(System.String,System.Boolean)">
            <summary>
Convert collection file name or alias into a index useable by CRhinoToolBarManager::Collection(...)
</summary>
            <param name="lpsName">[in] - Collection file name or alias.</param>
            <param name="bAlias">[in[ - if true then lpsCollection is alias otherwise it is a file name.</param>
            <returns>-1 If name not found otherwise a zero based index for collection</returns>
        </member>
        <member name="M:RMA.UI.MRhinoUiToolBarManager.GetCollection(System.Int32)">
            <summary>Enumerate currently open tool bar collection file list.</summary>
            <param name="index">[in] - Zero based collection index.</param>
            <returns>If index is valid then a CRhinoUiToolBarCollection pointer is returned; otherwise NULL.</returns>
        </member>
        <member name="M:RMA.UI.MRhinoUiToolBarManager.Collection(System.String)">
            <summary>Find specified collection file name.</summary>
            <param name="lpsName">[in] - Collection file name or alias.</param>
            <returns>
If name is found then a CRhinoUiToolBarCollection pointer is returned; otherwise NULL.
</returns>
        </member>
        <member name="M:RMA.UI.MRhinoUiToolBarManager.Collection(System.String,System.Boolean)">
            <summary>Find specified collection file name.</summary>
            <param name="lpsName">[in] - Collection file name or alias.</param>
            <param name="bAlias">[in] - true = lpsName is alias, false = lpsName is file name.</param>
            <returns>
If name is found then a CRhinoUiToolBarCollection pointer is returned; otherwise NULL.
</returns>
        </member>
        <member name="M:RMA.UI.MRhinoUiToolBarManager.Collection(System.Int32)">
            <summary>Enumerate currently open tool bar collection file list.</summary>
            <param name="index">[in] - Zero based collection index.</param>
            <returns>If index is valid then a CRhinoUiToolBarCollection pointer is returned; otherwise NULL.</returns>
        </member>
        <member name="M:RMA.UI.MRhinoUiToolBarManager.CollectionCount">
            <summary>Number of currently open collection files.</summary>
            <returns>Number of currently open collection files.</returns>
        </member>
        <member name="M:RMA.UI.MRhinoUiToolBarManager.ReadFile(System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Open and read existing tool bar collection file</summary>
            <param name="lpsFileName">[in] - Full path to collection file to open including file extension.</param>
            <param name="bRecalcLayout">[in] - Call Rhino frame windows RecalcLayout() method.</param>
            <param name="bShowProgressControl">[in] - If true then progress control will be displayed in the status bar otherwise nothing will be displayed.</param>
            <returns>true if collection is opened succesfully.</returns>
        </member>
        <member name="M:RMA.UI.MRhinoUiToolBarCollection.GetExistingCollectionFileVersion(System.String,System.String@)">
            <returns>value &lt; 0 on error or file version.  Two is returned for version two files.</returns>
        </member>
        <member name="M:RMA.UI.IRhinoUiToolBarCollection.GetExistingCollectionFileVersion(System.String,System.String@)">
            <returns>Returns value &lt; 0 on error or file version.  Two is returned for version two files.</returns>
        </member>
        <member name="M:RMA.UI.MRhinoDockBarManager.LockDockingLocation(System.Boolean)">
            <summary>
Docking location locked means any dock bar that is currently docked can not
be moved and any floating dock bar may be moved around but not docked.  This
does not preclude a dock bars visibility state from changing.
</summary>
            <param name="b">[in] New value for locked state.</param>
            <returns>previous locked state.</returns>
        </member>
        <member name="M:RMA.UI.MRhinoDockBarManager.DockingLocationLocked">
            <summary>
Docking location locked means any dock bar that is currently docked can not
be moved and any floating dock bar may be moved around but not docked.  This
does not preclude a dock bars visibility state from changing.
</summary>
            <returns>true if dock bars current docked/floating state is locked otherwise false</returns>
        </member>
        <member name="M:RMA.UI.MRhinoDockBarManager.HideOnDeactivateEnabled">
            <summary>
The CRhinoUiDockBarManager calls this method to determine if it should 
hide floating, visible CRhinoUiDockBars and floating Rhino views when
the application is deactivated.
</summary>
            <returns>true if it bars and views should be temporarily hidden.</returns>
        </member>
        <member name="M:RMA.UI.MRhinoDockBarManager.DisableHideOnDeactivate(System.Boolean)">
            <summary>
The CRhinoUiDockBarManager calls this method to determine if it should 
hide floating, visible CRhinoUiDockBars and floating Rhino views when
the application is deactivated.
</summary>
            <param name="b">
[in] If true then dock bars and views will not be hidden oterwise they will.
</param>
        </member>
        <member name="M:RMA.UI.MRhinoDockBarManager.IsDockBarVisible(System.Guid)">
            <summary>Call this method to determine if a dock bar is currently visible.</summary>
            <param name="bar_id">[in] ID for dock bar to check visiblity state.</param>
            <returns>true if dock bar is currently visible or false if it is not.</returns>
        </member>
        <member name="M:RMA.UI.MRhinoDockBarManager.DockDockBar(System.Guid,System.UInt32)">
            <summary>Call this method to cause a dock bar to be docked to the main frame window.</summary>
            <param name="bar_id">[in] ID for dock bar to dock.</param>
            <param name="dock_location">
[in] Determines which sides of the frame window to consider for docking.
It can be 0, or one or more of the following: 
MRhinoUiDockBar::DockLocation::AFX_IDW_DOCKBAR_TOP
MRhinoUiDockBar::DockLocation::AFX_IDW_DOCKBAR_BOTTOM
MRhinoUiDockBar::DockLocation::AFX_IDW_DOCKBAR_LEFT
MRhinoUiDockBar::DockLocation::AFX_IDW_DOCKBAR_RIGHT
If 0, the dock bar can be docked to any side enabled for docking in the destination frame window. 
</param>
        </member>
        <member name="M:RMA.UI.MRhinoDockBarManager.DockDockBar(System.Guid,System.UInt32,System.Drawing.Rectangle)">
            <summary>Call this method to cause a dock bar to be docked to the main frame window.</summary>
            <param name="bar_id">[in] ID for dock bar to dock.</param>
            <param name="dock_location">
[in] Determines which sides of the frame window to consider for docking.
It can be 0, or one or more of the following: 
MRhinoUiDockBar::DockLocation::AFX_IDW_DOCKBAR_TOP
MRhinoUiDockBar::DockLocation::AFX_IDW_DOCKBAR_BOTTOM
MRhinoUiDockBar::DockLocation::AFX_IDW_DOCKBAR_LEFT
MRhinoUiDockBar::DockLocation::AFX_IDW_DOCKBAR_RIGHT
If 0, the dock bar can be docked to any side enabled for docking in the destination frame window. 
</param>
            <param name="rect">
[in] Determines, in screen coordinates, where the dock bar will be docked in the nonclient area
of the destination frame window. 
</param>
        </member>
        <member name="M:RMA.UI.MRhinoDockBarManager.FloatDockBar(System.Guid,System.Drawing.Point)">
            <summary>Call this method to cause a dock bar to not be docked to the frame window.</summary>
            <param name="bar_id">[in] ID for dock bar to float.</param>
            <param name="point">[in] The location, in screen coordinates, where the top left corner of the dock bar will be placed.</param>
            <seealso>
MSDN help for CFrameWnd::FloatControlBar()
MSDN help for CFrameWnd::FloatControlBar
</seealso>
        </member>
        <member name="M:RMA.UI.MRhinoDockBarManager.ShowDockBar(System.Guid,System.Boolean,System.Boolean)">
            <summary>Show or hide specified dock bar.</summary>
            <param name="bar_id">[in] ID for dock bar to show or hide.</param>
            <param name="show_control_bar">[in] If true show dock bar otherwise hide it</param>
            <param name="delay_recalc_layout">[in] See MSDN help for CFrameWnd::ShowDockBar</param>
        </member>
        <member name="M:RMA.UI.MRhinoDockBarManager.CreateRhinoDockBar(RMA.Rhino.MRhinoPlugIn,RMA.UI.MRhinoUiDockBar,System.Boolean,&lt;unknown type&gt;,&lt;unknown type&gt;,System.Drawing.Point)">
            <summary>Call to create and display dock bar in default location.</summary>
            <param name="plugin">plug-in creating this dock bar</param>
            <param name="dock_bar">Control bar information</param>
            <param name="show_control_bar">[in] Display dock bar if created successfully.</param>
            <param name="default_dock_location">[in] Default display location of dock bar.</param>
            <param name="dock_style">[in] - Areas this dock bar is allowed to be docked.</param>
            <param name="float_point">
[in] - Only used if default_dock_location==floating.  If floating
dock bar then this is the top left corner of the dock bar.
</param>
        </member>
        <member name="M:RMA.UI.MRhinoDockBarManager.CreateRhinoDockBar(RMA.Rhino.MRhinoPlugIn,RMA.UI.MRhinoUiDockBar,System.Boolean,&lt;unknown type&gt;,&lt;unknown type&gt;)">
            <summary>Call to create and display dock bar in default location.</summary>
            <param name="plugin">plug-in creating this dock bar</param>
            <param name="dock_bar">Control bar information</param>
            <param name="show_control_bar">[in] Display dock bar if created successfully.</param>
            <param name="default_dock_location">[in] Default display location of dock bar.</param>
            <param name="dock_style">[in] - Areas this dock bar is allowed to be docked.</param>
        </member>
        <member name="M:RMA.UI.MRhinoDockBarManager.CreateRhinoDockBar(RMA.Rhino.MRhinoPlugIn,RMA.UI.MRhinoUiDockBar,System.Boolean,&lt;unknown type&gt;)">
            <summary>Call to create and display dock bar in default location.</summary>
            <param name="plugin">plug-in creating this dock bar</param>
            <param name="dock_bar">Control bar information</param>
            <param name="show_control_bar">[in] Display dock bar if created successfully.</param>
            <param name="default_dock_location">[in] Default display location of dock bar.</param>
        </member>
        <member name="M:RMA.UI.MRhinoDockBarManager.CreateRhinoDockBar(RMA.Rhino.MRhinoPlugIn,RMA.UI.MRhinoUiDockBar,System.Boolean)">
            <summary>Call to create and display dock bar in default location.</summary>
            <param name="plugin">plug-in creating this dock bar</param>
            <param name="dock_bar">Control bar information</param>
            <param name="show_control_bar">[in] Display dock bar if created successfully.</param>
        </member>
        <member name="M:RMA.UI.MRhinoDockBarManager.CreateRhinoDockBar(RMA.Rhino.MRhinoPlugIn,RMA.UI.MRhinoUiDockBar)">
            <summary>Call to create and display dock bar in default location.</summary>
            <param name="plugin">plug-in creating this dock bar</param>
            <param name="dock_bar">Control bar information</param>
        </member>
        <member name="M:RMA.UI.MRhinoUiDockBar.ToggleDocking">
            <summary>
Toggle dock bars docked state.  If docked then float otherwise if floating then
return to most recent docked position.
</summary>
        </member>
        <member name="M:RMA.UI.MRhinoUiDockBar.IsCaptionButtonVisible(RMA.UI.MRhinoUiDockBar.caption_button)">
            <summary>Check to see if a caption button is visible or will be when the dock bar is created.</summary>
            <param name="button">Caption button to check for.</param>
            <returns>
true If caption button visibility is visible or will be when dock bar is created.
</returns>
        </member>
        <member name="M:RMA.UI.MRhinoUiDockBar.ShowCaptionButton(RMA.UI.MRhinoUiDockBar.caption_button,System.Boolean)">
            <summary>Show or hide dock bar caption buttons.</summary>
            <param name="button">Caption button to show or hide.</param>
            <param name="show">If true then show the button otherwise hide it.</param>
            <returns>
true If caption button visibility is updated or will be updated when dock bar is created.
false On error.
</returns>
        </member>
        <member name="M:RMA.UI.MRhinoUiDockBar.SetDockBarFlag(RMA.UI.MRhinoUiDockBar.control_bar_flags,System.Boolean)">
            <summary>Set dock bar style flag.</summary>
            <param name="flag">Flag to set</param>
            <param name="b">New value for flag</param>
            <returns>Previous flag value</returns>
        </member>
        <member name="M:RMA.UI.MRhinoUiDockBar.IsDockBarFlagSet(RMA.UI.MRhinoUiDockBar.control_bar_flags)">
            <summary>Check to see if style flag is set.</summary>
            <param name="flag">Flag to check</param>
            <returns>true If flag is set otherwise false.</returns>
        </member>
        <member name="M:RMA.UI.MRhinoUiDockBar.IsDockedVert">
            <summary>Check to see if this dock bar is docked at the right or left side of the Rhino main frame window.</summary>
            <returns>true If the dock bar is docked on the right or left side.</returns>
        </member>
        <member name="M:RMA.UI.MRhinoUiDockBar.IsDockedLeft">
            <summary>Check to see if this dock bar is docked on the right sied of the Rhino main frame window.</summary>
            <returns>true If the dock bar is docked on the left side.</returns>
        </member>
        <member name="M:RMA.UI.MRhinoUiDockBar.IsDockedRight">
            <summary>Check to see if this dock bar is docked on the right sied of the Rhino main frame window.</summary>
            <returns>true If the dock bar is docked on the rigth side.</returns>
        </member>
        <member name="M:RMA.UI.MRhinoUiDockBar.IsDockedHoriz">
            <summary>Check to see if this dock bar is docked at the top or bottom of the Rhino  main frame window.</summary>
            <returns>true If the dock bar is docked at the top or bottom.</returns>
        </member>
        <member name="M:RMA.UI.MRhinoUiDockBar.IsDockedBottom">
            <summary>Check to see if this dock bar is docked at the bottom of the Rhino main frame window.</summary>
            <returns>true If the dock bar is docked at the bottom.</returns>
        </member>
        <member name="M:RMA.UI.MRhinoUiDockBar.IsDockedTop">
            <summary>Check to see if this dock bar is docked at the top of the Rhino main frame window.</summary>
            <returns>true If the dock bar is docked at the top.</returns>
        </member>
        <member name="M:RMA.UI.MRhinoUiDockBar.IsDocked">
            <summary>Check to see if this dock bar is docked.</summary>
            <summary>true If the dock bar is docked at the top, bottom, left or right.</summary>
        </member>
        <member name="M:RMA.UI.MRhinoUiDockBar.GetDockLocation">
            <summary>Get the current docked location of this dock bar.</summary>
        </member>
        <member name="M:RMA.UI.MRhinoUiDockBar.UseSmallGripper(System.Boolean)">
            <summary>Use small gripper like CRhinoUiToolbar</summary>
            <param name="b">[in] If true then small gripper is used otherwise large gripper is used.</param>
            <returns>previous state.</returns>
        </member>
        <member name="M:RMA.UI.MRhinoUiDockBar.ForceOnScreen">
            <summary>
Call to assure that the entire dock bar is visible on the monitor which
contains the greatest amount of the control bar.  If the control bar 
is outside of a monitor then it is pushed onto the monitor containing
the main Rhino window.  This is used by CRhinoUiDockBarManager::ShowDockBar()
right after showing a control bar.
</summary>
        </member>
        <member name="M:RMA.UI.MRhinoUiDockBar.SetInitialSizeDockedHorz(System.Drawing.Size)">
            <summary>
Set initial dock bar size when docked on top or bottom of Rhino main
frame window. Should be called prior to calling CRhinoUiDockBar::CreateRhinoDockBar().
</summary>
            <param name="initialSize">[in] initial size</param>
            <returns>false if this function was called after CreateRhinoDockBar</returns>
        </member>
        <member name="M:RMA.UI.MRhinoUiDockBar.SetInitialSizeDockedVert(System.Drawing.Size)">
            <summary>
Set initial dock bar size when docked on right or left side of Rhino main
frame window. Should be called prior to calling CRhinoUiDockBar::CreateRhinoDockBar().
If this function is not called before CreateRhinoDockBar, the size of the custom control
is used t deteremine initial size
</summary>
            <param name="initialSize">[in] initial size</param>
            <returns>false if this function was called after CreateRhinoDockBar</returns>
        </member>
        <member name="M:RMA.UI.MRhinoUiDockBar.SetInitialSizeFloating(System.Drawing.Size)">
            <summary>
Set initial dock bar size when floating. Must be called prior to calling
CRhinoUiDockBar::CreateRhinoDockBar().
</summary>
            <param name="initialSize">[in] initial size</param>
            <returns>false if this function was called after CreateRhinoDockBar</returns>
        </member>
        <member name="M:RMA.UI.MRhinoUiDockBar.OnDockBarPositionChanged(&lt;unknown type&gt;)">
            <summary>Called when a dock bars docked location has changed.</summary>
            <param name="dwNewLocation">[in] New dock location</param>
        </member>
        <member name="M:RMA.UI.MRhinoUiDockBar.OnStartTracking(System.Boolean)">
            <summary>Called just priror to and just after dock bar is stretched while docked.</summary>
            <param name="bDoneTracking">
[in] If true then it stretching is complete; otherwise just getting started.
</param>
        </member>
        <member name="M:RMA.UI.MRhinoUiDockBar.OnToggleDocking(System.Boolean)">
            <summary>Called just priror to and just after tool bars docking state is being toggled.</summary>
            <param name="bStart">
[in] If true then it is being called prior to state changing;
otherwise state has changed.
</param>
        </member>
        <member name="M:RMA.UI.MRhinoUiDockBar.CanClose">
            <summary>
Called by close caption button prior to closing the dock bar.  Default
Implimentation returns true.
</summary>
            <returns>true If dock bar is allowed to close.</returns>
        </member>
        <member name="M:RMA.UI.MRhinoUiDockBar.OnHelpCaptionButtonPressed">
            <summary>Called when help caption button is pressed.</summary>
        </member>
        <member name="M:RMA.UI.MRhinoMenuItem.FireClickEvent">
text menu items can fire events back to .NET delegates
</member>
        <member name="F:RMA.UI.MRhinoMenuItem.m_command_id">
The following may or may not have values base on the menu item type
Menu Items can be text, separators, or submenus
</member>
        <member name="F:RMA.UI.MRhinoMenuItem.m_parent_menu">
The menu or submenu that owns this menu item
</member>
        <member name="M:RMA.Rhino.MRhinoVisualAnalysisMode.DrawNurbsCurve(RMA.Rhino.IRhinoObject,RMA.OpenNURBS.IOnNurbsCurve,RMA.Rhino.MRhinoDisplayPipeline)">
            <summary>
The default does nothing. This is a good function to override for analysis modes like curvature hair display.
</summary>
            <param name="nurbs_curve">
[in] A nurbs representation of portion of the curve or a dynamically edited nurbs_curve.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoVisualAnalysisMode.DrawCurveObject(RMA.Rhino.IRhinoCurveObject,RMA.Rhino.MRhinoDisplayPipeline)">
            <summary>
If m_style = wireframe_style, then the default decomposes the curve object into
nurbs curve segments and calls the virtual DrawNurbsCurve  for each segment.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoVisualAnalysisMode.UpdateVertexColors(RMA.Rhino.IRhinoObject,RMA.OpenNURBS.OnMesh[])">
            <summary>
If m_style = CRhinoVisualAnalysisMode::false_color_style, then this virtual function must be overridden.
</summary>
            <param name="meshes">[in/out] meshes used to draw the object.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoVisualAnalysisMode.SetAnalysisModeDisplayAttributes(RMA.Rhino.IRhinoObject,RMA.Rhino.MDisplayPipelineAttributes@)">
            <summary>
If an analysis mode needs to modify display attributes, this this is the place to do it.
In particular, if m_style = CRhinoVisualAnalysisMode::texture_style, 
then this virtual function must be overridden.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoVisualAnalysisMode.ShowIsoCurves">
            <returns>
True if this visual analysis mode should show isocuves on shaded surface objects.
Often a mode's user interface will provide a way to change this setting.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoVisualAnalysisMode.ObjectSupportsAnalysisMode(RMA.Rhino.IRhinoObject)">
            <summary>Generally, a plug-in developer will override this function.</summary>
            <returns>True if this visual analysis mode can be used on object.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoVisualAnalysisMode.EnableUserInterface(System.Boolean)">
            <summary>
Turn the analysis mode's user interface on and off. For Rhino's built in modes this
opens or closes the modeless dialog that controls the analysis mode's display settings.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoVisualAnalysisMode.GetAnalysisModeName">
            <summary>
Get the name of the analysis mode.  This name is used by the What command and the
object properties details window to describe the object.
</summary>
        </member>
        <member name="P:RMA.Rhino.MRhinoVisualAnalysisMode.m_am_id">
            <value>
Identifies the analysis mode.  For built-in analysis modes, 
this is one of the static ON_UUIDs listed in the MRhinoVisualAnalysisModes properties.  Plug-ins may define
their own analysis modes, so the list above is not a complete list. The value of m_mode_id is set by the constructor.
</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoVisualAnalysisMode.Mode(System.Guid)">
            <summary>Use the visual analsis mode id to lookup a visual analysis mode.</summary>
        </member>
        <member name="P:RMA.Rhino.MRhinoVisualAnalysisMode.RhinoThicknessAnalysisModeID">
            <value>
{B28E5435-D299-4933-A95D-3783C496FC66}
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoVisualAnalysisMode.RhinoDraftAngleAnalysisModeID">
            <value>
In draft angle analysis mode, draft angle is displayed using false colors.
{F08463F4-22E2-4cf1-B810-F01925446D71}
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoVisualAnalysisMode.RhinoCurvatureColorAnalysisModeID">
            <value>
In curvature color analysis mode, surface curvature is shown using false color mapping.
{639E9144-1C1A-4bba-8248-D330F50D7B69}
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoVisualAnalysisMode.RhinoEmapAnalysisModeID">
            <value>
In emap analysis mode, an environment map is shown on surfaces and meshes.
{DAEF834E-E978-4f7b-9026-A432C678C189}
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoVisualAnalysisMode.RhinoZebraStripeAnalysisModeID">
            <value>
In zebra stripe analysis mode, zebra stripes are shown on surfaces and meshes.
{0CCA817C-95D0-4b79-B5D7-CEB5A2975CE0}
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoVisualAnalysisMode.RhinoCurvatureGraphAnalysisModeID">
            <value>
In curvature graph analysis mode, curvature hair is shown on curves and surfaces.
{DF59A9CF-E517-4846-9232-D9AE56A9D13D}
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoVisualAnalysisMode.RhinoEdgeAnalysisModeID">
            <value>
In edge anlysis mode brep and mesh edges are shown in a selected color.
{197B765D-CDA3-4411-8A0A-AD8E0891A918}
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoVisualAnalysisMode.RhinoWireframeAnalysisModeID">
            <value>
This id is passed to CRhinoObject::InAnalysisMode() to answer queries about
what types of analysis modes are active.

{43BB9491-51E9-493a-B838-89536DD00960}
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoVisualAnalysisMode.RhinoTexturedAnalysisModeID">
            <value>
This id is passed to CRhinoObject::InAnalysisMode() to answer queries about
what types of analysis modes are active.

This ID is used to check for any texture based analsysis mode like zebra or emap.
{DF0D8626-3BEA-4471-B8D9-1E85A7967985}
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoVisualAnalysisMode.RhinoFalseColorAnalysisModeID">
            <value>
This id is passed to CRhinoObject::InAnalysisMode() to answer queries about
what types of analysis modes are active.

This ID is used to check for any false color analsysis mode like draft angle or curvature.
{5B3A0840-7899-4e22-987D-4921282558C0}
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoVisualAnalysisMode.RhinoShadedAnalysisModeID">
            <value>
This id is passed to CRhinoObject::InAnalysisMode() to answer queries about
what types of analysis modes are active.

This ID is used to check for any shaded analsysis mode:
false color (like draft angle) or texture based (like zebra and emap).
{2E5FE617-7D66-4ea0-8572-A1C3F8F06B84}
</value>
        </member>
        <member name="M:RMA.Rhino.IRhinoVisualAnalysisMode.UpdateVertexColors(RMA.Rhino.IRhinoObject,RMA.OpenNURBS.OnMesh[])">
            <summary>
If m_style = CRhinoVisualAnalysisMode::false_color_style, then this virtual function must be overridden.
</summary>
            <param name="meshes">[in/out] meshes used to draw the object.</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoVisualAnalysisMode.SetAnalysisModeDisplayAttributes(RMA.Rhino.IRhinoObject,RMA.Rhino.MDisplayPipelineAttributes@)">
            <summary>
If an analysis mode needs to modify display attributes, this this is the place to do it.
In particular, if m_style = CRhinoVisualAnalysisMode::texture_style, 
then this virtual function must be overridden.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoVisualAnalysisMode.ShowIsoCurves">
            <returns>
True if this visual analysis mode should show isocuves on shaded surface objects.
Often a mode's user interface will provide a way to change this setting.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoVisualAnalysisMode.ObjectSupportsAnalysisMode(RMA.Rhino.IRhinoObject)">
            <summary>Generally, a plug-in developer will override this function.</summary>
            <returns>True if this visual analysis mode can be used on object.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoVisualAnalysisMode.EnableUserInterface(System.Boolean)">
            <summary>
Turn the analysis mode's user interface on and off. For Rhino's built in modes this
opens or closes the modeless dialog that controls the analysis mode's display settings.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoVisualAnalysisMode.GetAnalysisModeName">
            <summary>
Get the name of the analysis mode.  This name is used by the What command and the
object properties details window to describe the object.
</summary>
        </member>
        <member name="P:RMA.Rhino.IRhinoVisualAnalysisMode.m_am_id">
            <value>
Identifies the analysis mode.  For built-in analysis modes, 
this is one of the static ON_UUIDs listed in the MRhinoVisualAnalysisModes properties.  Plug-ins may define
their own analysis modes, so the list above is not a complete list. The value of m_mode_id is set by the constructor.
</value>
        </member>
        <member name="T:RMA.Rhino.IRhinoVisualAnalysisMode.analysis_style">
            <summary>
There are three supported styles.  Anything more complex has to create a display pipeline.
wireframe = like curvature hair or naked edge analysis
texture = like emap and zebra
false_color = like draft angle, curvature, thickness analysis
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.RhinoLayerIndex">
            <summary>Return layer index of item the drag cursor is currently over.</summary>
            <returns>Valid layer index if over a layer item in the Rhino layer dialog otherwise returns -1.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.RhinoLayerListCtrl">
            <summary>Check to see if mouse is currently over an the Rhino layer list control.</summary>
            <returns>
When the mouse is over the Rhino layer list control a pointer to it is returned. If not over the control then NULL is returned.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.RhinoLayerListCtrlFromDragPoint(System.Windows.Forms.IWin32Window,System.Drawing.Point,System.ValueType!System.Drawing.Point!System.Runtime.CompilerServices.IsBoxed@)">
            <summary>Point to the layer list control if the drag cursor is currently over it.</summary>
            <returns>Valid point if over the layer list control otherwise NULL.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.RhinoViewFromDragPoint(System.Windows.Forms.IWin32Window,System.Drawing.Point,System.ValueType!System.Drawing.Point!System.Runtime.CompilerServices.IsBoxed@)">
            <summary>CRhinoView that the drag cursor is currently over.</summary>
            <returns>Valid point if over a view otherwise NULL.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.DeselectAllOnDrag">
            <summary>Controls the deselection of preselected input when drag event starts.</summary>
            <returns>True if pre-selected input will be deselected when drop event starts.</returns>
            <remarks>The default is false.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.EnableDeselectAllOnDrag(System.Boolean)">
            <summary>Controls the deselection of preselected input when drag event starts.</summary>
            <param name="b">[in] If true then any objects currently selected will be deselected at beginig of drop event.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.DefaultOnEventReturnCode">
            <summary>Default value returned by CRhinoDropTarget::OnDrop... methods.</summary>
            <returns>Default value returned by CRhinoDropTarget::OnDrop... methods.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.SetDefaultOnEventReturnCode(System.Windows.Forms.DragDropEffects)">
            <summary>Default value returned by CRhinoDropTarget::OnDrop... methods.</summary>
            <param name="rc">[in] Value to be returned.</param>
            <returns>Previous value.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.AllowDropOnRhinoLayerListControl">
            <summary>
Allow drop action to happen on the layer list control. If this is set to true and the drop event is
terminated over the layer list control then CRhinoDropTarget::OnDropOnLayerListCtrl will be called.
</summary>
            <returns>true to allow dropping on layer list control.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.EnableAllowDropOnRhinoLayerListControl(System.Boolean)">
            <summary>
Allow drop action to happen on the layer list control. If this is set to true and the drop event
is terminated over the layer list control then CRhinoDropTarget::OnDropOnLayerListCtrl will be called.
</summary>
            <param name="b">[in] true to enable. false to disable.</param>
            <returns>Previous state.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.AllowDropOnRhinoView">
            <summary>Allow drop action to happen on a valid CRhinoView without landing on an object.</summary>
            <returns>true means the drop event can terminate on a CRhinoView</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.EnableAllowDropOnRhinoView(System.Boolean)">
            <summary>Allow drop action to happen on a valid CRhinoView without landing on an object.</summary>
            <param name="b">[in] true to enable. false to disable.</param>
            <returns>Previous state.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.RhinoObject">
            <summary>
Check to see if mouse is currently over an object. This is only valid if CRhinoDropTarget::DropOnObject() is true.
</summary>
            <returns>Object the mouse is currently over. If CRhinoObjRef.Object() returns NULL then the mouse is not over a valid object.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.OverObject">
            <summary>
Check to see if mouse is currently over an object. This is only valid if CRhinoDropTarget::DropOnObject() is true.
</summary>
            <returns>true when the mouse is over object that is selected and it passes all selection filter tests. false when nothing is selected.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.ReferenceObjectSelect">
            <summary>
By default, reference objects can not be selected. If you do not want to be able to select reference objects, then call EnableReferenceObjectSelect( true).
</summary>
            <returns>true, then reference objects may be selected by drag and drop. false, then reference objects are ignored by drag and drop.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.EnableReferenceObjectSelect(System.Boolean)">
            <summary>
By default, reference objects can not be selected. If you do not want to be able to select reference objects, then call EnableReferenceObjectSelect( true).
</summary>
            <param name="b">[in] true to enable selection of referenced objects false reference objects will not be selected</param>
            <returns>previous value.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.GroupSelect">
            <summary>
By default, groups are ignored in OnDragOver. If you want the drag event to select every object in a group then enable group selection.
</summary>
            <returns>true, When dropping on an object in a group the entire group will be selected. true, When dropping on an object in a group only the object dropped on gets selected.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.EnableGroupSelect(System.Boolean)">
            <summary>
By default, groups are ignored in OnDragOver. If you want the drag event to select every object in a group then enable group selection.
</summary>
            <param name="b">
[in] true to enable selecting all objects in a group with a single drop event
false to only select the object dropped on ignoring the other objects in the group it belongs to.
</param>
            <returns>previous value.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.AllowDropOnSubObject">
            <summary>
By default, CRhinoDropTarget::OnDragOver will permit a user to select only top level objects. To select sub-objects (like a curve
in a b-rep or a curve in a group) call EnableSubObjectSelect( true).
</summary>
            <returns>true if selection of sub-objects is permitted.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.EnableAllowDropOnSubObject(System.Boolean)">
            <summary>
By default, CRhinoDropTarget::OnDragOver will permit a user to select only top level objects. To select sub-objects (like a curve
in a b-rep or a curve in a group) call EnableSubObjectSelect( true).
</summary>
            <param name="b">[in] true to enable sub-object selection false to disable sub-object selection.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.PassesGeometryAttributeFilter(RMA.Rhino.IRhinoObject,RMA.OpenNURBS.IOnGeometry,RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Checks geometry to see if it passes the basic GeometryAttributeFilter.</summary>
            <param name="rhObject">[in] parent object being considered.</param>
            <param name="geometry">[in] geometry being considered.</param>
            <param name="component_index">[in] if &gt;= 0, geometry is a proper sub-part of object-&gt;Geometry() with component_index.</param>
            <remarks>The default simply checks that the geometry passes the filter returned by GeometryAttributeFilter().</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.CustomGeometryFilter(RMA.Rhino.IRhinoObject,RMA.OpenNURBS.IOnGeometry,RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>
Checks geometry to see if it passes the basic GeometryAttributeFilter. This is only valid if EnableDropOnObject() is set to true.
</summary>
            <param name="rhObject">[in] parent object being considered.</param>
            <param name="geometry">[in] geometry being considered.</param>
            <param name="component_index">[in] if &gt;= 0, geometry is a proper sub-part of object-&gt;Geometry() with component_index.</param>
            <remarks>The default simply checks that the geometry passes the filter returned by GeometryAttributeFilter().</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.GeometryAttributeFilter">
            <summary>
The geometry attribute filter provides a secondary filter can be used to restrict which objects can be selected.
Control of the type of geometry (points, curves, surfaces, meshes, etc.) is provided by CRhinoDropTarget::SetGeometryFilter.
The geometry attribute filter is used to require the selected geometry to have certain attributes (open, closed, etc.).
The default attribute filter permits selection of all types of geometry. This is only valid if EnableDropOnObject() is set to true.
</summary>
            <returns>
An unsigned int "object_attribute_filter". If the bit from an CRhinoGetObject::GEOMETRY_ATTRIBUTE_FILTER enum
value is set in the geometry_attribute_filter, then OnDragOver() will permit selection of object's that have that
geometric attribute. If geometry_attribute_filter is 0xFFFFFFFF, then OnDragOver() can select all types of geometry.
Example: If (GeometryAttributeFilter() | closed_curve) != 0, then any curve selected by OnDragOver() will be closed.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.SetGeometryAttributeFilter(System.UInt32)">
            <summary>
The geometry attribute filter provides a secondary filter can be used to restrict which objects can be selected.
Control of the type of geometry (points, curves, surfaces, meshes, etc.) is provided by CRhinoGetObject::SetGeometryFilter.
The geometry attribute filter is used to require the selected geometry to have certain attributes (open, closed, etc.).
The default attribute filter permits selection of all types of geometry. This is only valid if EnableDropOnObject() is set to true.
</summary>
            <param name="geometry_attribute_filter">
[in] an unsigned int made by bitwise or-ing ( | ) values from the CRhinoGetObject::GEOMETRY_ATTRIBUTE_FILTER enum.
If you pass 0, then all geometry attributes will be acceptable.
Example: If you want to be able to select open curves or solids, then you would make a call like
unsigned int geometry_type_filter = 0;
unsigned int geometry_attribute_filter = 0;
geometry_type_filter |= CRhinoGetObject::curve;
geometry_type_filter |= CRhinoGetObject::surface_object;
geometry_type_filter |= CRhinoGetObject::polysurface_object;
geometry_attribute_filter |= CRhinoGetObject::closed_curve;
geometry_attribute_filter |= CRhinoGetObject::solid_object;
SetSetGeometryFilter( geometry_type_filter );
SetGeometryAttributeFilter( geometry_attribute_filter );
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.GeometryFilter">
            <summary>
The geometry type filter controls which types of geometry (points, curves, surfaces, meshes, etc.) can be selected.
The default geometry type filter permits selection of all types of geometry. This is only valid if EnableDropOnObject()
is set to true.
</summary>
            <returns>An unsigned int "object_filter". If the bit from an CRhinoGetObject::GEOMETRY_TYPE_FILTER enum
value is set in the geometry_filter, then OnDragOver() will permit selection of object's that have that type
of geometry. If geometry_filter is 0xFFFFFFFF, then OnDragOver() can select all types of geometry.
Example: If (GeometryFilter() | curve_object) != 0, then GetObjects() will permit curves to be selected.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.SetGeometryFilter(System.UInt32)">
            <summary>
The geometry type filter controls which types of geometry (points, curves, surfaces, meshes, etc.) can be selected.
The default geometry type filter permits selection of all types of geometry. This is only valid if EnableDropOnObject()
is set to true.
</summary>
            <param name="geometry_type_filter">
[in] an unsigned int made by or-ing ( | ) values from the CRhinoGetObject::GEOMETRY_TYPE_FILTER enum.
If you pass 0, then all geometry will be acceptable.
Example: If you want to be able to select curves and meshes, then you would make a call like
unsigned int geometry_type_filter = 0;
geometry_filter |= CRhinoGetObject::curve_object;
geometry_filter |= CRhinoGetObject::mesh_object;
SetGeometryFilter( geometry_type_filter );
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.AllowDropOnObject">
            <summary>
Allow drag over to select objects. If this is enabled and something is dropped on a valid Rhino
object then the object is selected and CRhinoDropTarget::OnDropOnObject is called.
</summary>
            <returns>true then objects will be selected when dragged over.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.EnableAllowDropOnObject(System.Boolean)">
            <summary>
Allow drag over to select objects. If this is enabled and something is dropped on a valid Rhino
object then the object is selected and CRhinoDropTarget::OnDropOnObject is called.
</summary>
            <param name="b">[in] If true then objects will be selected when dragged over.</param>
            <returns>Previous value.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.AllowDropWhileInRhinoCommand">
            <summary>
Call this method to find out if droppging while a Rhino command is running is allowed.
</summary>
            <returns>true if dropping on objects is allowed while a command is running otherwise false.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.EnableAllowDropWhileInRhinoCommand(System.Boolean)">
            <summary>
Call this method to enable or disable dropping while a command is running. The default
behavior is to not allow dropping while a command is running.
</summary>
            <param name="b">[in] If true then droppgin will be allowed while commands are running otherwise it will not.</param>
            <returns>previous value for this setting.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.AllowOnDropEx">
            <summary>Call this method to find out if CRhinoDropTarget::OnDropEx() should get called.</summary>
            <returns>true if CRhinoDropTarget::OnDropEx() should be called otherwise returns false</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.EnableAllowOnDropEx(System.Boolean)">
            <summary>Call this method to enable/disable calling of CRhinoDropTarget::OnDropEx()</summary>
            <param name="b">[in] If true then OnDropEx() will be called otherwise it will not</param>
            <returns>previous state See Also: CRhinoDropTarget::AllowOnDropEx()</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.DeselectAllObjects">
            <summary>Call this method to unselect any currently selected objects.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.DragStartedWhileInCommand">
            <summary>Call this method to find out if a command was running when the drag event started.</summary>
            <returns>true if a command was running when the drag event started.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.ShiftKeyDownWhenDragStarted">
            <summary>Call this method to find out if the shift key was pressed when the drag event started.</summary>
            <returns>true if the shift key was pressed when the drag event started.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.CtrlKeyDownWhenDragStarted">
            <summary>Call this method to find out if the control key was pressed when the drag event started.</summary>
            <returns>true if the control key was pressed when the drag event started.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.SetDragImageHotSpot(System.Drawing.Point)">
            <summary>
Coordinates of the starting drag position (typically, the cursor position). The coordinates are
relative to the upper left corner of the drag image.
</summary>
            <param name="pt">Coordinates of the starting drag position relative to the upper left corner of the drag image.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.DragImageHotSpot">
            <summary>
Coordinates of the starting drag position (typically, the cursor position). The coordinates
are relative to the upper left corner of the drag image.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.SetDragImageIndex(System.Int32)">
            <summary>
Call this method to set the zero based index into the DragImageList(). Setting this to -1 will disable the drag image.
</summary>
            <param name="iIndex">[in] Zero based drag image index or -1 to not display a drag image.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.DragImageIndex">
            <summary>
Zero based index into image list associated with this drop target. It will only
be used if SetDragImageList() was called and an image list was specified.
</summary>
            <returns>
Zero based index into image list associated with this drop target.
It will only be used if SetDragImageList() was called and an image list was specified.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.SetDragImageList(System.Windows.Forms.ImageList)">
            <summary>Call this method to set the ImageList associated with this drop target.</summary>
            <param name="pImageList">[in] Pointer to the ImageList to use when dragging or NULL to use none</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.OnDropExWasCalled">
            <summary>Call this method to find out if the user pressed the Escape key to cancel the drop event.</summary>
            <returns>true if the drop event was canceled otherwise returns false</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.OnDropWasCalled">
            <summary>Call this method to find out if the user pressed the Escape key to cancel the drop event.</summary>
            <returns>true if the drop event was canceled otherwise returns false</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.IsRhinoDropTargetEnabled">
            <summary>Call this method to find out if this drop target is enabled or not.</summary>
            <returns>true if the drop target will be notified of drop events otherwise it returns false.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.EnableRhinoDropTarget(System.Boolean)">
            <summary>
Call this method to enable or disable the drop target. If the drop target is disabled
then it will not get called by the frame work durring drop events.
</summary>
            <param name="bEnable">[in] If true then the drop target will be notified of drop events otherwise it will not.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.OnDropDone(System.Windows.Forms.IWin32Window,System.Windows.Forms.DataObject,System.Windows.Forms.DragDropEffects,System.Drawing.Point)">
            <summary>Called at the end of the drop event.</summary>
            <param name="pWnd">[in] Points to the window the cursor is entering.</param>
            <param name="pDataObject">[in] Points to the data object containing the data that can be dropped.</param>
            <param name="dropEffect">[in] The effect that the user chose for the drop operation.</param>
            <param name="point">[in] Contains the current location of the cursor in client coordinates.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.ResetDropFlags">
            <summary>Called by the frame work at the very begining and end of a drag event.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.OnDropOnRhinoView(RMA.Rhino.MRhinoView,System.Windows.Forms.DataObject,System.Windows.Forms.DragDropEffects,System.Drawing.Point)">
            <summary>Called by frame work when data object is dropped on a Rhino view and does not land on a selectable object.</summary>
            <param name="pRhinoView">[in] View the drop action occured in</param>
            <param name="pDataObject">[in] Points to the data object that contains the data to be dropped.</param>
            <param name="dropEffect">[in] The desired drop affect</param>
            <param name="point">[in] Contains the current location of the cursor in client coordinates.</param>
            <returns>true if data object was succesfully dropped.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.OnDropOnLayerListCtrl(System.Windows.Forms.IWin32Window,System.Int32,System.Windows.Forms.DataObject,System.Windows.Forms.DragDropEffects,System.Drawing.Point)">
            <summary>Called by frame work when data object is dropped on the layer list control</summary>
            <param name="pLayerListCtrl">[in] The layer list control window the object was dropped on.</param>
            <param name="nLayerIndex">
[in] The zero base layer table index the data object was dropped on or -1 if it was dropped on the control but not on a layer.
</param>
            <param name="pDataObject">[in] Points to the data object that contains the data to be dropped.</param>
            <param name="dropEffect">[in] The desired drop affect</param>
            <param name="point">[in] Contains the current location of the cursor in client coordinates.</param>
            <returns>true if data object was succesfully dropped.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.OnDropOnObject(RMA.Rhino.IRhinoObjRef,RMA.Rhino.MRhinoView,System.Windows.Forms.DataObject,System.Windows.Forms.DragDropEffects,System.Drawing.Point)">
            <summary>Called by frame work when data object is dropped on an object.</summary>
            <param name="obj_ref">[in] Object data was dropped on a rhino view</param>
            <param name="pRhinoView">[in] View the drop action occured in</param>
            <param name="pDataObject">[in] Points to the data object that contains the data to be dropped.</param>
            <param name="dropEffect">[in] The desired drop affect</param>
            <param name="point">[in] Contains the current location of the cursor in client coordinates.</param>
            <returns>true if data object was succesfully dropped on the specified object</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.OnDragLeave(System.Windows.Forms.IWin32Window)">
            <param name="pWnd">[in] Points to the window the cursor is currently over.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.OnDropEx(System.Windows.Forms.IWin32Window,System.Windows.Forms.DataObject,System.Windows.Forms.DragDropEffects,System.Windows.Forms.DragDropEffects,System.Drawing.Point)">
            <summary>Called by the framework when a drop operation is to occur.</summary>
            <param name="pWnd">[in] Points to the window the cursor is currently over.</param>
            <param name="pDataObject">[in] Points to the data object that contains the data to be dropped.</param>
            <param name="point">[in] Contains the location of the cursor, in pixels, relative to the screen.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.OnDrop(System.Windows.Forms.IWin32Window,System.Windows.Forms.DataObject,System.Windows.Forms.DragDropEffects,System.Drawing.Point)">
            <summary>Called by the framework when the cursor is dragged over the window.</summary>
            <param name="pWnd">[in] Points to the window that the cursor is over.</param>
            <param name="pDataObject">[in] Points to the data object that contains the data to be dropped.</param>
            <param name="point">[in] Contains the current location of the cursor in client coordinates.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.OnDragOver(System.Windows.Forms.IWin32Window,System.Windows.Forms.DataObject,System.Windows.Forms.Keys,System.Drawing.Point)">
            <summary>Called by the framework when the cursor is dragged over the window.</summary>
            <param name="pWnd">[in] Points to the window that the cursor is over.</param>
            <param name="pDataObject">[in] Points to the data object that contains the data to be dropped.</param>
            <param name="dwKeyState">[in] Contains the state of the modifier keys.</param>
            <param name="point">[in] Contains the current location of the cursor in client coordinates.</param>
            <returns>
The effect that would result if a drop were attempted at the location specified by point.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.OnDragEnter(System.Windows.Forms.IWin32Window,System.Windows.Forms.DataObject,System.Windows.Forms.Keys,System.Drawing.Point)">
            <summary>Called by the framework when the cursor is first dragged into the window</summary>
            <param name="pWnd">[in] Points to the window the cursor is entering.</param>
            <param name="pDataObject">[in] Points to the data object containing the data that can be dropped.</param>
            <param name="dwKeyState">[in] Contains the state of the modifier keys.</param>
            <param name="point">[in] Contains the current location of the cursor in client coordinates.</param>
            <returns>
The effect that would result if a drop were attempted at the location specified by point.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDropTarget.SupportDataObject(System.Windows.Forms.DataObject)">
            <summary>
This method is called by Rhino to determine if this drop data object is associated
with this drop target.  Rhino will forward messages to the first enabled drop target
whos SupportDataObject() returns true.
</summary>
            <param name="data">[in] Points to the data object containing the data that can be dropped.</param>
            <returns>true if this drop target supports the specified data object.</returns>
        </member>
        <member name="M:RMA.RhDN_Manager.FindLoadedPlugIn(System.String)">
            <summary>Attempt to locate a loaded plug-in based on the assembly's path</summary>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGet1RailFrames(RMA.OpenNURBS.IOnCurve,System.Double[],RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.OnPlane[]@)">
            <summary>Get relatively parallel frames at selected points along a curve.</summary>
            <param name="curve">[in]</param>
            <param name="t">[in] increasing array of curve parameters</param>
            <param name="starting_x0">
[in] optional vector that specifies the x direction to use for the plane at t[0].
If starting_x0 is ON_unset_point, then the curve's curvature vector at t[0] is used.
</param>
            <param name="frames">
[out] The plane's origin is on the curve and the zaxis is the curve's tangent.
</param>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoCopyAnalysisModes(RMA.Rhino.IRhinoObject,RMA.Rhino.MRhinoObject)">
            <summary>Copy analysis modes to destination object.</summary>
            <returns>Number of analysis modes enabled on destination_object.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoOffsetCurveOnSrf(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnBrep,System.Int32,System.Double[],System.Double[],System.Double,RMA.OpenNURBS.OnCurve[]@)">
            <summary>
Offset a curve on a surface.  
The source curve must lie on the surface.
</summary>
            <param name="p3dCurve">[in] the curve to offset</param>
            <param name="pBrep">[in] brep on which to offset the curve</param>
            <param name="fid">[in] index of the face in the brep</param>
            <param name="params">[in] curve parameters corresponding to the offset distances</param>
            <param name="dists">[in] distances to offset  +: left, -: right</param>
            <param name="tol">[in] fitting tolerance</param>
            <param name="result_curves">[out] results of the offset</param>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoOffsetCurveOnSrf(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnBrep,System.Int32,RMA.OpenNURBS.IOn2dPoint,System.Double,RMA.OpenNURBS.OnCurve[]@)">
            <summary>
Offset a curve on a surface.  
The source curve must lie on the surface.
</summary>
            <param name="p3dCurve">[in] the curve to offset</param>
            <param name="pBrep">[in] brep on which to offset the curve</param>
            <param name="fid">[in] index of the face in the brep</param>
            <param name="through_point">[in] 2d point on the brep face to offset through</param>
            <param name="tol">[in] fitting tolerance</param>
            <param name="result_curves">[out] results of the offset</param>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoOffsetCurveOnSrf(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnBrep,System.Int32,System.Double,System.Double,RMA.OpenNURBS.OnCurve[]@)">
            <summary>
Offset a curve on a surface.  
The source curve must lie on the surface.
</summary>
            <param name="p3dCurve">[in] the curve to offset</param>
            <param name="pBrep">[in] brep on which to offset the curve</param>
            <param name="fid">[in] index of the face in the brep</param>
            <param name="distance">[in] distance to offset +: left, -: right</param>
            <param name="tol">[in] fitting tolerance</param>
            <param name="result_curves">[out] results of the offset</param>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoSplitBrepFace(RMA.OpenNURBS.IOnBrep,System.Int32,RMA.OpenNURBS.IOnCurve[],System.Double)">
            <summary>Splits a face into pieces using 3d trimming curves.</summary>
            <param name="brep">[in] - the base brep.</param>
            <param name="face_index">[in] index of face in m_F[] array to split.</param>
            <param name="curves">[in] - array of 3d curves used for trimming.</param>
            <param name="tolerance">
[in] fitting and intersecting tolerance.  When in doubt, use the document's absolute tolerance.
</param>
            <returns>The resulting brep or NULL.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoOffsetCurve(RMA.OpenNURBS.IOnCurve,System.Double,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,System.Int32,System.Double,RMA.OpenNURBS.OnCurve[]@)">
            <summary>Offsets a curve.</summary>
            <param name="curve_in">[in] the curve to offset.</param>
            <param name="distance">[in] the distance to offset the curve.</param>
            <param name="direction_point">[in] a point that indicates the direction of the offset.</param>
            <param name="normal">[in] a vector that indicates the normal of the plane in which the offset will occur.</param>
            <param name="corner_style">
[in] the corner style, where:
no_corner = 0, sharp = 1, round = 2, smooth = 3, chamfer = 4
</param>
            <param name="tolerance">[in] the offset tolerance.</param>
            <param name="curves_out">[out] the offset curves.</param>
            <returns>Returns number of curves that are appended to array.</returns>
            <remarks>The caller is responsible for deleting these curves when finished.</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetSplitPoints(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnBrep,System.Double[]@,System.Double)">
            <summary>Finds split points on a curve using a cutter brep</summary>
            <param name="curve">[in] curve to find the split points on.</param>
            <param name="cutter">[in] brep to split curve with.</param>
            <param name="tsplit">[out] array of split parameters on curve</param>
            <param name="tolerance">[in] intersection tolerance</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoRetrimSurface(RMA.OpenNURBS.IOnBrepFace,RMA.OpenNURBS.IOnSurface)">
            <summary>
Transfers trims from a brep face to another surface roughly the same shape and in the same location
as the original face, and returns the result in a single surface brep.
This is useful for retrimming a trimmed surface after rebuild or refit.
</summary>
            <param name="trim_source">[in] the original face to transfer the trims from.</param>
            <param name="trim_target">[in] the surface to transfer the trims to.</param>
            <returns>
pointer to single face brep if success. The target surface is duplicated.
NULL if unsuccessful.
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoRebuildSurface(RMA.OpenNURBS.IOnSurface,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Rebuilds an existing surface with a new surface to given point count.</summary>
            <param name="surface_in">[in] the surface to rebuild.</param>
            <param name="udegree">[in] the output surface u degree. (default = 3)</param>
            <param name="vdegree">[in] the output surface u degree. (default = 3)</param>
            <param name="upointcount">[in] the number of points in the output surface u direction.</param>
            <param name="vpointcount">
[in] the number of points in the output surface v direction.
Must be bigger than the degree.
With closed curves the minumum point count is three.
The highest accepted point count is 1000.
</param>
            <returns>
pointer to curve if success.
NULL if unsuccessful.
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoRebuildCurve(RMA.OpenNURBS.IOnCurve,System.Int32,System.Int32)">
            <summary>Rebuilds an existing curve with a new curve to given point count.</summary>
            <param name="curve_in">[in] the curve to rebuild.</param>
            <param name="degree">[in] the output curve degree. (default = 3)</param>
            <param name="pointcount">
[in] the number of points in the output curve.
Must be bigger than the degree.
With closed curves the minumum point count is three.
The highest accepted point count is 1000.
</param>
            <returns>
pointer to curve if success.
NULL if unsuccessful.
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoRebuildCurve(RMA.OpenNURBS.IOnCurve,System.Int32,System.Int32,System.Boolean,RMA.OpenNURBS.OnNurbsCurve@)">
            <summary>Rebuilds an existing curve with a new curve to given point count.</summary>
            <param name="curve_in">[in] the curve to rebuild.</param>
            <param name="degree">[in] the output curve degree.</param>
            <param name="pointcount">
[in] the number of points in the output curve. Must be bigger than the degree.
With closed curves the minumum point count is three. The highest accepted point count is 1000.
</param>
            <param name="bKeepTangents">
[in] if set, maintain start and end tangent directions.  The minimum number of points to do this is degree + 2
</param>
            <param name="curve_out">[out] this curve will be used for output.</param>
            <returns>true if success.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetIsoCurves(RMA.OpenNURBS.IOnBrepFace,System.Int32,System.Double,RMA.OpenNURBS.OnCurve[]@)">
            <summary>Gets isoparametric curve(s) from a brep face.</summary>
            <param name="face">[in] the brep face to evaluate.</param>
            <param name="iso_dir">
0 = intervals are "u" intervals, c = constant "v" value
1 = intervals are "v" intervals, c = constant "u" value
</param>
            <param name="iso_constant">[in] constant "c" above</param>
            <param name="curves">[out] curves are appended to this array.</param>
            <returns>number of curves that are appended to array.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetIsoIntervals(RMA.OpenNURBS.IOnBrepFace,System.Int32,System.Double,RMA.OpenNURBS.ArrayOnInterval)">
            <summary>Gets parameter intervals for the active part of brep face.</summary>
            <param name="face">[in] the brep face to evaluate.</param>
            <param name="iso_dir">
0 = intervals are "u" intervals, c = constant "v" value
1 = intervals are "v" intervals, c = constant "u" value
</param>
            <param name="iso_constant">[in] constant "c" above</param>
            <param name="intervals">[out] intervals are appended to this array.</param>
            <returns>number of intervals that are appended to array.</returns>
            <remarks>The isoparametric curve(s) exist on the domain of the intervals.</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoFitSurface(RMA.OpenNURBS.IOnSurface,System.Int32,System.Int32,System.Double,System.Double@)">
            <summary>Fits a new surface through an existing surface.</summary>
            <param name="surface_in">[in] the surface to fit.</param>
            <param name="udegree">[in] the output surface U degree. Must be bigger than 1. (default = 3)</param>
            <param name="vdegree">[in] the output surface V degree. Must be bigger than 1. (default = 3)</param>
            <param name="dFitTol">
[in] the fitting tolerance. (default = ON_UNSET_VALUE)
If dFitTol is ON_UNSET_VALUE or &lt;=0.0, the document absolute tolerance is used.
</param>
            <param name="pAchievedTol">
[out] if not NULL this will be used for the achieved tolerance. 
pAchievedTol is always &lt;= dFitTol.
</param>
            <returns>
pointer to surface if success.
NULL if unsuccessful.
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoFitCurve(RMA.OpenNURBS.IOnCurve,System.Int32,System.Double,System.Double)">
            <summary>Fits a new curve through an existing curve.</summary>
            <param name="curve_in">[in] the curve to fit.</param>
            <param name="degree">[in] the output curve degree. Must be bigger than 1. (default = 3)</param>
            <param name="dFitTol">
[in] the fitting tolerance. (default = ON_UNSET_VALUE)
If dFitTol is ON_UNSET_VALUE or &lt;=0.0, the document absolute tolerance is used.
</param>
            <param name="dAngleTol">
[in] the kink smoothing tolerance in radians. (default = ON_UNSET_VALUE)
If dAngleTol is 0.0, all kinks are smoothed.
If dAngleTol is &gt;0.0, kinks smaller than dAngleTol are smoothed.
If dAngleTol is ON_UNSET_VALUE or &lt;0.0, the document angle tolerance is used for the kink smoothing.
</param>
            <returns>
pointer to curve if success.
NULL if unsuccessful.
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoMergeBreps(RMA.OpenNURBS.IOnBrep[],System.Double,RMA.OpenNURBS.OnBrep@)">
            <summary>Combines two or more breps into one.</summary>
            <param name="InBreps">[in] the breps to merge.</param>
            <param name="tolerance">[in] the tolerance to use when merging.</param>
            <param name="MergedBrep">[out] the resulting brep.</param>
            <returns>
true if success.
false if unsuccessful.
</returns>
            <remarks>Faces are split by intersection curves.</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.Rhino_dup_cmp_surface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.IOnSurface)">
            <summary>Compare 2 surfaces to see if the geometry is the same.</summary>
            <returns>
1 or -1 if the surfaces are different
0 if they are the same
</returns>
            <remarks>This is a fast compare function that can be used for sorting</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.Rhino_dup_cmp_curve(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnCurve)">
            <summary>Compare 2 curves to see if the geometry is the same.</summary>
            <returns>
1 or -1 if the curves are different
0 if they are the same
</returns>
            <remarks>This is a fast compare function that can be used for sorting</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoReadHatchPatternFile(System.String,RMA.OpenNURBS.OnHatchPattern[]@,System.Boolean,System.Boolean)">
            <summary>Read hatch pattern definitions from a file.</summary>
            <param name="pFilename">[in] name of existing file.</param>
            <param name="hatchPatterns">[in/out] hatch patterns are appended to this list.</param>
            <param name="bAllowDuplicates">
[in] if false, the function checks before append new patterns that no
other hatch patter exists in the array with the same name.
</param>
            <param name="bQuiet">
[in] If file doesn't exist, and bQuiet is false, an error meesage box is shown.
</param>
            <returns>true if success.</returns>
            <remarks>
If pFilename is NULL, default hatch pattern filename is used. In this case, if file doesn't
exist, default hatch patterns will be appended to hatchPatterns.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoBrepGet2dSection(RMA.Rhino.IRhinoBrepObject[],RMA.OpenNURBS.IOnBrep,RMA.OpenNURBS.IOnPlane,RMA.Rhino.MRhinoCurveObject[]@,RMA.Rhino.MRhinoCurveObject[]@,RMA.Rhino.MRhinoCurveObject[]@,RMA.Rhino.MRhinoCurveObject[]@,RMA.Rhino.MRhinoCurveObject[]@)">
            <summary>
Generates a 2D section of a list of breps. Splits all breps using 
the specified brep splitter, then generates the 2D projection of
resulting pieces, and finally returns all output projection curves
separeted depending in curve position (back or front) and visibility.
</summary>
            <param name="brepObjects">[in] List of brep objects to be sectioned.</param>
            <param name="brepSplitter">
[in] Brep used to split objects. Splitter is a single possibly non-manifold brep. (See RhinoBrepSplit)
</param>
            <param name="projectionPlane">[in] Plane used to get 2D projection.</param>
            <param name="pSectionCurves">[out] Curve objects that lies in brepSplitter</param>
            <param name="pForegroundCurves">
[out] Curves that are in the positive part of the splitter and are visible.
</param>
            <param name="pBackgroundCurves">
[out] Curves that are in the negative part of the splitter and are visible.
</param>
            <param name="pForegroundHiddenCurves">
[out] Curves that are in the positive part of the splitter and are hidden.
</param>
            <param name="pBackgroundHiddenCurves">
[out] Curves that are in the negative part of the splitter and are hidden.
</param>
            <returns>true if success.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoBrepGet2dSection(RMA.Rhino.IRhinoBrepObject[],RMA.OpenNURBS.IOnBrep,RMA.OpenNURBS.IOnPlane,RMA.Rhino.MRhinoCurveObject[]@,RMA.Rhino.MRhinoCurveObject[]@,RMA.Rhino.MRhinoCurveObject[]@,RMA.Rhino.MRhinoCurveObject[]@,RMA.Rhino.MRhinoCurveObject[]@,System.Double,System.Double)">
            <summary>
Generates a 2D section of a list of breps. Splits all breps using 
the specified brep splitter, then generates the 2D projection of
resulting pieces, and finally returns all output projection curves
separeted depending in curve position (back or front) and visibility.
</summary>
            <param name="brepObjects">[in] List of brep objects to be sectioned.</param>
            <param name="brepSplitter">
[in] Brep used to split objects. Splitter is a single possibly non-manifold brep. (See RhinoBrepSplit)
</param>
            <param name="projectionPlane">[in] Plane used to get 2D projection.</param>
            <param name="pSectionCurves">[out] Curve objects that lies in brepSplitter</param>
            <param name="pForegroundCurves">
[out] Curves that are in the positive part of the splitter and are visible.
</param>
            <param name="pBackgroundCurves">
[out] Curves that are in the negative part of the splitter and are visible.
</param>
            <param name="pForegroundHiddenCurves">
[out] Curves that are in the positive part of the splitter and are hidden.
</param>
            <param name="pBackgroundHiddenCurves">
[out] Curves that are in the negative part of the splitter and are hidden.
</param>
            <param name="distTolerance">
[in] Tolerance used for distance comparisions.
If &lt;= 0, then the current document tolerance is used.
</param>
            <param name="angTolerance">
[in] Tolerance used for angular comparisions.
If &lt;= 0, then the current document tolerance is used.
</param>
            <returns>true if success.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoBrepGet2dProjection(RMA.Rhino.IRhinoBrepObject[],RMA.OpenNURBS.IOnPlane,RMA.Rhino.MRhinoCurveObject[]@)">
            <summary>RhinoBrepGet2dProjection generates a 2D projection of a list of breps.</summary>
            <param name="brepObjects">[in] List of brep objects to be projected.</param>
            <param name="projectionPlane">[in] Plane used to get 2D projection.</param>
            <param name="projectedCurves">
[out] Curves that are in the positive part of the plane and are visible will be appended.
</param>
            <returns>true if success.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoBrepGet2dProjection(RMA.Rhino.IRhinoBrepObject[],RMA.OpenNURBS.IOnPlane,RMA.Rhino.MRhinoCurveObject[]@,RMA.Rhino.MRhinoCurveObject[]@)">
            <summary>RhinoBrepGet2dProjection generates a 2D projection of a list of breps.</summary>
            <param name="brepObjects">[in] List of brep objects to be projected.</param>
            <param name="projectionPlane">[in] Plane used to get 2D projection.</param>
            <param name="projectedCurves">
[out] Curves that are in the positive part of the plane and are visible will be appended.
</param>
            <param name="projectedHiddenCurves">
[out] If not NULL, curves that are in the positive part of the plane and are hidden will be appended.
</param>
            <returns>true if success.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoBrepGet2dProjection(RMA.Rhino.IRhinoBrepObject[],RMA.OpenNURBS.IOnPlane,RMA.Rhino.MRhinoCurveObject[]@,RMA.Rhino.MRhinoCurveObject[]@,System.Double,System.Double)">
            <summary>RhinoBrepGet2dProjection generates a 2D projection of a list of breps.</summary>
            <param name="brepObjects">[in] List of brep objects to be projected.</param>
            <param name="projectionPlane">[in] Plane used to get 2D projection.</param>
            <param name="projectedCurves">
[out] Curves that are in the positive part of the plane and are visible will be appended.
</param>
            <param name="projectedHiddenCurves">
[out] If not NULL, curves that are in the positive part of the plane and are hidden will be appended.
</param>
            <param name="distTolerance">
[in] Tolerance used for distance comparisions.
If &lt;= 0, then the current document tolerance is used.
</param>
            <param name="angTolerance">
[in] Tolerance used for angular comparisions.
If &lt;= 0, then the current document tolerance is used.
</param>
            <returns>true if success.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoChangeSeam(RMA.OpenNURBS.IOnBrepFace,System.Int32,System.Double)">
            <summary>Change the seam of a closed trimmed surface.</summary>
            <param name="Face">[in] A face brep with a closed underlying surface.</param>
            <param name="di">[in] the parameter direction to 0=u, 1 = v</param>
            <param name="t">[in] the parameter at which to place the seam.</param>
            <returns>
a pointer to a new suface or polysurface that has the same geometry as Face with the relocated seam.
</returns>
            <remarks>
Must have the following conitions where Srf = Face.SurfaceOf()
Srf-&gt;IsClosed(di),
Srf-&gt;Domain(di).Includes(t,true)
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoMakeCubicBeziers(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.OnBezierCurve[]@,System.Double,System.Double)">
            <summary>Makes an array of cubic, non-rational beziers that fit a curve to a tolerance</summary>
            <param name="Curve">[in]</param>
            <param name="BezArray">[out] List of beziers</param>
            <param name="dist_tol">[in] max fitting error.  Will use ON_SQRT_EPSILON as a minimum.</param>
            <param name="kink_tol">
[in] If the input curve has a g1-discontinuity with angle radian measure
greater than kink_tol at some point P, the list of beziers will also have a kink at P
</param>
            <returns>True if faces were merged.  False if no faces were merged.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoMergeBrepCoplanarFaces(RMA.OpenNURBS.OnBrep@)">
            <summary>Merges adjacent coplanar faces into single faces.</summary>
            <param name="brep">[in/out]</param>
            <returns>True if faces were merged. False if no faces were merged.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoMergeBrepCoplanarFaces(RMA.OpenNURBS.OnBrep@,System.Double)">
            <summary>Merges adjacent coplanar faces into single faces.</summary>
            <param name="brep">[in/out]</param>
            <param name="tolerance">
3d tolerance for determining when edges are adjacent. If &lt;= 0,
then the current document tolerance is used.
</param>
            <returns>True if faces were merged. False if no faces were merged.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoCullControlPolygon">
            <returns>True if backfaces of surface and mesh control polygons are culled.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhPlanarRegionDifference(RMA.OpenNURBS.IOnBrep,RMA.OpenNURBS.IOnBrep,RMA.OpenNURBS.IOnPlane,System.Double,RMA.OpenNURBS.OnBrep[]@)">
            <summary>Find difference of two planar faces, B0 - B1.</summary>
            <param name="B0">[in] breps to be subtracted, each with a single face with a planar surface.</param>
            <param name="B1">[in] breps to be subtracted, each with a single face with a planar surface.</param>
            <param name="plane">
[in] The planar faces should be on or parallel to this plane. The results will be on this plane.
</param>
            <param name="tolerance">[in] Used to decide if edges overlap.</param>
            <param name="OutRegions">
[out] OutRegions will consist of the difference of the projected regions,
each member will have a single face with a planar surface based on plane.
</param>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhPlanarRegionIntersection(RMA.OpenNURBS.IOnBrep,RMA.OpenNURBS.IOnBrep,RMA.OpenNURBS.IOnPlane,System.Double,RMA.OpenNURBS.OnBrep[]@)">
            <summary>Find intersection of two planar faces.</summary>
            <param name="B0">[in] breps to be intersected, each with a single face with a planar surface.</param>
            <param name="B1">[in] breps to be intersected, each with a single face with a planar surface.</param>
            <param name="plane">
[in] The planar faces should be on or parallel to this plane. The results will be on this plane.
</param>
            <param name="tolerance">[in] Used to decide if edges overlap.</param>
            <param name="OutRegions">
[out] OutRegions will consist of the union of the projected regions,
each member will have a single face with a planar surface based on plane.
</param>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhPlanarRegionUnion(RMA.OpenNURBS.IOnBrep,RMA.OpenNURBS.IOnBrep,RMA.OpenNURBS.IOnPlane,System.Double,RMA.OpenNURBS.OnBrep[]@)">
            <summary>Find Union of two planar faces.</summary>
            <param name="B0">[in] breps to be unioned, each with a single face with a planar surface.</param>
            <param name="B1">[in] breps to be unioned, each with a single face with a planar surface.</param>
            <param name="plane">
[in]  The planar faces should be on or parallel to this plane. The results will be on this plane.
</param>
            <param name="tolerance">[in] Used to decide if edges overlap.</param>
            <param name="OutRegions">
[out] OutRegions will consist of the union of the projected regions,
each member will have a single face with a planar surface based on plane.
</param>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhPlanarRegionBoolean(RMA.OpenNURBS.IOnBrep[],RMA.OpenNURBS.IOnPlane,System.Double,RMA.OpenNURBS.OnBrep[]@)">
            <summary>Merges planar faces.</summary>
            <param name="InRegions">
[in]  Array of breps, each with a single face with a planar surface.
Will fail if any do not satisfy this requirement.
</param>
            <param name="plane">
[in] The planar faces should be on or parallel to this plane. The results will be on this plane.
</param>
            <param name="tolerance">[in] Used to decide if edges overlap.</param>
            <param name="OutRegions">
[out] OutRegions will consist of the union of the projected regions,
each member will have a single face with a planar surface based on plane.
</param>
            <remarks>tolerance will be used to detect overlapping and near-missing edges</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhPlanarRegionBoolean(RMA.OpenNURBS.IOnBrep[],RMA.OpenNURBS.IOnPlane,System.Double,RMA.OpenNURBS.OnBrep[]@,RMA.OpenNURBS.Arraybool)">
            <summary>Merges planar faces.</summary>
            <param name="InRegions">
[in]  Array of breps, each with a single face with a planar surface.
Will fail if any do not satisfy this requirement.
</param>
            <param name="plane">
[in] The planar faces should be on or parallel to this plane. The results will be on this plane.
</param>
            <param name="tolerance">[in] Used to decide if edges overlap.</param>
            <param name="OutRegions">
[out] OutRegions will consist of the union of the projected regions,
each member will have a single face with a planar surface based on plane.
</param>
            <param name="pbRev">
[in] if non-null, pbRev must have the same size as InRegions.
if null, the array will be assumed to have all elements = false
if pbRev[i] = true, the complement of InRegions[i] will be used in the
boolean. if pbRev is non-null, the complement of the union of the
regions or complements will be returned.  For Union, no  array is necessary.
For intersection of 2 regions, bRev[0] = bRev[1] = true.
For A-B bRev[0] = true, bRev[1] = false
</param>
            <remarks>tolerance will be used to detect overlapping and near-missing edges</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoBrepSplit(RMA.OpenNURBS.IOnBrep,RMA.OpenNURBS.IOnBrep,System.Double,RMA.OpenNURBS.OnBrep[]@)">
            <summary>Splits a brep into pieces.</summary>
            <param name="brep">[in] Brep to split.</param>
            <param name="splitter">[in] Splitter is a single possibly non-manifold brep.</param>
            <param name="tolerance">[in] Intersection tolerance</param>
            <param name="pieces">[out] Output array that contains all the split components.</param>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoBrepSplit(RMA.OpenNURBS.IOnBrep,RMA.OpenNURBS.IOnBrep,System.Double,RMA.OpenNURBS.OnBrep[]@,System.Boolean@)">
            <summary>Splits a brep into pieces.</summary>
            <param name="brep">[in] Brep to split.</param>
            <param name="splitter">[in] Splitter is a single possibly non-manifold brep.</param>
            <param name="tolerance">[in] Intersection tolerance</param>
            <param name="pieces">[out] Output array that contains all the split components.</param>
            <param name="bRaisedTol">
[in/out] If not null then *bRaisedTol is set to true if the
split failed at tolerance but succeeded when the tolerance
was increased to twice tolerance.
</param>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoBrepCapPlanarHoles(RMA.OpenNURBS.IOnBrep,System.Double)">
            <summary>Make planar faces out of planar closed boundaries.</summary>
            <param name="pInputBrep">[in] the brep.</param>
            <param name="tol">[in] tolerance to determine planarity and for joining</param>
            <returns>A joined, capped brep if successful. Null if it failed.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetOverlapDistance(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnInterval,System.Double,System.Double,System.Int32@,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>Calculates the minimum and maximum distances between two curves.</summary>
            <param name="crv_a">[in] curve A</param>
            <param name="dom_a">[in] optional domain for curve A. can bew null</param>
            <param name="crv_b">[in] curve B</param>
            <param name="dom_b">[in] optional domain for curve B. can bew null</param>
            <param name="tol">[in] tolerance for common normal detection</param>
            <param name="lim">[in] limits acceptable overlap distance</param>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoIsPointInBrep(RMA.OpenNURBS.IOnBrep,RMA.OpenNURBS.IOn3dPoint,System.Double,System.Boolean)">
            <summary>
Determine if a 3D point is inside of a brep.
This function only makes sense for closed manifold Breps.
</summary>
            <param name="pBrep">[in] the brep.</param>
            <param name="pt">[in] 3d point to test.</param>
            <param name="tolerance">
[in] 3d distance tolerance used for intersection and determining strict inclusion.
default = ON_SQRT_EPSILON
</param>
            <param name="bStrictlyIn">
[in] if true, pt is in if inside pBrep by at least tolerance.
if false, pt is in if truly in or within tolerance of boundary.
</param>
            <returns>true if pt is in, false if not.  See parameter bStrictlyIn.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoMergeAdjoiningEdges(RMA.OpenNURBS.OnBrepEdge@,System.Double)">
            <summary>Merge adjacent edges to this edge rescursivly using tolerance</summary>
            <param name="edge">[in] edge in the brep to be modified</param>
            <param name="angle_tolerance_radians">
[in] The maximum allowable difference of angle in radian between
adjacent edges that can be merged.
</param>
            <remarks>
A pair of adjacent edges in a brep are mergable if the angle between them is less than
tolerance and the valence of the shared vertex is 2.
</remarks>
            <returns>A pointer to the resulting merged edge. or NULL if nothing was merged.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoMergeAdjoiningEdges(RMA.OpenNURBS.OnBrepEdge@,System.Double,System.Int32@)">
            <summary>Merge adjacent edges to this edge rescursivly using tolerance</summary>
            <param name="edge">[in] edge in the brep to be modified</param>
            <param name="angle_tolerance_radians">
[in] The maximum allowable difference of angle in radian between
adjacent edges that can be merged.
</param>
            <param name="merge_cnt">[out] Number of edges merged into final edge</param>
            <remarks>
A pair of adjacent edges in a brep are mergable if the angle between them is less than
tolerance and the valence of the shared vertex is 2.
</remarks>
            <returns>A pointer to the resulting merged edge. or NULL if nothing was merged.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoIsPointOnFace(RMA.OpenNURBS.IOnBrepFace,System.Double,System.Boolean,System.Double@,System.Double@)">
            <summary>Determine if a point is in the active region of a face.</summary>
            <param name="face">[in]</param>
            <param name="tolerance">[in] 3d tolerance</param>
            <param name="bOkToWrap">
If true and if surface the face is built on is closed,
the the test parameter is permitted to wrap across the
surface seam.  If the (s,t)parameters are the result
of a closest point or intersection query, then you
generally want bOkToWrap = true.
</param>
            <param name="s">
[in/out] (s,t) is the paramter to be tested.
If true is returned, then the returned values of
(s,t) are the parameters of the active point.  When
bOkToWrap is true and the surface is closed, the
return values may differ from the input values.
</param>
            <param name="t">
[in/out] (s,t) is the paramter to be tested.
If true is returned, then the returned values of
(s,t) are the parameters of the active point.  When
bOkToWrap is true and the surface is closed, the
return values may differ from the input values.
</param>
            <returns>True if (s,t) is on the active part of the face.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoOffsetCurve(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint,System.Double,RMA.OpenNURBS.OnCurve[]@)">
            <summary>Offsets a curve.</summary>
            <param name="curve">[in] The curve to offset</param>
            <param name="normal">[in] The normal to the offset plane</param>
            <param name="origin">[in] A point on offset plane</param>
            <param name="distance">[in] The positive or negative distance to offset</param>
            <param name="offset_curves">[out] The offset curves.</param>
            <returns>TRUE or FALSE</returns>
            <remarks>
If you have a nice offset, then there will be one entry in
the array. If the original curve had kinks or the offset curve
had self intersections, you will get multiple segments in the
offset_curves[] array.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoOffsetCurve(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint,System.Double,RMA.OpenNURBS.OnCurve[]@,System.Double)">
            <summary>Offsets a curve.</summary>
            <param name="curve">[in] The curve to offset</param>
            <param name="normal">[in] The normal to the offset plane</param>
            <param name="origin">[in] A point on offset plane</param>
            <param name="distance">[in] The positive or negative distance to offset</param>
            <param name="offset_curves">[out] The offset curves.</param>
            <param name="tolerance">[in] The offset or fitting tolerance</param>
            <remarks>
If you have a nice offset, then there will be one entry in
the array. If the original curve had kinks or the offset curve
had self intersections, you will get multiple segments in the
offset_curves[] array.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoOffsetCurve(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint,System.Double,RMA.OpenNURBS.OnCurve[]@,System.Double,System.Double)">
            <summary>Offsets a curve.</summary>
            <param name="curve">[in] The curve to offset</param>
            <param name="normal">[in] The normal to the offset plane</param>
            <param name="origin">[in] A point on offset plane</param>
            <param name="distance">[in] The positive or negative distance to offset</param>
            <param name="offset_curves">[out] The offset curves.</param>
            <param name="tolerance">[in] The offset or fitting tolerance</param>
            <param name="angle_tolerance">[in] The angle tolerance (radians)</param>
            <returns>TRUE or FALSE</returns>
            <remarks>
If you have a nice offset, then there will be one entry in
the array. If the original curve had kinks or the offset curve
had self intersections, you will get multiple segments in the
offset_curves[] array.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoOffsetCurve(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint,System.Double,RMA.OpenNURBS.OnCurve[]@,System.Double,System.Double,System.Int32)">
            <summary>Offsets a curve.</summary>
            <param name="curve">[in] The curve to offset</param>
            <param name="normal">[in] The normal to the offset plane</param>
            <param name="origin">[in] A point on offset plane</param>
            <param name="distance">[in] The positive or negative distance to offset</param>
            <param name="offset_curves">[out] The offset curves.</param>
            <param name="tolerance">[in] The offset or fitting tolerance</param>
            <param name="angle_tolerance">[in] The angle tolerance (radians)</param>
            <param name="corner_style">
[in] The corner style. Possible values are:
no_corner = 0
sharp     = 1
round     = 2
smooth    = 3
chamfer   = 4
</param>
            <returns>TRUE or FALSE</returns>
            <remarks>
If you have a nice offset, then there will be one entry in
the array. If the original curve had kinks or the offset curve
had self intersections, you will get multiple segments in the
offset_curves[] array.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoDivideCurve(RMA.OpenNURBS.IOnCurve,System.Double,System.Double,System.Boolean,System.Boolean,RMA.OpenNURBS.ArrayOn3dPoint,RMA.OpenNURBS.Arraydouble)">
            <summary>Calculation tool for the Rhino DivideCurve command.</summary>
            <param name="curve">[in]</param>
            <param name="seg_count">
If &gt; 0, the curve will be divided into this many segments.
If &gt; 0, then seg_length must be 0.
</param>
            <param name="seg_length">
If &gt; 0, the curve will be divided into segments of this length.
If &gt; 0, then seg_count must be 0.
</param>
            <param name="bReverse">
If true and seg_length is used to divide the curve,
then the divisions start from the end.
</param>
            <param name="bIncludeEnd">
If true, then the points at the start and end of
the curve are returned.
</param>
            <param name="curve_P">
[out] If not NULL, the division points are returned here.
</param>
            <param name="curve_t">
[out] If not NULL, the curve parameters at the division points
are returned here.
</param>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoConvertCurveToPolyline(RMA.OpenNURBS.IOnCurve,System.Int32,System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,RMA.OpenNURBS.OnPolylineCurve@)">
            <summary>Get a polyline approximation of a curve</summary>
            <param name="curve">[in]</param>
            <param name="main_seg_count">[in]</param>
            <param name="sub_seg_count">
If main_seg_count &lt;= 0, then both these parameters are ignored.
If main_seg_count &gt; 0, then sub_seg_count must be &gt;= 1.  In this
case the nurb will be broken into main_seg_count equally spaced
chords.  If needed, each of these chords can be split into as many
sub_seg_count sub-parts if the subdivision is necessary for the
mesh to meet the other meshing constraints.  In particular, if
sub_seg_count = 0, then the curve is broken into main_seg_count
pieces and no further testing is performed.
</param>
            <param name="max_ang_radians">
[in] ( 0 to pi )
Maximum angle (in radians) between unit tangents at adjacent vertices.
</param>
            <param name="max_chr">
Maximum permitted value of (distance chord midpoint to curve) / (length of chord)
</param>
            <param name="max_aspect">
If max_aspect &lt; 1.0, the parameter is ignored.  If 
1 &lt;= max_aspect &lt; sqrt(2), it is treated as if max_aspect = sqrt(2).
This parameter controls the maximum permitted value of
(length of longest chord) / (length of shortest chord)
</param>
            <param name="tolerance">
If tolerance = 0, the parameter is ignored.
This parameter controls the maximum permitted value of the
distance from the curve to the polyline.  
</param>
            <param name="max_edge_length">
If max_edge_length = 0, the parameter is ignored.
This parameter controls the maximum permitted edge length.
</param>
            <param name="polyline">
[out] The polyline approximation of the NURBS curve is appended
to this polyline. If bKeepStartPoint is FALSE, the starting point is not appened.
</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoConvertCurveToPolyline(RMA.OpenNURBS.IOnCurve,System.Int32,System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,RMA.OpenNURBS.OnPolylineCurve@,System.Boolean)">
            <summary>Get a polyline approximation of a curve</summary>
            <param name="curve">[in]</param>
            <param name="main_seg_count">[in]</param>
            <param name="sub_seg_count">
If main_seg_count &lt;= 0, then both these parameters are ignored.
If main_seg_count &gt; 0, then sub_seg_count must be &gt;= 1.  In this
case the nurb will be broken into main_seg_count equally spaced
chords.  If needed, each of these chords can be split into as many
sub_seg_count sub-parts if the subdivision is necessary for the
mesh to meet the other meshing constraints.  In particular, if
sub_seg_count = 0, then the curve is broken into main_seg_count
pieces and no further testing is performed.
</param>
            <param name="max_ang_radians">
[in] ( 0 to pi )
Maximum angle (in radians) between unit tangents at adjacent vertices.
</param>
            <param name="max_chr">
Maximum permitted value of (distance chord midpoint to curve) / (length of chord)
</param>
            <param name="max_aspect">
If max_aspect &lt; 1.0, the parameter is ignored.  If 
1 &lt;= max_aspect &lt; sqrt(2), it is treated as if max_aspect = sqrt(2).
This parameter controls the maximum permitted value of
(length of longest chord) / (length of shortest chord)
</param>
            <param name="tolerance">
If tolerance = 0, the parameter is ignored.
This parameter controls the maximum permitted value of the
distance from the curve to the polyline.  
</param>
            <param name="max_edge_length">
If max_edge_length = 0, the parameter is ignored.
This parameter controls the maximum permitted edge length.
</param>
            <param name="polyline">
[out] The polyline approximation of the NURBS curve is appended
to this polyline. If bKeepStartPoint is FALSE, the starting point is not appened.
</param>
            <param name="bKeepStartPoint">
TRUE  The starting point of the curve is added to the polyline
FALSE The starting point of the curve is not added to the polyline
</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoConvertCurveToPolyline(RMA.OpenNURBS.IOnCurve,System.Int32,System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,RMA.OpenNURBS.OnPolylineCurve@,System.Boolean,RMA.OpenNURBS.OnInterval)">
            <summary>Get a polyline approximation of a curve</summary>
            <param name="curve">[in]</param>
            <param name="main_seg_count">[in]</param>
            <param name="sub_seg_count">
If main_seg_count &lt;= 0, then both these parameters are ignored.
If main_seg_count &gt; 0, then sub_seg_count must be &gt;= 1.  In this
case the nurb will be broken into main_seg_count equally spaced
chords.  If needed, each of these chords can be split into as many
sub_seg_count sub-parts if the subdivision is necessary for the
mesh to meet the other meshing constraints.  In particular, if
sub_seg_count = 0, then the curve is broken into main_seg_count
pieces and no further testing is performed.
</param>
            <param name="max_ang_radians">
[in] ( 0 to pi )
Maximum angle (in radians) between unit tangents at adjacent vertices.
</param>
            <param name="max_chr">
Maximum permitted value of (distance chord midpoint to curve) / (length of chord)
</param>
            <param name="max_aspect">
If max_aspect &lt; 1.0, the parameter is ignored.  If 
1 &lt;= max_aspect &lt; sqrt(2), it is treated as if max_aspect = sqrt(2).
This parameter controls the maximum permitted value of
(length of longest chord) / (length of shortest chord)
</param>
            <param name="tolerance">
If tolerance = 0, the parameter is ignored.
This parameter controls the maximum permitted value of the
distance from the curve to the polyline.  
</param>
            <param name="max_edge_length">
If max_edge_length = 0, the parameter is ignored.
This parameter controls the maximum permitted edge length.
</param>
            <param name="polyline">
[out] The polyline approximation of the NURBS curve is appended
to this polyline. If bKeepStartPoint is FALSE, the starting point is not appened.
</param>
            <param name="bKeepStartPoint">
TRUE  The starting point of the curve is added to the polyline
FALSE The starting point of the curve is not added to the polyline
</param>
            <param name="curve_domain">[in] if not NULL, this subdomain of the NURBS curve is approximated.</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoProjectPointsToBreps(RMA.OpenNURBS.IOnBrep[],RMA.OpenNURBS.IOn3dPointArray,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.On3dPointArray@,RMA.OpenNURBS.Arrayint@,System.Double)">
            <summary>Projects points onto breps</summary>
            <param name="Breps">[in]  The breps to project onto</param>
            <param name="Points">[in]  The points to project</param>
            <param name="ProjDir">[in]  The direction to project</param>
            <param name="OutPoints">[out] The output, or projected, points. </param>
            <param name="Indices">[out] OutPoints[i] is a projection of Points[Indices[i]]</param>
            <param name="tolerance">
[in]  The projection tolerance - used for culling close points and for line-brep intersection.
</param>
            <returns>true if at least one of the input points was projected, otherwise false.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoProjectCurvesToBreps(RMA.OpenNURBS.IOnBrep[],RMA.OpenNURBS.IOnCurve[],RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.OnCurve[]@,RMA.OpenNURBS.Arrayint@,RMA.OpenNURBS.Arrayint@,System.Double)">
            <summary>Projects curves onto breps</summary>
            <param name="Breps">[in]  The breps to project onto</param>
            <param name="Curves">[in]  The curves to project</param>
            <param name="ProjDir">[in]  The direction to project</param>
            <param name="OutCurves">[out] The output, or projected, curves.</param>
            <param name="CurveIndices">[out] OutCurves[i] is a projection of Curves[CurveIndices[i]]</param>
            <param name="BrepIndices">[out] OutCurves[i] was projected onto Breps[BrepIndices[i]]</param>
            <param name="tolerance">[in]  The projection tolerance.</param>
            <returns>true if at least one of the input curves was projected, otherwise false.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoBooleanDifference(RMA.OpenNURBS.IOnBrep[],RMA.OpenNURBS.IOnBrep[],System.Double,System.Boolean@,RMA.OpenNURBS.OnBrep[]@,RMA.OpenNURBS.Arrayint@)">
            <summary>Subtract each brep of Inbreps1 from each brep of InBreps0. Separate.</summary>
            <param name="InBreps0">[in] first set of input breps.</param>
            <param name="InBreps1">[in] second set of input breps.</param>
            <param name="tolerance">[in] distance tolerance</param>
            <param name="bResult">
[out] true if any of the breps had intersecting faces
if false, and OutBreps.Count() is less than InBreps0.Count(),
then some closed Breps were inside others, 
or bManifoldOnly == true and some were non-manifold.
</param>
            <param name="OutBreps">[out] Resulting breps</param>
            <param name="InputIndexForOutput">
[out] OutBrep[i] is the result if subtracting something from InBreps0[InputIndexForOutPut[i]].
</param>
            <returns>false if error</returns>
            <remarks>
Think of this as an operation on InBreps0. Each brep of InBreps1 may remove part of a brep of
InBreps0.  If a member of InBreps0 does not intersect any member of InBreps1, then it is copied to
OutBreps.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoBooleanDifference(RMA.OpenNURBS.IOnBrep[],RMA.OpenNURBS.IOnBrep[],System.Double,System.Boolean@,RMA.OpenNURBS.OnBrep[]@,RMA.OpenNURBS.Arrayint@,System.Boolean)">
            <summary>Subtract each brep of Inbreps1 from each brep of InBreps0. Separate.</summary>
            <param name="InBreps0">[in] first set of input breps.</param>
            <param name="InBreps1">[in] second set of input breps.</param>
            <param name="tolerance">[in] distance tolerance</param>
            <param name="bResult">
[out] true if any of the breps had intersecting faces
if false, and OutBreps.Count() is less than InBreps0.Count(),
then some closed Breps were inside others, 
or bManifoldOnly == true and some were non-manifold.
</param>
            <param name="OutBreps">[out] Resulting breps</param>
            <param name="InputIndexForOutput">
[out] OutBrep[i] is the result if subtracting something from InBreps0[InputIndexForOutPut[i]].
</param>
            <param name="bManifoldOnly">[in] If true, leave out any non-manifold input breps.</param>
            <returns>false if error</returns>
            <remarks>
Think of this as an operation on InBreps0. Each brep of InBreps1 may remove part of a brep of
InBreps0.  If a member of InBreps0 does not intersect any member of InBreps1, then it is copied to
OutBreps.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoBooleanDifference(RMA.OpenNURBS.IOnBrep[],RMA.OpenNURBS.IOnBrep[],System.Double,System.Boolean@,RMA.OpenNURBS.OnBrep[]@,RMA.OpenNURBS.Arrayint@,System.Boolean,System.Boolean@)">
            <summary>Subtract each brep of Inbreps1 from each brep of InBreps0. Separate.</summary>
            <param name="InBreps0">[in] first set of input breps.</param>
            <param name="InBreps1">[in] second set of input breps.</param>
            <param name="tolerance">[in] distance tolerance</param>
            <param name="bResult">
[out] true if any of the breps had intersecting faces
if false, and OutBreps.Count() is less than InBreps0.Count(),
then some closed Breps were inside others, 
or bManifoldOnly == true and some were non-manifold.
</param>
            <param name="OutBreps">[out] Resulting breps</param>
            <param name="InputIndexForOutput">
[out] OutBrep[i] is the result if subtracting something from InBreps0[InputIndexForOutPut[i]].
</param>
            <param name="bManifoldOnly">[in] If true, leave out any non-manifold input breps.</param>
            <param name="bRaisedTol">
[out] If non-null and boolean fails at tolerance, try at twice tol and indicate success.
</param>
            <returns>false if error</returns>
            <remarks>
Think of this as an operation on InBreps0. Each brep of InBreps1 may remove part of a brep of
InBreps0.  If a member of InBreps0 does not intersect any member of InBreps1, then it is copied to
OutBreps.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoBooleanIntersection(RMA.OpenNURBS.IOnBrep[],RMA.OpenNURBS.IOnBrep[],System.Double,System.Boolean@,RMA.OpenNURBS.OnBrep[]@)">
            <param name="InBreps0">[in] first set of input breps.</param>
            <param name="InBreps1">[in] second set of input breps.</param>
            <param name="tolerance">[in] distance tolerance</param>
            <param name="bResult">
[out] true if any of the breps had intersecting faces
if false, and OutBreps.Count() is not empty, then some closed Breps
were inside others, or bManifoldOnly == true and some were non-manifold.
</param>
            <param name="OutBreps">[out] Resulting breps</param>
            <returns>false if error</returns>
            <remarks>
Think of this as an operation on InBreps0. Each brep of InBreps1 may remove part of a brep of
InBreps0.  If a member of InBreps0 does not intersect any member of InBreps1, then it is copied
to OutBreps.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoBooleanIntersection(RMA.OpenNURBS.IOnBrep[],RMA.OpenNURBS.IOnBrep[],System.Double,System.Boolean@,RMA.OpenNURBS.OnBrep[]@,System.Boolean)">
            <param name="InBreps0">[in] first set of input breps.</param>
            <param name="InBreps1">[in] second set of input breps.</param>
            <param name="tolerance">[in] distance tolerance</param>
            <param name="bResult">
[out] true if any of the breps had intersecting faces
if false, and OutBreps.Count() is not empty, then some closed Breps
were inside others, or bManifoldOnly == true and some were non-manifold.
</param>
            <param name="OutBreps">[out] Resulting breps</param>
            <param name="bManifoldOnly">[in] If true, leave out any non-manifold input breps.</param>
            <returns>false if error</returns>
            <remarks>
Think of this as an operation on InBreps0. Each brep of InBreps1 may remove part of a brep of
InBreps0.  If a member of InBreps0 does not intersect any member of InBreps1, then it is copied
to OutBreps.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoBooleanIntersection(RMA.OpenNURBS.IOnBrep[],RMA.OpenNURBS.IOnBrep[],System.Double,System.Boolean@,RMA.OpenNURBS.OnBrep[]@,System.Boolean,System.Boolean@)">
            <param name="InBreps0">[in] first set of input breps.</param>
            <param name="InBreps1">[in] second set of input breps.</param>
            <param name="tolerance">[in] distance tolerance</param>
            <param name="bResult">
[out] true if any of the breps had intersecting faces
if false, and OutBreps.Count() is not empty, then some closed Breps
were inside others, or bManifoldOnly == true and some were non-manifold.
</param>
            <param name="OutBreps">[out] Resulting breps</param>
            <param name="bManifoldOnly">[in] If true, leave out any non-manifold input breps.</param>
            <param name="bRaisedTol">[out] If non-null and boolean fails at tolerance, try at twice tol and indicate success.</param>
            <returns>false if error</returns>
            <remarks>
Think of this as an operation on InBreps0. Each brep of InBreps1 may remove part of a brep of
InBreps0.  If a member of InBreps0 does not intersect any member of InBreps1, then it is copied
to OutBreps.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoBooleanUnion(RMA.OpenNURBS.IOnBrep[],System.Double,System.Boolean@,RMA.OpenNURBS.OnBrep[]@)">
            <summary>Find the union of the breps in InBreps. Separate into disjoint pieces.</summary>
            <param name="InBreps">[in] breps to be unioned.</param>
            <param name="tolerance">[in] distance tolerance</param>
            <param name="bResult">
[out] true if any of the breps had intersecting faces
if false, and OutBreps.Count() is less than InBreps.Count(),
then some closed Breps were inside others, 
or bManifoldOnly == true and some were non-manifold.
</param>
            <param name="OutBreps">[out] Resulting breps</param>
            <returns>false if error</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoBooleanUnion(RMA.OpenNURBS.IOnBrep[],System.Double,System.Boolean@,RMA.OpenNURBS.OnBrep[]@,System.Boolean)">
            <summary>Find the union of the breps in InBreps. Separate into disjoint pieces.</summary>
            <param name="InBreps">[in] breps to be unioned.</param>
            <param name="tolerance">[in] distance tolerance</param>
            <param name="bResult">
[out] true if any of the breps had intersecting faces
if false, and OutBreps.Count() is less than InBreps.Count(),
then some closed Breps were inside others, 
or bManifoldOnly == true and some were non-manifold.
</param>
            <param name="OutBreps">[out] Resulting breps</param>
            <param name="bManifoldOnly">[in] If true, leave out any non-manifold input breps.</param>
            <returns>false if error</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoBooleanUnion(RMA.OpenNURBS.IOnBrep[],System.Double,System.Boolean@,RMA.OpenNURBS.OnBrep[]@,System.Boolean,System.Boolean@)">
            <summary>Find the union of the breps in InBreps. Separate into disjoint pieces.</summary>
            <param name="InBreps">[in] breps to be unioned.</param>
            <param name="tolerance">[in] distance tolerance</param>
            <param name="bResult">
[out] true if any of the breps had intersecting faces
if false, and OutBreps.Count() is less than InBreps.Count(),
then some closed Breps were inside others, 
or bManifoldOnly == true and some were non-manifold.
</param>
            <param name="OutBreps">[out] Resulting breps</param>
            <param name="bManifoldOnly">[in] If true, leave out any non-manifold input breps.</param>
            <param name="bRaisedTol">[out] If non-null and boolean fails at tolerance, try at twice tol and indicate success.</param>
            <returns>false if error</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoJoinBreps(RMA.OpenNURBS.OnBrep[],System.Double)">
            <summary>Join breps into a single brep.</summary>
            <param name="breps">[in] Array of breps to join.</param>
            <param name="tolerance">[in] 3d join tolerance.</param>
            <returns>Brep made by joining all the inputs together.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoCutUpSurface(RMA.OpenNURBS.IOnSurface,System.Boolean,RMA.OpenNURBS.OnCurve[],System.Double,System.Double,RMA.OpenNURBS.OnBrep[]@)">
            <summary>Surface splitter.</summary>
            <param name="srf">[in]  The surface to be split</param>
            <param name="bFlip">[in]  If true, input curves are oriented clockwise.</param>
            <param name="EdgeCurves">[in]  The new edge curves (with consistent orientation).</param>
            <param name="ftol">[in]  The fitting tolerance.</param>
            <param name="ctol">[in]  Used to decide which face to keep. For best results, should be at least 2*ftol.</param>
            <param name="Breps">[out] The results of the split.</param>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoCutUpSurface(RMA.OpenNURBS.IOnSurface,System.Boolean,RMA.OpenNURBS.OnCurve[],System.Double,System.Double,RMA.OpenNURBS.OnBrep[]@,System.Double@)">
            <summary>Surface splitter.</summary>
            <param name="srf">[in]  The surface to be split</param>
            <param name="bFlip">[in]  If true, input curves are oriented clockwise.</param>
            <param name="EdgeCurves">[in]  The new edge curves (with consistent orientation).</param>
            <param name="ftol">[in]  The fitting tolerance.</param>
            <param name="ctol">[in]  Used to decide which face to keep. For best results, should be at least 2*ftol.</param>
            <param name="Breps">[out] The results of the split.</param>
            <param name="max_tol_used">
[in] Default is NULL. ftol is the desired trimming tolerance. If the curves
are not within ftol of the surface, the distance to the surface is used for
trimming. max_ftol_used returns the maximum of the tolerances used. Always at least ftol.
</param>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoBrepClosestPoint(RMA.OpenNURBS.IOnBrep,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.OnCOMPONENT_INDEX,System.Double@,System.Double@)">
            <summary>Finds a point on a brep that is closest to test_point.</summary>
            <param name="brep">[in] input brep</param>
            <param name="pt">[in] base point to project to surface</param>
            <param name="ci">
[out] Component index of the brep component that contains the closest point.
Possible types are brep_face, brep_edge or brep_vertex
</param>
            <param name="s">
[out] If the component_index type is brep_edge, then s is the parameter of the closest edge point.
</param>
            <param name="t">
[out] If the component_index type is brep_face, then (s,t) is the parameter of the closest edge point.
</param>
            <returns>
TRUE - successful
FALSE - failure - No point exists within maximum_distance
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoBrepClosestPoint(RMA.OpenNURBS.IOnBrep,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.OnCOMPONENT_INDEX,System.Double@,System.Double@,RMA.OpenNURBS.On3dPoint)">
            <summary>Finds a point on a brep that is closest to test_point.</summary>
            <param name="brep">[in] input brep</param>
            <param name="pt">[in] base point to project to surface</param>
            <param name="ci">
[out] Component index of the brep component that contains the closest point.
Possible types are brep_face, brep_edge or brep_vertex
</param>
            <param name="s">
[out] If the component_index type is brep_edge, then s is the parameter of the closest edge point.
</param>
            <param name="t">
[out] If the component_index type is brep_face, then (s,t) is the parameter of the closest edge point.
</param>
            <param name="brep_point">
[out] if not NULL and true is returned, this is the location of the closest brep point.
</param>
            <returns>
TRUE - successful
FALSE - failure - No point exists within maximum_distance
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoBrepClosestPoint(RMA.OpenNURBS.IOnBrep,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.OnCOMPONENT_INDEX,System.Double@,System.Double@,RMA.OpenNURBS.On3dPoint,System.Double)">
            <summary>Finds a point on a brep that is closest to test_point.</summary>
            <param name="brep">[in] input brep</param>
            <param name="pt">[in] base point to project to surface</param>
            <param name="ci">
[out] Component index of the brep component that contains the closest point.
Possible types are brep_face, brep_edge or brep_vertex
</param>
            <param name="s">
[out] If the component_index type is brep_edge, then s is the parameter of the closest edge point.
</param>
            <param name="t">
[out] If the component_index type is brep_face, then (s,t) is the parameter of the closest edge point.
</param>
            <param name="brep_point">
[out] if not NULL and true is returned, this is the location of the closest brep point.
</param>
            <param name="maximum_distance">
[in]. If maximum_distance &gt; 0, then only points whose distance to p0
is &lt;= maximum_distance will be returned. Using a positive value of
maximum_distance can substantially speed up the search.
</param>
            <returns>
TRUE - successful
FALSE - failure - No point exists within maximum_distance
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoCurveFaceIntersect(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnBrepFace,System.Double,RMA.OpenNURBS.OnCurve[]@,RMA.OpenNURBS.On3dPointArray@)">
            <summary>
Brep face - curve intersector. Gets 3d points of intersection
and 3d overlap curves.  Returns FALSE if there is an error processing an
overlap curve.  In that case, partial results will be returned.
</summary>
            <param name="crv">[in] input curve</param>
            <param name="face">[in] input face</param>
            <param name="tol">[in] fitting and near miss tolerance</param>
            <param name="curves">[out] output 3d overlap curves</param>
            <param name="points">[out] output 3d intersection points</param>
            <returns>
TRUE - successful
FALSE - failure. Partial results will be returned
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoCurveBrepIntersect(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnBrep,System.Double,RMA.OpenNURBS.OnCurve[]@,RMA.OpenNURBS.On3dPointArray@)">
            <summary>
Brep - curve intersector. Gets 3d points of intersection
and 3d overlap curves.  Returns FALSE if there is an error processing an
overlap curve.  In that case, partial results will be returned.
</summary>
            <param name="crv">[in] input curve</param>
            <param name="brep">[in] input brep</param>
            <param name="tol">[in] fitting and near miss tolerance</param>
            <param name="curves">[out] output 3d overlap curves</param>
            <param name="points">[out] output 3d intersection points</param>
            <returns>
TRUE - successful
FALSE - failure. Partial results will be returned
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoIntersectBreps(RMA.OpenNURBS.IOnBrep,RMA.OpenNURBS.IOnBrep,System.Double,RMA.OpenNURBS.OnCurve[]@,RMA.OpenNURBS.On3dPointArray@)">
            <summary>Brep intersector.</summary>
            <param name="B0">[in]  The first input brep.</param>
            <param name="B1">[in]  The second input brep.</param>
            <param name="tolerance">[in]  The fitting and near miss tolerance.</param>
            <param name="curves">[out] The output 3d curves.</param>
            <param name="points">[out] the 3d intersection points.</param>
            <returns>
TRUE if successful.
FALSE if B0 == B1, or on error.
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoIntersectSurfaces(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.IOnSurface,System.Double,RMA.OpenNURBS.OnCurve[]@,RMA.OpenNURBS.On3dPointArray@)">
            <summary>Surface intersector.</summary>
            <param name="srf0">[in]  The first input surface.</param>
            <param name="srf1">[in]  The second input surface.</param>
            <param name="tolerance">[in]  The fitting and near miss tolerance.</param>
            <param name="curves">[out] The output 3d curves.</param>
            <param name="points">[out] the 3d intersection points.</param>
            <returns>
TRUE if successful.
FALSE if B0 == B1, or on error.
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoDollyExtentsSelected(RMA.Rhino.MRhinoView,System.Boolean)">
            <summary>
Dolly the camera location and so that the view frustum contains
all of the selected document objects that can be seen in view.
If the projection is perspective, the camera angle is not changed.
</summary>
            <param name="view">[in/out] The view to adjust</param>
            <param name="active_viewport">
[in] if true, dolly is performed on the ActiveViewport of the view
if false, dolly is performed on the MainViewport of the view
</param>
            <returns>True if successful.</returns>
            <remarks>
This version of RhinoDollyExtents determines what border factor
would be used by the Rhino Zoom command and calls
RhinoDollyExtentsSelected(view,border).
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoDollyExtents(RMA.Rhino.MRhinoView,System.Boolean)">
            <summary>
Dolly the camera location and so that the view frustum contains
all of the selected document objects that can be seen in view.
If the projection is perspective, the camera angle is not changed.
</summary>
            <param name="view">[in/out] The view to adjust</param>
            <param name="active_viewport">
[in] if true, dolly is performed on the ActiveViewport of the view
if false, dolly is performed on the MainViewport of the view
</param>
            <returns>True if successful.</returns>
            <remarks>
This version of RhinoDollyExtents determines what border factor
would be used by the Rhino Zoom command and calls
RhinoDollyExtents(view,border).
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoDollyExtentsSelected(RMA.Rhino.MRhinoViewport@,System.Double)">
            <summary>
Dolly the camera location and so that the view frustum contains
all of the selected document objects that can be seen in view.
If the projection is perspective, the camera angle is not changed.
</summary>
            <param name="viewport">[in/out]</param>
            <param name="border">
If border &gt; 1.0, then the fustum in enlarged by this factor
to provide a border around the view.  1.1 works well for
parallel projections; 0.0 is suggested for perspective projections.
</param>
            <returns>True if successful.</returns>
            <remarks>
This version of RhinoDollyExtentsSelected sets up an appropriate
iterator and uses 
RhinoDollyExtents( iterator, viewport.VP(), border, viewport.VP() )
to calculate the new projection.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoDollyExtents(RMA.Rhino.MRhinoViewport@,System.Double)">
            <summary>
Dolly the camera location and so that the view frustum contains
all of the document objects that can be seen in view.
If the projection is perspective, the camera angle is not changed.
</summary>
            <param name="viewport">[in/out]</param>
            <param name="border">
If border &gt; 1.0, then the fustum in enlarged by this factor
to provide a border around the view.  1.1 works well for
parallel projections; 0.0 is suggested for perspective projections.
</param>
            <returns>True if successful.</returns>
            <remarks>
This version of RhinoDollyExtents sets up an appropriate iterator and uses
RhinoDollyExtents( iterator, viewport.VP(), border, viewport.VP() )
to calculate the new projection.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoDollyExtents(RMA.Rhino.MRhinoObjectIterator,RMA.OpenNURBS.IOnViewport,System.Double,RMA.OpenNURBS.OnViewport@)">
            <summary>
Dolly the camera location and so that the view frustum contains
the list of objects and the objects are as large as possible.
If the projection is perspective, the camera angle is not changed.
</summary>
            <param name="it">[in] list of objects that need to be seen in the view.</param>
            <param name="current_vp">[in] current projection - must be valid.</param>
            <param name="border">
If border &gt; 1.0, then the fustum in enlarged by this factor
to provide a border around the view.  1.1 works well for
parallel projections; 0.0 is suggested for perspective projections.
</param>
            <param name="zoomed_vp">
[out] (can be the same as current_vp) projection with a view
frustum that contains the list of objects.
</param>
            <returns>True if successful.</returns>
            <remarks>
This version of RhinoDollyExtents calculates a tight camera
coordinate bounding box of the list of objects and calls

RhinoDollyExtents( current_vp, camcoord_bbox, zoomed_vp )
to calculate the new projection.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoDollyExtents(RMA.Rhino.MRhinoObjectIterator,RMA.OpenNURBS.IOnViewport,System.Double,RMA.OpenNURBS.OnViewport@,RMA.OpenNURBS.ArrayOn3dPoint)">
            <summary>
Dolly the camera location and so that the view frustum contains
the list of objects and the objects are as large as possible.
If the projection is perspective, the camera angle is not changed.
</summary>
            <param name="it">[in] list of objects that need to be seen in the view.</param>
            <param name="current_vp">[in] current projection - must be valid.</param>
            <param name="border">
If border &gt; 1.0, then the fustum in enlarged by this factor
to provide a border around the view.  1.1 works well for
parallel projections; 0.0 is suggested for perspective projections.
</param>
            <param name="zoomed_vp">
[out] (can be the same as current_vp) projection with a view
frustum that contains the list of objects.
</param>
            <param name="extra_points">
[in] (default = NULL) optional list of world 3d points that need to be included in the view.
</param>
            <returns>True if successful.</returns>
            <remarks>
This version of RhinoDollyExtents calculates a tight camera
coordinate bounding box of the list of objects and calls

RhinoDollyExtents( current_vp, camcoord_bbox, zoomed_vp )
to calculate the new projection.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoDollyExtents(RMA.Rhino.MRhinoObjectIterator,RMA.OpenNURBS.IOnViewport,System.Double,RMA.OpenNURBS.OnViewport@,RMA.OpenNURBS.ArrayOn3dPoint,RMA.OpenNURBS.OnBoundingBox@)">
            <summary>
Dolly the camera location and so that the view frustum contains
the list of objects and the objects are as large as possible.
If the projection is perspective, the camera angle is not changed.
</summary>
            <param name="it">[in] list of objects that need to be seen in the view.</param>
            <param name="current_vp">[in] current projection - must be valid.</param>
            <param name="border">
If border &gt; 1.0, then the fustum in enlarged by this factor
to provide a border around the view.  1.1 works well for
parallel projections; 0.0 is suggested for perspective projections.
</param>
            <param name="zoomed_vp">
[out] (can be the same as current_vp) projection with a view
frustum that contains the list of objects.
</param>
            <param name="extra_points">
[in] (default = NULL) optional list of world 3d points that need to be included in the view.
</param>
            <param name="camcoord_box">
[out] (default = NULL)
will be set to the camera coordinate bounding used to compute the
extents with respect to the viewport
</param>
            <returns>True if successful.</returns>
            <remarks>
This version of RhinoDollyExtents calculates a tight camera
coordinate bounding box of the list of objects and calls

RhinoDollyExtents( current_vp, camcoord_bbox, zoomed_vp )
to calculate the new projection.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoDollyExtents(RMA.OpenNURBS.IOnViewport,RMA.OpenNURBS.IOnBoundingBox,RMA.OpenNURBS.OnViewport@)">
            <summary>
Dolly the camera location and so that the view frustum contains
camcoord_bbox and the volume of camcoord_bbox fills the frustum.
If the projection is perspective, the camera angle is not changed.
</summary>
            <param name="current_vp">[in] current projection - must be valid.</param>
            <param name="camcoord_bbox">[in] valid bounding box in current_vp camera coordinates</param>
            <param name="zoomed_vp">[out] can be the same as current_vp projection</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoCompareGeometry(RMA.Rhino.IRhinoObject,RMA.Rhino.IRhinoObject)">
            <summary>Compares the geometry of two objects, similar to the SelDup command.</summary>
            <param name="a">[in] The first object to compare</param>
            <param name="b">[in] The second object to compare</param>
            <returns>
true:  The two objects are geometrically equivalent
false:  The two objects are not geometrically equivalent
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoJoinBrepNakedEdges(RMA.OpenNURBS.OnBrep@)">
            <summary>Join naked edge pairs within the same brep that overlap within tolerance.</summary>
            <param name="B">[in] Brep</param>
            <returns>number of joins made.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoJoinBrepNakedEdges(RMA.OpenNURBS.OnBrep@,System.Double)">
            <summary>Join naked edge pairs within the same brep that overlap within tolerance.</summary>
            <param name="B">[in] Brep</param>
            <param name="tolerance">
[in] overlap tolerance for joining edges. Uses document tolerance if &lt;= 0.0
</param>
            <returns>number of joins made.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoPointInPlanarClosedCurve(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOnCurve)">
            <summary>
Determine if a point is inside of a closed curve, on a closed curve, or outside of a closed curve.
</summary>
            <param name="closed_curve">[in] simple closed curve</param>
            <returns>
0:  point is outside of the closed curve
1:  point is inside of the closed curve
2:  point is on the closed curve
See Also: RhinoPlanarClosedCurveContainmentTest RhinoPlanarCurveCollisionTest
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoPointInPlanarClosedCurve(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnPlane)">
            <summary>
Determine if a point is inside of a closed curve, on a closed curve, or outside of a closed curve.
</summary>
            <param name="closed_curve">[in] simple closed curve</param>
            <param name="plane">[in] plane containing the closed curve and point</param>
            <returns>
0:  point is outside of the closed curve
1:  point is inside of the closed curve
2:  point is on the closed curve
See Also: RhinoPlanarClosedCurveContainmentTest RhinoPlanarCurveCollisionTest
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoPointInPlanarClosedCurve(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnPlane,System.Double)">
            <summary>
Determine if a point is inside of a closed curve, on a closed curve, or outside of a closed curve.
</summary>
            <param name="closed_curve">[in] simple closed curve</param>
            <param name="plane">[in] plane containing the closed curve and point</param>
            <param name="tolerance">[in] intersection tolerance</param>
            <returns>
0:  point is outside of the closed curve
1:  point is inside of the closed curve
2:  point is on the closed curve
See Also: RhinoPlanarClosedCurveContainmentTest RhinoPlanarCurveCollisionTest
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoPlanarCurveCollisionTest(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnCurve)">
            <summary>Determine if two coplanar curves intersect.</summary>
            <returns>
false:  curves do not intersect
true:   curves intersect
See Also: RhinoPlanarClosedCurveContainmentTest RhinoPointInPlanarClosedCurve
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoPlanarCurveCollisionTest(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnPlane)">
            <summary>Determine if two coplanar curves intersect.</summary>
            <param name="plane">[in] plane containing the curves</param>
            <returns>
false:  curves do not intersect
true:   curves intersect
See Also: RhinoPlanarClosedCurveContainmentTest RhinoPointInPlanarClosedCurve
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoPlanarCurveCollisionTest(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnPlane,System.Double)">
            <summary>Determine if two coplanar curves intersect.</summary>
            <param name="plane">[in] plane containing the curves</param>
            <param name="tolerance">[in] intersection tolerance</param>
            <returns>
false:  curves do not intersect
true:   curves intersect
See Also: RhinoPlanarClosedCurveContainmentTest RhinoPointInPlanarClosedCurve
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoPlanarClosedCurveContainmentTest(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnCurve)">
            <summary>Determine the relationship between the regions bounded by two coplanar simple closed curves.</summary>
            <param name="closed_curveA">[in] simple closed curve</param>
            <param name="closed_curveB">[in] simple closed curve</param>
            <returns>
0:  regions bounded by the curves are disjoint
1:  curves intersect
2:  region bounded by curveA is inside of curveB
3:  region bounded by curveB is inside of curveA
See Also: RhinoPlanarCurveCollisionTest RhinoPointInPlanarClosedCurve
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoPlanarClosedCurveContainmentTest(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnPlane)">
            <summary>Determine the relationship between the regions bounded by two coplanar simple closed curves.</summary>
            <param name="closed_curveA">[in] simple closed curve</param>
            <param name="closed_curveB">[in] simple closed curve</param>
            <param name="plane">[in] plane containing the closed curves</param>
            <returns>
0:  regions bounded by the curves are disjoint
1:  curves intersect
2:  region bounded by curveA is inside of curveB
3:  region bounded by curveB is inside of curveA
See Also: RhinoPlanarCurveCollisionTest RhinoPointInPlanarClosedCurve
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoPlanarClosedCurveContainmentTest(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnPlane,System.Double)">
            <summary>Determine the relationship between the regions bounded by two coplanar simple closed curves.</summary>
            <param name="closed_curveA">[in] simple closed curve</param>
            <param name="closed_curveB">[in] simple closed curve</param>
            <param name="plane">[in] plane containing the closed curves</param>
            <param name="tolerance">[in] intersection tolerance</param>
            <returns>
0:  regions bounded by the curves are disjoint
1:  curves intersect
2:  region bounded by curveA is inside of curveB
3:  region bounded by curveB is inside of curveA
See Also: RhinoPlanarCurveCollisionTest RhinoPointInPlanarClosedCurve
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoStraightenBrep(RMA.OpenNURBS.OnBrep@)">
            <summary>
If any surface in a brep is very nearly G1-continuous, move control points
to make it exactly G1.
</summary>
            <param name="B">[in] Brep to straighten.</param>
            <returns>
number of surfaces that were changed
See Also: RhinoMakeG1Surface
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoStraightenBrep(RMA.OpenNURBS.OnBrep@,System.Double)">
            <summary>
If any surface in a brep is very nearly G1-continuous, move control points
to make it exactly G1.
</summary>
            <param name="B">[in] Brep to straighten.</param>
            <param name="tol">
[in] tolerance.  Control points will be moved if they do not
need to be moved any more than tol.  If tol &lt;= 0,
the Rhino document tolerance will be used.
</param>
            <returns>
number of surfaces that were changed
See Also: RhinoMakeG1Surface
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoMakeG1Surface(RMA.OpenNURBS.OnSurface@)">
            <summary>If a surface is very nearly G1-continuous, move control points to make it exactly G1.</summary>
            <param name="srf">[in] surface to be made G1</param>
            <returns>
true if srf was changed
See Also: RhinoStraightenBrep
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoMakeG1Surface(RMA.OpenNURBS.OnSurface@,System.Double)">
            <summary>If a surface is very nearly G1-continuous, move control points to make it exactly G1.</summary>
            <param name="srf">[in] surface to be made G1</param>
            <param name="tol">
[in] tolerance.  Control points will be moved if they do not
need to be moved any more than tol.  If tol &lt;= 0,
the Rhino document tolerance will be used.
</param>
            <returns>
true if srf was changed
See Also: RhinoStraightenBrep
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetBrepFaceIsoCurves(RMA.OpenNURBS.IOnBrepFace,System.Int32,System.Double,RMA.OpenNURBS.OnCurve[]@)">
            <summary>Get iso curves on an ON_BrepFace (trimmed surface)</summary>
            <param name="face">[in] brep face</param>
            <param name="iso_dir">
0: intervals are u intervals at constant v values
1: intervals are v intervals at constant u values
</param>
            <param name="iso_constant">
If iso_dir is 0, then iso_constant is a constant v parameter.
If iso_dir is 1, then iso_constant is a constant u parameter.
</param>
            <param name="iso_curves">[out] 3d iso curves are appended to this list</param>
            <returns>number of curves appended to the iso_curves[] array.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetBrepFaceIsoIntervals(RMA.OpenNURBS.IOnBrepFace,System.Int32,System.Double,RMA.OpenNURBS.ArrayOnInterval@)">
            <summary>Get intervals where the iso curve exists on an ON_BrepFace (trimmed surface)</summary>
            <param name="face">[in] (trim curves will be promoted to TL_NurbsCurves)</param>
            <param name="iso_dir">
0 intervals are u intervals, c = constant v value
1 intervals are v intervals, c = constant u value
</param>
            <param name="iso_constant">
If iso_dir is 0, then iso_constant is the constant v parameter.
If iso_dir is 1, then iso_constant is the constant u parameter.
</param>
            <param name="intervals">
[out] intervals are append to this list. The iso curve(s) exist on the domain of the intervals.
</param>
            <returns>number of intervals appended to the intervals[] array.</returns>
            <remarks>
If iso_dir = 0, the parameter space iso interval connects the 2d points
(intervals[i][0],iso_constant) and (intervals[i][1],iso_constant).
If iso_dir = 0, the parameter space iso interval connects the 2d points
(iso_constant,intervals[i][0]) and (iso_constant,intervals[i][1]).
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetTightBoundingBox(RMA.Rhino.IRhinoObject[],RMA.OpenNURBS.OnBoundingBox@)">
            <summary>
Get objects tight axis aligned bounding box or the
union of the input box with the object's bounding box.
The alignment of the box may be specified by a parameter.
</summary>
            <param name="box">[in/out] 3d axis aligned bounding box</param>
            <returns>true if success</returns>
            <remarks>
If onb points to a valid ON_Plane the geometry is bounded by the 
plane  aligned box  defined by the point set:
onb-&gt;Origin() + x*onb-&gt;Xaxis() + y*onb-&gt;YAxis() + z*onb-&gt;zaxis
for all (x,y,z) in bbox.
If MakeMeshes is false the brep surface wireframe is used for breps without meshes
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetTightBoundingBox(RMA.Rhino.IRhinoObject[],RMA.OpenNURBS.OnBoundingBox@,System.Boolean)">
            <summary>
Get objects tight axis aligned bounding box or the
union of the input box with the object's bounding box.
The alignment of the box may be specified by a parameter.
</summary>
            <param name="box">[in/out] 3d axis aligned bounding box</param>
            <param name="bGrowBox">
If true, then the union of the input bbox and the object's bounding box is returned.
If false, the object's bounding box is returned.
</param>
            <returns>true if success</returns>
            <remarks>
If onb points to a valid ON_Plane the geometry is bounded by the 
plane  aligned box  defined by the point set:
onb-&gt;Origin() + x*onb-&gt;Xaxis() + y*onb-&gt;YAxis() + z*onb-&gt;zaxis
for all (x,y,z) in bbox.
If MakeMeshes is false the brep surface wireframe is used for breps without meshes
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetTightBoundingBox(RMA.Rhino.IRhinoObject[],RMA.OpenNURBS.OnBoundingBox@,System.Boolean,RMA.OpenNURBS.OnPlane)">
            <summary>
Get objects tight axis aligned bounding box or the
union of the input box with the object's bounding box.
The alignment of the box may be specified by a parameter.
</summary>
            <param name="box">[in/out] 3d axis aligned bounding box</param>
            <param name="bGrowBox">
If true, then the union of the input bbox and the object's bounding box is returned.
If false, the object's bounding box is returned.
</param>
            <param name="onb">
If null the box is computed in world coordinates.
If not null must *onb must be a valid ON_Plane.
onb's origin, xaxis, yaxis and zaxis specify an oriented orthonormal frame.
</param>
            <returns>true if success</returns>
            <remarks>
If onb points to a valid ON_Plane the geometry is bounded by the 
plane  aligned box  defined by the point set:
onb-&gt;Origin() + x*onb-&gt;Xaxis() + y*onb-&gt;YAxis() + z*onb-&gt;zaxis
for all (x,y,z) in bbox.
If MakeMeshes is false the brep surface wireframe is used for breps without meshes
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetTightBoundingBox(RMA.Rhino.IRhinoObject[],RMA.OpenNURBS.OnBoundingBox@,System.Boolean,RMA.OpenNURBS.OnPlane,System.Boolean)">
            <summary>
Get objects tight axis aligned bounding box or the
union of the input box with the object's bounding box.
The alignment of the box may be specified by a parameter.
</summary>
            <param name="box">[in/out] 3d axis aligned bounding box</param>
            <param name="bGrowBox">
If true, then the union of the input bbox and the object's bounding box is returned.
If false, the object's bounding box is returned.
</param>
            <param name="onb">
If null the box is computed in world coordinates.
If not null must *onb must be a valid ON_Plane.
onb's origin, xaxis, yaxis and zaxis specify an oriented orthonormal frame.
</param>
            <param name="MakeMeshes">
[in] Make render meshes for all meshless breps	in a cancelable thread
</param>
            <returns>true if success</returns>
            <remarks>
If onb points to a valid ON_Plane the geometry is bounded by the 
plane  aligned box  defined by the point set:
onb-&gt;Origin() + x*onb-&gt;Xaxis() + y*onb-&gt;YAxis() + z*onb-&gt;zaxis
for all (x,y,z) in bbox.
If MakeMeshes is false the brep surface wireframe is used for breps without meshes
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoExtendSurface(RMA.OpenNURBS.OnSurface@,RMA.OpenNURBS.IOnSurface.ISO,System.Double,System.Boolean)">
            <summary>Extend an untrimmed surface along one edge.</summary>
            <param name="srf">
[in/out] surface to modify/ or replace.  The surface must be on the heap since
it may be deleted and a new object of the appropriate type is returned.
</param>
            <param name="edge_index">[in] edge to extend must be N_iso, E_iso, S_iso, or W_iso</param>
            <param name="ExtensionLength">[in]&gt;0</param>
            <param name="SmoothToggle">
[in] true for smooth (C-infinity) extension
false  for a C1- ruled extension
</param>
            <returns>
true if extension is successfully computed
false no changes 
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoSimplifyCurveEnd(RMA.OpenNURBS.OnCurve@,System.Int32,System.Int32,System.Double,System.Double)">
            <summary>Same as RhinoSimplifyCurve, but simplifies only the last two segments at "side" end.</summary>
            <param name="side">[in] specifies end to simplify. 0=start, 1=end</param>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoSimplifyCurve(RMA.OpenNURBS.OnCurve@,System.Double,System.Double)">
            <summary>
Simplify curve replaces the curve with a geometrically equivalent ON_PolyCurve.
The ON_PolyCurve has the following properties
1. All the PolyCurve segments are ON_LineCurve, ON_PolylineCurve ON_ArcCurve, or ON_NurbsCurve.
2. The Nurbs Curves segments do not have fully multiple interior knots.
3. Rational Nurbs curves do not have constant weights.
4. Any segment for which IsLinear() or IsArc() is true is an ON_Line, ON_Polyline segment, or an ON_Arc.
5. Adjacent Colinear or Cocircular segments are combined.
6. Segments that meet with G1-continuity have there ends tuned up so that they meet
  with G1-continuity to within machine precision
</summary>
            <param name="crv">[in/out] input curve can be of any ON_Curve type. output curve is an ON_PolyCurve.</param>
            <remarks>
The default of flags=0 implies all of the simplification functions will be used.
DONT_SPLIT_FMK				Don't split NurbsCurves at fully multiple knots
DONT_REBUILD_LINES	 	Don't replace segments with IsLinear()==true with ON_LineCurves
DONT_REBUILD_ARCS		 	Don't replace segments with IsArc()==true with ON_Arc
DONT_REBUILD_RATIONALS	Don't replace rational nurbscurves with constant denominator
                     with an equivalent non-rational ON_NurbsCurve
DONT_ADJUST_G1				Don't adjust Curves at G1-joins.     
DONT_MERGE            Don't merge adjacent co-linear lines or co-circular arc
										or combine consecutive line segments into a polyline		

The distance_tolerance is used in the following stages
Detecting lines and arcs

Both distance_tolerance and angle_tolerance are used in the following stages
Detecting G1 continuity
Detecting co-linearity of adjacent line segments and cocircularity of adjacent arcs

If in doubt about what to use for the tolerance settings use
dist_tol  = RhinoApp().ActiveDoc()-&gt;AbsoluteTolerance(), and  
angle_tol = RhinoApp().ActiveDoc()-&gt;AngleToleranceRadians()
</remarks>
            <returns>true if the curve is modified</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoSimplifyCurve(RMA.OpenNURBS.OnCurve@,System.Int32,System.Double,System.Double)">
            <summary>
Simplify curve replaces the curve with a geometrically equivalent ON_PolyCurve.
The ON_PolyCurve has the following properties
1. All the PolyCurve segments are ON_LineCurve, ON_PolylineCurve ON_ArcCurve, or ON_NurbsCurve.
2. The Nurbs Curves segments do not have fully multiple interior knots.
3. Rational Nurbs curves do not have constant weights.
4. Any segment for which IsLinear() or IsArc() is true is an ON_Line, ON_Polyline segment, or an ON_Arc.
5. Adjacent Colinear or Cocircular segments are combined.
6. Segments that meet with G1-continuity have there ends tuned up so that they meet
  with G1-continuity to within machine precision
</summary>
            <param name="crv">[in/out] input curve can be of any ON_Curve type. output curve is an ON_PolyCurve.</param>
            <param name="flags">[in] flags specifying which function to use to simplify curve.</param>
            <remarks>
The default of flags=0 implies all of the simplification functions will be used.
DONT_SPLIT_FMK				Don't split NurbsCurves at fully multiple knots
DONT_REBUILD_LINES	 	Don't replace segments with IsLinear()==true with ON_LineCurves
DONT_REBUILD_ARCS		 	Don't replace segments with IsArc()==true with ON_Arc
DONT_REBUILD_RATIONALS	Don't replace rational nurbscurves with constant denominator
                     with an equivalent non-rational ON_NurbsCurve
DONT_ADJUST_G1				Don't adjust Curves at G1-joins.     
DONT_MERGE            Don't merge adjacent co-linear lines or co-circular arc
										or combine consecutive line segments into a polyline		

The distance_tolerance is used in the following stages
Detecting lines and arcs

Both distance_tolerance and angle_tolerance are used in the following stages
Detecting G1 continuity
Detecting co-linearity of adjacent line segments and cocircularity of adjacent arcs

If in doubt about what to use for the tolerance settings use
dist_tol  = RhinoApp().ActiveDoc()-&gt;AbsoluteTolerance(), and  
angle_tol = RhinoApp().ActiveDoc()-&gt;AngleToleranceRadians()
</remarks>
            <returns>true if the curve is modified</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoExtendCurve(RMA.OpenNURBS.OnCurve@,RMA.Rhino.IRhinoExtend.Type,System.Int32,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Extend a curve by a line, arc or smooth extension.  The extension endpoint	is specified.
</summary>
            <param name="crv">
[in/out] curve to extend.  Note either *crv can change or the pointer crv can be changed by the routine.
</param>
            <param name="type">[in]type of extension, line, arc or smooth</param>
            <param name="side">[in] end to extend. 0- beginning, 1- end</param>
            <param name="end">[in] end point of extension</param>
            <returns>true if the extension hit an object.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoExtendCurve(RMA.OpenNURBS.OnCurve@,RMA.Rhino.IRhinoExtend.Type,System.Int32,RMA.OpenNURBS.IOnGeometry[])">
            <summary>Extend a curve by a line, arc or smooth extension untill it intersects a collection of objects</summary>
            <param name="crv">
[in/out] curve to extend. Note either *crv can change or the pointer crv can be changed by the routine.
</param>
            <param name="type">[in] type of extension, line, arc or smooth</param>
            <param name="side">[in] end to extend. 0- beginning, 1, end, 2 - both</param>
            <param name="geom">[in] collection of objects.  Allowable object types are	ON_Curve, ON_Surface, ON_Brep</param>
            <returns>true if the extension hit an object.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoExtendCrvOnSrf(RMA.OpenNURBS.IOnBrepFace,RMA.OpenNURBS.OnCurve@)">
            <summary>Extend a curve on a face</summary>
            <param name="face">[in] a brep face to extend the curve on</param>
            <param name="crv">
[in/out] pointer to the  input curve can be either a 2d parameter space curve or a 3d-curve.
At output this is a pointer to the output curve, which contains the input curve as a subcurve.
</param>
            <returns>
true the function suceeded
false the function failed the crv is left unchanged
</returns>
            <remarks>
If crv is a 2d parameter space curve and either end is in the active 
region of the face the curve is extended at this end,in a C^1 fashion.
the extension may not end at the boundary of the face. The resulting curve is a ON_PolyCurve
with the original curve as one of the polycurve segments.  

If crv is a 3d model space curve and either end projects, via the closest
point projection, to the interior of the active  region of the face then 
the curve is extended at this end, in a C^1 fashion.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoExtendCrvOnSrf(RMA.OpenNURBS.IOnBrepFace,RMA.OpenNURBS.OnCurve@,System.Int32)">
            <summary>Extend a curve on a face</summary>
            <param name="face">[in] a brep face to extend the curve on</param>
            <param name="crv">
[in/out] pointer to the  input curve can be either a 2d parameter space curve or a 3d-curve.
At output this is a pointer to the output curve, which contains the input curve as a subcurve.
</param>
            <param name="side">[in] end to extend. 0- beginning, 1, end, 2 - both</param>
            <returns>
true the function suceeded
false the function failed the crv is left unchanged
</returns>
            <remarks>
If crv is a 2d parameter space curve and either end is in the active 
region of the face the curve is extended at this end,in a C^1 fashion.
the extension may not end at the boundary of the face. The resulting curve is a ON_PolyCurve
with the original curve as one of the polycurve segments.  

If crv is a 3d model space curve and either end projects, via the closest
point projection, to the interior of the active  region of the face then 
the curve is extended at this end, in a C^1 fashion.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoExtendCurve(RMA.OpenNURBS.OnCurve@,RMA.Rhino.IRhinoExtend.Type,System.Int32,System.Double)">
            <summary>Extend a curve by a line, arc or smooth extension for a specified distance</summary>
            <param name="crv">
[in/out] curve to extend.  Note either *crv can change or the pointer crv can be changed by the routine.
</param>
            <param name="type">[in] type of extension, line, arc or smooth</param>
            <param name="side">[in] end to extend. 0- beginning, 1, end, 2 - both</param>
            <param name="length">[in] length of extension ( &gt;= 0)</param>
            <returns>true if desired extension achieved.</returns>
            <remarks>
The parametric curve is extended, i.e. if c' is the extension of c then
   c(t) = c'(t)   for any t in the domain of c.
The extension is generally C1-continous at the point of the extension,
and may be smoother depending on the type of extension.

When type==RhinoExtend::Smooth the parametric curve  is extended by the analytic 
extension.  The curve *crv is modified, in particular the type is unchanged.
If the curve is	a nurbs curve, or a poly curve with a nurbscurve at the end to be 
extended, then the extension length is only approximate.  Also, refer to the comments
in TL_ExtendNurb for warnings about smooth extensions of nurbs curves. 

When type==RhinoExtend::Line or RhinoExtend::Arc the result is an ON_PolyCurve with the 
input curve as one of the curve segments.  The user must delete the returned polycurve.

When type=RhinoExtend::Arc the result is G2-continuous, but generally not C2-continuous.

Even if the function returns false the curve may be extended as far as possible, e.g.,
an arc may be extended to 360 degrees but not more.

Returns false on closed curves.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoSrfControlPtGrid(System.Int32[],System.Int32[],RMA.OpenNURBS.IOn3dPointArray)">
            <summary>Creates a nurbs surface from a 2D grid of control points</summary>
            <param name="point_count">[in] The number of points in the U and V directions. (array size=2)</param>
            <param name="degree">[in] The surface degree in the U and V directions. (array size=2)</param>
            <param name="point_array">[in] The grid (array) of control points.</param>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoSrfControlPtGrid(System.Int32[],System.Int32[],RMA.OpenNURBS.IOn3dPointArray,RMA.OpenNURBS.OnNurbsSurface)">
            <summary>Creates a nurbs surface from a 2D grid of control points</summary>
            <param name="point_count">[in] The number of points in the U and V directions. (array size=2)</param>
            <param name="degree">[in] The surface degree in the U and V directions. (array size=2)</param>
            <param name="point_array">[in] The grid (array) of control points.</param>
            <param name="nurbs_surface">[in] If not NULL, this surface will be used and returned.</param>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoSrfPtGrid(System.Int32[],System.Int32[],System.Boolean[],RMA.OpenNURBS.IOn3dPointArray)">
            <summary>Creates a nurbs surface from a 2D grid of control points</summary>
            <param name="point_count">[in] The number of points in the U and V directions. (array size=2)</param>
            <param name="degree">[in] The surface degree in the U and V directions. (array size=2)</param>
            <param name="is_closed">[in] Whether or not the surface is closed in the U and V directions.</param>
            <param name="point_array">[in] The grid (array) of control points.</param>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoSrfPtGrid(System.Int32[],System.Int32[],System.Boolean[],RMA.OpenNURBS.IOn3dPointArray,RMA.OpenNURBS.OnNurbsSurface)">
            <summary>Creates a nurbs surface from a 2D grid of control points</summary>
            <param name="point_count">[in] The number of points in the U and V directions. (array size=2)</param>
            <param name="degree">[in] The surface degree in the U and V directions. (array size=2)</param>
            <param name="is_closed">[in] Whether or not the surface is closed in the U and V directions.</param>
            <param name="point_array">[in] The grid (array) of control points.</param>
            <param name="nurbs_surface">[in] If not NULL, this surface will be used and returned.</param>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoDoCurveDirectionsMatch(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnCurve)">
            <summary>
Tests if 2 open curves are grenerally in the same direction
or if they would be more in the same direction if they were flipped
</summary>
            <returns>
true - now in same direction
false - would be more in the same direction if they weree flipped
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoShortPath(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOn2dPoint,System.Double)">
            <summary>Constructs a geodesic between 2 points, used by ShortPath command in Rhino</summary>
            <param name="Srf">[in] Surface</param>
            <param name="start">[in] endpoints of curve in parameter space.  Points must be distinct</param>
            <param name="end">[in] in the domain of Srf</param>
            <param name="tol">[in] tolerance used in fitting discrete solution</param>
            <returns>a geodesic curve on the surface</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoInterpolatePointsOnSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.IArrayOn2dPoint,System.Int32,System.Double,System.Int32)">
            <summary>
returns a curve that interpolates points on a surface.  The interpolant lies on the surface.
</summary>
            <param name="srf">[in] Surface containing the points.</param>
            <param name="PtIn">[in] Arrray of at least 2 parameter points on the surface</param>
            <param name="is_closed">
0 - not closed. The interpolating curve is not closed
1 - closed.    The interpolating curve is closed.  
              The last point and first point of PtIn should generally not be equal.
</param>
            <param name="tol">
[in] tolerance used for the fit of the pushup curve.
Generally, the resulting interpolating curve will be within tol of the surface.
</param>
            <param name="ClosedSrfHandling">
0 - All points in PtIn must be in the rectangular domain of srf.
   If srf is closed in some direction then this routine will 
   interpret each point and place it at an appropriate location in the
   the covering space.  This is the simpleest option and should give 
   good results. 
1 - Use this option for more control of handling curves going across seams.
   If the surface is closed in some direction then the points in PtIn
   are taken as points in the covering space.
   Example: Suppose srf.IsClosed(0)=TRUE and srf.IsClosed(1)=FALSE
   and srf.Domain(0)=srf.Domain(1)=ON_Interval(0,1) then if
   ClosedSrfHandling = 1  a point (u,v) in PtIn can have any
   value for the u coordinate, but must have 0&lt;=v&lt;=1.  In particular
   if PtIn = { (0.0,0.5), (2.0,0.5) } then the interpolating curve will
   wrap around the surface 2 times in the closed direction befor ending
   at start of the curve.  If is_closed=1 the last point should equal 
   the first point plus an integer multiple of the period on a closed 
   direction.
</param>
            <returns>An interpolating curve lying on the surface.</returns>
            <remarks>This code doesn't make periodic curves, but will make closed curves.</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoInterpCurve(System.Int32,RMA.OpenNURBS.IArrayOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,System.Int32)">
            <summary>Interpolates a sequence of points.  Used by InterpCurve Command</summary>
            <param name="degree">[in] The degree of the curve &gt;=1.  Degree must be odd.</param>
            <param name="Pt">
[in] Array of points to interpolate. For periodic curves if the final point is 
a duplicate of the initial point it is  ignored.
Pt.Count()&gt;=2
</param>
            <param name="start_tan">
[in] If not NULL this is the unit tangent at the start of the curve.
For periodic style curves start_tan must be NULL.
</param>
            <param name="end_tan">
[in] If not NULL this is unit tangent at the end of the curve.
For periodic style curves end_tan must be NULL.
</param>
            <param name="knot_style">
[in]Knot-style to use  and specifies if the curve should be periodic. 
0  uniform knots. Parameter spacing between consecutive knots is 1.0
1  chord length spacing,  requires degree=3 with CV1 and CVn1 specified.
2  sqrt(chord length),  requires degree=3 with CV1 and CVn1 specified.
3  periodic with uniform spacing
4  periodic with chord length spacing.
5  periodic with sqrt(chord length) spacing.
</param>
            <returns>Pointer to interpolating curve.  Returns NULL if failure.</returns>
            <remarks>This routine works best when degree=3.</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoInterpCurve(System.Int32,RMA.OpenNURBS.IArrayOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,System.Int32,RMA.OpenNURBS.OnNurbsCurve)">
            <summary>Interpolates a sequence of points.  Used by InterpCurve Command</summary>
            <param name="degree">[in] The degree of the curve &gt;=1.  Degree must be odd.</param>
            <param name="Pt">
[in] Array of points to interpolate. For periodic curves if the final point is 
a duplicate of the initial point it is  ignored.
Pt.Count()&gt;=2
</param>
            <param name="start_tan">
[in] If not NULL this is the unit tangent at the start of the curve.
For periodic style curves start_tan must be NULL.
</param>
            <param name="end_tan">
[in] If not NULL this is unit tangent at the end of the curve.
For periodic style curves end_tan must be NULL.
</param>
            <param name="knot_style">
[in]Knot-style to use  and specifies if the curve should be periodic. 
0  uniform knots. Parameter spacing between consecutive knots is 1.0
1  chord length spacing,  requires degree=3 with CV1 and CVn1 specified.
2  sqrt(chord length),  requires degree=3 with CV1 and CVn1 specified.
3  periodic with uniform spacing
4  periodic with chord length spacing.
5  periodic with sqrt(chord length) spacing.
</param>
            <param name="nurbs_curve">[in]If not NULL, this curve will be used and returned.</param>
            <returns>Pointer to interpolating curve.  Returns NULL if failure.</returns>
            <remarks>This routine works best when degree=3.</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.MakeRhinoContours(RMA.Rhino.IRhinoContourInput,RMA.OpenNURBS.OnPolyline[]@,RMA.OpenNURBS.OnCurve[]@,RMA.OpenNURBS.ArrayOn3dPoint@)">
            <summary>
This function will create contour curves for breps and contour polylines for meshes
that are input.m_interval distance apart and fill the output arrays with the results.
If m_bAddOutputToDocument = true the output will be added to the current Rhino document
instead of populating the output arrays.
</summary>
            <param name="input">[in]</param>
            <param name="output_PlineArray">[out] output from mesh and pointcloud intersection</param>
            <param name="output_CurveArray">[out] output from surface and polysurface intersection</param>
            <param name="output_PointArray">[out] output from curve intersection</param>
            <returns>
true     Success
false    Failure
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetFilletPoints(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnCurve,System.Double,System.Double,System.Double,System.Double@,System.Double@,RMA.OpenNURBS.OnPlane@)">
            <summary>find points at which to cut a pair of curves so that a fillet of radius r fits.</summary>
            <param name="c0">[in] curves</param>
            <param name="c1">[in] curves</param>
            <param name="radius">[in] fillet radius</param>
            <param name="t0_base">[in] parameter value for base point on curve 0</param>
            <param name="t1_base">[in] parameter value for base point on curve 1</param>
            <param name="t0">[out] parameter value of fillet point on curve 0</param>
            <param name="t1">[out] parameter value of fillet point on curve 1</param>
            <param name="FilletPlane">[out] The fillet is contained in this plane with center at the plane origin.</param>
            <returns>
true - solution found
false - no solution found
</returns>
            <remarks>
A fillet point is a pair of curve parameters (t0,t1) such that there is a 
circle of radius r tangent to curve c0 at t0 and tangent to curve c1 at t1. 
Of all possible fillet points this function returns the one which is the closest
to the base point t0_base, t1_base.  Distance from the base point is 
measured by  the sum of arc lengths along the two curves. 
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetLineExtremes(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.OnLine@)">
            <summary>
Find the extreme geometric end points of a curve that may be
doubled back on itself as when a circle is collapsed edge-wise
Such a curve may have endpoints on the interior of the geometric line
</summary>
            <param name="curve">[in] the curve to examine</param>
            <param name="line">[out] the geometric line representing the curve</param>
            <returns>
TRUE     Success
FALSE    Failure
</returns>
            <remarks>
Does not check if the curve is linear or not - just returns
the max distance between kinks
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoAcadNameString(System.String@)">
            <summary>Converts a string to a name string valid in AutoCAD</summary>
            <param name="name">[in/out] a string to convert / the converted string</param>
            <remarks>
Replaces characters not valid in AutoCAD strings with '_'
and truncates to 31 characters
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoAcadNameString(System.String@,System.Int32,System.Boolean)">
            <summary>Converts a string to a name string valid in AutoCAD</summary>
            <param name="name">[in/out] a string to convert / the converted string</param>
            <param name="max_length">maximum length of output name</param>
            <param name="bAllowSpaces">optional to allow spaces in output</param>
            <remarks>
Replaces characters not valid in AutoCAD strings with '_'
and truncates to max_length
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoExtendLineThroughBox(RMA.OpenNURBS.IOnLine,RMA.OpenNURBS.IOnBoundingBox,RMA.OpenNURBS.OnLine@)">
            <summary>Find a line colinear with line_in that goes completely through the box</summary>
            <param name="line_in">[in] - The original line ( not modified)</param>
            <param name="bbox">[in] - The box to extend through</param>
            <param name="line_out">[out] - The extended line</param>
            <returns>
TRUE     Success
False    Failure
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoProjectToPlane(RMA.OpenNURBS.OnBoundingBox@,RMA.OpenNURBS.OnPlane@)">
            <summary>Project an ON_BoundingBox to a plane</summary>
            <param name="box">
[in] the box to project.  
[out] the modified box
</param>
            <returns>
TRUE     Success
False    Failure
</returns>
            <remarks>Bounding box is flattered in place</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoProjectToPlane(RMA.OpenNURBS.OnNurbsCurve@,RMA.OpenNURBS.OnPlane@)">
            <summary>Project a Nurbs curve to a plane</summary>
            <param name="curve">
[in] the curve to project.
[out] the modified curve
</param>
            <returns>
TRUE     Success
False    Failure
</returns>
            <remarks>Curve is flattered in place</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoActiveCPlane">
            <summary>Return a pointer to the active cplane</summary>
            <returns>pointer to cplane or NULL if there is none.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoArePointsCoplanar(RMA.OpenNURBS.ArrayOn4dPoint@)">
            <summary>Tests if the points in an array are coplanar</summary>
            <param name="points">[in] - the array of points to test</param>
            <returns>
TRUE     Points are Coplanar
False    Points are not Coplanar
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoArePointsCoplanar(RMA.OpenNURBS.ArrayOn4dPoint@,RMA.OpenNURBS.On3dPoint)">
            <summary>Tests if the points in an array are coplanar</summary>
            <param name="points">[in] - the array of points to test</param>
            <returns>
TRUE     Points are Coplanar
False    Points are not Coplanar
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoArePointsCoplanar(RMA.OpenNURBS.ArrayOn4dPoint@,RMA.OpenNURBS.On3dPoint,RMA.OpenNURBS.On3dVector)">
            <summary>Tests if the points in an array are coplanar</summary>
            <param name="points">[in] - the array of points to test</param>
            <returns>
TRUE     Points are Coplanar
False    Points are not Coplanar
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoArePointsCoplanar(RMA.OpenNURBS.ArrayOn4dPoint@,RMA.OpenNURBS.On3dPoint,RMA.OpenNURBS.On3dVector,System.Double)">
            <summary>Tests if the points in an array are coplanar</summary>
            <param name="points">[in] - the array of points to test</param>
            <returns>
TRUE     Points are Coplanar
False    Points are not Coplanar
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoArePointsCoplanar(RMA.OpenNURBS.ArrayOn3dPoint@)">
            <summary>Tests if the points in an array are coplanar</summary>
            <param name="points">[in] - the array of points to test</param>
            <returns>
TRUE     Points are Coplanar
False    Points are not Coplanar
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoArePointsCoplanar(RMA.OpenNURBS.ArrayOn3dPoint@,RMA.OpenNURBS.On3dPoint)">
            <summary>Tests if the points in an array are coplanar</summary>
            <param name="points">[in] - the array of points to test</param>
            <returns>
TRUE     Points are Coplanar
False    Points are not Coplanar
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoArePointsCoplanar(RMA.OpenNURBS.ArrayOn3dPoint@,RMA.OpenNURBS.On3dPoint,RMA.OpenNURBS.On3dVector)">
            <summary>Tests if the points in an array are coplanar</summary>
            <param name="points">[in] - the array of points to test</param>
            <returns>
TRUE     Points are Coplanar
False    Points are not Coplanar
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoArePointsCoplanar(RMA.OpenNURBS.ArrayOn3dPoint@,RMA.OpenNURBS.On3dPoint,RMA.OpenNURBS.On3dVector,System.Double)">
            <summary>Tests if the points in an array are coplanar</summary>
            <param name="points">[in] - the array of points to test</param>
            <param name="tolerance">[in] - Optional toleranc for distance from the plane</param>
            <returns>
TRUE     Points are Coplanar
False    Points are not Coplanar
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoFitPlaneToPoints(RMA.OpenNURBS.IArrayOn3dPoint,RMA.OpenNURBS.OnPlane@,RMA.OpenNURBS.OnBoundingBox@)">
            <summary>Fit a plane through an array of points</summary>
            <param name="point_array">[in] - The points through which to fit</param>
            <param name="plane">[out] - The resulting plane</param>
            <param name="box">[out] - The 3d bounding box of the corners of the plane</param>
            <returns>
1   Results were inconclusive, as in colinear points, but some plane was found
0   Sucess
-1  Couldn't find a plane
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoMakePlanarBreps(RMA.OpenNURBS.IOnCurve[],RMA.OpenNURBS.OnBrep[]@)">
            <summary>Creates planar breps of 1 face from array of CRhinoPlanarFaces</summary>
            <param name="input_loops">[in] loops to sort and use as boundaries</param>
            <param name="breps">[out] array of 1 face breps</param>
            <returns>
TRUE     Success
FALSE    Failure
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoMakePlanarBreps(RMA.OpenNURBS.IOnCurve[],RMA.OpenNURBS.OnBrep[]@,RMA.OpenNURBS.Arrayint)">
            <summary>Creates planar breps of 1 face from array of CRhinoPlanarFaces</summary>
            <param name="input_loops">[in] loops to sort and use as boundaries</param>
            <param name="breps">[out] array of 1 face breps</param>
            <param name="used">optional array to hold indeces of the input curves that got used</param>
            <returns>
TRUE     Success
FALSE    Failure
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoRemoveShortSegments(RMA.OpenNURBS.OnCurve)">
            <summary>Remove short segments from the input curve.</summary>
            <param name="curve">[in] curve to check</param>
            <returns>
True    short segments were removed.
False   no changes to curve.
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoRemoveShortSegments(RMA.OpenNURBS.OnCurve,System.Double)">
            <summary>Remove short segments from the input curve.</summary>
            <param name="curve">[in] curve to check</param>
            <param name="tolerance">
[in] if &lt; 0 (default), then an appropriate tolerance is automatically calculated.
if == 0, then ON_ZERO_TOLERANCE is used.
if &gt; 0, then the input value is used.
</param>
            <returns>
True    short segments were removed.
False   no changes to curve.
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoMakeCurveEndsMeet(RMA.OpenNURBS.OnCurve,System.Int32,RMA.OpenNURBS.OnCurve,System.Int32)">
            <summary>
Make adjustments to the ends of one or both input curves
so that they meet at a point
</summary>
            <param name="pCrv0">[in] 1st curve to adjust</param>
            <param name="end0">[in] end of the 1st curve to adjust 0: start, 1: end</param>
            <param name="pCrv1">[in] 2nd curve to adjust</param>
            <param name="end1">[in] end of the 2nd curve to adjust 0: start, 1: end</param>
            <returns>
TRUE     Success
False    Failure
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoMakeCurveClosed(RMA.OpenNURBS.OnCurve)">
            <summary>
If pCrv-&gt;IsClosed(), just return TRUE.  Otherwise, decide if
pCrv can be closed as follows: Linear curves polylinear curves 
with 2 segments, Nurbs with 3 or less control points cannot 
be made closed, Also, if tolerance &gt; 0 and the gap between 
start and end is larger than tolerance, curve cannot be made 
closed.Adjust the curve's endpoint to match its start point.
</summary>
            <param name="pCrv">[in] curve to adjust</param>
            <returns>
TRUE     Success
False    Curve could not be made closed.
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoMakeCurveClosed(RMA.OpenNURBS.OnCurve,System.Double)">
            <summary>
If pCrv-&gt;IsClosed(), just return TRUE.  Otherwise, decide if
pCrv can be closed as follows: Linear curves polylinear curves 
with 2 segments, Nurbs with 3 or less control points cannot 
be made closed, Also, if tolerance &gt; 0 and the gap between 
start and end is larger than tolerance, curve cannot be made 
closed.Adjust the curve's endpoint to match its start point.
</summary>
            <param name="pCrv">[in] curve to adjust</param>
            <param name="tolerance">
[in] if nonzero, and the gap is more than tolerance, curve cannot be made closed.
</param>
            <returns>
TRUE     Success
False    Curve could not be made closed.
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoMergeCurves(RMA.OpenNURBS.IOnCurve[],RMA.OpenNURBS.OnCurve[]@)">
            <summary>Join a bunch of ON_Curves into one or more ON_Curves</summary>
            <param name="input_curves">[in] Array of pointers to ON_Curves to be joined</param>
            <param name="output">[out] Array of pointers to joined results</param>
            <returns>
TRUE     Success
False    Failure
</returns>
            <remarks>
Join as many of the input curves as have matching endpoints
If the input curve is a Nurbs Curve or a line, the endpoints
within the specified tolerance are trued up to meet exactly.
All of the input curves are copied and the caller must free the
results.  When curves are loined they are made into polycurves.
Memory for the brep is alliocated and becomes the responsibility
of the caller.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoMergeCurves(RMA.OpenNURBS.IOnCurve[],RMA.OpenNURBS.OnCurve[]@,System.Double)">
            <summary>Join a bunch of ON_Curves into one or more ON_Curves</summary>
            <param name="input_curves">[in] Array of pointers to ON_Curves to be joined</param>
            <param name="output">[out] Array of pointers to joined results</param>
            <param name="join_tol">
[in] max distance between endpoints to be joined.
If join_tol &lt; ON_EPSILON, use CRhinoDoc::AbsoluteTolerance()
</param>
            <returns>
TRUE     Success
False    Failure
</returns>
            <remarks>
Join as many of the input curves as have matching endpoints
If the input curve is a Nurbs Curve or a line, the endpoints
within the specified tolerance are trued up to meet exactly.
All of the input curves are copied and the caller must free the
results.  When curves are loined they are made into polycurves.
Memory for the brep is alliocated and becomes the responsibility
of the caller.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoMergeCurves(RMA.OpenNURBS.IOnCurve[],RMA.OpenNURBS.OnCurve[]@,System.Double,System.Boolean)">
            <summary>Join a bunch of ON_Curves into one or more ON_Curves</summary>
            <param name="input_curves">[in] Array of pointers to ON_Curves to be joined</param>
            <param name="output">[out] Array of pointers to joined results</param>
            <param name="join_tol">
[in] max distance between endpoints to be joined.
If join_tol &lt; ON_EPSILON, use CRhinoDoc::AbsoluteTolerance()
</param>
            <param name="bPreserveDir">[in] if TRUE, don't reverse input curves to get them to join</param>
            <returns>
TRUE     Success
False    Failure
</returns>
            <remarks>
Join as many of the input curves as have matching endpoints
If the input curve is a Nurbs Curve or a line, the endpoints
within the specified tolerance are trued up to meet exactly.
All of the input curves are copied and the caller must free the
results.  When curves are loined they are made into polycurves.
Memory for the brep is alliocated and becomes the responsibility
of the caller.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoMergeCurves(RMA.OpenNURBS.IOnCurve[],RMA.OpenNURBS.OnCurve[]@,System.Double,System.Boolean,RMA.OpenNURBS.Arrayint)">
            <summary>Join a bunch of ON_Curves into one or more ON_Curves</summary>
            <param name="input_curves">[in] Array of pointers to ON_Curves to be joined</param>
            <param name="output">[out] Array of pointers to joined results</param>
            <param name="join_tol">
[in] max distance between endpoints to be joined.
If join_tol &lt; ON_EPSILON, use CRhinoDoc::AbsoluteTolerance()
</param>
            <param name="bPreserveDir">[in] if TRUE, don't reverse input curves to get them to join</param>
            <param name="key">[out] if non-null, curves[i] is part of output[key[i]]</param>
            <returns>
TRUE     Success
False    Failure
</returns>
            <remarks>
Join as many of the input curves as have matching endpoints
If the input curve is a Nurbs Curve or a line, the endpoints
within the specified tolerance are trued up to meet exactly.
All of the input curves are copied and the caller must free the
results.  When curves are loined they are made into polycurves.
Memory for the brep is alliocated and becomes the responsibility
of the caller.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoJoinBreps(RMA.OpenNURBS.OnBrep@,RMA.OpenNURBS.IOnBrep,System.Double)">
            <summary>
If any edges of B overlap edges of B1, merge a copy of B1 into B 
joining all edges that overlap within tolerance
</summary>
            <param name="B">[in] Base Brep to which faces will be added.</param>
            <param name="B1">[in] Brep to be added to B</param>
            <param name="tolerance">[in] 3d distance tolerance for detecting overlapping edges</param>
            <returns>true if any edges were joined.</returns>
            <remarks>
if no edges overlap, B is unchanged.
B1 is copied if it is merged with B, ans B1 is always unchanged
Use this to join a list of breps in a series. 

When joining multiple breps in series, bCompact should be set to false.
If bCompact is false, the caller should do something like this afterwards:
B.Compact();
B.SetEdgeTolerances(TRUE);
B.SetVertexTolerances(TRUE);
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoJoinBreps(RMA.OpenNURBS.OnBrep@,RMA.OpenNURBS.IOnBrep,System.Double,System.Boolean)">
            <summary>
If any edges of B overlap edges of B1, merge a copy of B1 into B 
joining all edges that overlap within tolerance
</summary>
            <param name="B">[in] Base Brep to which faces will be added.</param>
            <param name="B1">[in] Brep to be added to B</param>
            <param name="tolerance">[in] 3d distance tolerance for detecting overlapping edges</param>
            <param name="bCompact">[in] if true, set brep flags and tolerances, remove unused faces and edges</param>
            <returns>true if any edges were joined.</returns>
            <remarks>
if no edges overlap, B is unchanged.
B1 is copied if it is merged with B, ans B1 is always unchanged
Use this to join a list of breps in a series. 

When joining multiple breps in series, bCompact should be set to false.
If bCompact is false, the caller should do something like this afterwards:
B.Compact();
B.SetEdgeTolerances(TRUE);
B.SetVertexTolerances(TRUE);
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoJoinBreps(RMA.OpenNURBS.OnBrep[],RMA.OpenNURBS.OnBrep[]@,System.Double)">
            <summary>
Joins the breps in the input array at any overlapping edges to form
as few as possible resulting breps.
There may be more than one brep in the result array
</summary>
            <param name="input_breps">[in] Array of breps to join</param>
            <param name="output_breps">[in] Empty array to return results of the join</param>
            <param name="tolerance">[in] 3d distance tolerance for detecting overlapping edges</param>
            <returns>true if any edges were joined.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoCreateEdgeSrf(RMA.OpenNURBS.IOnNurbsCurve[])">
            <summary>Creates a coons patch from 2, 3, or 4 curves</summary>
            <param name="curves">[in] Array of input curves</param>
            <returns>The resulting surface or NULL</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoCreateSurfaceFromCorners(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@)">
            <summary>
Make a CRhinoNurbsSurface from 4 corner points
a, b, c, d -  [in] 3 or 4 corner points for the face
</summary>
            <returns>The resulting surface or NULL</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoCreateSurfaceFromCorners(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@,System.Double)">
            <summary>
Make a CRhinoNurbsSurface from 4 corner points
a, b, c, d -  [in] 3 or 4 corner points for the face
</summary>
            <param name="dtol">[in] min edge length without collapsing to a singularity</param>
            <returns>The resulting surface or NULL</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoCreate1FaceBrepFromPoints(RMA.OpenNURBS.IOn3dPoint[])">
            <summary>Make a CRhinoBrep with 1 face from 3 or 4 points</summary>
            <param name="corners">[in] 3 or 4 corner points for the face</param>
            <returns>The resulting surface or NULL</returns>
            <remarks>
Calls RhinoCreateSurfaceFromCorners() to make the surface and trims it to a triangle for 3-corners
Makes a singular surface for 4 corneers with 2 coincident
Memory for the brep is alliocated and becomes the responsibility of the caller.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoCreate1FaceBrepFromPoints(RMA.OpenNURBS.IOn3dPoint[],System.Double)">
            <summary>Make a CRhinoBrep with 1 face from 3 or 4 points</summary>
            <param name="corners">[in] 3 or 4 corner points for the face</param>
            <param name="tolerance">[in] min edge length without colapsing to a singularity</param>
            <returns>The resulting surface or NULL</returns>
            <remarks>
Calls RhinoCreateSurfaceFromCorners() to make the surface and trims it to a triangle for 3-corners
Makes a singular surface for 4 corneers with 2 coincident
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoBackupFile(System.String,System.String@)">
            <summary>Rename an existing file for temporary backup purposes.</summary>
            <param name="filename">[in] name of existing file</param>
            <param name="backup_filename">[out] new file name created</param>
            <returns>
TRUE if candidate_filename is successfully renamed unused_filename.
FALSE if filename did not exist or could not be renamed.  If FALSE
is returned, then unused_filename is not changed.
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoIsValidName(System.String)">
            <summary>
Tests a string to see if it can be used as a name for an object, layer, material, group, font, etc.
</summary>
            <param name="name">[in] name to test.</param>
            <remarks>
Valid names do not have leading or trailing white space,
do not contain DEL characters (127), and do not contain
characters with values &lt; 32.
</remarks>
            <returns>
TRUE if the string is valid name for an object, layer, material, group, font, etc.
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoFormatNumber(System.Double,RMA.OpenNURBS.IOn3dmUnitsAndTolerances,RMA.OpenNURBS.IOn3dmUnitsAndTolerances,System.String@,System.Boolean)">
            <summary>Format a number for printing.</summary>
            <param name="x">[in]</param>
            <param name="string">[in/out] string representation of x is appended to this string</param>
            <param name="input_units">[in]</param>
            <param name="output_units">
[in] If output_units.m_unit_system != input_units.m_unit_system, then x is scaled.
If output_units.m_display_mode is decimal or fractional and 
output_units.m_unit_system is not ON::no_unit_system, 
then a localized unit system name is appended to string.
</param>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoFormatNumber(System.Double,RMA.OpenNURBS.IOn3dmUnitsAndTolerances,System.String@,System.Boolean)">
            <summary>Format a number for printing.</summary>
            <param name="x">[in]</param>
            <param name="string">[in/out] string representation of x is appended to this string</param>
            <param name="units">
[in] x is assumed to be in units.m_unit_system. The settings on units are
used to control the display format and decimal precision.
</param>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoFormatNumber(System.Double,System.String@)">
            <summary>Format a number for printing.</summary>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoFormatColor(RMA.OpenNURBS.IOnColor,System.String@)">
            <summary>Format a color for printing.</summary>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoFormatPoint(RMA.OpenNURBS.IOn3dPoint,System.String@)">
            <summary>Format a point for printing.</summary>
            <param name="string">
[in/out] string representation of point is appended to this string
</param>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoFormatPoint(RMA.OpenNURBS.IOn3dPoint,System.String@,System.String)">
            <summary>Format a point for printing.</summary>
            <param name="string">
[in/out] string representation of point is appended to this string
</param>
            <param name="number_format">
[in] (default=NULL) if not NULL, this string overrides the automatic format used by Rhino.
</param>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoParsePoint(System.String,RMA.OpenNURBS.On3dPoint@)">
            <summary>Parse a string to see if it is a point.</summary>
            <param name="string">[in] string to parse</param>
            <param name="point_value">[out] value of point</param>
            <returns>
0:   string does not parse to a point
&gt;0:   number of characters parsed
</returns>
            <remarks>
RhinoParsePoint will parse stings of the form
_x,y,z~ where "x", "y", and "z" are numbers,
"_" can be zero or more white space characters,
and "~" is any non-digit value.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoParseColor(System.String,RMA.OpenNURBS.OnColor@)">
            <summary>Parse a string to see if it is an RGB color.</summary>
            <param name="string">[in] string to parse</param>
            <param name="color_value">[out] value of number</param>
            <returns>
0:   string does not parse to a color
&gt;0:   number of characters parsed
</returns>
            <remarks>
An RGB string can have two formats.

r,g,b where r, g, and b are integers in the range 0 to 255
and no spaces are around the commas.

A name from the color table RhinoApp().AppSettings().NamedColorList().

Since the formats of r,g,b colors and points are the same,
care must be taken to avoid confusing points and colors.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoFormatDegreesLongitude(System.Double,System.String@,System.Int32)">
            <summary>Convert a double to a longitude string.</summary>
            <param name="longitude_decimal_degrees">[in] logitude in degrees</param>
            <param name="str">
[out] Longitude in deg min secE/W format. If the decimal latitude
is not exactly dms, then the decimal format is appended.
</param>
            <param name="format">
0 = degrees minutes seconds
1 = decimal degrees
2 = degrees minutes seconds (decimal degreees)
</param>
            <returns>
Fractional seconds. If this number is not zero, then the number of fractional seconds in the
decimal angle.  This value can be used to make UI decisions about what format to use.
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoFormatDegreesLatitude(System.Double,System.String@,System.Int32)">
            <summary>Convert a double to a latitude string.</summary>
            <param name="latitude_decimal_degrees">[in] latitude in degrees</param>
            <param name="str">
[out] latitude in deg min secN/S format. If the decimal latitude is not exactly dms,
then the decimal format is appended.
</param>
            <param name="format">
0 = degrees minutes seconds
1 = decimal degrees
</param>
            <returns>
Fractional seconds. If this number is not zero, then the number of fractional seconds in the
decimal angle.  This value can be used to make UI decisions about what format to use.
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoFormatDegreesInDMS(System.Double,System.String@,System.Boolean)">
            <summary>Parse a string to see if it is an angle.</summary>
            <param name="angle_decimal_degrees">[in] angle in degrees</param>
            <param name="str">
[out] angle in deg min sec format. When needed, the seconds have up
to 4 decimal points. This provides a linear precision of better than
1 cm on the surface of the earth.
</param>
            <param name="bWithSpaces">
[in] If true, there will be a space between the degrees, minutes,
and seconds. If false, there will not be a space.
</param>
            <returns>
Fractional seconds. If this number is not zero, then the number of fractional seconds in the
decimal angle. This value can be used to make UI decisions about what format to use.
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoDegreesSymbol">
            <summary>0x0B0 - the ascii and unicode degrees symbol</summary>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoParseAngleDegrees(System.String,System.Double@)">
            <summary>Parse a string to see if it is an angle.</summary>
            <param name="str">[in] string to parse</param>
            <param name="angle_degrees_value">[out] value of angle in degrees</param>
            <remarks>A "plain" number is assumed to be in degrees.</remarks>
            <returns>
0:   string does not parse to an angle
&gt;0:   number of characters parsed
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoParseAngle(System.String,System.Double@)">
            <summary>Parse a string to see if it is an angle.</summary>
            <param name="str">[in] string to parse</param>
            <param name="angle_radians_value">[out] value of angle in radians</param>
            <remarks>A "plain" number is assumed to be in degrees.</remarks>
            <returns>
0:   string does not parse to an angle
&gt;0:   number of characters parsed
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoSelectMultipleLayersDialog(System.Windows.Forms.IWin32Window,System.String,RMA.OpenNURBS.Arrayint@,System.Boolean,System.Boolean)">
            <summary>Display Rhino's multiple layer selection dialog.</summary>
            <param name="hwndParent">[in] Window handle of dialog's parent window.</param>
            <param name="lpsPrompt">[in] The prompt, or title, of the dialog window.</param>
            <param name="layer_indices">
[in/out] Default layers for the dialog, and will receive new layers if function returns TRUE.
</param>
            <param name="bDisplayDialog">
[in] If TRUE, a dialog box is displayed. Otherwise, a command line version is displayed.
</param>
            <param name="bEnableNewLayerButton">[in] Enable the "New" layer button.</param>
            <returns>
TRUE - Dialog or command completed successfully.
FALSE - Dialog, or command was cancelled.
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoSelectLayerDialog(System.Windows.Forms.IWin32Window,System.String,System.Int32@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Display Rhino's single layer selection dialog.</summary>
            <param name="hwndParent">[in] Window handle of dialog's parent window.</param>
            <param name="lpsPrompt">[in] The prompt, or title, of the dialog window.</param>
            <param name="layer_index">
[in/out] Default layer for the dialog, and will receive new layer if function returns TRUE.
</param>
            <param name="bDisplayDialog">
[in] If TRUE, a dialog box is displayed. Otherwise, a command line version is displayed.
</param>
            <param name="bEnableNewLayerButton">[in] Enable the "New" layer button.</param>
            <param name="bEnableSetLayerCurrentButton">[in] Enable the "Set layer current" checkbox.</param>
            <returns>
TRUE - Dialog or command completed successfully.
FALSE - Dialog, or command was cancelled.
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoSelectLayerDialog(System.Windows.Forms.IWin32Window,System.String,System.Int32@,System.Boolean,System.Boolean,System.Boolean,System.Boolean@)">
            <summary>Display Rhino's single layer selection dialog.</summary>
            <param name="hwndParent">[in] Window handle of dialog's parent window.</param>
            <param name="lpsPrompt">[in] The prompt, or title, of the dialog window.</param>
            <param name="layer_index">
[in/out] Default layer for the dialog, and will receive new layer if function returns TRUE.
</param>
            <param name="bDisplayDialog">
[in] If TRUE, a dialog box is displayed. Otherwise, a command line version is displayed.
</param>
            <param name="bEnableNewLayerButton">[in] Enable the "New" layer button.</param>
            <param name="bEnableSetLayerCurrentButton">[in] Enable the "Set layer current" checkbox.</param>
            <param name="pbSetLayerCurrentButtonValue">
[in/out] Default value for Set layer current checkbox, and will receive dialog value if function return TRUE.
</param>
            <returns>
TRUE - Dialog or command completed successfully.
FALSE - Dialog, or command was cancelled.
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoPrintWidthDialog(System.Windows.Forms.IWin32Window,System.Double@)">
            <summary>Display Rhino's print width selection dialog.</summary>
            <param name="hwndParent">[in] Window handle of dialog's parent window.</param>
            <param name="print_width">
[in/out] Default print width for dialog, and will receive new print width if function returns TRUE.
</param>
            <returns>
TRUE - Dialog completed successfully.
FALSE - Dialog was cancelled.
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoLinetypeDialog(System.Windows.Forms.IWin32Window,System.Int32@)">
            <summary>Display Rhino's linetype selection dialog.</summary>
            <param name="hwndParent">[in] Window handle of dialog's parent window.</param>
            <param name="linetype_index">
[in/out] Default linetype index for dialog, and will receive new linetype index if function returns TRUE.
</param>
            <returns>
TRUE - Dialog completed successfully.
FALSE - Dialog was cancelled.
</returns>
            <remarks>
If the user selects the "Continuous" linetype, then linetype_index will
equal -1. If bDisplayByLayer = true and the user selects the "ByLayer"
linetype, then linetype_index will equal -2.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoLinetypeDialog(System.Windows.Forms.IWin32Window,System.Int32@,System.Boolean)">
            <summary>Display Rhino's linetype selection dialog.</summary>
            <param name="hwndParent">[in] Window handle of dialog's parent window.</param>
            <param name="linetype_index">
[in/out] Default linetype index for dialog, and will receive new linetype index if function returns TRUE.
</param>
            <param name="bDisplayByLayer">[in] Displays the "ByLayer" linetype in the list</param>
            <returns>
TRUE - Dialog completed successfully.
FALSE - Dialog was cancelled.
</returns>
            <remarks>
If the user selects the "Continuous" linetype, then linetype_index will
equal -1. If bDisplayByLayer = true and the user selects the "ByLayer"
linetype, then linetype_index will equal -2.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoColorDialog(System.Windows.Forms.IWin32Window,RMA.OpenNURBS.OnColor@)">
            <summary>Display Rhino's color selection dialog.</summary>
            <param name="hwndParent">[in] Window handle of dialog's parent window.</param>
            <param name="color">
[in/out] Default color for dialog, and will receive new color if function returns TRUE.
</param>
            <returns>
TRUE - color changed
FALSE - color not changed or dialog cancelled
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoColorDialog(System.Windows.Forms.IWin32Window,RMA.OpenNURBS.OnColor@,System.Boolean)">
            <summary>Display Rhino's color selection dialog.</summary>
            <param name="hwndParent">[in] Window handle of dialog's parent window.</param>
            <param name="color">
[in/out] Default color for dialog, and will receive new color if function returns TRUE.
</param>
            <param name="include_button_colors">
[in] Display button face and text options at top of named color list.
</param>
            <returns>
TRUE - color changed
FALSE - color not changed or dialog cancelled
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoColorDialog(System.Windows.Forms.IWin32Window,RMA.OpenNURBS.OnColor@,System.Boolean,System.String)">
            <summary>Display Rhino's color selection dialog.</summary>
            <param name="hwndParent">[in] Window handle of dialog's parent window.</param>
            <param name="color">
[in/out] Default color for dialog, and will receive new color if function returns TRUE.
</param>
            <param name="include_button_colors">
[in] Display button face and text options at top of named color list.
</param>
            <param name="dialog_title">[in] The title of the dialog</param>
            <returns>
TRUE - color changed
FALSE - color not changed or dialog cancelled
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoRenderDrawWiresInDIB(RMA.Rhino.MRhinoDoc,RMA.OpenNURBS.IOn3dmView,System.Drawing.Size,RMA.UI.MRhinoUiDib@,System.Boolean)">
            <summary>
Same as calling CRhinoSdkRenderViewWnd::GetWireframeCompositeDIBs( alpha, wires) then
CRhinoSdkRenderViewWnd::DrawWiresInDIB( alpha, wires, my_dib);
</summary>
            <param name="doc">[in] - Document to iterate</param>
            <param name="view">[in] - view to draw</param>
            <param name="size">[in] - size of image</param>
            <param name="final_dib">[out] - alpha_dib and wires_dib will be created, transparently blit to this DIB. and destroyed.</param>
            <param name="bGetRenderSettingsFromDoc">
[in] - Tells compositor to setup render engine using the settings from the Document (true) or Display (false) settings.
</param>
            <returns>Success == true, failure == false.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoRenderDrawWiresInDIB(RMA.UI.MRhinoUiDib,RMA.UI.MRhinoUiDib,RMA.UI.MRhinoUiDib@)">
            <summary>Composite bitmaps created in CRhinoSdkRenderViewWnd::GetWireframeCompositeDIBs with final_dib.</summary>
            <param name="alpha_dib">[in] - Alpha map for all wireframe and curves.</param>
            <param name="wires_dib">[in] - Rendered wireframes and curves in their display colors.</param>
            <param name="final_dib">[out] - alpha_dib and wires_dib will be transparently blit to this DIB.</param>
            <returns>Success == true, failure == false.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoMeshBooleanSplit(RMA.OpenNURBS.IOnMesh[],RMA.OpenNURBS.IOnMesh[],System.Double,System.Double,System.Boolean@,RMA.OpenNURBS.OnMesh[]@)">
            <summary>
RhinoMeshBooleanSplit splits the meshes in MeshesToSplit with MeshSplitters.  That is, each mesh in MeshesToSplit is 
split with every mesh in MeshSplitters and for every subsequent splitter mesh all of the previous results ar split.  
If the attribute arrays are non null then the attributes for MeshesToSplit will be used.
</summary>
            <param name="MeshesToSplit">[In] Meshes to be split</param>
            <param name="MeshSplitters">[In] Meshes to split with</param>
            <param name="Intersection_Tolerance">[In] General tolerance to be used in mesh-mesh intersection</param>
            <param name="Overlap_Tolerance">[In] Tolerance used to determine overlaps in mesh-mesh intersection</param>
            <param name="something_happened">[Out] Set to true if something actually happened, independent of function return</param>
            <param name="OutMeshes">[Out] Result of the split of the input meshes</param>
            <returns>
True or false based on whether the function was able to complete successfully.  It does not indicate whether the function actually 
unioned the input meshes.  The argument, something_happened, is used for that purpose.
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoMeshBooleanIntersection(RMA.OpenNURBS.IOnMesh[],RMA.OpenNURBS.IOnMesh[],System.Double,System.Double,System.Boolean@,RMA.OpenNURBS.OnMesh[]@)">
            <summary>
RhinoMeshBooleanIntersection intersects the meshes in InMeshes0 with InMeshes1.  Meshes from InMeshes0 and InMeshes1 are 
unioned together first and the results are intersected.  If the attribute arrays are non null then the attributes for 
InMeshes0 will be used.
</summary>
            <param name="InMeshes0">[In] First input mesh set</param>
            <param name="InMeshes1">[In] Second input mesh set</param>
            <param name="Intersection_Tolerance">[In] General tolerance to be used in mesh-mesh intersection</param>
            <param name="Overlap_Tolerance">[In] Tolerance used to determine overlaps in mesh-mesh intersection</param>
            <param name="something_happened">[Out] Set to true if something actually happened, independent of function return</param>
            <param name="OutMeshes">[Out] Result of the intersection of the input meshes</param>
            <returns>
True or false based on whether the function was able to complete successfully.  It does not indicate whether the function actually 
unioned the input meshes.  The argument, something_happened, is used for that purpose. 
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoMeshBooleanDifference(RMA.OpenNURBS.IOnMesh[],RMA.OpenNURBS.IOnMesh[],System.Double,System.Double,System.Boolean@,RMA.OpenNURBS.OnMesh[]@)">
            <summary>
RhinoMeshBooleanDifference subtracts the meshes in InMeshes1 from InMeshes0. Meshes from InMeshes1 are unioned
together first and the result is differenced with each mesh in InMeshes0.  If the attribute arrays are non null
then the attributes for InMeshes0 will be used.
</summary>
            <param name="InMeshes0">[In] Meshes to be from which to have InMeshes1 subtracted</param>
            <param name="InMeshes1">[In] Meshes to subtract from InMeshes0</param>
            <param name="Intersection_Tolerance">[In]  General tolerance to be used in mesh-mesh intersection</param>
            <param name="Overlap_Tolerance">[In]  Tolerance used to determine overlaps in mesh-mesh intersection</param>
            <param name="something_happened">[Out] Set to true if something actually happened, independent of function return</param>
            <param name="OutMeshes">[Out] Result of the difference of the input meshes</param>
            <returns>
True or false based on whether the function was able to complete successfully.  It does not indicate whether the function actually 
unioned the input meshes.  The argument, something_happened, is used for that purpose.
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoMeshBooleanUnion(RMA.OpenNURBS.IOnMesh[],System.Double,System.Double,System.Boolean@,RMA.OpenNURBS.OnMesh[]@,RMA.OpenNURBS.IOn3dmObjectAttributes[],System.Int32[]@)">
            <summary>
RhinoMeshBooleanUnion Finds the union of the meshes in InMeshes. If the attribute arrays
are non null then the first attribute of each union will be used.
</summary>
            <param name="InMeshes">[In]  Meshes to be unioned</param>
            <param name="Intersection_Tolerance">[In]  General tolerance to be used in mesh-mesh intersection</param>
            <param name="Overlap_Tolerance">[In]  Tolerance used to determine overlaps in mesh-mesh intersection</param>
            <param name="something_happened">[Out] Set to true if something actually happened, independent of function return</param>
            <param name="OutMeshes">[Out] Result of the union of the input meshes</param>
            <param name="InputAttributeArray">[In] Array of attributes. Must have count equal to InMeshes to be used.</param>
            <param name="OutputAttributeArray">[Out] Array of indices in InputAttributesArray for attributes of OutMeshes based on Input Attribtues</param>
            <returns>
True or false based on whether the function was able to complete successfully. It does not indicate
whether the function actually unioned the input meshes. The argument, something_happened, is used for that purpose. 
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoMeshBooleanUnion(RMA.OpenNURBS.IOnMesh[],System.Double,System.Double,System.Boolean@,RMA.OpenNURBS.OnMesh[]@)">
            <summary>
RhinoMeshBooleanUnion Finds the union of the meshes in InMeshes. If the attribute arrays
are non null then the first attribute of each union will be used.
</summary>
            <param name="InMeshes">[In]  Meshes to be unioned</param>
            <param name="Intersection_Tolerance">[In]  General tolerance to be used in mesh-mesh intersection</param>
            <param name="Overlap_Tolerance">[In]  Tolerance used to determine overlaps in mesh-mesh intersection</param>
            <param name="something_happened">[Out] Set to true if something actually happened, independent of function return</param>
            <param name="OutMeshes">[Out] Result of the union of the input meshes</param>
            <returns>
True or false based on whether the function was able to complete successfully. It does not indicate
whether the function actually unioned the input meshes. The argument, something_happened, is used for that purpose. 
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoTriangulate3dPolygon(RMA.OpenNURBS.IOn3dPointArray,System.Int32[]@)">
            <summary>
Triangulate a 3D simple closed polygon that projects onto a plane.
The polygon must project to a plane and the projected polygon must be a simple
closed curve.  Do NOT duplicate the start/end point; i.e., a triangle will have
a point count of 3 and P will specify 3 distinct non-collinear points.
</summary>
            <param name="points">[in] array of points to triangulate</param>
            <param name="triangle">[out] an array of (point_count-2)*3 integers</param>
            <returns>
0 if successful
&lt;0 on failure
</returns>
            <remarks>
The polygon is trianglulated into point_count-2 triangles.  The indices of the
3 points that are the corner of the i-th (0&lt;= i &lt; point_count-2) triangle are
{triangle[i*3], triangle[i*3+1], triangle[i*3+2]}.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoSplitDisjointMesh(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.OnMesh[]@,System.Boolean)">
            <summary>
Splits up the input mesh into its unconnected pieces. If bJustCount is true then it
returns the number of meshes that the input mesh would be split into.
</summary>
            <param name="pMesh">Input mesh.</param>
            <param name="MeshArray">Output array of meshes.</param>
            <param name="bJustCount">Input flag to determine whether to actually split the input mesh</param>
            <returns>Returns number of meshes the input mesh would be split into.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoMeshOffset(System.Double,RMA.OpenNURBS.IOnMesh)">
            <summary>
Makes a new mesh with vertices offset at distance d in the opposite direction
of the existing vertex normals.
</summary>
            <param name="d">Input offset distance.</param>
            <param name="pMesh">Input mesh.</param>
            <returns>a ON_Mesh pointer on success.  Returns null on failure.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoPullCurveToMesh(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnMesh,System.Double)">
            <summary>
Makes a polyline approximation of the input curve and gets the closest point on
the mesh for each point on the mesh. Then it "connects the points" so 
that you have a polyline on the mesh.
</summary>
            <param name="pCrv">Input curve.</param>
            <param name="pMesh">Input mesh.</param>
            <param name="tolerance">Input tolerance.</param>
            <returns>a ON_PolylineCurve on success.  Returns null on failure.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoUnifyMeshNormals(RMA.OpenNURBS.IOnMesh)">
            <summary>Function that attempts to fix inconsistenties in the directions of meshfaces for a mesh.</summary>
            <param name="origmesh">Input.</param>
            <returns>
If bGetCountOnly is false the the return is a pointer to a copy of origmesh with the appropriate faces flipped.  If pNewMesh is not null
then the return is pNewMesh.  If pNewMesh is null and bGetCountOnly is true then the return will be null.
</returns>
            <remarks>
bGetCountOnly and pCount were added so the function could be used to examine the origmesh without the need to create a new modified mesh.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoUnifyMeshNormals(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.OnMesh)">
            <summary>Function that attempts to fix inconsistenties in the directions of meshfaces for a mesh.</summary>
            <param name="origmesh">Input.</param>
            <param name="pNewMesh">Output.  If pNewMesh is not null the the return will be pNewMesh also.</param>
            <returns>
If bGetCountOnly is false the the return is a pointer to a copy of origmesh with the appropriate faces flipped.  If pNewMesh is not null
then the return is pNewMesh.  If pNewMesh is null and bGetCountOnly is true then the return will be null.
</returns>
            <remarks>
bGetCountOnly and pCount were added so the function could be used to examine the origmesh without the need to create a new modified mesh.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoUnifyMeshNormals(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.OnMesh,System.Boolean)">
            <summary>Function that attempts to fix inconsistenties in the directions of meshfaces for a mesh.</summary>
            <param name="origmesh">Input.</param>
            <param name="pNewMesh">Output.  If pNewMesh is not null the the return will be pNewMesh also.</param>
            <param name="bGetCountOnly">Input.  Default is false.  If set to true no mesh is modified and the return is null.</param>
            <returns>
If bGetCountOnly is false the the return is a pointer to a copy of origmesh with the appropriate faces flipped.  If pNewMesh is not null
then the return is pNewMesh.  If pNewMesh is null and bGetCountOnly is true then the return will be null.
</returns>
            <remarks>
bGetCountOnly and pCount were added so the function could be used to examine the origmesh without the need to create a new modified mesh.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoUnifyMeshNormals(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.OnMesh,System.Boolean,System.Int32@)">
            <summary>Function that attempts to fix inconsistenties in the directions of meshfaces for a mesh.</summary>
            <param name="origmesh">Input.</param>
            <param name="pNewMesh">Output.  If pNewMesh is not null the the return will be pNewMesh also.</param>
            <param name="bGetCountOnly">Input.  Default is false.  If set to true no mesh is modified and the return is null.</param>
            <param name="pCount">Output. If bGetCountOnly is true then pCount is the number of faces that would be modified.</param>
            <returns>
If bGetCountOnly is false the the return is a pointer to a copy of origmesh with the appropriate faces flipped.  If pNewMesh is not null
then the return is pNewMesh.  If pNewMesh is null and bGetCountOnly is true then the return will be null.
</returns>
            <remarks>
bGetCountOnly and pCount were added so the function could be used to examine the origmesh without the need to create a new modified mesh.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetPointOnMesh(RMA.Rhino.IRhinoMeshObject,System.String,System.Boolean,RMA.OpenNURBS.OnMESH_POINT@)">
            <summary>Interactively picks a point on a mesh object</summary>
            <param name="mesh_object">[in]  mesh object</param>
            <param name="sPrompt">[in]  command line prompt</param>
            <param name="bAcceptNothing">
[in] allows the user to be able to press enter in order to skip selecting the point.
</param>
            <param name="output_point">[out] the selected ON_MESH_POINT</param>
            <returns>
0 - success
1 - nothing
2 - cancel
3 - failure
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoScriptGetMeshParameters(RMA.OpenNURBS.OnMeshParameters@)">
            <summary>Get mesh parameters in a scriptable manner.</summary>
            <param name="mp">[in/out] in = current settings</param>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetAnalysisMeshes(RMA.Rhino.IRhinoObject[],RMA.Rhino.ArrayMRhinoObjRef@)">
            <summary>Mesh Rhino objects.</summary>
            <param name="objects">[in] objects to get analysis meshes for.</param>
            <param name="analysis_meshes">
[out] 
analysis_meshes[i].Object() = input object
analysis_meshes[i].Mesh() = analysis mesh
</param>
            <returns>Number of meshes appended to analysis_meshes[].</returns>
            <remarks>
References to instance definitions that contain multiple objects will appear multiple
times in the output list.
When the input object is a CRhinoInstanceObject, one or more CRhinoObjRefs may be returned
in the render_meshes[] array. Each atomic object the instance reference ultimately refers
to gets a CRhinoObjRef. The Object() returned by the CRhinoObjRef points to a the atomic
object in the instance definition table. The Geometry() returned by the CRhinoObjRef is a
transformed copy of the mesh. The mesh is correctly located and does not require further
transformations. In this case, CRhinoObjRef::GetInstanceTransformation() will return a
pointer to the top level instance reference (the input CRhinoInstanceObject) and report
the total transformation that was applied to the mesh. In the case of nested instance
references, this transformation may be different from the transformation associated with
the input CRhinoInstanceObject.  
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetAnalysisMeshes(RMA.Rhino.IRhinoObject[],RMA.Rhino.ArrayMRhinoObjRef@,System.Boolean)">
            <summary>Mesh Rhino objects.</summary>
            <param name="objects">[in] objects to get analysis meshes for.</param>
            <param name="analysis_meshes">
[out] 
analysis_meshes[i].Object() = input object
analysis_meshes[i].Mesh() = analysis mesh
</param>
            <param name="bOkToCreate">
[in] if true and the analysis meshes do not exist, then they will be created.
</param>
            <returns>Number of meshes appended to analysis_meshes[].</returns>
            <remarks>
References to instance definitions that contain multiple objects will appear multiple
times in the output list.
When the input object is a CRhinoInstanceObject, one or more CRhinoObjRefs may be returned
in the render_meshes[] array. Each atomic object the instance reference ultimately refers
to gets a CRhinoObjRef. The Object() returned by the CRhinoObjRef points to a the atomic
object in the instance definition table. The Geometry() returned by the CRhinoObjRef is a
transformed copy of the mesh. The mesh is correctly located and does not require further
transformations. In this case, CRhinoObjRef::GetInstanceTransformation() will return a
pointer to the top level instance reference (the input CRhinoInstanceObject) and report
the total transformation that was applied to the mesh. In the case of nested instance
references, this transformation may be different from the transformation associated with
the input CRhinoInstanceObject.  
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetAnalysisMeshes(RMA.Rhino.IRhinoObject[],RMA.Rhino.ArrayMRhinoObjRef@,System.Boolean,System.Boolean)">
            <summary>Mesh Rhino objects.</summary>
            <param name="objects">[in] objects to get analysis meshes for.</param>
            <param name="analysis_meshes">
[out] 
analysis_meshes[i].Object() = input object
analysis_meshes[i].Mesh() = analysis mesh
</param>
            <param name="bOkToCreate">
[in] if true and the analysis meshes do not exist, then they will be created.
</param>
            <param name="bReturnAllObjects">
[in] curves, points, etc., do not have analysis meshes. If you want these objects to
appear in the output list with a NULL mesh, then set this flag to true.
</param>
            <returns>Number of meshes appended to analysis_meshes[].</returns>
            <remarks>
References to instance definitions that contain multiple objects will appear multiple
times in the output list.
When the input object is a CRhinoInstanceObject, one or more CRhinoObjRefs may be returned
in the render_meshes[] array. Each atomic object the instance reference ultimately refers
to gets a CRhinoObjRef. The Object() returned by the CRhinoObjRef points to a the atomic
object in the instance definition table. The Geometry() returned by the CRhinoObjRef is a
transformed copy of the mesh. The mesh is correctly located and does not require further
transformations. In this case, CRhinoObjRef::GetInstanceTransformation() will return a
pointer to the top level instance reference (the input CRhinoInstanceObject) and report
the total transformation that was applied to the mesh. In the case of nested instance
references, this transformation may be different from the transformation associated with
the input CRhinoInstanceObject.  
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetRenderMeshes(RMA.Rhino.IRhinoObject[],RMA.Rhino.ArrayMRhinoObjRef@)">
            <summary>Mesh Rhino objects.</summary>
            <param name="objects">[in] objects to get render meshes for.</param>
            <param name="render_meshes">
[out]
render_meshes[i].Object() = input object
render_meshes[i].Mesh() = render mesh
</param>
            <returns>Number of meshes appended to render_meshes[].</returns>
            <remarks>
References to instance definitions that contain multiple objects will appear multiple
times in the output list.
When the input object is a CRhinoInstanceObject, one or more CRhinoObjRefs may be
returned in the render_meshes[] array. Each atomic object the instance reference ultimately
refers to gets a CRhinoObjRef. The Object() returned by the CRhinoObjRef points to the
atomic object in the instance definition table. The Geometry() returned by the CRhinoObjRef
is a transformed copy of the mesh. The mesh is correctly located and does not require
further transformations. In this case, CRhinoObjRef::GetInstanceTransformation() will
return a pointer to the top level instance reference (the input CRhinoInstanceObject) and
report the total transformation that was applied to the mesh.  
In the case of nested instance references, this transformation may be different from the
transformation associated with the input CRhinoInstanceObject.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetRenderMeshes(RMA.Rhino.IRhinoObject[],RMA.Rhino.ArrayMRhinoObjRef@,System.Boolean)">
            <summary>Mesh Rhino objects.</summary>
            <param name="objects">[in] objects to get render meshes for.</param>
            <param name="render_meshes">
[out]
render_meshes[i].Object() = input object
render_meshes[i].Mesh() = render mesh
</param>
            <param name="bOkToCreate">
[in] if true and the render meshes do not exist, then they will be created.
</param>
            <returns>Number of meshes appended to render_meshes[].</returns>
            <remarks>
References to instance definitions that contain multiple objects will appear multiple
times in the output list.
When the input object is a CRhinoInstanceObject, one or more CRhinoObjRefs may be
returned in the render_meshes[] array. Each atomic object the instance reference ultimately
refers to gets a CRhinoObjRef. The Object() returned by the CRhinoObjRef points to the
atomic object in the instance definition table. The Geometry() returned by the CRhinoObjRef
is a transformed copy of the mesh. The mesh is correctly located and does not require
further transformations. In this case, CRhinoObjRef::GetInstanceTransformation() will
return a pointer to the top level instance reference (the input CRhinoInstanceObject) and
report the total transformation that was applied to the mesh.  
In the case of nested instance references, this transformation may be different from the
transformation associated with the input CRhinoInstanceObject.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetRenderMeshes(RMA.Rhino.IRhinoObject[],RMA.Rhino.ArrayMRhinoObjRef@,System.Boolean,System.Boolean)">
            <summary>Mesh Rhino objects.</summary>
            <param name="objects">[in] objects to get render meshes for.</param>
            <param name="render_meshes">
[out]
render_meshes[i].Object() = input object
render_meshes[i].Mesh() = render mesh
</param>
            <param name="bOkToCreate">
[in] if true and the render meshes do not exist, then they will be created.
</param>
            <param name="bReturnAllObjects">
[in] curves, points, etc., do not have render meshes. If you want these objects to
appear in the output list with a NULL mesh, then set this flag to true.
</param>
            <returns>Number of meshes appended to render_meshes[].</returns>
            <remarks>
References to instance definitions that contain multiple objects will appear multiple
times in the output list.
When the input object is a CRhinoInstanceObject, one or more CRhinoObjRefs may be
returned in the render_meshes[] array. Each atomic object the instance reference ultimately
refers to gets a CRhinoObjRef. The Object() returned by the CRhinoObjRef points to the
atomic object in the instance definition table. The Geometry() returned by the CRhinoObjRef
is a transformed copy of the mesh. The mesh is correctly located and does not require
further transformations. In this case, CRhinoObjRef::GetInstanceTransformation() will
return a pointer to the top level instance reference (the input CRhinoInstanceObject) and
report the total transformation that was applied to the mesh.  
In the case of nested instance references, this transformation may be different from the
transformation associated with the input CRhinoInstanceObject.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoMeshObjects(RMA.Rhino.IRhinoObject[],RMA.OpenNURBS.OnMeshParameters@,RMA.Rhino.MRhinoMeshObjectsUI@,RMA.Rhino.ArrayMRhinoObjectMesh@)">
            <summary>Mesh Rhino objects.</summary>
            <param name="objects">[in] objects to mesh</param>
            <param name="mp">
[in/out] meshing parameters. The meshing parameters may change.
The parameters used to create the meshes are returned.
</param>
            <param name="ui">[in] Defines a custom ui for setting meshing parameters.</param>
            <param name="meshes">
[out] the created meshes are appended to this array.
If an input object is a CRhinoBrepObject, then there will be
one mesh in the output list for that brep.  If an input object
is a CRhinoInstanceObject, then there will be one object in
the list for each piece of instance definition geometry that
can be meshed.
If an input object is not a brep and not an instance reference
that has meshable parts, then nothing is added to the output list.
</param>
            <remarks>
If you want to create meshes using the UI that is found in the
Rhino Mesh command, then you can use the version of
RhinoMeshObjects() that takes an int instead of a CRhinoMeshObjectsUI.
</remarks>
            <returns>
CRhinoCommand::success         meshes created
CRhinoCommand::cancel          user canceled meshing
CRhinoCommand::exit_rhino      user closed Rhino
CRhinoCommand::failure         unable to create meshes
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoMeshObjects(RMA.Rhino.IRhinoObject[],RMA.OpenNURBS.OnMeshParameters@,System.Int32@,RMA.Rhino.ArrayMRhinoObjectMesh@)">
            <summary>Mesh Rhino objects.</summary>
            <param name="objects">[in] objects to mesh</param>
            <param name="mp">
[in/out] meshing parameters. The meshing parameters may change.
The parameters used to create the meshes are returned.
</param>
            <param name="meshes">
[out] the created meshes are appended to this array.
If an input object is a CRhinoBrepObject, then there will be
one mesh in the output list for that brep.  If an input object
is a CRhinoInstanceObject, then there will be one object in
the list for each piece of instance definition geometry that
can be meshed.
If an input object is not a brep and not an instance reference
that has meshable parts, then nothing is added to the output list.
</param>
            <remarks>
If you want to create meshes using the UI that is found in the
Rhino Mesh command, then you can use the version of
RhinoMeshObjects() that takes an int instead of a CRhinoMeshObjectsUI.
</remarks>
            <returns>
CRhinoCommand::success         meshes created
CRhinoCommand::cancel          user canceled meshing
CRhinoCommand::exit_rhino      user closed Rhino
CRhinoCommand::failure         unable to create meshes
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoMeshPlane(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval,System.Int32,System.Int32)">
            <summary>Create a mesh plane.</summary>
            <param name="X">number of faces in X direction</param>
            <param name="Y">number of faces in Y direction</param>
            <returns>
A mesh of the rectangle with corners
plane.PointAt(x_interval[0],x_interval[0]), 
plane.PointAt(x_interval[1],x_interval[1]).
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoMeshPlane(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval,RMA.Rhino.IRhinoMeshDensity)">
            <summary>Create a mesh plane.</summary>
            <returns>
A mesh of the rectangle with corners
plane.PointAt(x_interval[0],x_interval[0]), 
plane.PointAt(x_interval[1],x_interval[1]).
The number of quads is determined by mesh_density
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoSdkLoft(RMA.Rhino.MArgsRhinoLoft,RMA.OpenNURBS.OnBrep[]@)">
            <summary>make a loft brep through curves</summary>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoSdkLoftSurface(RMA.Rhino.MArgsRhinoLoft,RMA.OpenNURBS.OnNurbsSurface[]@)">
            <summary>make a loft surface through curves</summary>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoSelectHatchPattern(System.Boolean)">
            <summary>Ask user to select an existing HatchPattern</summary>
            <param name="interactive">if true, a dialog is used, otherwise, the commandline is used</param>
            <returns>integer index of selected pattern or -1 for none.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoRailRevolve(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnLine,System.Boolean,RMA.OpenNURBS.OnNurbsSurface)">
            <summary>Create a rail revolve surface.</summary>
            <example>
CArgsRhinoRailRevolve args;
CRhinoCommand::result cmdrc = RhinoGetRailRevolveInput(args);
if ( CRhinoCommand::success == cmdrc )
{
 ON_NurbsSurface* srf = RhinoRailRevolve( args.ProfileCurve(), args.RailCurve(),
                                          args.Axis(), args.ScaleHeight(), NULL);
}
</example>
            <returns>
If succcessful, a pointer to the surface is returned.  If the input srf
pointer was not NULL, then the returned point = srf.  If the input srf
point was NULL, then the returned surface was allocated with
ON_NurbsCurve::New().
See Also: RhinoGetRailRevolveInput
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoRevolve(RMA.OpenNURBS.OnCurve,RMA.OpenNURBS.OnLine@,RMA.OpenNURBS.OnInterval@)">
            <summary>
Non-interactive Rotated Surface maker
Make 1 Revolved Surface from 1 profile, axis, and angle domain
</summary>
            <param name="pProfile">[in] - The curve to revolve</param>
            <param name="axis">[in] - Revolve around this line</param>
            <param name="domain">[in] - starting and ending angles for the revolve</param>
            <returns>Pointer to the Revolved surface or NULL on error</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoRevolve(RMA.OpenNURBS.OnCurve,RMA.OpenNURBS.OnLine@,RMA.OpenNURBS.OnInterval@,System.Boolean)">
            <summary>
Non-interactive Rotated Surface maker
Make 1 Revolved Surface from 1 profile, axis, and angle domain
</summary>
            <param name="pProfile">[in] - The curve to revolve</param>
            <param name="axis">[in] - Revolve around this line</param>
            <param name="domain">[in] - starting and ending angles for the revolve</param>
            <returns>Pointer to the Revolved surface or NULL on error</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoRevolve(RMA.OpenNURBS.OnCurve,RMA.OpenNURBS.OnLine@,RMA.OpenNURBS.OnInterval@,System.Boolean,System.Int32)">
            <summary>
Non-interactive Rotated Surface maker
Make 1 Revolved Surface from 1 profile, axis, and angle domain
</summary>
            <param name="pProfile">[in] - The curve to revolve</param>
            <param name="axis">[in] - Revolve around this line</param>
            <param name="domain">[in] - starting and ending angles for the revolve</param>
            <returns>Pointer to the Revolved surface or NULL on error</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetBox(RMA.Rhino.MArgsRhinoGetBox,RMA.OpenNURBS.On3dPoint[]@)">
            <summary>Get a 3d box</summary>
            <param name="args">[in] controls how the box is picked, prompts, etc.</param>
            <param name="box_corners">
[out] corners of the box.

    7______________6
    |\             |
    | \            | 
    |  \ _____________
    |   4          |   5
    |   |          |   |
    |   |          |   |
    3---|----------2   |
    \   |          \   |
     \  |           \  |
      \ |            \ |
       \0_____________\1
</param>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoPlaneThroughBox(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.IOnBoundingBox)">
            <summary>Extend a plane so that it goes through a bounding box</summary>
            <param name="plane_in">plane to extend through box</param>
            <param name="bbox">box through which to extend</param>
            <returns>a plane that goes through the box. NULL for error</returns>
            <remarks>Projects the corners of the box to the plane and sets the domain to include the projections</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoPlaneThroughBox(RMA.OpenNURBS.IOnLine,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOnBoundingBox)">
            <summary>Make a plane that includes a line and a vector and goes through a bounding box</summary>
            <param name="line_in">line in the plane</param>
            <param name="vector_in">vector in the plane</param>
            <param name="bbox">box to cut through</param>
            <returns>a plane that goes through the box; NULL for error</returns>
            <remarks>Makes a plane from the line and vector and projects the corners of the box to it</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoCutPlane(RMA.OpenNURBS.IOnLine,RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.IOnBoundingBox,RMA.OpenNURBS.On3dPoint[]@)">
            <summary>
Gets a bounded plane that cuts through a boundingbox
The output rectangle is perpendicular to the input plane and parallel to the input line
</summary>
            <param name="line_in">line included in the output redtangle</param>
            <param name="plane">plane perpendicular to the output rectangle</param>
            <param name="bbox">bounding box through which to cut</param>
            <param name="rect_out">four 3d corners of the output rectangle</param>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGet2dRectangle(System.Drawing.Rectangle@)">
            <summary>Get a rectangle in view window coordinates.</summary>
            <param name="rect">
[out] rectangle
0 &lt;= left &lt; right &lt;= view width
0 &lt;= top &lt; bottom &lt;= view height
</param>
            <returns>Pointer to the view the rectangle is in or NULL if the user canceled.</returns>
            <remarks>
The user can either click_down-drag-release or click_down-release-drag-click_down to draw the rectangle.
See Also: CRhinoGetPoint::Get2dRectangle
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGet2dRectangle(System.Drawing.Rectangle@,System.Int32)">
            <summary>Get a rectangle in view window coordinates.</summary>
            <param name="rect">
[out] rectangle
0 &lt;= left &lt; right &lt;= view width
0 &lt;= top &lt; bottom &lt;= view height
</param>
            <param name="pen_style">
[in] (default = PS_SOLID) style of pen to use for drawing the dynamic 2d rectangle.
PS_SOLID      = 0
PS_DASH       = 1
PS_DOT        = 2
PS_DASHDOT    = 3
PS_DASHDOTDOT = 4
</param>
            <returns>Pointer to the view the rectangle is in or NULL if the user canceled.</returns>
            <remarks>
The user can either click_down-drag-release or click_down-release-drag-click_down to draw the rectangle.
See Also: CRhinoGetPoint::Get2dRectangle
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetRectangle(RMA.Rhino.MArgsRhinoGetPlane@,RMA.OpenNURBS.On3dPoint[]@)">
            <summary>Get a 3d rectangle.</summary>
            <param name="args">[in]</param>
            <param name="rectangle_corners">[out] corners of rectangle in counter clockwise order</param>
            <returns>
CRhinoCommand::success if successful.
See Also: RhinoGetScreenRectangle
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetPlane(RMA.Rhino.MArgsRhinoGetPlane@,RMA.OpenNURBS.OnPlane@)">
            <summary>Gets an oriented infinite plane</summary>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetParaboloid(RMA.Rhino.MArgsRhinoGetParabola@,RMA.OpenNURBS.OnBrep@)">
            <summary>UI tool to get a paraboloid surface or solid.</summary>
            <param name="args">[in/out] used to specify ui elements and return user choices, focus, and vertex.</param>
            <param name="paraboloid_out">[out] paraboloid returned here</param>
            <returns>CRhinoCommand::success if successful.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetParabola(RMA.Rhino.MArgsRhinoGetParabola@,RMA.OpenNURBS.OnBezierCurve@)">
            <summary>UI tool to get a parabola curve.</summary>
            <param name="args">[in/out] used to specify ui elements and return user choices, focus, and vertex.</param>
            <param name="parabola_out">[out] parabola returned here</param>
            <returns>CRhinoCommand::success if successful.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetPolyline(RMA.Rhino.MArgsRhinoGetPolyline@,RMA.OpenNURBS.OnPolyline@)">
            <summary>Interactively get a polyline.</summary>
            <param name="args">[in/out] controls prompts and options available when getting the polyline.</param>
            <param name="output_polyline">[out] polyline returned here</param>
            <returns>
CRhinoCommand::success - successfully go polyline
CRhinoCommand::cancel - user canceled
CRhinoCommand::failure - unable to get valid polyline
</returns>
            <remarks>The Rhino "Polyline" command uses RhinoGetPolyline.</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetLine(RMA.Rhino.MArgsRhinoGetLine@,RMA.OpenNURBS.OnLine@)">
            <summary>
Use RhinoGetLine() to interactively get an ON_Line.  The Rhino "Line"
command uses RhinoGetLine.  Use the CArgsRhinoGetLine argument to
specify input options like prompts, fixed starting points, and so on.
See CArgsRhinoGetLine for complete details.  The line is returned as
the second argument.
</summary>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetCCHTcone(RMA.Rhino.MArgsRhinoGetTube@,RMA.OpenNURBS.OnBrep@)">
            <summary>UI tool to get a tcone.  Old style.  Circle, circle, height.</summary>
            <param name="args">[in] controls get point prompts, options, etc.</param>
            <param name="tcone">[out] tcone returned here</param>
            <returns>CRhinoCommand::success if successful.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetTcone(RMA.Rhino.MArgsRhinoGetTube@,RMA.OpenNURBS.OnBrep@)">
            <summary>UI tool to get a tcone.</summary>
            <param name="args">[in] controls get point prompts, options, etc.</param>
            <param name="tcone">[out] tcone returned here</param>
            <returns>CRhinoCommand::success if successful.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetTube(RMA.Rhino.MArgsRhinoGetTube@,RMA.OpenNURBS.OnBrep@)">
            <summary>UI tool to get a tube.</summary>
            <param name="args">[in] controls get point prompts, options, etc.</param>
            <param name="tube">[out] tube returned here</param>
            <returns>CRhinoCommand::success if successful.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetCylinder(RMA.Rhino.MArgsRhinoGetCylinder,RMA.OpenNURBS.OnCylinder@)">
            <summary>UI tool to get a cylinder.</summary>
            <param name="args">[in] controls get point prompts, options, etc.</param>
            <param name="cylinder">[out] cylinder returned here</param>
            <returns>CRhinoCommand::success if successful.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetInterpolatedCurve(RMA.Rhino.MArgsRhinoGetCurve@,RMA.OpenNURBS.OnNurbsCurve@)">
            <summary>Interactively get an interpolated curve.</summary>
            <param name="args">[in/out] controls prompts and options available when getting the curve.</param>
            <param name="curve_out">[out] curve returned here</param>
            <returns>
CRhinoCommand::success - successfully got curve
CRhinoCommand::cancel - user canceled
CRhinoCommand::failure - unable to get valid curve
</returns>
            <remarks>The Rhino "InterpCrv" command uses RhinoGetInterpolatedCurve.</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetControlPointCurve(RMA.Rhino.MArgsRhinoGetCurve@,RMA.OpenNURBS.OnNurbsCurve@)">
            <summary>Interactively get a contol point curve.</summary>
            <param name="args">[in/out] controls prompts and options available when getting the curve.</param>
            <param name="curve_out">[out] curve returned here</param>
            <returns>
CRhinoCommand::success - successfully got curve
CRhinoCommand::cancel - user canceled
CRhinoCommand::failure - unable to get valid curve
</returns>
            <remarks>The Rhino "Curve" command uses RhinoGetControlPointCurve.</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetInterpolatedCurveOnSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.OnCurve@)">
            <summary>Interactively get an interpolated curve on surface.</summary>
            <param name="pS">[in] surface on which to draw curve, or NULL to prompt user</param>
            <param name="ppCout">[out] curve returned here</param>
            <returns>
CRhinoCommand::success - successfully got curve
CRhinoCommand::cancel - user canceled
CRhinoCommand::failure - unable to get valid curve
</returns>
            <remarks>
The Rhino "InterpCrvOnSrf" command uses RhinoGetInterpolatedCurveOnSurface.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetCone(RMA.Rhino.MArgsRhinoGetCone,RMA.OpenNURBS.OnCone@)">
            <summary>UI tool to get a cone.</summary>
            <param name="args">[in] controls get point prompts, options, etc.</param>
            <param name="cone">[out] cone returned here</param>
            <returns>CRhinoCommand::success if successful.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetCircle(RMA.Rhino.MArgsRhinoGetCircle,RMA.OpenNURBS.OnCircle@)">
            <summary>
Global Utility function to interactively get a Circle
Starts in Center/Radius mode.
If an option is chosen for another construction method, switches to that method
Used by the circle command
</summary>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetInteger(System.String,System.Boolean,System.Int32@)">
            <summary>Easy to use integer getter.</summary>
            <param name="prompt">[in] command prompt</param>
            <param name="bAcceptNothing">[in] if true, the user can press enter</param>
            <param name="output_integer">
[in/out] default integer to this value and integer value returned here
</param>
            <returns>
CRhinoCommand::success - got integer
CRhinoCommand::nothing - user pressed enter
CRhinoCommand::cancel - user cancel integer getting
</returns>
            <remarks>
If you need options or more advanced user interface, then use CRhinoGetinteger.
See Also:
CRhinoGetInteger
CRhinoGet::AddCommandOptioninteger
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetInteger(System.String,System.Boolean,System.Int32@,System.Double)">
            <summary>Easy to use integer getter.</summary>
            <param name="prompt">[in] command prompt</param>
            <param name="bAcceptNothing">[in] if true, the user can press enter</param>
            <param name="output_integer">
[in/out] default integer to this value and integer value returned here
</param>
            <param name="lower_limit">[in]</param>
            <returns>
CRhinoCommand::success - got integer
CRhinoCommand::nothing - user pressed enter
CRhinoCommand::cancel - user cancel integer getting
</returns>
            <remarks>
If you need options or more advanced user interface, then use CRhinoGetinteger.
See Also:
CRhinoGetInteger
CRhinoGet::AddCommandOptioninteger
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetInteger(System.String,System.Boolean,System.Int32@,System.Double,System.Double)">
            <summary>Easy to use integer getter.</summary>
            <param name="prompt">[in] command prompt</param>
            <param name="bAcceptNothing">[in] if true, the user can press enter</param>
            <param name="output_integer">
[in/out] default integer to this value and integer value returned here
</param>
            <param name="lower_limit">[in]</param>
            <returns>
CRhinoCommand::success - got integer
CRhinoCommand::nothing - user pressed enter
CRhinoCommand::cancel - user cancel integer getting
</returns>
            <remarks>
If you need options or more advanced user interface, then use CRhinoGetinteger.
See Also:
CRhinoGetInteger
CRhinoGet::AddCommandOptioninteger
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetNumber(System.String,System.Boolean,System.Boolean,System.Double@)">
            <summary>Easy to use number getter.</summary>
            <param name="prompt">[in] command prompt</param>
            <param name="bAcceptNothing">[in] if true, the user can press enter</param>
            <param name="is_integer">[in] if true then value constrainded to integer value</param>
            <param name="output_number">[in/out] default number to this value and number value returned here</param>
            <returns>
CRhinoCommand::success - got number
CRhinoCommand::nothing - user pressed enter
CRhinoCommand::cancel - user cancel number getting
</returns>
            <remarks>
If you need options or more advanced user interface, then use CRhinoGetNumber.
See Also:
CRhinoGetInteger
CRhinoGet::AddCommandOptionNumber
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetNumber(System.String,System.Boolean,System.Boolean,System.Double@,System.Double)">
            <summary>Easy to use number getter.</summary>
            <param name="prompt">[in] command prompt</param>
            <param name="bAcceptNothing">[in] if true, the user can press enter</param>
            <param name="is_integer">[in] if true then value constrainded to integer value</param>
            <param name="output_number">[in/out] default number to this value and number value returned here</param>
            <param name="lower_limit">[in]</param>
            <returns>
CRhinoCommand::success - got number
CRhinoCommand::nothing - user pressed enter
CRhinoCommand::cancel - user cancel number getting
</returns>
            <remarks>
If you need options or more advanced user interface, then use CRhinoGetNumber.
See Also:
CRhinoGetInteger
CRhinoGet::AddCommandOptionNumber
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetNumber(System.String,System.Boolean,System.Boolean,System.Double@,System.Double,System.Double)">
            <summary>Easy to use number getter.</summary>
            <param name="prompt">[in] command prompt</param>
            <param name="bAcceptNothing">[in] if true, the user can press enter</param>
            <param name="is_integer">[in] if true then value constrainded to integer value</param>
            <param name="output_number">[in/out] default number to this value and number value returned here</param>
            <param name="lower_limit">[in]</param>
            <returns>
CRhinoCommand::success - got number
CRhinoCommand::nothing - user pressed enter
CRhinoCommand::cancel - user cancel number getting
</returns>
            <remarks>
If you need options or more advanced user interface, then use CRhinoGetNumber.
See Also:
CRhinoGetInteger
CRhinoGet::AddCommandOptionNumber
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetString(System.String,System.Boolean,System.String@)">
            <summary>Easy to use string getter.</summary>
            <param name="prompt">[in] command prompt</param>
            <param name="bAcceptNothing">[in] if true, the user can press enter</param>
            <param name="output_string">
[in/out] default string set to this value and string value returned here
</param>
            <returns>
CRhinoCommand::success - got string
CRhinoCommand::nothing - user pressed enter
CRhinoCommand::cancel - user cancel string getting
</returns>
            <remarks>
If you need options or more advanced user interface, then use CRhinoGetString.
See Also:
CRhinoGetString
CRhinoGet::AddCommandOption
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetColor(System.String,System.Boolean,RMA.OpenNURBS.OnColor@)">
            <summary>Easy to use color getter.</summary>
            <param name="prompt">[in] command prompt</param>
            <param name="bAcceptNothing">[in] if true, the user can press enter</param>
            <param name="output_color">[out] color value returned here</param>
            <returns>
CRhinoCommand::success - got color
CRhinoCommand::nothing - user pressed enter
CRhinoCommand::cancel - user cancel color getting
</returns>
            <remarks>
If you need options or more advanced user interface, then use CRhinoGetColor.
See Also:
CRhinoGetColor
CRhinoGet::AddCommandOptionColor
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoGetPoint(System.String,System.Boolean,RMA.OpenNURBS.On3dPoint@)">
            <summary>Easy to use point getter.</summary>
            <param name="prompt">[in] command prompt</param>
            <param name="bAcceptNothing">[in] if true, the user can press enter</param>
            <param name="point">[out] point value returned here</param>
            <returns>
CRhinoCommand::success - got point
CRhinoCommand::nothing - user pressed enter
CRhinoCommand::cancel - user cancel point getting
</returns>
            <remarks>
If you need options or more advanced user interface, then use CRhinoGetPoint.
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoReadFile(System.String,RMA.Rhino.MRhinoDoc@,RMA.Rhino.IRhinoFileReadOptions)">
            <summary>SDK tool to read a file using the Rhino file I/O plug-ins.</summary>
            <param name="lpsFileName">
[in] complete name of the file to write, including full path and extension.
The extension is used to determine what type of file is read.
</param>
            <param name="doc">[in]</param>
            <param name="options">[in] file reading options</param>
            <remarks>See Also: CRhinoDoc::Read3DM</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoWriteFile(System.String,RMA.Rhino.MRhinoDoc@,RMA.Rhino.IRhinoFileWriteOptions)">
            <summary>SDK tool to write a file using the Rhino file I/O plug-ins.</summary>
            <param name="lpsFileName">
[in] complete name of the file to write, including full path and extension.
The extension is used to determine what type of file is written.
</param>
            <param name="doc">[in]</param>
            <param name="options">[in] file writing options</param>
            <remarks>See Also: CRhinoDoc::Write3DM</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoFairCurve(RMA.Rhino.MArgsRhinoFair@)">
            <summary>
Fair a curve according to the settings in args  
The input curve, args.m_pCurve, is not changed.
</summary>
            <param name="args">[in] What to fair and how to fair it ( see CArgsRhinoFair)</param>
            <returns>The resulting faired curve.  Caller must free this when done with it.</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoExtrudeCurveToPoint(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Extrude a curve to a point making a coned surface</summary>
            <param name="pCurve">[in] the curve to extrude</param>
            <param name="apex">[in] the point for the tip of the surface</param>
            <returns>
The extruded surface if successful
NULL if not
</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoExtrudeCurveStraight(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOn3dVector)">
            <summary>Extrude a curve along a vector direction</summary>
            <param name="pCurve">[in] curve to extrude</param>
            <param name="direction">[in] the extrude vector</param>
            <returns>
The extruded surface if successful
NULL if not
</returns>
            <remarks>
The direction vector is used for both distance and direction input
The direction vector length is multiplied by scale
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoExtrudeCurveStraight(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOn3dVector,System.Double)">
            <summary>Extrude a curve along a vector direction</summary>
            <param name="pCurve">[in] curve to extrude</param>
            <param name="direction">[in] the extrude vector</param>
            <param name="scale">[in] optional scalar for the extrude vector</param>
            <returns>
The extruded surface if successful
NULL if not
</returns>
            <remarks>
The direction vector is used for both distance and direction input
The direction vector length is multiplied by scale
</remarks>
        </member>
        <member name="M:RMA.Rhino.RhUtil.RhinoApp">
            <summary>
returns theApp
</summary>
        </member>
        <member name="M:RMA.Rhino.RhUtil.GetPlugInInstance(System.String)">
            <summary>Get instance of the simgle plug-in class for a given assembly</summary>
            <returns>The plug in class for a given assembly if the plugin is currently loaded</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.GetPlugInInstance(System.Reflection.Assembly)">
            <summary>Get instance of the simgle plug-in class for a given assembly</summary>
            <returns>The plug in class for a given assembly if the plugin is currently loaded</returns>
        </member>
        <member name="M:RMA.Rhino.RhUtil.GetPlugInInstance">
            <summary>Get instance of the currently executing plug-in class</summary>
            <returns>The plug in class for the calling assembly if the calling assembly is a rhino plug-in.</returns>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoSweep2.TestForSimpleSweep">
            <summary>
See if inputs are perfect enough to do greville interpolate
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoSweep2.#ctor">
            <summary>
class CArgsRhinoSweep2
--------------------------------------------------------------------------------
</summary>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoSweep2.m_bSameHeight">
            <value>
maintain height between shapes - don't scale it the same as width
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoSweep2.m_angle_tolerance">
            <value>
tolerance to pass to TL sweeper as AngleTolerance
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoSweep2.m_sweep_tolerance">
            <value>
tolerance to pass to TL sweeper as SweepTolerance
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoSweep2.m_refit_tolerance">
            <value>
tolerance to refit shape curves
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoSweep2.m_rebuild_count">
            <value>
Sample point count for rebuilding shapes
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoSweep2.m_simplify">
            <value>
Simplify method for shape curves
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoSweep2.m_bClosed">
            <value>
Open or closed sweep if both rails are closed
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoSweep2.m_bSimpleSweep">
            <value>
Make a simple surface by greville interpolation of shapes
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoSweep2.m_rail_params(System.Int32)">
            <value>
params on the rail that correspond to each shape
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoSweep2.m_points">
            <value>
start and end points
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoSweep2.m_rail_pick_points(System.Int32)">
            <value>
first pick points for rails or ON_UNSET_POINT if not point picked
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoSweep2.m_shape_curves">
            <value>array of input shapes</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoSweep2.m_rail_curves(System.Int32)">
            <value>input rail curve</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoSweep2.m_bSameHeight">
            <value>
maintain height between shapes - don't scale it the same as width
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoSweep2.m_angle_tolerance">
            <value>
tolerance to pass to TL sweeper as AngleTolerance
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoSweep2.m_sweep_tolerance">
            <value>
tolerance to pass to TL sweeper as SweepTolerance
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoSweep2.m_refit_tolerance">
            <value>
tolerance to refit shape curves
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoSweep2.m_rebuild_count">
            <value>
Sample point count for rebuilding shapes
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoSweep2.m_simplify">
            <value>
Simplify method for shape curves
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoSweep2.m_bClosed">
            <value>
Open or closed sweep if both rails are closed
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoSweep2.m_bSimpleSweep">
            <value>
Make a simple surface by greville interpolation of shapes
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoSweep2.m_rail_params(System.Int32)">
            <value>
params on the rail that correspond to each shape
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoSweep2.m_points">
            <value>
start and end points
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoSweep2.m_rail_pick_points(System.Int32)">
            <value>
first pick points for rails or ON_UNSET_POINT if not point picked
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoSweep2.m_rail_curves(System.Int32)">
            <value>input rail curves</value>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoSweep1.AllShapesEndAtPoint">
            <summary>
Test function used for RailRevolve sweeps
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoSweep1.AllShapesEndAtPoint(RMA.OpenNURBS.On3dPoint)">
            <summary>
Test function used for RailRevolve sweeps
</summary>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoSweep1.m_miter_count">
            <value>
number of kink miters sucessfully complered
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoSweep1.m_miter_attempts">
            <value>
number of kink miters attempted
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoSweep1.m_miter_type">
            <value>
0: don't miter
1: intersect surfaces and trim sweeps
2: rotate shapes at kinks and don't trim
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoSweep1.m_angle_tolerance">
            <value>
tolerance to pass to TL sweeper as AngleTolerance
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoSweep1.m_sweep_tolerance">
            <value>
tolerance to pass to TL sweeper as SweepTolerance
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoSweep1.m_refit_tolerance">
            <value>
tolerance to refit shape curves
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoSweep1.m_rebuild_count">
            <value>
Sample point count for rebuilding shapes
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoSweep1.m_simplify">
            <value>
Simplify method for shape curves
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoSweep1.m_planar_up">
            <value>
Up direction for roadlike style
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoSweep1.m_style">
            <value>
how the frames get rotated around the rail
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoSweep1.m_bClosed">
            <value>
Open or closed sweep if the rail is closed
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoSweep1.m_point_objrefs(System.Int32)">
            <value>
point objects picked for endpoints
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoSweep1.m_shape_objrefs">
            <value>
Where the shapes came from
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoSweep1.m_bUsePoints(System.Int32)">
            <value>
flag for valid start and/or endpoint to use
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoSweep1.m_points(System.Int32)">
            <value>
start and end points
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoSweep1.m_rail_params">
            <value>
params on the rail that correspond to each shape
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoSweep1.m_shape_curves">
            <value>array of input shapes</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoSweep1.m_rail_curve">
            <value>input rail curve</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoSweep1.m_RailPickPoint">
            <value>
point where the rail was picked
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoSweep1.m_bHaveRailPickPoint">
            <value>
true if the rail was selected with a point pick
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoSweep1.m_miter_count">
            <value>
number of kink miters sucessfully complered
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoSweep1.m_miter_attempts">
            <value>
number of kink miters attempted
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoSweep1.m_miter_type">
            <value>
0: don't miter
1: intersect surfaces and trim sweeps
2: rotate shapes at kinks and don't trim
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoSweep1.m_angle_tolerance">
            <value>
tolerance to pass to TL sweeper as AngleTolerance
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoSweep1.m_sweep_tolerance">
            <value>
tolerance to pass to TL sweeper as SweepTolerance
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoSweep1.m_refit_tolerance">
            <value>
tolerance to refit shape curves
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoSweep1.m_rebuild_count">
            <value>
Sample point count for rebuilding shapes
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoSweep1.m_simplify">
            <value>
Simplify method for shape curves
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoSweep1.m_planar_up">
            <value>
Up direction for roadlike style
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoSweep1.m_style">
            <value>
how the frames get rotated around the rail
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoSweep1.m_bClosed">
            <value>
Open or closed sweep if the rail is closed
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoSweep1.m_point_objrefs(System.Int32)">
            <value>
point objects picked for endpoints
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoSweep1.m_shape_objrefs">
            <value>
Where the shapes came from
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoSweep1.m_bUsePoints(System.Int32)">
            <value>
flag for valid start and/or endpoint to use
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoSweep1.m_points(System.Int32)">
            <value>
start and end points
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoSweep1.m_rail_params">
            <value>
params on the rail that correspond to each shape
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoSweep1.m_rail_curve">
            <value>input rail curve</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoSweep1.m_RailPickPoint">
            <value>
point where the rail was picked
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoSweep1.m_bHaveRailPickPoint">
            <value>
true if the rail was selected with a point pick
</value>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetEllipse.AroundDirectionCount">
            <summary>
number of faces in the around direction
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetEllipse.VerticalDirectionCount">
            <summary>
number of faces in the vertical direction
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetEllipse.SetPromptForMeshDensity">
            <summary>
Interface to allow primitive mesh creation to use 
RhinoGetPlane, RhinoGetBox, RhinoGetCircle etc.
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetEllipse.SetPromptForMeshDensity(System.Boolean)">
            <summary>
Interface to allow primitive mesh creation to use 
RhinoGetPlane, RhinoGetBox, RhinoGetCircle etc.
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetEllipse.Eccentricity">
            <summary>The eccentricity of FromFoci ellipse</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetEllipse.SetEccentricity(System.Double)">
            <summary>The eccentricity of FromFoci ellipse</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetEllipse.Angle">
            <summary>The current Ellipse angle in center_start_angle</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetEllipse.SetAngle(System.Double)">
            <summary>The current Ellipse angle in center_start_angle</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetEllipse.Normal">
            <summary>The current Ellipse normal in center_start_end</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetEllipse.SetNormal(RMA.OpenNURBS.IOn3dVector)">
            <summary>The current Ellipse normal in center_start_end</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetEllipse.Dir">
            <summary>The current Ellipse direction in center_start_end</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetEllipse.SetDir(System.Int32)">
            <summary>The current Ellipse direction in center_start_end</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetEllipse.Quadrant">
            <summary>The current third point quadrant in center_start_end</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetEllipse.SetQuadrant(System.Int32)">
            <summary>The current third point quadrant in center_start_end</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetEllipse.MarkFoci">
            <summary>Indicates the user wants the ellipse foci marked with point objects</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetEllipse.SetMarkFoci">
            <summary>Indicates the user wants the ellipse foci marked with point objects</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetEllipse.SetMarkFoci(System.Boolean)">
            <summary>Indicates the user wants the ellipse foci marked with point objects</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetEllipse.SetAcceptNumber">
            <summary>Set whether the last prompt accepts a number or not. Used in center_start_end</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetEllipse.SetAcceptNumber(System.Boolean)">
            <summary>Set whether the last prompt accepts a number or not. Used in center_start_end</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetEllipse.SetEllipseMode(RMA.Rhino.IArgsRhinoGetEllipse.eEllipseMode)">
            <summary>Set the Ellipse mode</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetEllipse.SetThirdPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Set the third point to use instead of asking for one</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetEllipse.SetSecondPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Set the second point to use instead of asking for one</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetEllipse.SetFirstPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Set the first point to use instead of asking for one</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetEllipse.SetThirdPrompt(System.String)">
            <summary>Set a custom prompt to use for getting third point</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetEllipse.SetSecondPrompt(System.String)">
            <summary>Set a custom prompt to use for getting the second point</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetEllipse.SetFirstPrompt(System.String)">
            <summary>Set a custom prompt to use for getting the first point</summary>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoGetEllipse.m_tangent_mode">
            <value>
true if curve tangent defined
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoGetEllipse.m_tangent">
            <value>
[i] curve tangent in around curve mode
</value>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetEllipse.AroundDirectionCount">
            <summary>
number of faces in the around direction
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetEllipse.VerticalDirectionCount">
            <summary>
number of faces in the vertical direction
</summary>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoGetEllipse.m_tangent_mode">
            <value>
true if curve tangent defined
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoGetEllipse.m_tangent">
            <value>
[i] curve tangent in around curve mode
</value>
        </member>
        <member name="T:RMA.Rhino.IArgsRhinoGetEllipse.eEllipseMode">
            <summary>current Ellipse mode of RhinoGetEllipse functions</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoDimOrdinate.#ctor">
            <summary>
---------------------------------------------------------------------------
</summary>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoDimOrdinate.m_direction">
            <value>
-1: determine by dimpoint and leader point
0: measure parallel to x axis
2: measure parallel to y axis
</value>
        </member>
        <member name="T:RMA.Rhino.MArgsRhinoDimOrdinate">
            <summary>CArgsRhinoDimOrdinate is used to pass input to RhinoGetDimOrdinate().</summary>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoDimOrdinate.m_direction">
            <value>
-1: determine by dimpoint and leader point
0: measure parallel to x axis
2: measure parallel to y axis
</value>
        </member>
        <member name="T:RMA.Rhino.IArgsRhinoDimOrdinate">
            <summary>CArgsRhinoDimOrdinate is used to pass input to RhinoGetDimOrdinate().</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoDimLinear.FirstPointObjRef">
            <summary>
ObjRef's of points between which to dimension
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoDimLinear.FirstPoint">
            <summary>
Points between which to dimension
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoDimLinear.FeedbackColor">
            <summary>
color used to draw feedback line
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoDimLinear.DragPointPrompt">
            <summary>
prompt when getting dimension line location
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoDimLinear.SecondPointPrompt">
            <summary>
prompt when getting second dimension
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoDimLinear.FirstPointPrompt">
            <summary>
prompt when getting first dimension point
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoDimLinear.#ctor">
            <summary>
---------------------------------------------------------------------------
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoDimLinear.#ctor(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
---------------------------------------------------------------------------
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoDimLinear.#ctor(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
---------------------------------------------------------------------------
</summary>
        </member>
        <member name="T:RMA.Rhino.MArgsRhinoDimLinear">
            <summary>CArgsRhinoDimLinear is used to pass input to RhinoGetDimLinear().</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoDimLinear.FirstPointObjRef">
            <summary>
ObjRef's of points between which to dimension
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoDimLinear.FirstPoint">
            <summary>
Points between which to dimension
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoDimLinear.FeedbackColor">
            <summary>
color used to draw feedback line
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoDimLinear.DragPointPrompt">
            <summary>
prompt when getting dimension line location
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoDimLinear.SecondPointPrompt">
            <summary>
prompt when getting second dimension
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoDimLinear.FirstPointPrompt">
            <summary>
prompt when getting first dimension point
</summary>
        </member>
        <member name="T:RMA.Rhino.IArgsRhinoDimLinear">
            <summary>CArgsRhinoDimLinear is used to pass input to RhinoGetDimLinear().</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetXform.CalculateTransform(RMA.Rhino.MRhinoViewport@,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.OnXform@)">
            <summary>
Override this virtual function to provide your own custom
transformation method.  Call this function to retrieve
the final transformation.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetXform.AppendObject(RMA.Rhino.IRhinoObject)">
            <summary>
Add any objects you want transformed and grips you want
transformed.  Make sure no duplicates are in the list
and that no grip ownwers are passed in as objects.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetXform.AppendObjects(RMA.Rhino.IRhinoXformObjectList)">
            <summary>
Add any objects you want transformed and grips you want
transformed.  Make sure no duplicates are in the list
and that no grip ownwers are passed in as objects.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetXform.AppendObjects(RMA.Rhino.IRhinoGetObject)">
            <summary>
Add any objects you want transformed and grips you want
transformed.  Make sure no duplicates are in the list
and that no grip ownwers are passed in as objects.
</summary>
        </member>
        <member name="T:RMA.Rhino.MRhinoGetXform">
            <summary>
Base class for object transformation point getters.

You will never directly create a CRhinoGetXform but you will use
its member functions after calling CRhinoGetXform::GetXform(). 
</summary>
        </member>
        <member name="T:RMA.Rhino.IRhinoGetXform">
            <summary>
Base class for object transformation point getters.

You will never directly create a CRhinoGetXform but you will use
its member functions after calling CRhinoGetXform::GetXform(). 
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoXformObjectList.HasBreps">
            <summary>
Returns: True if m_objects[] contains a brep (any number of faces).
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoXformObjectList.HasSurfaces">
            <summary>
Returns: True if m_objects[] contains a surface (brep with 1 face).
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoXformObjectList.HasPolysurfaces">
            <summary>
Returns: True if m_objects[] contains a polysurface (brep with 2 or more faces).
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoXformObjectList.AddObject(RMA.Rhino.IRhinoObject)">
            <summary>
returns 0 = not added, 1 = added as object, 2 = added as grip
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoXformObjectList.AddObject(RMA.Rhino.IRhinoObject,System.Boolean)">
            <summary>
returns 0 = not added, 1 = added as object, 2 = added as grip
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoXformObjectList.AddObject(RMA.Rhino.IRhinoObjRef)">
            <summary>
returns 0 = not added, 1 = added as object, 2 = added as grip
Use this to add Polyedges so the references are properly counted.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoXformObjectList.AddObject(RMA.Rhino.IRhinoObjRef,System.Boolean)">
            <summary>
returns 0 = not added, 1 = added as object, 2 = added as grip
Use this to add Polyedges so the references are properly counted.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoXformObjectList.AddObjects(RMA.Rhino.IRhinoGetObject)">
            <summary>
returns number of objects and grips added to lists.
If all grips are selected, 
If bAllowAllGrips is set, add all of the grips
otherwise, just add the owner object instead
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoXformObjectList.AddObjects(RMA.Rhino.IRhinoGetObject,System.Boolean)">
            <summary>
returns number of objects and grips added to lists.
If all grips are selected, 
If bAllowAllGrips is set, add all of the grips
otherwise, just add the owner object instead
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoXformObjectList.Empty">
            <summary>
If an object is in the m_objects[] list, then it is not in the m_grip_owners[] list, and vice verse.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoXformObjectList.HasBreps">
            <summary>
Returns: True if m_objects[] contains a brep (any number of faces).
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoXformObjectList.HasSurfaces">
            <summary>
Returns: True if m_objects[] contains a surface (brep with 1 face).
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoXformObjectList.HasPolysurfaces">
            <summary>
Returns: True if m_objects[] contains a polysurface (brep with 2 or more faces).
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetBox.#ctor">
            <summary>
------------------------------------------------------------------
CArgsRhinoGetBox
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.AddExtraOptions(RMA.Rhino.MRhinoGetPoint@)">
            <summary>
Allows for adding extra command options during RhinoGetRectangle
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.ExtraOptionsAtStart">
            <summary>
Interface for subclasses adding extra options. 
Return true if you want to add extra options to the start of the command option list
      false for options at the end
Default is false
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.ArgsType">
            <summary>
return type of args class plane or derived box
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.ThirdDirectionCount">
            <summary>
number of faces in third direction
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.ThirdMeshDensityDirectionPrompt">
            <summary>
prompt for number of faces in third direction
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.SecondDirectionCount">
            <summary>
number of faces in second direction
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.SecondMeshDensityDirectionPrompt">
            <summary>
prompt for number of faces in second direction
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.FirstDirectionCount">
            <summary>
number of faces in first direction
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.FirstMeshDensityDirectionPrompt">
            <summary>
prompt for number of faces in first direction
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.SetPromptForMeshDensity">
            <summary>
Interface to allow primitive mesh creation to use 
RhinoGetPlane, RhinoGetBox, etc.
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.SetPromptForMeshDensity(System.Boolean)">
            <summary>
Interface to allow primitive mesh creation to use 
RhinoGetPlane, RhinoGetBox, etc.
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.SetAllowCorners">
            <summary>
Set or Get whether to allow the respective interactive modes
Default is to allow them all
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.SetAllowCorners(System.Boolean)">
            <summary>
Set or Get whether to allow the respective interactive modes
Default is to allow them all
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.SetCurrentMode">
            <summary>
Set or get the starting mode for getting input
Default is start_corners
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.SetCurrentMode(System.Int32)">
            <summary>
Set or get the starting mode for getting input
Default is start_corners
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.SetThirdPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Set or get the third point in rect3pt mode
If one isn't supplied, the user is prompted for one
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.SetSecondPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Set or get the second end of the first edge
If one isn't supplied, the user is prompted for one
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.SetFirstPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Set or get the basepoint used for the first corner
of the rectangle
If one isn't supplied, the user is prompted for one
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.SetPlane(RMA.OpenNURBS.IOnPlane)">
            <summary>
setting getting enabling plane
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.Plane">
            <summary>
Set or get a plane to which the rectangle is constrained
If none is set, the construction plane of the current
viewport is used
The base point is snapped to this plane
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.AcceptNothing">
            <summary>
Like CRhinoGet::AcceptNothing().
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.AcceptNothing(System.Boolean)">
            <summary>
Like CRhinoGet::AcceptNothing().
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.FeedbackColor">
            <summary>
color used to draw feedback line
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.SetSecondPointPromptCenter(System.String)">
            <summary>
prompt when getting end point
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.SecondPointPromptCenter">
            <summary>
prompt when getting corner in center mode
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.SetFirstPointPromptCenter(System.String)">
            <summary>
-----
prompt when getting first point 3point mode
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.FirstPointPromptCenter">
            <summary>
prompt when getting center in center mode
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.SetThirdPointPromptVertical(System.String)">
            <summary>
prompt when getting end point
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.ThirdPointPromptVertical">
            <summary>
prompt when getting opposite side in vertical mode
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.SetSecondPointPromptVertical(System.String)">
            <summary>
prompt when getting end point
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.SecondPointPromptVertical">
            <summary>
prompt when getting second point in vertical mode
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.SetFirstPointPromptVertical(System.String)">
            <summary>
prompt when getting first point
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.FirstPointPromptVertical">
            <summary>
prompt when getting first corner
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.SetThirdPointPrompt3Point(System.String)">
            <summary>
prompt when getting end point
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.ThirdPointPrompt3Point">
            <summary>
prompt when getting opposite side in 3point mode
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.SetSecondPointPrompt3Point(System.String)">
            <summary>
prompt when getting end point
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.SecondPointPrompt3Point">
            <summary>
prompt when getting second point in 3 point mode
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.SetFirstPointPrompt3Point(System.String)">
            <summary>
prompt when getting first point 3point mode
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.FirstPointPrompt3Point">
            <summary>
prompt when getting first corner
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.SetSecondPointPromptCorners(System.String)">
            <summary>
prompt when getting end point
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.SecondPointPromptCorners">
            <summary>
prompt when getting opposite corner
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.SetFirstPointPromptCorners(System.String)">
            <summary>
prompt when getting first point
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPlane.FirstPointPromptCorners">
            <summary>
prompt when getting first corner
</summary>
        </member>
        <member name="T:RMA.Rhino.MArgsRhinoGetPlane">
            <summary>Input to the RhinoGetPlane() and RhinoGetRectangle() functions</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetPlane.ExtraOptionsAtStart">
            <summary>
Interface for subclasses adding extra options. 
Return true if you want to add extra options to the start of the command option list
      false for options at the end
Default is false
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetPlane.ArgsType">
            <summary>
return type of args class plane or derived box
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetPlane.ThirdDirectionCount">
            <summary>
number of faces in third direction
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetPlane.ThirdMeshDensityDirectionPrompt">
            <summary>
prompt for number of faces in third direction
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetPlane.SecondDirectionCount">
            <summary>
number of faces in second direction
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetPlane.SecondMeshDensityDirectionPrompt">
            <summary>
prompt for number of faces in second direction
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetPlane.FirstDirectionCount">
            <summary>
number of faces in first direction
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetPlane.FirstMeshDensityDirectionPrompt">
            <summary>
prompt for number of faces in first direction
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetPlane.Plane">
            <summary>
Set or get a plane to which the rectangle is constrained
If none is set, the construction plane of the current
viewport is used
The base point is snapped to this plane
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetPlane.FeedbackColor">
            <summary>
color used to draw feedback line
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetPlane.SecondPointPromptCenter">
            <summary>
prompt when getting corner in center mode
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetPlane.FirstPointPromptCenter">
            <summary>
prompt when getting center in center mode
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetPlane.ThirdPointPromptVertical">
            <summary>
prompt when getting opposite side in vertical mode
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetPlane.SecondPointPromptVertical">
            <summary>
prompt when getting second point in vertical mode
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetPlane.FirstPointPromptVertical">
            <summary>
prompt when getting first corner
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetPlane.ThirdPointPrompt3Point">
            <summary>
prompt when getting opposite side in 3point mode
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetPlane.SecondPointPrompt3Point">
            <summary>
prompt when getting second point in 3 point mode
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetPlane.FirstPointPrompt3Point">
            <summary>
prompt when getting first corner
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetPlane.SecondPointPromptCorners">
            <summary>
prompt when getting opposite corner
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetPlane.FirstPointPromptCorners">
            <summary>
prompt when getting first corner
</summary>
        </member>
        <member name="T:RMA.Rhino.IArgsRhinoGetPlane">
            <summary>Input to the RhinoGetPlane() and RhinoGetRectangle() functions</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetParabola.#ctor">
            <summary>
CArgsRhinoGetParabola implementation
</summary>
        </member>
        <member name="T:RMA.Rhino.MArgsRhinoGetParabola">
            <summary>Arguments for RhinoGetParabola... functions</summary>
        </member>
        <member name="T:RMA.Rhino.IArgsRhinoGetParabola">
            <summary>Arguments for RhinoGetParabola... functions</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPolyline.NextPointPrompt">
            <summary>
prompt when getting forth and subsequent points
Default = "Next point of polyline".
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetPolyline.ThirdPointPrompt">
            <summary>
prompt when getting third point
Default = "Next point of polyline".
</summary>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoGetPolyline.m_bClosed">
            <value>
[out]  If the polyline was closed by using the "Close" option
or snapping to the start point, then m_bClosed is set to TRUE.
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoGetPolyline.m_max_point_count">
            <value>
[in] maximum number of points to require; zero for no limit.
On closed polylines, the start/end point is counted twice.
The default is 0.
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoGetPolyline.m_min_point_count">
            <value>
[in] minimum number of points to require.  On closed polylines,
the start/end point is counted once.  The default is 2.
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoGetPolyline.m_bForceClosed">
            <value>
[in] If m_bForceClosed is TRUE, then the returned polyline
is always closed. If m_bForceClosed is TRUE, then m_max_point_count
must be 0 or &gt;= 4.  The default is FALSE.
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoGetPolyline.m_bPermitCloseSnap">
            <value>
[in] If m_bPermitCloseSnap is TRUE, then after 3 points
have been picked, the user can pick near the start point and
a closed polyline will be returned.
The default is TRUE.
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoGetPolyline.m_bPermitCloseOption">
            <value>
[in] If m_bPermitCloseOption is TRUE, then after 3 points
have been picked, the user can type "Close" and a closed 
polyline will be returned. The default is TRUE.
</value>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetPolyline.NextPointPrompt">
            <summary>
prompt when getting forth and subsequent points
Default = "Next point of polyline".
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetPolyline.ThirdPointPrompt">
            <summary>
prompt when getting third point
Default = "Next point of polyline".
</summary>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoGetPolyline.m_bClosed">
            <value>
[out]  If the polyline was closed by using the "Close" option
or snapping to the start point, then m_bClosed is set to TRUE.
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoGetPolyline.m_max_point_count">
            <value>
[in] maximum number of points to require; zero for no limit.
On closed polylines, the start/end point is counted twice.
The default is 0.
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoGetPolyline.m_min_point_count">
            <value>
[in] minimum number of points to require.  On closed polylines,
the start/end point is counted once.  The default is 2.
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoGetPolyline.m_bForceClosed">
            <value>
[in] If m_bForceClosed is TRUE, then the returned polyline
is always closed. If m_bForceClosed is TRUE, then m_max_point_count
must be 0 or &gt;= 4.  The default is FALSE.
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoGetPolyline.m_bPermitCloseSnap">
            <value>
[in] If m_bPermitCloseSnap is TRUE, then after 3 points
have been picked, the user can pick near the start point and
a closed polyline will be returned.
The default is TRUE.
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoGetPolyline.m_bPermitCloseOption">
            <value>
[in] If m_bPermitCloseOption is TRUE, then after 3 points
have been picked, the user can type "Close" and a closed 
polyline will be returned. The default is TRUE.
</value>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetLine.LineMode">
            <summary>The current line mode</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetLine.SetLineMode">
            <summary>Set current line mode</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetLine.SetLineMode(System.Int32)">
            <summary>Set current line mode</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetLine.FirstPoint">
            <summary>
If FirstPoint() returns NULL, then the user interactively picks the
starting point.  If FirstPoint() is not NULL, then that point is
used as the first point.
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetLine.SetFirstPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Use SetFirstPoint() to specify the line's starting point and skip the
start point interactive picking.
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetLine.ShowVariations">
            <summary>If TRUE, then showing line variations is enabled</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetLine.EnableShowVariations">
            <summary>If TRUE, then the all line variations are shown if the default line mode is used</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetLine.EnableShowVariations(System.Boolean)">
            <summary>If TRUE, then the all line variations are shown if the default line mode is used</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetLine.FromMidPoint">
            <summary>If TRUE, then the user picked the midpoint and endpoint</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetLine.EnableFromMidPoint">
            <summary>If TRUE, then the user picks the midpoint and endpoint</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetLine.EnableFromMidPoint(System.Boolean)">
            <summary>If TRUE, then the user picks the midpoint and endpoint</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetLine.EnableFromMidPointOption">
            <summary>
If TRUE, then the "BothSides" option shows up when the
start point is inteactively picked.
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetLine.EnableFromMidPointOption(System.Boolean)">
            <summary>
If TRUE, then the "BothSides" option shows up when the
start point is inteactively picked.
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetLine.Length">
            <summary>If Length() &gt; 0, the line must have the specified length.</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetLine.SetLength(System.Double)">
            <summary>If the line should have a fixed length, set that length here</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetLine.SetFeedbackColor(System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
If set, the feedback color is used to draw the dynamic line when the
second point is begin picked. If not set, the active layer color is used.
</summary>
            <returns>TRUE if line feedback color has been set.</returns>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetLine.FeedbackColor">
            <summary>
If set, the feedback color is used to draw the dynamic line when the second point
is begin picked. If not set, the active layer color is used.
</summary>
            <returns>TRUE if line feedback color has been set.</returns>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetLine.HaveFeedbackColor">
            <summary>
If set, the feedback color is used to draw the dynamic line when the second
point is begin picked. If not set, the active layer color is used.
</summary>
            <returns>TRUE if line feedback color has been set.</returns>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetLine.EnableAcceptZeroLengthLine">
            <summary>
Controls whither or not a zero length line is acceptable. The default is
to require the user to keep picking the end point until we get a point
different than the start point.
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetLine.EnableAcceptZeroLengthLine(System.Boolean)">
            <summary>
Controls whither or not a zero length line is acceptable. The default is
to require the user to keep picking the end point until we get a point
different than the start point.
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetLine.AcceptZeroLengthLine">
            <summary>
Controls whether or not a zero length line is acceptable. The default is
to require the user to keep picking the end point until we get a point
different than the start point.
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetLine.SecondPointPrompt">
            <summary>
prompt when getting second point
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetLine.MidPointPrompt">
            <summary>
prompt when getting midpoint
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetLine.FirstPointPrompt">
            <summary>
prompt when getting first point
</summary>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoGetLine.m_objref(System.Int32)">
            <value>
RhinoGetLine() returns GetPoint object references to 
picked points here.
</value>
        </member>
        <member name="T:RMA.Rhino.MArgsRhinoGetLine">
            <summary>CArgsRhinoGetLine is used to pass input to RhinoGetLine().</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetLine.LineMode">
            <summary>The current line mode</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetLine.FirstPoint">
            <summary>
If FirstPoint() returns NULL, then the user interactively picks the
starting point.  If FirstPoint() is not NULL, then that point is
used as the first point.
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetLine.ShowVariations">
            <summary>If TRUE, then showing line variations is enabled</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetLine.FromMidPoint">
            <summary>If TRUE, then the user picked the midpoint and endpoint</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetLine.Length">
            <summary>If Length() &gt; 0, the line must have the specified length.</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetLine.FeedbackColor">
            <summary>
If set, the feedback color is used to draw the dynamic line when the second point
is begin picked. If not set, the active layer color is used.
</summary>
            <returns>TRUE if line feedback color has been set.</returns>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetLine.HaveFeedbackColor">
            <summary>
If set, the feedback color is used to draw the dynamic line when the second
point is begin picked. If not set, the active layer color is used.
</summary>
            <returns>TRUE if line feedback color has been set.</returns>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetLine.AcceptZeroLengthLine">
            <summary>
Controls whether or not a zero length line is acceptable. The default is
to require the user to keep picking the end point until we get a point
different than the start point.
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetLine.SecondPointPrompt">
            <summary>
prompt when getting second point
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetLine.MidPointPrompt">
            <summary>
prompt when getting midpoint
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetLine.FirstPointPrompt">
            <summary>
prompt when getting first point
</summary>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoGetLine.m_objref(System.Int32)">
            <value>
RhinoGetLine() returns GetPoint object references to 
picked points here.
</value>
        </member>
        <member name="T:RMA.Rhino.IArgsRhinoGetLine">
            <summary>CArgsRhinoGetLine is used to pass input to RhinoGetLine().</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCurve.PointArray2d">
            <summary>
Array of selected parameter space points
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCurve.PointArray">
            <summary>
Array of selected points
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCurve.SetSharp(System.Boolean)">
            <summary>FALSE = periodic when closed, TRUE = sharp when closed</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCurve.SetKnotSpacing(System.Int32)">
            <summary>
Method of Knot Spacing for interpolated curve 
0=uniform, 1=chord, 2=sqrt(chord)
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCurve.SetSurface(RMA.OpenNURBS.IOnSurface)">
            <summary>Surface for Interpolate curve on surface</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCurve.SetDegree(System.Int32)">
            <summary>
degree of curve
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCurve.SetEndTangent(RMA.OpenNURBS.IOn3dVector)">
            <summary>
interpolated curve end tangent, ON_3dVector(0,0,0) if not defined
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCurve.SetStartTangent(RMA.OpenNURBS.IOn3dVector)">
            <summary>
interpolated curve start tangent, ON_3dVector(0,0,0) if not defined
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCurve.SetThirdPrompt(System.String)">
            <summary>
prompt when getting third and following points 
Default = "Next point. Press Enter when done".
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCurve.SetSecondPrompt(System.String)">
            <summary>
prompt when getting second point
Default = "Next point".
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCurve.SetFirstPrompt(System.String)">
            <summary>
prompt when getting first point
Default = "Start of curve".
</summary>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoGetCone.m_ApexAngle">
            <value>
Full angle of the apex, not the half angle, in degrees.
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoGetCone.m_BaseAngle">
            <value>
Angle between the base circle and the side of the cone in degrees.
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoGetCone.m_bAllowAngleInput">
            <value>
If this is true Angle options are exposed in the end point prompt.
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoGetCone.m_ApexAngle">
            <value>
Full angle of the apex, not the half angle, in degrees.
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoGetCone.m_BaseAngle">
            <value>
Angle between the base circle and the side of the cone in degrees.
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoGetCone.m_bAllowAngleInput">
            <value>
If this is true Angle options are exposed in the end point prompt.
</value>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetArc.SetDefaultRadius(System.Double)">
            <summary>The default radius in start_end_radius</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetArc.SetAngle(System.Double)">
            <summary>The current arc angle in center_start_angle</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetArc.SetNormal(RMA.OpenNURBS.IOn3dVector)">
            <summary>The current arc normal in center_start_end</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetArc.SetDir(System.Int32)">
            <summary>The current arc direction in center_start_end</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetArc.SetQuadrant(System.Int32)">
            <summary>The current third point quadrant in center_start_end</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetArc.SetAcceptNumber(System.Boolean)">
            <summary>Set whether the last prompt accepts a number or not. Used in center_start_end</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetArc.SetPoint3(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Set the third point to use instead of asking for one</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetArc.SetPoint2(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Set the second point to use instead of asking for one</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetArc.SetPoint1(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Set the first point to use instead of asking for one</summary>
        </member>
        <member name="T:RMA.Rhino.IArgsRhinoGetArc.eArcMode">
            <summary>current arc mode of GetArc functions</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetAngle.Angle">
            <summary>
If GetAngle() returned CRhinoGet::angle, Call Angle() to get the angle value.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetAngle.GetAngle">
            <summary>Call GetAngle() to get an angle.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetAngle.SetDefault(System.Double)">
            <summary>
Angle in radians
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetAngle.SetReferencePoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
if a reference point is set, the reference angle is calculated 
from it and a reference lijne is drawn from the base point to it
This will override any reference angle set with SetReference()
the point will be projected to the plane or cplane
being used by GetAngle()
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetAngle.SetReference(System.Double)">
            <summary>
Angle in radians
</summary>
        </member>
        <member name="T:RMA.Rhino.MRhinoGetAngle">
            <summary>
All programatic input and output to CRhinoGetAngle is in radians
But the user input if a number is typed is in the 
current angle mode ( which for now is always degrees)
</summary>
        </member>
        <member name="T:RMA.Rhino.IRhinoGetAngle">
            <summary>
All programatic input and output to CRhinoGetAngle is in radians
But the user input if a number is typed is in the 
current angle mode ( which for now is always degrees)
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDigitizerManager.GetTransformedRay(RMA.OpenNURBS.IOn3dRay,RMA.OpenNURBS.On3dRay@)">
            <summary>
END TestDigSpy command
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDigitizerManager.GetDigClickPoint(System.String,System.Boolean,RMA.OpenNURBS.On3dPoint@)">
            <summary>
get a raw dig point during calibration
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDigitizerManager.CurrentPlugInID">
            <summary>
Return the UUID for the current digitizer plug-in.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDigitizerManager.SetUserScale(System.Double)">
            <summary>
returns previous value
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDigitizerManager.IsActive">
            <summary>
true if GetPoint can accept digitizer input
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDigitizerManager.IsPaused">
            <summary>
true if a digitizer is connected and paused
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDigitizerManager.IsCalibrated">
            <summary>
true if a digitizer is connected and calibrated
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDigitizerManager.IsConnected">
            <summary>
true if a digitizer is connected
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDigitizerManager.MimicDigClick">
            <summary>
Description: Mimic a digitizer "foot pedal" click. Returns: True if successful.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDigitizerManager.PauseDigitizer">
            <summary>
Description: When the digitizer is "paused", it cannot be used for getting points. Parameters: bPause - [in] Returns: Previous pause state
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDigitizerManager.PauseDigitizer(System.Boolean)">
            <summary>
Description: When the digitizer is "paused", it cannot be used for getting points. Parameters: bPause - [in] Returns: Previous pause state
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDigitizerManager.CheckDigitizer(RMA.Rhino.IRhinoCommandContext)">
            <summary>
Description: Commands that need a digitizer can call CheckDigitizer to make sure everything is ready. It takes care of starting a digitizer if one is not already running.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDigitizerManager.CheckDigitizer(RMA.Rhino.IRhinoCommandContext,System.Boolean)">
            <summary>
Description: Commands that need a digitizer can call CheckDigitizer to make sure everything is ready. It takes care of starting a digitizer if one is not already running.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDigitizerManager.GetDigitizer(RMA.Rhino.IRhinoCommandContext,System.Guid@)">
            <summary>
Returns: UUID of the digitizer plugin or ON_nil_uuid if none
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDigitizerManager.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
called in CRhinoApp::ExitInstance
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDigitizerManager.LoadProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
called in CRhinoApp::InitInstance
</summary>
        </member>
        <member name="P:RMA.Rhino.MRhinoDigitizerManager.m_nFlags">
            <value>
value of nFlags on last point sent to PostDigitizerPointEvent
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoDigitizerManager.m_scale">
            <value>
Digitizer to Rhino scale factor
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoDigitizerManager.m_dig_vector_xform">
            <value>
transforms directions
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoDigitizerManager.m_dig_point_xform">
            <value>
transforms point (has unit system scaling)
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoDigitizerManager.m_rhino_us">
            <value>
This value is set by carefully placed calls to 
GetCurrentModel()-&gt;Settings().m_ModelUnitsAndTolerances.m_unit_system;
bool m_bRhinoRunning; // true after CRhinoApp::InitInstance()
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoDigitizerManager.m_bGetDigClickPoint">
            <value>
true when we are getting 3 raw coord dig calibration pts
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoDigitizerManager.m_dig_tol">
            <value>
in m_dig_us units
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoDigitizerManager.m_dig_us">
            <value>
This information is from m_current_plugin
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoDigitizerManager.m_rhino_origin">
            <value>
These points are in rhino world coordinates and are 
set by the "DigCalibrate" command
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoDigitizerManager.m_dig_origin">
            <value>
These points are in digitizer coordinates and are 
set by the "DigCalibrate" command
</value>
        </member>
        <member name="M:RMA.Rhino.IRhinoDigitizerManager.CurrentPlugInID">
            <summary>
Return the UUID for the current digitizer plug-in.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDigitizerManager.IsActive">
            <summary>
true if GetPoint can accept digitizer input
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDigitizerManager.IsPaused">
            <summary>
true if a digitizer is connected and paused
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDigitizerManager.IsCalibrated">
            <summary>
true if a digitizer is connected and calibrated
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDigitizerManager.IsConnected">
            <summary>
true if a digitizer is connected
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDigitizerManager.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
called in CRhinoApp::ExitInstance
</summary>
        </member>
        <member name="P:RMA.Rhino.IRhinoDigitizerManager.m_nFlags">
            <value>
value of nFlags on last point sent to PostDigitizerPointEvent
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoDigitizerManager.m_scale">
            <value>
Digitizer to Rhino scale factor
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoDigitizerManager.m_dig_vector_xform">
            <value>
transforms directions
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoDigitizerManager.m_dig_point_xform">
            <value>
transforms point (has unit system scaling)
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoDigitizerManager.m_rhino_us">
            <value>
This value is set by carefully placed calls to 
GetCurrentModel()-&gt;Settings().m_ModelUnitsAndTolerances.m_unit_system;
bool m_bRhinoRunning; // true after CRhinoApp::InitInstance()
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoDigitizerManager.m_bGetDigClickPoint">
            <value>
true when we are getting 3 raw coord dig calibration pts
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoDigitizerManager.m_dig_tol">
            <value>
in m_dig_us units
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoDigitizerManager.m_dig_us">
            <value>
This information is from m_current_plugin
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoDigitizerManager.m_rhino_origin">
            <value>
These points are in rhino world coordinates and are 
set by the "DigCalibrate" command
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoDigitizerManager.m_dig_origin">
            <value>
These points are in digitizer coordinates and are 
set by the "DigCalibrate" command
</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoZBuffer.GrayscaleDib">
            <summary>
Retrieces the zbuffer in the form of a grayscale
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoZBuffer.WorldPoint(System.Int32,System.Int32)">
            <summary>
Retrieves zbuffer value at (x,y) in world coordinates...
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoZBuffer.ZValue(System.Int32,System.Int32)">
            <summary>
Retrieves the raw zbuffer value at (x,y)...
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoZBuffer.MinZ">
            <summary>
Returns minimum Z value that's &gt; 0.0 within the
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoZBuffer.MaxZ">
            <summary>
Returns maximum Z value that's &lt; 1.0 within the
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoZBuffer.HitCount">
            <summary>
Returns the number of points within the capture
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoZBuffer.CaptureRect">
            <summary>
Returns the current capture rect (area)...
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoZBuffer.Height">
            <summary>
Returns the height of the entire ZBuffer...
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoZBuffer.Width">
            <summary>
Returns the width of the entire ZBuffer...
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoZBuffer.SetDisplayMode(System.Guid)">
            <summary>
Sets display mode used in creating zbuffer...
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoZBuffer.SetProjection(RMA.Rhino.IRhinoViewport)">
            <summary>
Resets zbuffer with viewport projection...
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoZBuffer.SetCaptureRect(System.Drawing.Rectangle)">
            <summary>
Defines the capture area...
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoZBuffer.#ctor(RMA.Rhino.IRhinoViewport)">
            <summary>
Uses passed in viewport projection...
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoZBuffer.#ctor">
            <summary>
Assumes active viewport projection...
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceObject.Explode(RMA.Rhino.ArrayMRhinoInstanceObjectPiece@)">
            <summary>Explodes the instance reference into pieces and add these pieces to piece_list.</summary>
            <param name="piece_list">[out] pieces of the instance reference are appended to this list.</param>
            <returns>Number of pieces appended to piece_list.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceObject.Explode(RMA.Rhino.ArrayMRhinoInstanceObjectPiece@,System.Boolean)">
            <summary>Explodes the instance reference into pieces and add these pieces to piece_list.</summary>
            <param name="piece_list">[out] pieces of the instance reference are appended to this list.</param>
            <param name="bExplodeNestedReferences">
[in] If true, then nested instance references are recursively exploded into until
actual geometry is found.
If false, an CRhinoInstanceReference is added to piece_list when this
CRhinoInstanceObject has nested references.
</param>
            <returns>Number of pieces appended to piece_list.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceObject.UsesDefinition(System.Int32)">
            <summary>Determine if this reference uses an instance definition.</summary>
            <param name="idef_index">[in]</param>
            <returns>
0 no
&gt;=1 This CRhinoInstanceObject uses the instance definition and the returned value is the nesting depth.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoInstanceObject.Explode(RMA.Rhino.ArrayMRhinoInstanceObjectPiece@)">
            <summary>Explodes the instance reference into pieces and add these pieces to piece_list.</summary>
            <param name="piece_list">[out] pieces of the instance reference are appended to this list.</param>
            <returns>Number of pieces appended to piece_list.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoInstanceObject.Explode(RMA.Rhino.ArrayMRhinoInstanceObjectPiece@,System.Boolean)">
            <summary>Explodes the instance reference into pieces and add these pieces to piece_list.</summary>
            <param name="piece_list">[out] pieces of the instance reference are appended to this list.</param>
            <param name="bExplodeNestedReferences">
[in] If true, then nested instance references are recursively exploded into until
actual geometry is found.
If false, an CRhinoInstanceReference is added to piece_list when this
CRhinoInstanceObject has nested references.
</param>
            <returns>Number of pieces appended to piece_list.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoInstanceObject.UsesDefinition(System.Int32)">
            <summary>Determine if this reference uses an instance definition.</summary>
            <param name="idef_index">[in]</param>
            <returns>
0 no
&gt;=1 This CRhinoInstanceObject uses the instance definition and the returned value is the nesting depth.
</returns>
        </member>
        <member name="P:RMA.Rhino.MRhinoInstanceObjectPiece.m_Object">
            <value>
part of document - do NOT modify
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoInstanceObjectPiece.m_atts">
            <value>
attributes to apply
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoInstanceObjectPiece.m_xform">
            <value>
transformation to apply
</value>
        </member>
        <member name="T:RMA.Rhino.MRhinoInstanceObjectPiece">
            <summary>CRhinoInstanceObject::Explode uses CRhinoInstanceObjectPiece to return the pieces.</summary>
        </member>
        <member name="P:RMA.Rhino.IRhinoInstanceObjectPiece.m_Object">
            <value>
part of document - do NOT modify
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoInstanceObjectPiece.m_atts">
            <value>
attributes to apply
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoInstanceObjectPiece.m_xform">
            <value>
transformation to apply
</value>
        </member>
        <member name="T:RMA.Rhino.IRhinoInstanceObjectPiece">
            <summary>CRhinoInstanceObject::Explode uses CRhinoInstanceObjectPiece to return the pieces.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinitionTable.GetUnusedInstanceDefinitionName(System.String@)">
            <summary>
Gets unsed instance definition name used as default when creating new instance definitions.
</summary>
            <param name="result">[out] this is the wString which receives new name</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinitionTable.GetSortedList(RMA.Rhino.IRhinoInstanceDefinition[]@)">
            <summary>
Gets an array of pointers to instance definitions that are sorted by the values of CRhinoInstanceDefinition::m_sort_index.
</summary>
            <param name="sorted_list">
[out] this array is filled in with CRhinoInstanceDefinition pointers sorted
by the values of CRhinoInstanceDefinition::m_sort_index.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinitionTable.GetSortedList(RMA.Rhino.IRhinoInstanceDefinition[]@,System.Boolean)">
            <summary>
Description: Use this to set CRhinoInstanceDefinition::m_sort_index so that the values of m_sort_index run from 0 to InstanceDefinitionCount()-1 and compare( idef_table[i], idef_table[j]) &lt; 0 ) implies idef_table[i].m_sort_index &lt; idef_table[j].m_sort_index. Parameters: compare - [in] compare function with prototype that returns &lt;0 if arg1&lt;arg2, 0 if arg1=arg2, and &gt;0 if arg1&gt;arg2. cull - [in] optional filter function that returns TRUE if the instance definition should be ignored when sorting. Instance definitions that are ignored are not included in the list returned by GetSortedList(). Pass 0 if you do not need to cull instance definitions. p - [in] pointer passed as last argument to compare() and cull(). Remarks: After calling Sort(), you can repeatedly call GetSortedList() to get a sorted list of CRhinoInstanceDefinition pointers. Sort() and GetSortedList() do not modify the order or persistent information in the layer table. They are intended to be used to get sorted lists of instance definitions for dialogs, etc.
</summary>
            <summary>
Description: Use this to set CRhinoInstanceDefinition::m_sort_index so that the values of m_sort_index run from 0 to InstanceDefinitionCount()-1 and compare( idef_table[i], idef_table[j]) &lt; 0 ) implies idef_table[i].m_sort_index &lt; idef_table[j].m_sort_index. Parameters: compare - [in] compare function with prototype that returns &lt;0 if arg1&lt;arg2, 0 if arg1=arg2, and &gt;0 if arg1&gt;arg2. cull - [in] optional filter function that returns TRUE if the instance definition should be ignored when sorting. Instance definitions that are ignored are not included in the list returned by GetSortedList(). Pass 0 if you do not need to cull instance definitions. p - [in] pointer passed as last argument to compare() and cull(). Remarks: After calling Sort(), you can repeatedly call GetSortedList() to get a sorted list of CRhinoInstanceDefinition pointers. Sort() and GetSortedList() do not modify the order or persistent information in the layer table. They are intended to be used to get sorted lists of instance definitions for dialogs, etc.
</summary>
            <summary>
Gets an array of pointers to instance definitions that are sorted by the values of CRhinoInstanceDefinition::m_sort_index.
</summary>
            <param name="sorted_list">
[out] this array is filled in with CRhinoInstanceDefinition pointers sorted
by the values of CRhinoInstanceDefinition::m_sort_index.
</param>
            <param name="bIgnoreDeleted">[in] if TRUE then deleted layers are filtered out.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinitionTable.UpdateLinkedInstanceDefinition(System.Int32,System.String,System.Boolean)">
            <summary>Read the objects from a file and use them as the instance's definition geometry.</summary>
            <param name="idef_index">[in] instance definition index</param>
            <param name="filename">[in] name of file (can be any type of file that Rhino or a plug-in can read).</param>
            <param name="bUpdateNestedLinks">
[in] If true and the instance definition referes to a linked instance definition,
that needs to be updated, then the nested defition is also updated. If false,
nested updates are skipped.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinitionTable.UndeleteInstanceDefinition(System.Int32)">
            <summary>Undeletes an instance definition that has been deleted by DeleteInstanceDefinition().</summary>
            <param name="idef_index">
[in] zero based index of an instance definition to undelete.
This must be in the range 0 &lt;= idef_index &lt; InstanceDefinitionCount().
</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinitionTable.DeleteInstanceDefinition(System.Int32,System.Boolean)">
            <summary>Deletes instance definition.</summary>
            <param name="idef_index">
[in] zero based index of instance definition to delete.
This must be in the range 0 &lt;= idef_index &lt; InstanceDefinitionCount().
</param>
            <param name="bDeleteReferences">
[in] true to delete all references to this definition.
False to delete definition only if there are no references.
</param>
            <returns>
TRUE if successful.
false if the instance definition has active references and bDeleteReferences is false.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinitionTable.DeleteInstanceDefinition(System.Int32,System.Boolean,System.Boolean)">
            <summary>Deletes instance definition.</summary>
            <param name="idef_index">
[in] zero based index of instance definition to delete.
This must be in the range 0 &lt;= idef_index &lt; InstanceDefinitionCount().
</param>
            <param name="bDeleteReferences">
[in] true to delete all references to this definition.
False to delete definition only if there are no references.
</param>
            <param name="bQuiet">
[in] If TRUE, no warning message box appears if an instance definition
cannot be deleted because it is the current layer or it contains active geometry.
</param>
            <returns>
TRUE if successful.
false if the instance definition has active references and bDeleteReferences is false.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinitionTable.ModifyInstanceDefinitionGeometry(System.Int32,RMA.Rhino.IRhinoObject[])">
            <summary>
Modify instance definition geometry and replace all references to the current
definition with references to the new definition.
</summary>
            <param name="idef_index">[in] zero based index of the instance definition to change.</param>
            <param name="new_objects">[in] new geometry for the instance definition.</param>
            <returns>
index of the new definition or -1 if it fails
See Also: CRhinoInstanceDefinitionTable::ModifyInstanceDefinitionGeometry
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinitionTable.ModifyInstanceDefinitionGeometry(System.Int32,RMA.Rhino.IRhinoObject[],System.Boolean)">
            <summary>
Modify instance definition geometry and replace all references to the current
definition with references to the new definition.
</summary>
            <param name="idef_index">[in] zero based index of the instance definition to change.</param>
            <param name="new_objects">[in] new geometry for the instance definition.</param>
            <param name="bQuiet">[in] if TRUE, information message boxes pop up when illegal changes are attempted.</param>
            <returns>
index of the new definition or -1 if it fails
See Also: CRhinoInstanceDefinitionTable::ModifyInstanceDefinitionGeometry
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinitionTable.UndoModifyInstanceDefinition(System.Int32)">
            <summary>
If the instance definition has been modified and the modifcation can be undone,
then UndoModifyInstanceDefinition() will restore the instance definition to its previous state.
</summary>
            <returns>TRUE if this layer had been modified and the modifications were undone.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinitionTable.UndoModifyInstanceDefinition(System.Int32,System.UInt32)">
            <summary>
If the instance definition has been modified and the modifcation can be undone,
then UndoModifyInstanceDefinition() will restore the instance definition to its previous state.
</summary>
            <returns>TRUE if this layer had been modified and the modifications were undone.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinitionTable.ModifyInstanceDefinition(RMA.OpenNURBS.IOnInstanceDefinition,System.Int32,System.UInt32,System.Boolean)">
            <summary>
Modify instance definition settings (name, url, description). Does not change
instance defintion uuid or geometry.
</summary>
            <param name="idef_settings">[in] new settings. (The uuid list is ignored.)</param>
            <param name="idef_index">
[in] zero based index of layer to set.
This must be in the range 0 &lt;= layer_index &lt; LayerCount().
</param>
            <param name="modify_field_mask">
[in] Bitfield with values from ON_InstanceDefinition::idef_*_settings enum.
If a bit is set, then the corresponding values in idef_settings are used to
modify the instance definition.
</param>
            <param name="bQuiet">
[in] if TRUE, information message boxes pop up when illegal changes are attempted.
</param>
            <returns>
TRUE if successful.
FALSE if layer_index is out of range or the settings attempt to lock or hide the current layer.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinitionTable.AddInstanceDefinition(RMA.OpenNURBS.IOnInstanceDefinition,RMA.Rhino.IRhinoObject[])">
            <summary>Add an instance definition to the instance definition table.</summary>
            <param name="idef">[in] The UUID in idef is ignored.</param>
            <param name="objects">[in] will be moved to instance geometry list</param>
            <returns>
-1 failure
&gt;=0 index of instance definition in the instance definition table.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinitionTable.AddInstanceDefinition(RMA.OpenNURBS.IOnInstanceDefinition,RMA.Rhino.IRhinoObject[],System.Boolean)">
            <summary>Add an instance definition to the instance definition table.</summary>
            <param name="idef">[in] The UUID in idef is ignored.</param>
            <param name="objects">[in] will be moved to instance geometry list</param>
            <param name="bReference">[in] true if this is from a reference file</param>
            <returns>
-1 failure
&gt;=0 index of instance definition in the instance definition table.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinitionTable.AddInstanceDefinition(RMA.OpenNURBS.IOnInstanceDefinition,RMA.Rhino.IRhinoObject[],System.Boolean,System.Boolean)">
            <summary>Add an instance definition to the instance definition table.</summary>
            <param name="idef">[in] The UUID in idef is ignored.</param>
            <param name="objects">[in] will be moved to instance geometry list</param>
            <param name="bReference">[in] true if this is from a reference file</param>
            <param name="bQuiet">[in] true if errors should be silent</param>
            <returns>
-1 failure
&gt;=0 index of instance definition in the instance definition table.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinitionTable.AddInstanceDefinition(RMA.OpenNURBS.IOnInstanceDefinition,RMA.Rhino.IRhinoObject)">
            <summary>Add an instance definition to the instance definition table.</summary>
            <param name="idef">[in] the UUID in idef is ignored.</param>
            <param name="object">[in] will be moved to instance geometry list</param>
            <returns>
-1 failure
&gt;=0 index of instance definition in the instance definition table.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinitionTable.AddInstanceDefinition(RMA.OpenNURBS.IOnInstanceDefinition,RMA.Rhino.IRhinoObject,System.Boolean)">
            <summary>Add an instance definition to the instance definition table.</summary>
            <param name="idef">[in] the UUID in idef is ignored.</param>
            <param name="object">[in] will be moved to instance geometry list</param>
            <param name="bReference">[in] true if this is from a reference file</param>
            <returns>
-1 failure
&gt;=0 index of instance definition in the instance definition table.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinitionTable.AddInstanceDefinition(RMA.OpenNURBS.IOnInstanceDefinition,RMA.Rhino.IRhinoObject,System.Boolean,System.Boolean)">
            <summary>Add an instance definition to the instance definition table.</summary>
            <param name="idef">[in] the UUID in idef is ignored.</param>
            <param name="object">[in] will be moved to instance geometry list</param>
            <param name="bReference">[in] true if this is from a reference file</param>
            <param name="bQuiet">[in] true if errors should be silent</param>
            <returns>
-1 failure
&gt;=0 index of instance definition in the instance definition table.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinitionTable.AddInstanceDefinition(RMA.OpenNURBS.IOnInstanceDefinition)">
            <summary>Add an instance definition to the instance definition table.</summary>
            <param name="idef">[in] the UUID in idef is used to find the objects</param>
            <returns>
-1 failure
&gt;=0 index of instance definition in the instance definition table.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinitionTable.AddInstanceDefinition(RMA.OpenNURBS.IOnInstanceDefinition,System.Boolean)">
            <summary>Add an instance definition to the instance definition table.</summary>
            <param name="idef">[in] the UUID in idef is used to find the objects</param>
            <param name="bReference">[in] true if this is from a reference file</param>
            <returns>
-1 failure
&gt;=0 index of instance definition in the instance definition table.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinitionTable.AddInstanceDefinition(RMA.OpenNURBS.IOnInstanceDefinition,System.Boolean,System.Boolean)">
            <summary>Add an instance definition to the instance definition table.</summary>
            <param name="idef">[in] the UUID in idef is used to find the objects</param>
            <param name="bReference">[in] true if this is from a reference file</param>
            <param name="bQuiet">[in] true if errors should be silent</param>
            <returns>
-1 failure
&gt;=0 index of instance definition in the instance definition table.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinitionTable.FindInstanceDefinition(System.Guid)">
            <summary>Finds the instance definition with a given name.</summary>
            <param name="idef_uuid">
[in] Unique id of the instance definition to search for. The search ignores case.
</param>
            <returns>
&gt;=0 index of the instance definition with the given name
-1 no instance definition has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinitionTable.FindInstanceDefinition(System.Guid,System.Boolean)">
            <summary>Finds the instance definition with a given name.</summary>
            <param name="idef_uuid">
[in] Unique id of the instance definition to search for. The search ignores case.
</param>
            <param name="bIgnoreDeletedInstanceDefs">
[in] true means don't search deleted instance definitions.
</param>
            <returns>
&gt;=0 index of the instance definition with the given name
-1 no instance definition has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinitionTable.FindInstanceDefinition(System.String)">
            <summary>Finds the instance definition with a given name.</summary>
            <param name="idef_name">[in] name of instance definition to search for. The search ignores case.</param>
            <returns>
&gt;=0 index of the instance definition with the given name
-1 no instance definition has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinitionTable.FindInstanceDefinition(System.String,System.Boolean)">
            <summary>Finds the instance definition with a given name.</summary>
            <param name="idef_name">[in] name of instance definition to search for. The search ignores case.</param>
            <param name="bIgnoreDeletedInstanceDefs">
[in] true means don't search deleted instance definitions.
</param>
            <returns>
&gt;=0 index of the instance definition with the given name
-1 no instance definition has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinitionTable.InstanceDefinitionCount">
            <summary>
Returns: Number of items in the instance definitions table, including deleted layers.
</summary>
        </member>
        <member name="P:RMA.Rhino.MRhinoInstanceDefinitionTable.Item(System.Int32)">
            <summary>
Conceptually, the instance definition table is an array of InstanceDefinitionCount() idefs.
The operator[] can be used to get individual instance definitions.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoInstanceDefinitionTable.GetUnusedInstanceDefinitionName(System.String@)">
            <summary>
Gets unsed instance definition name used as default when creating new instance definitions.
</summary>
            <param name="result">[out] this is the wString which receives new name</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoInstanceDefinitionTable.GetSortedList(RMA.Rhino.IRhinoInstanceDefinition[]@)">
            <summary>
Gets an array of pointers to instance definitions that are sorted by the values of CRhinoInstanceDefinition::m_sort_index.
</summary>
            <param name="sorted_list">
[out] this array is filled in with CRhinoInstanceDefinition pointers sorted
by the values of CRhinoInstanceDefinition::m_sort_index.
</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoInstanceDefinitionTable.GetSortedList(RMA.Rhino.IRhinoInstanceDefinition[]@,System.Boolean)">
            <summary>
Gets an array of pointers to instance definitions that are sorted by the values of CRhinoInstanceDefinition::m_sort_index.
</summary>
            <param name="sorted_list">
[out] this array is filled in with CRhinoInstanceDefinition pointers sorted
by the values of CRhinoInstanceDefinition::m_sort_index.
</param>
            <param name="bIgnoreDeleted">[in] if TRUE then deleted layers are filtered out.</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoInstanceDefinitionTable.FindInstanceDefinition(System.Guid)">
            <summary>Finds the instance definition with a given name.</summary>
            <param name="idef_uuid">
[in] Unique id of the instance definition to search for. The search ignores case.
</param>
            <returns>
&gt;=0 index of the instance definition with the given name
-1 no instance definition has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoInstanceDefinitionTable.FindInstanceDefinition(System.Guid,System.Boolean)">
            <summary>Finds the instance definition with a given name.</summary>
            <param name="idef_uuid">
[in] Unique id of the instance definition to search for. The search ignores case.
</param>
            <param name="bIgnoreDeletedInstanceDefs">
[in] true means don't search deleted instance definitions.
</param>
            <returns>
&gt;=0 index of the instance definition with the given name
-1 no instance definition has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoInstanceDefinitionTable.FindInstanceDefinition(System.String)">
            <summary>Finds the instance definition with a given name.</summary>
            <param name="idef_name">[in] name of instance definition to search for. The search ignores case.</param>
            <returns>
&gt;=0 index of the instance definition with the given name
-1 no instance definition has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoInstanceDefinitionTable.FindInstanceDefinition(System.String,System.Boolean)">
            <summary>Finds the instance definition with a given name.</summary>
            <param name="idef_name">[in] name of instance definition to search for. The search ignores case.</param>
            <param name="bIgnoreDeletedInstanceDefs">
[in] true means don't search deleted instance definitions.
</param>
            <returns>
&gt;=0 index of the instance definition with the given name
-1 no instance definition has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoInstanceDefinitionTable.InstanceDefinitionCount">
            <value>
Description: Layer tables store the list of layers in a Rhino document. Returns: CRhinoDocument that owns this layer table.
</value>
            <summary>
Returns: Number of items in the instance definitions table, including deleted layers.
</summary>
        </member>
        <member name="P:RMA.Rhino.IRhinoInstanceDefinitionTable.Item(System.Int32)">
            <summary>
Conceptually, the instance definition table is an array of InstanceDefinitionCount() idefs.
The operator[] can be used to get individual instance definitions.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinition.RemoveLinetypeReference(System.Int32)">
            <summary>
Change all of the objects in the block to use continuous linetype instead
of the one in the linetype table at linetype_index
Does not change layers referenced by the block even if they reference the linetype.
Doesn't remove references to table[0] (continuous)
</summary>
            <param name="linetype_index">[in] index of linetype to search for</param>
            <returns>
true: success
false: failure
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinition.UsesLinetype(System.Int32)">
            <summary>
Returns true if some object in the instance defintion references the
linetype with index linetype_index.
</summary>
            <param name="linetype_index">[in] index of linetype to search for</param>
            <returns>True if there is an object in the instance defintion that references that linetype.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinition.UsesLayer(System.Int32)">
            <summary>
Returns true if some object in the instance defintion is on the layer with index layer_index.
</summary>
            <param name="layer_index">[in] index of layer to search for</param>
            <returns>True if there is an object in the instance defintion that is on the layer.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinition.Index">
            <summary>
index of this instance definition in the index definition table.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinition.InUse(System.Int32)">
            <param name="where_to_look">
0 = check for top level references in active document
1 = check for top level and nested references in active document
2 = check for references in other instance definitions
</param>
            <returns>
True if the instance definition is refereneced.
See Also: CRhinoInstanceDefinition::GetReferences
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinition.UsesDefinition(System.Int32)">
            <summary>
Determine if this instance definition contains a reference to another instance definition.
</summary>
            <param name="other_idef_index">[in] index of another instance definition</param>
            <returns>
0 no
1 other_idef_index is the index of this instance definition
&gt;1 This CRhinoInstanceDefinition uses the instance definition and
    the returned value is the nesting depth.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinition.GetContainers(RMA.Rhino.IRhinoInstanceDefinition[]@)">
            <summary>
Get a list of all the CRhinoInstanceDefinitions that contain a reference this instance definition.
</summary>
            <param name="idef_list">[out]</param>
            <returns>
number of objects added to the list.
See Also: CRhinoInstanceDefinition::GetObjects
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinition.GetReferences(RMA.Rhino.IRhinoInstanceObject[]@)">
            <summary>
Get a list of the CRhinoInstanceObjects (inserts) that contains a reference
this instance definition.
</summary>
            <param name="iref_object_list">[out]</param>
            <returns>
number of objects added to the list.
See Also: CRhinoInstanceDefinition::GetObjects
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinition.GetReferences(RMA.Rhino.IRhinoInstanceObject[]@,System.Int32)">
            <summary>
Get a list of the CRhinoInstanceObjects (inserts) that contains a reference
this instance definition.
</summary>
            <param name="iref_object_list">[out]</param>
            <param name="where_to_look">
0 = get top level references in active document
1 = get top level and nested references in active document
2 = check for references from other instance definitions
</param>
            <returns>
number of objects added to the list.
See Also: CRhinoInstanceDefinition::GetObjects
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinition.GetObjects(RMA.Rhino.IRhinoObject[]@)">
            <summary>
Get a list of the objects that belong to this instance definition.
These objects are stored in the CRhinoDoc::m_instance_geometry list.
</summary>
            <param name="objects">[out]</param>
            <returns>
number of objects in list.
See Also: CRhinoInstanceDefinition::GetReferences
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinition.Object(System.Int32)">
            <param name="index">[in] 0 &lt;= index &lt; ObjectCount()</param>
            <returns>Pointer to an object used as part of this definition.</returns>
            <remarks>
This returns an object that is used to define the geometry. This does
NOT return an object that references this definition.count the number
of references to this instance
See Also: CRhinoInstanceDefinition::GetReferences CRhinoInstanceDefinition::GetObjects
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoInstanceDefinition.ObjectCount">
            <returns>Number of objects this definition uses.</returns>
            <remarks>
This counts the objects that are used to define the geometry.
This does NOT count the number of references to this instance definition.
See Also: CRhinoInstanceDefinition::GetReferences CRhinoInstanceDefinition::GetObjects
</remarks>
        </member>
        <member name="P:RMA.Rhino.MRhinoInstanceDefinition.m_remap_index">
            <value>
Runtime index used when remapping for import/export
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoInstanceDefinition.m_sort_index">
            <value>
Runtime index used to sort these in the dialog
</value>
        </member>
        <member name="T:RMA.Rhino.MRhinoInstanceDefinition">
            <summary>This is a list of the actual geometry that CRhinoInstanceObjects reference.</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoInstanceDefinition.UsesLinetype(System.Int32)">
            <summary>
Returns true if some object in the instance defintion references the
linetype with index linetype_index.
</summary>
            <param name="linetype_index">[in] index of linetype to search for</param>
            <returns>True if there is an object in the instance defintion that references that linetype.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoInstanceDefinition.UsesLayer(System.Int32)">
            <summary>
Returns true if some object in the instance defintion is on the layer with index layer_index.
</summary>
            <param name="layer_index">[in] index of layer to search for</param>
            <returns>True if there is an object in the instance defintion that is on the layer.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoInstanceDefinition.Index">
            <summary>
index of this instance definition in the index definition table.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoInstanceDefinition.InUse(System.Int32)">
            <param name="where_to_look">
0 = check for top level references in active document
1 = check for top level and nested references in active document
2 = check for references in other instance definitions
</param>
            <returns>
True if the instance definition is refereneced.
See Also: CRhinoInstanceDefinition::GetReferences
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoInstanceDefinition.UsesDefinition(System.Int32)">
            <summary>
Determine if this instance definition contains a reference to another instance definition.
</summary>
            <param name="other_idef_index">[in] index of another instance definition</param>
            <returns>
0 no
1 other_idef_index is the index of this instance definition
&gt;1 This CRhinoInstanceDefinition uses the instance definition and
    the returned value is the nesting depth.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoInstanceDefinition.GetContainers(RMA.Rhino.IRhinoInstanceDefinition[]@)">
            <summary>
Get a list of all the CRhinoInstanceDefinitions that contain a reference this instance definition.
</summary>
            <param name="idef_list">[out]</param>
            <returns>
number of objects added to the list.
See Also: CRhinoInstanceDefinition::GetObjects
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoInstanceDefinition.GetReferences(RMA.Rhino.IRhinoInstanceObject[]@)">
            <summary>
Get a list of the CRhinoInstanceObjects (inserts) that contains a reference
this instance definition.
</summary>
            <param name="iref_object_list">[out]</param>
            <returns>
number of objects added to the list.
See Also: CRhinoInstanceDefinition::GetObjects
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoInstanceDefinition.GetReferences(RMA.Rhino.IRhinoInstanceObject[]@,System.Int32)">
            <summary>
Get a list of the CRhinoInstanceObjects (inserts) that contains a reference
this instance definition.
</summary>
            <param name="iref_object_list">[out]</param>
            <param name="where_to_look">
0 = get top level references in active document
1 = get top level and nested references in active document
2 = check for references from other instance definitions
</param>
            <returns>
number of objects added to the list.
See Also: CRhinoInstanceDefinition::GetObjects
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoInstanceDefinition.GetObjects(RMA.Rhino.IRhinoObject[]@)">
            <summary>
Get a list of the objects that belong to this instance definition.
These objects are stored in the CRhinoDoc::m_instance_geometry list.
</summary>
            <param name="objects">[out]</param>
            <returns>
number of objects in list.
See Also: CRhinoInstanceDefinition::GetReferences
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoInstanceDefinition.Object(System.Int32)">
            <param name="index">[in] 0 &lt;= index &lt; ObjectCount()</param>
            <returns>Pointer to an object used as part of this definition.</returns>
            <remarks>
This returns an object that is used to define the geometry. This does
NOT return an object that references this definition.count the number
of references to this instance
See Also: CRhinoInstanceDefinition::GetReferences CRhinoInstanceDefinition::GetObjects
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoInstanceDefinition.ObjectCount">
            <returns>Number of objects this definition uses.</returns>
            <remarks>
This counts the objects that are used to define the geometry.
This does NOT count the number of references to this instance definition.
See Also: CRhinoInstanceDefinition::GetReferences CRhinoInstanceDefinition::GetObjects
</remarks>
        </member>
        <member name="P:RMA.Rhino.IRhinoInstanceDefinition.m_remap_index">
            <value>
Runtime index used when remapping for import/export
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoInstanceDefinition.m_sort_index">
            <value>
Runtime index used to sort these in the dialog
</value>
        </member>
        <member name="T:RMA.Rhino.IRhinoInstanceDefinition">
            <summary>This is a list of the actual geometry that CRhinoInstanceObjects reference.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.GetWindowAreaWidth">
            <summary>Return Window Area Size</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.SetWindowRect(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Defines the window print area rectangle.</summary>
            <param name="corner1">[in] world coordinate corner first pick for defining the window rectangle</param>
            <param name="corner2">[in] world coordinate corner second pick for defining the window rectangle</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.GetPreviewLayout(System.Drawing.Size,RMA.Rhino.MRhinoPrintInfo@)">
            <summary>
Create a layout info that is based on this layout info but sized to fit inside
a preview area. Used by the print preview window to generate a preview image
</summary>
            <param name="preview_area">[in] size to fit the layout info inside of</param>
            <param name="preview">[out] sized layout for preview purposes</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.GetTileViewport(RMA.OpenNURBS.IOnViewport,RMA.OpenNURBS.OnViewport@,System.Drawing.Rectangle)">
            <summary>Used by DrawTileToDib to create tile viewports from a large single viewport</summary>
            <param name="full_viewport">[in] large single viewport that tiles are taken from</param>
            <param name="tile_viewport">[out] sub portion of the full viewport</param>
            <param name="tile_rect">[in] </param>
            <returns>true on success</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.GetScreenRects(System.Drawing.Rectangle@,System.Drawing.Rectangle@,System.Drawing.Rectangle@)">
            <summary>
Get the rectangles in screen space coordinates. This is used by the print dialog during
window selection of the print area to show preview rectangles on the view.
</summary>
            <param name="paper">[out] the full page rectangle</param>
            <param name="available">[out] the portion of the paper that can drawn/printed to. Always inside paper rectangle</param>
            <param name="draw">[out] defined area the will be drawn/printed to. Always inside available rectangle</param>
            <returns>true if the layout is valid and was able to successfully return rectangles</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.GetDeviceTile(System.Drawing.Rectangle)">
            <summary>
Creates a rectangle that represents an image tile on the output device.
This tile is at full resolution and positioned relative to the output
device available print rectangle (m_available_print_rect)
</summary>
            <param name="tile_rect">
[in] tile relative to the draw rect and scaled down by the
scale factor (typically from the GetTile functions.)
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.GetTile(System.Int32)">
            <summary>
Shaded/Rendered viewports are printed as a series of tileds bitmaps using the
display pipeline's graphics technology (i.e. OpenGL or DirectX).
These technologies are designed for drawing to an area the size of a screen,
so tiles are kept to these sizes and a final bitmap is constructed from the tiles.

Same as GetTile(row,column), but addresses the tile by index number. This
way you can do the following:
 for(int i=0; i&lt;GetTileCount(); i++){
   CRect tile_rect = GetTile(i);
   ...
 }
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.GetTile(System.Int32,System.Int32)">
            <summary>
Shaded/Rendered viewports are printed as a series of tileds bitmaps using the
display pipeline's graphics technology (i.e. OpenGL or DirectX).
These technologies are designed for drawing to an area the size of a screen,
so tiles are kept to these sizes and a final bitmap is constructed from the tiles.

Get a rectangle that represents a subtile of the entire image. Tiles are
in a coordinate system local to the m_draw_rect and scaled to the scale
factor. This means Tile(0,0) will always have a top,left value of 0,0 and
this maps to the top,left corner of the draw rectangle.
</summary>
            <param name="row">[in] position of tile to retrieve</param>
            <param name="column">[in] position of tile to retrieve</param>
            <returns>tile rectangle on success. empty rectangle on failure</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.GetTileCount">
            <summary>
Shaded/Rendered viewports are printed as a series of tileds bitmaps using the
display pipeline's graphics technology (i.e. OpenGL or DirectX).
These technologies are designed for drawing to an area the size of a screen,
so tiles are kept to these sizes and a final bitmap is constructed from the tiles.

Get number of tiles required to create a tiled image at the current settings.
Tile size is based on drawing size, target dpi, and preferred tile height/width
</summary>
            <returns>total number of tiles on success. 0 if an error occurs</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.GetTileCount(System.Int32@)">
            <summary>
Shaded/Rendered viewports are printed as a series of tileds bitmaps using the
display pipeline's graphics technology (i.e. OpenGL or DirectX).
These technologies are designed for drawing to an area the size of a screen,
so tiles are kept to these sizes and a final bitmap is constructed from the tiles.

Get number of tiles required to create a tiled image at the current settings.
Tile size is based on drawing size, target dpi, and preferred tile height/width
</summary>
            <param name="rows">[out] if not NULL, the number of tiles vertical</param>
            <returns>total number of tiles on success. 0 if an error occurs</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.GetTileCount(System.Int32@,System.Int32@)">
            <summary>
Shaded/Rendered viewports are printed as a series of tileds bitmaps using the
display pipeline's graphics technology (i.e. OpenGL or DirectX).
These technologies are designed for drawing to an area the size of a screen,
so tiles are kept to these sizes and a final bitmap is constructed from the tiles.

Get number of tiles required to create a tiled image at the current settings.
Tile size is based on drawing size, target dpi, and preferred tile height/width
</summary>
            <param name="rows">[out] if not NULL, the number of tiles vertical</param>
            <param name="columns">[out] if not NULL, the number of tiles across</param>
            <returns>total number of tiles on success. 0 if an error occurs</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.GetPreferredTileSize(System.Int32@,System.Int32@)">
            <summary>
Shaded/Rendered viewports are printed as a series of tileds bitmaps using the
display pipeline's graphics technology (i.e. OpenGL or DirectX).
These technologies are designed for drawing to an area the size of a screen,
so tiles are kept to these sizes and a final bitmap is constructed from the tiles.

Get the preferred tile size for tiled image generation. The width and height must
be less than the desktop size in order to allow for accelerated graphics.
</summary>
            <param name="width">[out] preferred tile size in pixels</param>
            <param name="height">[out] preferred tile size in pixels</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.DrawHeaderAndFooter(System.Drawing.IDeviceContext)">
            <summary>
Uses GDI to draw m_HeaderText and m_FooterText on top of the final image.
This should be called after calling the above Draw routines
</summary>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.DrawWithGDI(System.Drawing.IDeviceContext)">
            <summary>Draws a display pipeline to a printer using GDI</summary>
            <param name="draw_dc">[in] The device context to draw to. This could be a printer or a DIB.</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.DrawWithGDI(System.Drawing.IDeviceContext,RMA.Rhino.IDisplayPipelineAttributes)">
            <summary>Draws a display pipeline to a printer using GDI</summary>
            <param name="draw_dc">[in] The device context to draw to. This could be a printer or a DIB.</param>
            <param name="attrib">
[in] display attributes to use for drawing. If NULL, the values from CRhinoPrintInfo::DisplayAttributes() are used
</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.DrawWithGDI(System.Drawing.IDeviceContext,RMA.Rhino.IDisplayPipelineAttributes,System.Boolean)">
            <summary>Draws a display pipeline to a printer using GDI</summary>
            <param name="draw_dc">[in] The device context to draw to. This could be a printer or a DIB.</param>
            <param name="attrib">
[in] display attributes to use for drawing. If NULL, the values from CRhinoPrintInfo::DisplayAttributes() are used
</param>
            <param name="printer_output">
[in] Use styles in print info that draw to DC as if it was being sent to a printer
</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.DrawTileToDib(RMA.UI.MRhinoUiDib@,System.Drawing.Rectangle,RMA.Rhino.IRhinoViewport,RMA.Rhino.MRhinoDisplayPipeline,RMA.Rhino.MDisplayPipelineAttributes)">
            <summary>
Draws a sub-rect area of the full printable area rectangle. Tiled drawing is used for generating
large images from hardware accelerated graphics. Graphics cards have a limited area that they
can reasonably render to (typically screen resolution). This is called by the DrawToSingleDib
function and directly from printing code to send smaller bitmaps to the printer.
</summary>
            <param name="tile_dib">[out] the dib to draw to</param>
            <param name="tile_rect">[in] portion of printable area to draw</param>
            <param name="full_vp">[in] viewport that we are using to get geometry and projection information from</param>
            <param name="pPipeline">[in] display pipeline to use for drawing</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.DrawToSingleDib(RMA.UI.MRhinoUiDib@)">
            <summary>
Draw the layout to a single DIB. This is all done in memory, so make sure that the resulting
DIB is not too large. Tiled drawing may occur if the DIB is larger than the screen resolution,
but this is handled internally by this function. This version of the function just "cooks" up
the appropriate display pipelines and attributes and calls the other version of this function.
</summary>
            <param name="full_dib">[out] the dib to draw to</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.DrawToSingleDib(RMA.UI.MRhinoUiDib@,System.Boolean)">
            <summary>
Draw the layout to a single DIB. This is all done in memory, so make sure that the resulting
DIB is not too large. Tiled drawing may occur if the DIB is larger than the screen resolution,
but this is handled internally by this function. This version of the function just "cooks" up
the appropriate display pipelines and attributes and calls the other version of this function.
</summary>
            <param name="full_dib">[out] the dib to draw to</param>
            <param name="force_GDI_pipeline">
[in] if set to true, drawing is performed using a GDI display pipeline and
not the pipeline attached to the viewport (which may or may not be GDI).
</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.DrawToSingleDib(RMA.UI.MRhinoUiDib@,System.Boolean,System.Boolean)">
            <summary>
Draw the layout to a single DIB. This is all done in memory, so make sure that the resulting
DIB is not too large. Tiled drawing may occur if the DIB is larger than the screen resolution,
but this is handled internally by this function. This version of the function just "cooks" up
the appropriate display pipelines and attributes and calls the other version of this function.
</summary>
            <param name="full_dib">[out] the dib to draw to</param>
            <param name="force_GDI_pipeline">
[in] if set to true, drawing is performed using a GDI display pipeline and
not the pipeline attached to the viewport (which may or may not be GDI).
</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.DrawToSingleDib(RMA.UI.MRhinoUiDib@,RMA.Rhino.IDisplayPipelineAttributes,RMA.Rhino.IRhinoDisplayPipeline,System.Boolean)">
            <summary>
Draw the layout to a single DIB. This is all done in memory, so make sure that the resulting
DIB is not too large. Tiled drawing may occur if the DIB is larger than the screen resolution,
but this is handled internally by this function.
</summary>
            <param name="full_dib">[out] the dib to draw to</param>
            <param name="pAttributes">
[in] display attributes to use for drawing (typically from CRhinoPrintInfo::DisplayAttributes())
</param>
            <param name="pPipeline">[in] Display Pipeline to base drawing off of.</param>
            <param name="force_GDI_pipeline">
[in] if set to true, drawing is performed using a GDI display pipeline.
</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.GetPrintColor(RMA.Rhino.IRhinoObjectAttributes)">
            <summary>
Gets the color used for drawing an object with the current print info's settings
</summary>
            <param name="pAttributes">[in] rhino object attributes to use for getting color</param>
            <returns>The Color for the object</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.GetPrintWeight(RMA.Rhino.IRhinoObjectAttributes)">
            <summary>
Gets the weight used for drawing an object with the current print info's settings
</summary>
            <param name="pAttributes">[in] rhino object attributes to use for getting weight</param>
            <returns>
-1 if the object has "No Plot" set weight
otherwise, return a value greater than zero describing the weight used for draw functions
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.GetAvailableSize(RMA.OpenNURBS.IOn.unit_system,System.Double@,System.Double@)">
            <summary>
Get the size of the printed output paper available output area in a specified unit system. Custom
units are not allowed.
</summary>
            <param name="units">[in] unit system for the output sizes. custom units are not allowed</param>
            <param name="width">[out] size of output paper on success</param>
            <param name="height">[out] size of output paper on success</param>
            <returns>true on success, false on failure</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.GetPaperSize(RMA.OpenNURBS.IOn.unit_system,System.Double@,System.Double@)">
            <summary>
Get the size of the printed output paper in a specified unit system. Custom
units are not allowed.
</summary>
            <param name="units">[in] unit system for the output sizes. custom units are not allowed</param>
            <param name="width">[out] size of output paper on success</param>
            <param name="height">[out] size of output paper on success</param>
            <returns>true on success, false on failure</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.DrawAspectRatio">
            <summary>
returns the width/height of the currently defined draw area
0.0 if the draw area is not defined or invalid
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.PaperAspectRatio">
            <summary>
returns the width/height of the currently defined paper area
0.0 if the paper area is not defined or invalid
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.CreateDeviceViewport">
            <summary>
Creates a CRhinoViewport mapped to the output device with the appropriate view_area settings.
NOTE: you MUST delete the returned CRhinoViewport when you are done with it.
</summary>
            <returns>
a CRhinoViewport on success
NULL on failure
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.GetDeviceViewport(RMA.OpenNURBS.OnViewport@)">
            <summary>
Sets up an ON_Viewport that would be used for printing. This is the core function used to
get all of the information stored in this class and generate a viewport mapped to an output device.
</summary>
            <param name="viewport">
[out] this will get set up with the projection information for an output device if the function is successful
</param>
            <returns>true on success</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.GetMarginLimits(System.Boolean,RMA.OpenNURBS.IOn.unit_system,System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>
Get minimum/maximum print margins available for this page.
Margins are always measured from the edge of the page
</summary>
            <param name="minimum">[in] return minimum margins if true (otherwise maximum margins)</param>
            <param name="units">[in] units to return margins in</param>
            <param name="left">[out] the margins to return</param>
            <param name="right">[out] the margins to return</param>
            <param name="top">[out] the margins to return</param>
            <param name="bottom">[out] the margins to return</param>
            <returns>
true if successful
false if unsuccessful (this could happen if there is no set device_dpi)
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.GetMargins(RMA.OpenNURBS.IOn.unit_system,System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>Margins are always measured from the edge of the page (m_paper_rect)</summary>
            <param name="units">[in] units to return margins in</param>
            <param name="left">[out] the margins to return</param>
            <param name="right">[out] the margins to return</param>
            <param name="top">[out] the margins to return</param>
            <param name="bottom">[out] the margins to return</param>
            <returns>
true if successful
false if unsuccessful (this could happen if there is no set device_dpi)
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.StretchFactor">
            <summary>
Get factor used to scale tiles at the target DPI up to the device DPI
Images may be generated at a lower resolution than the device DPI and then
stretch blitted up to the device resolution.
DeviceDPI / StretchFactor = the resolution that images are being generated at
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.DisplayAttributes">
            <summary>
A CRhinoPrintInfo's display attributes are based on it's CRhinoViewport with
a few possible overrides that are specific to this layout (background, grid, axis)
</summary>
            <returns>display attributes specific to this CRhinoPrintInfo</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.UpdateFromPrinterDC(System.Drawing.IDeviceContext,System.Boolean)">
            <summary>Update the layout rectangles and dpi settings to match a printer dc</summary>
            <param name="printer_dc">
[in] device context for the printer this layout will probably be eventually sent to
</param>
            <param name="maintain_margins">
[in] set the m_draw_rect to keep the same margins as are currently set
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.MaximizeDrawRect">
            <summary>
Sets the draw rect equal to the available rect. This sets the drawable area to the
maximum available with the current settings.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.SetLayoutRectangles(System.Drawing.Rectangle)">
            <summary>
Set up the rectangles used to define the output image. This function
is used for image file output because there typically is no "unprintable"
portion for the output
</summary>
            <param name="rect">
[in] used for the paper rect, available rect, and draw rect
all three rects are set to the same size. The rectangles are
defined in dot positions on a printed page (no implied unit system)
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.GetRhinoViewport">
            <summary>Get the CRhinoViewport that this info is set up to print.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.SetViewport(RMA.Rhino.IRhinoViewport)">
            <summary>
Set the CRhinoViewport that this layout info is based off of.
Make sure that pViewport is valid during the entire scope of this info object
</summary>
            <param name="pViewport">[in] the viewport to use</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.SetViewport(System.Guid@)">
            <summary>
Set the CRhinoViewport that this info is based off of. This version only
works with CRhinoViewports that are "attached" to CRhinoViews since it needs to 
look up CRhinoViewports from the available view list.
</summary>
            <param name="viewport_id">
[in] unique ID of an existing CRhinoViewport. This can be
extracted from a viewport through CRhinoViewport::ViewportId()
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.IsValid">
            <summary>Determines if this has valid rectangles and a CRhinoViewport to work with</summary>
            <returns>true if this is a valid CRhinoPrintInfo</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPrintInfo.#ctor">
            <summary>
Create an invalid info that needs to be filled
</summary>
        </member>
        <member name="P:RMA.Rhino.MRhinoPrintInfo.m_maximum_dpi">
            <value>
Resolution cap when generating rester output. Images are stretched to
m_device_dpi when m_device_dpi &gt; m_maximum_dpi
Many photo printers have default resolutions of around 1200 dpi
which would demand enormous image size requirements if printing at full resolution
default DPI resolutions are set at 300 DPI. 
Personal Opinion (S. Baer):
 300DPI is a great setting for almost all prints
 600DPI looks only slightly better (but not worth 4x memory use)
 I can't see the difference between 600DPI and 1200 DPI
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoPrintInfo.m_device_dpi">
            <value>
The actual dot per inch resolution of the final output. This is the resolution
of the selected printer when sending an image to a printer. For raster image files,
this is used to determine image space sizes (things like line witdhs)
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoPrintInfo.m_draw_rect">
            <value>
location on m_paper_rect that image is drawn to in dots
this recangle holds information about where to draw and
what the margins are.
m_draw_rect must always be inside of m_available_print_rect
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoPrintInfo.m_available_print_rect">
            <value>
maximum portion of paper that can be drawn to
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoPrintInfo.m_paper_rect">
            <value>
physical size of paper in dots (no margins - the actual paper)
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoPrintInfo.m_FooterText">
            <value>
If we want to put text on top of the print assign it to the header and footer text
#NOTES# will be replaced with the document notes
#FILENAME# will be replaced with the document filename
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoPrintInfo.m_HeaderText">
            <value>
If we want to put text on top of the print assign it to the header and footer text
#NOTES# will be replaced with the document notes
#FILENAME# will be replaced with the document filename
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoPrintInfo.m_bOnlySelectedObjects">
            <value>
only display/print selected objects (default is false)
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoPrintInfo.m_view_area">
            <value>
how to map the viewport to the output device
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoPrintInfo.m_print_width_default">
            <value>
Line thickness used to print objects with no defined thickness (in mm)
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoPrintInfo.m_print_width_scale">
            <value>
scaling factor to apply to object print widths (typically 1.0). This is
helpful when printing something at 1/2 scale and having all of the curves
print 1/2 as thick
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoPrintInfo.m_bUseSavedLineTypeScale">
            <value>
Curve pen styles for thick lines
</value>
            <value>
default is false. Linetype scales are normally generated right before
printing in order to get linetypes to print to the same lengths as
defined. If true, the m_saved_linetype_scale is used. This is useful
if you want to print using the current display linetype scale or if
you want to print using some arbitrary linetype scale
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoPrintInfo.m_textdot_size">
            <value>
Font point size use for printing text dots (default = 10.0)
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoPrintInfo.m_arrowhead_size_mm">
            <value>
arrowhead size in millimeters
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoPrintInfo.m_point_scale">
            <value>
size of point objects in millimeters
if scale &lt;= 0 the size is minimized so points are always drawn as small as possible
</value>
        </member>
        <member name="T:RMA.Rhino.MRhinoPrintInfo">
            <summary>
The CRhinoPrintInfo class is used to hold the information required
to generate high resolution output of a CRhinoViewport. This is
used for generating paper prints or image files.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoPrintInfo.GetWindowAreaWidth">
            <summary>Return Window Area Size</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoPrintInfo.GetPreviewLayout(System.Drawing.Size,RMA.Rhino.MRhinoPrintInfo@)">
            <summary>
Create a layout info that is based on this layout info but sized to fit inside
a preview area. Used by the print preview window to generate a preview image
</summary>
            <param name="preview_area">[in] size to fit the layout info inside of</param>
            <param name="preview">[out] sized layout for preview purposes</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoPrintInfo.GetTileViewport(RMA.OpenNURBS.IOnViewport,RMA.OpenNURBS.OnViewport@,System.Drawing.Rectangle)">
            <summary>Used by DrawTileToDib to create tile viewports from a large single viewport</summary>
            <param name="full_viewport">[in] large single viewport that tiles are taken from</param>
            <param name="tile_viewport">[out] sub portion of the full viewport</param>
            <param name="tile_rect">[in] </param>
            <returns>true on success</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoPrintInfo.GetScreenRects(System.Drawing.Rectangle@,System.Drawing.Rectangle@,System.Drawing.Rectangle@)">
            <summary>
Get the rectangles in screen space coordinates. This is used by the print dialog during
window selection of the print area to show preview rectangles on the view.
</summary>
            <param name="paper">[out] the full page rectangle</param>
            <param name="available">[out] the portion of the paper that can drawn/printed to. Always inside paper rectangle</param>
            <param name="draw">[out] defined area the will be drawn/printed to. Always inside available rectangle</param>
            <returns>true if the layout is valid and was able to successfully return rectangles</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoPrintInfo.GetDeviceTile(System.Drawing.Rectangle)">
            <summary>
Creates a rectangle that represents an image tile on the output device.
This tile is at full resolution and positioned relative to the output
device available print rectangle (m_available_print_rect)
</summary>
            <param name="tile_rect">
[in] tile relative to the draw rect and scaled down by the
scale factor (typically from the GetTile functions.)
</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoPrintInfo.GetTile(System.Int32)">
            <summary>
Shaded/Rendered viewports are printed as a series of tileds bitmaps using the
display pipeline's graphics technology (i.e. OpenGL or DirectX).
These technologies are designed for drawing to an area the size of a screen,
so tiles are kept to these sizes and a final bitmap is constructed from the tiles.

Same as GetTile(row,column), but addresses the tile by index number. This
way you can do the following:
 for(int i=0; i&lt;GetTileCount(); i++){
   CRect tile_rect = GetTile(i);
   ...
 }
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoPrintInfo.GetTile(System.Int32,System.Int32)">
            <summary>
Shaded/Rendered viewports are printed as a series of tileds bitmaps using the
display pipeline's graphics technology (i.e. OpenGL or DirectX).
These technologies are designed for drawing to an area the size of a screen,
so tiles are kept to these sizes and a final bitmap is constructed from the tiles.

Get a rectangle that represents a subtile of the entire image. Tiles are
in a coordinate system local to the m_draw_rect and scaled to the scale
factor. This means Tile(0,0) will always have a top,left value of 0,0 and
this maps to the top,left corner of the draw rectangle.
</summary>
            <param name="row">[in] position of tile to retrieve</param>
            <param name="column">[in] position of tile to retrieve</param>
            <returns>tile rectangle on success. empty rectangle on failure</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoPrintInfo.GetTileCount">
            <summary>
Shaded/Rendered viewports are printed as a series of tileds bitmaps using the
display pipeline's graphics technology (i.e. OpenGL or DirectX).
These technologies are designed for drawing to an area the size of a screen,
so tiles are kept to these sizes and a final bitmap is constructed from the tiles.

Get number of tiles required to create a tiled image at the current settings.
Tile size is based on drawing size, target dpi, and preferred tile height/width
</summary>
            <returns>total number of tiles on success. 0 if an error occurs</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoPrintInfo.GetTileCount(System.Int32@)">
            <summary>
Shaded/Rendered viewports are printed as a series of tileds bitmaps using the
display pipeline's graphics technology (i.e. OpenGL or DirectX).
These technologies are designed for drawing to an area the size of a screen,
so tiles are kept to these sizes and a final bitmap is constructed from the tiles.

Get number of tiles required to create a tiled image at the current settings.
Tile size is based on drawing size, target dpi, and preferred tile height/width
</summary>
            <param name="rows">[out] if not NULL, the number of tiles vertical</param>
            <returns>total number of tiles on success. 0 if an error occurs</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoPrintInfo.GetTileCount(System.Int32@,System.Int32@)">
            <summary>
Shaded/Rendered viewports are printed as a series of tileds bitmaps using the
display pipeline's graphics technology (i.e. OpenGL or DirectX).
These technologies are designed for drawing to an area the size of a screen,
so tiles are kept to these sizes and a final bitmap is constructed from the tiles.

Get number of tiles required to create a tiled image at the current settings.
Tile size is based on drawing size, target dpi, and preferred tile height/width
</summary>
            <param name="rows">[out] if not NULL, the number of tiles vertical</param>
            <param name="columns">[out] if not NULL, the number of tiles across</param>
            <returns>total number of tiles on success. 0 if an error occurs</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoPrintInfo.GetPreferredTileSize(System.Int32@,System.Int32@)">
            <summary>
Shaded/Rendered viewports are printed as a series of tileds bitmaps using the
display pipeline's graphics technology (i.e. OpenGL or DirectX).
These technologies are designed for drawing to an area the size of a screen,
so tiles are kept to these sizes and a final bitmap is constructed from the tiles.

Get the preferred tile size for tiled image generation. The width and height must
be less than the desktop size in order to allow for accelerated graphics.
</summary>
            <param name="width">[out] preferred tile size in pixels</param>
            <param name="height">[out] preferred tile size in pixels</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoPrintInfo.DrawHeaderAndFooter(System.Drawing.IDeviceContext)">
            <summary>
Uses GDI to draw m_HeaderText and m_FooterText on top of the final image.
This should be called after calling the above Draw routines
</summary>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoPrintInfo.DrawWithGDI(System.Drawing.IDeviceContext)">
            <summary>Draws a display pipeline to a printer using GDI</summary>
            <param name="draw_dc">[in] The device context to draw to. This could be a printer or a DIB.</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoPrintInfo.DrawWithGDI(System.Drawing.IDeviceContext,RMA.Rhino.IDisplayPipelineAttributes)">
            <summary>Draws a display pipeline to a printer using GDI</summary>
            <param name="draw_dc">[in] The device context to draw to. This could be a printer or a DIB.</param>
            <param name="attrib">
[in] display attributes to use for drawing. If NULL, the values from CRhinoPrintInfo::DisplayAttributes() are used
</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoPrintInfo.DrawWithGDI(System.Drawing.IDeviceContext,RMA.Rhino.IDisplayPipelineAttributes,System.Boolean)">
            <summary>Draws a display pipeline to a printer using GDI</summary>
            <param name="draw_dc">[in] The device context to draw to. This could be a printer or a DIB.</param>
            <param name="attrib">
[in] display attributes to use for drawing. If NULL, the values from CRhinoPrintInfo::DisplayAttributes() are used
</param>
            <param name="printer_output">
[in] Use styles in print info that draw to DC as if it was being sent to a printer
</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoPrintInfo.DrawTileToDib(RMA.UI.MRhinoUiDib@,System.Drawing.Rectangle,RMA.Rhino.IRhinoViewport,RMA.Rhino.MRhinoDisplayPipeline,RMA.Rhino.MDisplayPipelineAttributes)">
            <summary>
Draws a sub-rect area of the full printable area rectangle. Tiled drawing is used for generating
large images from hardware accelerated graphics. Graphics cards have a limited area that they
can reasonably render to (typically screen resolution). This is called by the DrawToSingleDib
function and directly from printing code to send smaller bitmaps to the printer.
</summary>
            <param name="tile_dib">[out] the dib to draw to</param>
            <param name="tile_rect">[in] portion of printable area to draw</param>
            <param name="full_vp">[in] viewport that we are using to get geometry and projection information from</param>
            <param name="pPipeline">[in] display pipeline to use for drawing</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoPrintInfo.DrawToSingleDib(RMA.UI.MRhinoUiDib@)">
            <summary>
Draw the layout to a single DIB. This is all done in memory, so make sure that the resulting
DIB is not too large. Tiled drawing may occur if the DIB is larger than the screen resolution,
but this is handled internally by this function. This version of the function just "cooks" up
the appropriate display pipelines and attributes and calls the other version of this function.
</summary>
            <param name="full_dib">[out] the dib to draw to</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoPrintInfo.DrawToSingleDib(RMA.UI.MRhinoUiDib@,System.Boolean)">
            <summary>
Draw the layout to a single DIB. This is all done in memory, so make sure that the resulting
DIB is not too large. Tiled drawing may occur if the DIB is larger than the screen resolution,
but this is handled internally by this function. This version of the function just "cooks" up
the appropriate display pipelines and attributes and calls the other version of this function.
</summary>
            <param name="full_dib">[out] the dib to draw to</param>
            <param name="force_GDI_pipeline">
[in] if set to true, drawing is performed using a GDI display pipeline and
not the pipeline attached to the viewport (which may or may not be GDI).
</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoPrintInfo.DrawToSingleDib(RMA.UI.MRhinoUiDib@,System.Boolean,System.Boolean)">
            <summary>
Draw the layout to a single DIB. This is all done in memory, so make sure that the resulting
DIB is not too large. Tiled drawing may occur if the DIB is larger than the screen resolution,
but this is handled internally by this function. This version of the function just "cooks" up
the appropriate display pipelines and attributes and calls the other version of this function.
</summary>
            <param name="full_dib">[out] the dib to draw to</param>
            <param name="force_GDI_pipeline">
[in] if set to true, drawing is performed using a GDI display pipeline and
not the pipeline attached to the viewport (which may or may not be GDI).
</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoPrintInfo.DrawToSingleDib(RMA.UI.MRhinoUiDib@,RMA.Rhino.IDisplayPipelineAttributes,RMA.Rhino.IRhinoDisplayPipeline,System.Boolean)">
            <summary>
Draw the layout to a single DIB. This is all done in memory, so make sure that the resulting
DIB is not too large. Tiled drawing may occur if the DIB is larger than the screen resolution,
but this is handled internally by this function.
</summary>
            <param name="full_dib">[out] the dib to draw to</param>
            <param name="pAttributes">
[in] display attributes to use for drawing (typically from CRhinoPrintInfo::DisplayAttributes())
</param>
            <param name="pPipeline">[in] Display Pipeline to base drawing off of.</param>
            <param name="force_GDI_pipeline">
[in] if set to true, drawing is performed using a GDI display pipeline.
</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoPrintInfo.GetPrintColor(RMA.Rhino.IRhinoObjectAttributes)">
            <summary>
Gets the color used for drawing an object with the current print info's settings
</summary>
            <param name="pAttributes">[in] rhino object attributes to use for getting color</param>
            <returns>The Color for the object</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoPrintInfo.GetPrintWeight(RMA.Rhino.IRhinoObjectAttributes)">
            <summary>
Gets the weight used for drawing an object with the current print info's settings
</summary>
            <param name="pAttributes">[in] rhino object attributes to use for getting weight</param>
            <returns>
-1 if the object has "No Plot" set weight
otherwise, return a value greater than zero describing the weight used for draw functions
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoPrintInfo.GetAvailableSize(RMA.OpenNURBS.IOn.unit_system,System.Double@,System.Double@)">
            <summary>
Get the size of the printed output paper available are in a specified unit system. Custom
units are not allowed.
</summary>
            <param name="units">[in] unit system for the output sizes. custom units are not allowed</param>
            <param name="width">[out] size of output paper on success</param>
            <param name="height">[out] size of output paper on success</param>
            <returns>true on success, false on failure</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoPrintInfo.GetPaperSize(RMA.OpenNURBS.IOn.unit_system,System.Double@,System.Double@)">
            <summary>
Get the size of the printed output paper in a specified unit system. Custom
units are not allowed.
</summary>
            <param name="units">[in] unit system for the output sizes. custom units are not allowed</param>
            <param name="width">[out] size of output paper on success</param>
            <param name="height">[out] size of output paper on success</param>
            <returns>true on success, false on failure</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoPrintInfo.DrawAspectRatio">
            <summary>
returns the width/height of the currently defined draw area
0.0 if the draw area is not defined or invalid
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoPrintInfo.PaperAspectRatio">
            <summary>
returns the width/height of the currently defined paper area
0.0 if the paper area is not defined or invalid
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoPrintInfo.CreateDeviceViewport">
            <summary>
Creates a CRhinoViewport mapped to the output device with the appropriate view_area settings.
NOTE: you MUST delete the returned CRhinoViewport when you are done with it.
</summary>
            <returns>
a CRhinoViewport on success
NULL on failure
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoPrintInfo.GetDeviceViewport(RMA.OpenNURBS.OnViewport@)">
            <summary>
Sets up an ON_Viewport that would be used for printing. This is the core function used to
get all of the information stored in this class and generate a viewport mapped to an output device.
</summary>
            <param name="viewport">
[out] this will get set up with the projection information for an output device if the function is successful
</param>
            <returns>true on success</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoPrintInfo.GetMarginLimits(System.Boolean,RMA.OpenNURBS.IOn.unit_system,System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>
Get minimum/maximum print margins available for this page.
Margins are always measured from the edge of the page
</summary>
            <param name="minimum">[in] return minimum margins if true (otherwise maximum margins)</param>
            <param name="units">[in] units to return margins in</param>
            <param name="left">[out] the margins to return</param>
            <param name="right">[out] the margins to return</param>
            <param name="top">[out] the margins to return</param>
            <param name="bottom">[out] the margins to return</param>
            <returns>
true if successful
false if unsuccessful (this could happen if there is no set device_dpi)
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoPrintInfo.GetMargins(RMA.OpenNURBS.IOn.unit_system,System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>Margins are always measured from the edge of the page (m_paper_rect)</summary>
            <param name="units">[in] units to return margins in</param>
            <param name="left">[out] the margins to return</param>
            <param name="right">[out] the margins to return</param>
            <param name="top">[out] the margins to return</param>
            <param name="bottom">[out] the margins to return</param>
            <returns>
true if successful
false if unsuccessful (this could happen if there is no set device_dpi)
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoPrintInfo.StretchFactor">
            <summary>
Get factor used to scale tiles at the target DPI up to the device DPI
Images may be generated at a lower resolution than the device DPI and then
stretch blitted up to the device resolution.
DeviceDPI / StretchFactor = the resolution that images are being generated at
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoPrintInfo.DisplayAttributes">
            <summary>
A CRhinoPrintInfo's display attributes are based on it's CRhinoViewport with
a few possible overrides that are specific to this layout (background, grid, axis)
</summary>
            <returns>display attributes specific to this CRhinoPrintInfo</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoPrintInfo.GetRhinoViewport">
            <summary>Get the CRhinoViewport that this info is set up to print.</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoPrintInfo.IsValid">
            <summary>Determines if this has valid rectangles and a CRhinoViewport to work with</summary>
            <returns>true if this is a valid CRhinoPrintInfo</returns>
        </member>
        <member name="P:RMA.Rhino.IRhinoPrintInfo.m_maximum_dpi">
            <value>
Resolution cap when generating rester output. Images are stretched to
m_device_dpi when m_device_dpi &gt; m_maximum_dpi
Many photo printers have default resolutions of around 1200 dpi
which would demand enormous image size requirements if printing at full resolution
default DPI resolutions are set at 300 DPI. 
Personal Opinion (S. Baer):
 300DPI is a great setting for almost all prints
 600DPI looks only slightly better (but not worth 4x memory use)
 I can't see the difference between 600DPI and 1200 DPI
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoPrintInfo.m_device_dpi">
            <value>
The actual dot per inch resolution of the final output. This is the resolution
of the selected printer when sending an image to a printer. For raster image files,
this is used to determine image space sizes (things like line witdhs)
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoPrintInfo.m_draw_rect">
            <value>
location on m_paper_rect that image is drawn to in dots
this recangle holds information about where to draw and
what the margins are.
m_draw_rect must always be inside of m_available_print_rect
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoPrintInfo.m_available_print_rect">
            <value>
maximum portion of paper that can be drawn to
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoPrintInfo.m_paper_rect">
            <value>
physical size of paper in dots (no margins - the actual paper)
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoPrintInfo.m_FooterText">
            <value>
If we want to put text on top of the print assign it to the header and footer text
#NOTES# will be replaced with the document notes
#FILENAME# will be replaced with the document filename
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoPrintInfo.m_HeaderText">
            <value>
If we want to put text on top of the print assign it to the header and footer text
#NOTES# will be replaced with the document notes
#FILENAME# will be replaced with the document filename
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoPrintInfo.m_bOnlySelectedObjects">
            <value>
only display/print selected objects (default is false)
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoPrintInfo.m_view_area">
            <value>
how to map the viewport to the output device
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoPrintInfo.m_print_width_default">
            <value>
Line thickness used to print objects with no defined thickness (in mm)
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoPrintInfo.m_print_width_scale">
            <value>
scaling factor to apply to object print widths (typically 1.0). This is
helpful when printing something at 1/2 scale and having all of the curves
print 1/2 as thick
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoPrintInfo.m_bUseSavedLineTypeScale">
            <value>
Curve pen styles for thick lines
</value>
            <value>
default is false. Linetype scales are normally generated right before
printing in order to get linetypes to print to the same lengths as
defined. If true, the m_saved_linetype_scale is used. This is useful
if you want to print using the current display linetype scale or if
you want to print using some arbitrary linetype scale
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoPrintInfo.m_textdot_size">
            <value>
Font point size use for printing text dots (default = 10.0)
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoPrintInfo.m_arrowhead_size_mm">
            <value>
arrowhead size in millimeters
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoPrintInfo.m_point_scale">
            <value>
size of point objects in millimeters
if scale &lt;= 0 the size is minimized so points are always drawn as small as possible
</value>
        </member>
        <member name="T:RMA.Rhino.IRhinoPrintInfo.window_target_location">
            <summary>how the window is expanded off of the window anchor (location of m_anchor_location)</summary>
        </member>
        <member name="T:RMA.Rhino.IRhinoPrintInfo.view_area">
            <summary>how the CRhinoViewport is mapped to the output</summary>
        </member>
        <member name="T:RMA.Rhino.IRhinoPrintInfo.color_mode">
            <summary>color settings for generated output</summary>
        </member>
        <member name="T:RMA.Rhino.IRhinoPrintInfo">
            <summary>
The CRhinoPrintInfo class is used to hold the information required
to generate high resolution output of a CRhinoViewport. This is
used for generating paper prints or image files.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDetailViewObject.ScreenPointInBoundary(RMA.Rhino.IRhinoViewport,System.Drawing.Point)">
            <summary>
Return true if the screen point is inside of the detail's boundary curve.
</summary>
            <param name="parent_vp">
[in] Page view that this detail is shown in. This function is called
inside of page view mouse events and passing the parent viewport is done
purely for speed (don't have to look up the parent page)
</param>
            <param name="screen_pt">[in] point to test</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDetailViewObject.SetScale(System.Double,RMA.OpenNURBS.IOnUnitSystem,System.Double,RMA.OpenNURBS.IOnUnitSystem)">
            <summary>
Set the detail viewport's projection so geometry is displayed at a certain scale
</summary>
            <param name="model_length">[in] reference model length</param>
            <param name="model_units">[in] units for model length</param>
            <param name="paper_length">[in] length on page that the model_length should equal</param>
            <param name="paper_units">[in] units for paper length</param>
            <returns>
true on success
false if the viewport's projection is perspective or the input values do not make sense
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDetailViewObject.SetScale(System.Double,System.Double)">
            <summary>
Set the detail viewport's projection so geometry is displayed at a certain scale
</summary>
            <param name="model_length">[in] reference model length in current model units</param>
            <param name="paper_length">
[in] length on page that the model_length should equal in the current page units
</param>
            <returns>
true on success
false if the viewport's projection is perspective or the input values do not make sense
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDetailViewObject.ParentPageView">
            <summary>
Every detail view object belongs (displays) to one page view.
Page views can be parent to multiple detail views.
</summary>
            <returns>The CRhinoPageView that this detail view belongs to</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDetailViewObject.BoundaryCurve">
            <summary>The 2d boundary for this detail in page coordinates</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDetailViewObject.SetBoundaryCurve(RMA.OpenNURBS.IOnCurve)">
            <summary>Set the boundary curve for this detail object</summary>
            <param name="curve">[in] must be simple closed 2D curve on XY Plane</param>
            <remarks>No support for any boundary other than rectangles in V4</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDetailViewObject.SetRectangleBoundary(RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOn2dPoint)">
            <summary>
No support for any boundary other than rectangles at this point
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDetailViewObject.#ctor(RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <summary>
assigns a new object UUID
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDetailViewObject.#ctor">
            <summary>
assigns a new object UUID
</summary>
        </member>
        <member name="T:RMA.Rhino.MRhinoDetailViewObject">
            <summary>
A detail view is a nested CRhinoViewport placed on a page view with a 2D
closed curve boundary. Can be any type of modeling view.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDetailViewObject.ParentPageView">
            <summary>
Every detail view object belongs (displays) to one page view.
Page views can be parent to multiple detail views.
</summary>
            <returns>The CRhinoPageView that this detail view belongs to</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDetailViewObject.BoundaryCurve">
            <summary>The 2d boundary for this detail in page coordinates</summary>
        </member>
        <member name="T:RMA.Rhino.IRhinoDetailViewObject">
            <summary>
A detail view is a nested CRhinoViewport placed on a page view with a 2D
closed curve boundary. Can be any type of modeling view.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPageView.SetLinetypeDrawScaleFactor(System.Double)">
            <summary>
scale == 0, don't perform any special linetype scaling during draw
scale == 1, linetypes show on page and details at scale pattern defined
For other values scale is multiplied against the actual linetype scale.
This is useful when print at 1/2 size and displaying the linetypes at 1/2 size
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPageView.SetPageNumber(System.Int32)">
            <summary>
Sets the runtime page number and updates the page number for all of the other pages
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPageView.GetPageNumber">
            <summary>
Get the runtime page number. The first page returns a value of 0
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPageView.GetPixelsPerInch">
            <summary>
Get the number of pixels per inch of page for the current display viewport
</summary>
            <returns>pixels of screen display per inch page</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPageView.SetPaperSize(RMA.OpenNURBS.IOn.unit_system,System.Double,System.Double)">
            <summary>
Each page has a paper size used for WYSIWYG printing of page layouts. This
function sets the paper size for this page.
</summary>
            <param name="units">
[in] units system for setting the page size. If units = ON::inches,
the width and height are distances in inches
</param>
            <param name="width">[in] paper size in provided units</param>
            <param name="height">[in] paper size in provided units</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoPageView.GetPaperSize(RMA.OpenNURBS.IOn.unit_system,System.Double@,System.Double@)">
            <summary>
Each page has a paper size used for WYSIWYG printing of page layouts. This
function gets the paper size for this page.
</summary>
            <param name="units">
[in] units system for getting the page size. If units = ON::inches,
the width and height are distances in inches
</param>
            <param name="width">[out] paper size in provided units</param>
            <param name="height">[out] paper size in provided units</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoPageView.GetDetailViewObjects(RMA.Rhino.MRhinoDetailViewObject[]@)">
            <summary>
Get list of detail view objects that are displayed on this page
</summary>
            <param name="details">[out] list to fill</param>
            <returns>Number of detail view objects in list</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPageView.AddDetailView(RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOn2dPoint)">
            <summary>
Create a detail view object that is displayed on this page and adds it to the doc
</summary>
            <param name="corner0">[in] corners of the detail view in world coordinates</param>
            <param name="corner1">[in] corners of the detail view in world coordinates</param>
            <returns>NULL on failure</returns>
            <example>
The corner_units are supplied as a parameter so you can define the details position
on a page. The page always has it's lower left corner at 0,0. If you wanted to add
a detail that is 1/2 inch from the bottom and left edges, and is 6"wide x 3"tall
ON_2dPoint bottom_left(0.5,0.5);
ON_2dPoint top_right(6.5,3.5);
ON_UnitSystem units(ON::inches);
int index = AddDetailView(bottom_left, top_right, units);
</example>
        </member>
        <member name="M:RMA.Rhino.MRhinoPageView.AddDetailView(RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOnUnitSystem)">
            <summary>
Create a detail view object that is displayed on this page and adds it to the doc
</summary>
            <param name="corner0">[in] corners of the detail view in world coordinates</param>
            <param name="corner1">[in] corners of the detail view in world coordinates</param>
            <param name="corner_units">
[in] unit system corners are supplied in. If NULL, the document's page units are used
</param>
            <returns>NULL on failure</returns>
            <example>
The corner_units are supplied as a parameter so you can define the details position
on a page. The page always has it's lower left corner at 0,0. If you wanted to add
a detail that is 1/2 inch from the bottom and left edges, and is 6"wide x 3"tall
ON_2dPoint bottom_left(0.5,0.5);
ON_2dPoint top_right(6.5,3.5);
ON_UnitSystem units(ON::inches);
int index = AddDetailView(bottom_left, top_right, units);
</example>
        </member>
        <member name="M:RMA.Rhino.MRhinoPageView.CreatePageView">
            <summary>Create a new page view window.</summary>
            <returns>
pointer to the new CRhinoPageView on success
NULL on failure
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPageView.CreatePageView(System.String)">
            <summary>Create a new page view window.</summary>
            <param name="title">
[in] string that appears in the new page view's title window
If NULL, the name will be generated as "Page #" where this is the
largest page number.
</param>
            <returns>
pointer to the new CRhinoPageView on success
NULL on failure
</returns>
        </member>
        <member name="T:RMA.Rhino.MRhinoPageView">
            <summary>
A Page view represents a single sheet of paper with embedded detail views.
Rules:
- Always a "Top" 2D View
- Geometry in page view is always drawn on top of it's embedded detail views
- Geometry defined in a page view is ONLY drawn in this one page view.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoPageView.GetPageNumber">
            <summary>
Get the runtime page number. The first page returns a value of 0
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoPageView.GetPixelsPerInch">
            <summary>
Get the number of pixels per inch of page for the current display viewport
</summary>
            <returns>pixels of screen display per inch page</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoPageView.GetPaperSize(RMA.OpenNURBS.IOn.unit_system,System.Double@,System.Double@)">
            <summary>
Each page has a paper size used for WYSIWYG printing of page layouts. This
function gets the paper size for this page.
</summary>
            <param name="units">
[in] units system for getting the page size. If units = ON::inches,
the width and height are distances in inches
</param>
            <param name="width">[out] paper size in provided units</param>
            <param name="height">[out] paper size in provided units</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoPageView.GetDetailViewObjects(RMA.Rhino.MRhinoDetailViewObject[]@)">
            <summary>
Get list of detail view objects that are displayed on this page
</summary>
            <param name="details">[out] list to fill</param>
            <returns>Number of detail view objects in list</returns>
        </member>
        <member name="T:RMA.Rhino.IRhinoPageView">
            <summary>
A Page view represents a single sheet of paper with embedded detail views.
Rules:
- Always a "Top" 2D View
- Geometry in page view is always drawn on top of it's embedded detail views
- Geometry defined in a page view is ONLY drawn in this one page view.
</summary>
        </member>
        <member name="E:RMA.Rhino.MRhinoDisplayConduit.NotifyConduit">
            <summary>
Display pipelines will trigger this event when any of the actions defined in
EConduitNotifiers occurs.
</summary>
        </member>
        <member name="F:RMA.Rhino.MRhinoDisplayConduit.m_pDisplayAttrs">
            <summary>
Global pipeline display attributes that the conduit can adjust to modify the display
Note: Changing display attributes may have no effect based on which channel this
     conduit is currently running in (ie. The pipeline may step on any changes).
     A good rule is to only change these attributes inside SC_OBJECTDISPLAYATTRS,
     or all OBJECT DRAW channels, anywhere else may produce unexpected results.
</summary>
            <remarks>
This is set and assigned accordingly prior to calling ExecConduit...
These pointers can change often. Do not hold onto them and use them outside the
scope of the ExecConduit function
</remarks>
        </member>
        <member name="F:RMA.Rhino.MRhinoDisplayConduit.m_pChannelAttrs">
            <summary>
Channel attributes are set up for each channel or "phase" of drawing. If the conduit
modifies these attributes inside of the ExecConduit function, the display for the
current channel will be changed based on these attributes. 
Note: See the definition of CChannelAttributes for a "logical grouping" of which
     attributes apply to which channels.
Note2: Changing channel attributes that are not part of the "current channel"
     context will have unknown and unexpected results.
</summary>
            <remarks>
This is set and assigned accordingly prior to calling ExecConduit...
These pointers can change often. Do not hold onto them and use them outside the
scope of the ExecConduit function
</remarks>
        </member>
        <member name="F:RMA.Rhino.MRhinoDisplayConduit.m_pVP">
            <summary>The viewport the conduit is working with at the time of ExecConduit</summary>
            <remarks>
This is set and assigned accordingly prior to calling ExecConduit...
These pointers can change often. Do not hold onto them and use them outside the
scope of the ExecConduit function
</remarks>
        </member>
        <member name="F:RMA.Rhino.MRhinoDisplayConduit.m_pView">
            <summary>The view that the conduit is working with at the time of ExecConduit</summary>
            <remarks>
This is set and assigned accordingly prior to calling ExecConduit...
These pointers can change often. Do not hold onto them and use them outside the
scope of the ExecConduit function
</remarks>
        </member>
        <member name="F:RMA.Rhino.MRhinoDisplayConduit.m_pDoc">
            <summary>The document that the conduit is working with at the time of ExecConduit</summary>
            <remarks>
This is set and assigned accordingly prior to calling ExecConduit...
These pointers can change often. Do not hold onto them and use them outside the
scope of the ExecConduit function
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayConduit.BindingCount">
            <returns>number of viewports that this conduit is bound to</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayConduit.BindingsExist">
            <returns>true if this conduit is bound to any specific viewport</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayConduit.IsBound(RMA.OpenNURBS.IOnViewport)">
            <summary>Determines if this conduit is bound to a specific pipeline or viewport</summary>
            <param name="viewport">[in] the viewport to check binding against</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayConduit.IsBound(RMA.OpenNURBS.IOnViewport,System.Boolean)">
            <summary>Determines if this conduit is bound to a specific pipeline or viewport</summary>
            <param name="viewport">[in] the viewport to check binding against</param>
            <param name="ignore_state">
[in] determines if whether or not the "constant binding" state should be ignored.
(See comments for "EnableConstantBinding()"). In other words, if this conduit is using constant
binding (default), then it doesn't really matter if it is bound to anything since constant binding
means "always bind to everything". However, most of the time it is neccessary to pay attention to
the state since conduits can be manually bound and programs need to know which pipelines this
conduit is bound to. There are certain conditions where the display pipeline need not pay attention
to the constant binding state, but most likely all other programs do...It is recommended that if you
do not understand exactly what is going on here, that you just use the default.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayConduit.IsBound(RMA.Rhino.IRhinoView)">
            <summary>Determines if this conduit is bound to a specific pipeline or viewport</summary>
            <param name="view">[in] the view to check binding against</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayConduit.IsBound(RMA.Rhino.IRhinoView,System.Boolean)">
            <summary>Determines if this conduit is bound to a specific pipeline or viewport</summary>
            <param name="view">[in] the view to check binding against</param>
            <param name="ignore_state">
[in] determines if whether or not the "constant binding" state should be ignored.
(See comments for "EnableConstantBinding()"). In other words, if this conduit is using constant
binding (default), then it doesn't really matter if it is bound to anything since constant binding
means "always bind to everything". However, most of the time it is neccessary to pay attention to
the state since conduits can be manually bound and programs need to know which pipelines this
conduit is bound to. There are certain conditions where the display pipeline need not pay attention
to the constant binding state, but most likely all other programs do...It is recommended that if you
do not understand exactly what is going on here, that you just use the default.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayConduit.IsBound(RMA.Rhino.IRhinoViewport)">
            <summary>Determines if this conduit is bound to a specific pipeline or viewport</summary>
            <param name="viewport">[in] the viewport to check binding against</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayConduit.IsBound(RMA.Rhino.IRhinoViewport,System.Boolean)">
            <summary>Determines if this conduit is bound to a specific pipeline or viewport</summary>
            <param name="viewport">[in] the viewport to check binding against</param>
            <param name="ignore_state">
[in] determines if whether or not the "constant binding" state should be ignored.
(See comments for "EnableConstantBinding()"). In other words, if this conduit is using constant
binding (default), then it doesn't really matter if it is bound to anything since constant binding
means "always bind to everything". However, most of the time it is neccessary to pay attention to
the state since conduits can be manually bound and programs need to know which pipelines this
conduit is bound to. There are certain conditions where the display pipeline need not pay attention
to the constant binding state, but most likely all other programs do...It is recommended that if you
do not understand exactly what is going on here, that you just use the default.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayConduit.IsBound(RMA.Rhino.IRhinoDisplayPipeline)">
            <summary>Determines if this conduit is bound to a specific pipeline or viewport</summary>
            <param name="pipeline">[in] the pipeline to check binding against</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayConduit.IsBound(RMA.Rhino.IRhinoDisplayPipeline,System.Boolean)">
            <summary>Determines if this conduit is bound to a specific pipeline or viewport</summary>
            <param name="pipeline">[in] the pipeline to check binding against</param>
            <param name="ignore_state">
[in] determines if whether or not the "constant binding" state should be ignored.
(See comments for "EnableConstantBinding()"). In other words, if this conduit is using constant
binding (default), then it doesn't really matter if it is bound to anything since constant binding
means "always bind to everything". However, most of the time it is neccessary to pay attention to
the state since conduits can be manually bound and programs need to know which pipelines this
conduit is bound to. There are certain conditions where the display pipeline need not pay attention
to the constant binding state, but most likely all other programs do...It is recommended that if you
do not understand exactly what is going on here, that you just use the default.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayConduit.ReplaceBinding(RMA.OpenNURBS.IOnViewport,RMA.OpenNURBS.IOnViewport)">
            <summary>
Remove the binding for a pipeline or viewport and add a binding for a new
pipeline or viewport
</summary>
            <param name="old_viewport">[in] the viewport that this conduit is removing a binding from</param>
            <param name="new_viewport">[in] the viewport that this conduit is adding a binding to</param>
            <returns>
false if this conduit was not already bound to the pipeline or viewport that
it is trying to replace
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayConduit.ReplaceBinding(RMA.Rhino.IRhinoView,RMA.Rhino.IRhinoView)">
            <summary>
Remove the binding for a pipeline or viewport and add a binding for a new
pipeline or viewport
</summary>
            <param name="old_view">[in] the view that this conduit is removing a binding from</param>
            <param name="new_view">[in] the view that this conduit is adding a binding to</param>
            <returns>
false if this conduit was not already bound to the pipeline or viewport that
it is trying to replace
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayConduit.ReplaceBinding(RMA.Rhino.IRhinoViewport,RMA.Rhino.IRhinoViewport)">
            <summary>
Remove the binding for a pipeline or viewport and add a binding for a new
pipeline or viewport
</summary>
            <param name="old_viewport">[in] the viewport that this conduit is removing a binding from</param>
            <param name="new_viewport">[in] the viewport that this conduit is adding a binding to</param>
            <returns>
false if this conduit was not already bound to the pipeline or viewport that
it is trying to replace
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayConduit.ReplaceBinding(RMA.Rhino.IRhinoDisplayPipeline,RMA.Rhino.IRhinoDisplayPipeline)">
            <summary>
Remove the binding for a pipeline or viewport and add a binding for a new
pipeline or viewport
</summary>
            <param name="old_pipeline">[in] the pipeline that this conduit is removing a binding from</param>
            <param name="new_pipeline">[in] the pipeline that this conduit is adding a binding to</param>
            <returns>
false if this conduit was not already bound to the pipeline or viewport that
it is trying to replace
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayConduit.ToggleBinding(RMA.OpenNURBS.IOnViewport)">
            <summary>Flip binding state for a given pipeline / viewport</summary>
            <returns>Always returns true</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayConduit.ToggleBinding(RMA.Rhino.IRhinoView)">
            <summary>Flip binding state for a given pipeline / viewport</summary>
            <returns>Always returns true</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayConduit.ToggleBinding(RMA.Rhino.IRhinoViewport)">
            <summary>Flip binding state for a given pipeline / viewport</summary>
            <returns>Always returns true</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayConduit.ToggleBinding(RMA.Rhino.IRhinoDisplayPipeline)">
            <summary>Flip binding state for a given pipeline / viewport</summary>
            <returns>Always returns true</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayConduit.UnbindAll">
            <summary>Set this conduit to not be bound to any specific display pipeline or viewport</summary>
            <returns>Always returns true</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayConduit.EnableConstantBinding">
            <summary>
When a conduit runs inside of a pipeline, it is said to be "bound" to that 
pipeline. By default all conduits are bound to all existing pipelines and any
newly created ones...This is known as "constant binding"...If a conduit is
only supposed to run/execute inside a specific pipeline/viewport (or set of
viewports) then constant binding must be disabled, and the conduit must then
be manually "bound" to a specific pipeline/viewport. See comments on all of
"Bind()" methods.
 
Note: You can still bind conduits to specific pipelines/viewports, but the
conduit will have to manually check for bindings inside of "ExecConduit()"
using the "IsBound()" methods. By disabling constant binding and manually
binding your conduit, will force your conduit to only run in specific
pipelines/viewports (ie. no checks are necessary, they're handled by the
pipeline).
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayConduit.EnableConstantBinding(System.Boolean)">
            <summary>
When a conduit runs inside of a pipeline, it is said to be "bound" to that 
pipeline. By default all conduits are bound to all existing pipelines and any
newly created ones...This is known as "constant binding"...If a conduit is
only supposed to run/execute inside a specific pipeline/viewport (or set of
viewports) then constant binding must be disabled, and the conduit must then
be manually "bound" to a specific pipeline/viewport. See comments on all of
"Bind()" methods.
 
Note: You can still bind conduits to specific pipelines/viewports, but the
conduit will have to manually check for bindings inside of "ExecConduit()"
using the "IsBound()" methods. By disabling constant binding and manually
binding your conduit, will force your conduit to only run in specific
pipelines/viewports (ie. no checks are necessary, they're handled by the
pipeline).
</summary>
            <param name="enable">[in] Set to false to disable constant binding, true to enable it.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayConduit.Unbind(RMA.OpenNURBS.IOnViewport)">
            <summary>Remove a binding from a display pipeline/viewport.</summary>
            <returns>false if this conduit was not bound to the provided pipeline/viewport</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayConduit.Unbind(RMA.Rhino.IRhinoView)">
            <summary>Remove a binding from a display pipeline/viewport.</summary>
            <returns>false if this conduit was not bound to the provided pipeline/viewport</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayConduit.Unbind(RMA.Rhino.IRhinoViewport)">
            <summary>Remove a binding from a display pipeline/viewport.</summary>
            <returns>false if this conduit was not bound to the provided pipeline/viewport</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayConduit.Unbind(RMA.Rhino.IRhinoDisplayPipeline)">
            <summary>Remove a binding from a display pipeline/viewport.</summary>
            <returns>false if this conduit was not bound to the provided pipeline/viewport</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayConduit.Bind(RMA.OpenNURBS.IOnViewport)">
            <summary>
Bind this conduit to a display pipeline/viewport. If this conduit is already
bound to another pipeline or viewport, that binding will not be removed and
this conduit will be bound to multiple pipelines/viewports
</summary>
            <returns>false if this conduit is alread bound to the provided pipeline/viewport</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayConduit.Bind(RMA.Rhino.IRhinoView)">
            <summary>
Bind this conduit to a display pipeline/viewport. If this conduit is already
bound to another pipeline or viewport, that binding will not be removed and
this conduit will be bound to multiple pipelines/viewports
</summary>
            <returns>false if this conduit is alread bound to the provided pipeline/viewport</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayConduit.Bind(RMA.Rhino.IRhinoViewport)">
            <summary>
Bind this conduit to a display pipeline/viewport. If this conduit is already
bound to another pipeline or viewport, that binding will not be removed and
this conduit will be bound to multiple pipelines/viewports
</summary>
            <returns>false if this conduit is alread bound to the provided pipeline/viewport</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayConduit.Bind(RMA.Rhino.IRhinoDisplayPipeline)">
            <summary>
Bind this conduit to a display pipeline/viewport. If this conduit is already
bound to another pipeline or viewport, that binding will not be removed and
this conduit will be bound to multiple pipelines/viewports
</summary>
            <returns>false if this conduit is alread bound to the provided pipeline/viewport</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayConduit.Disable">
            <summary>
Turn this conduit off. When a conduit is disabled, it will not participate in any
custom drawing activity.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayConduit.Enable">
            <summary>
Turn this conduit on. When a conduit is enabled, it's ExecConduit function is called
for each viewport that this conduit pays attention to.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayConduit.ExecConduit(RMA.Rhino.MRhinoDisplayPipeline@,System.UInt32,System.Boolean@)">
            <summary>
Conduits should/could be thought of as small pieces of code that get "executed" 
inside of Rhino's pipeline...and by specifying which "channel" your conduit 
executes in, allows you to determine where and when your code runs.

This function is called for every CSupportChannel that this conduit has been
constructed with during the process of drawing a single frame. ExecConduit is not
called when the conduit is disabled.
</summary>
            <param name="pipeline">
[in] the pipeline that is currently executing and calling this conduit.
This is the pipeline you should be calling "Draw" functions on if you
want to perform any custom drawing.
</param>
            <param name="channel">
[in] This function can be called multiple times by a pipeline while
drawing a single frame. The channel parameter specifies what part of
CSupportChannels is currently being executed
</param>
            <param name="terminate">
[out] Set this to true if you don't want other conduits to perform
operations in the current channel after this function returns. Typically
you will leave this parameter alone and allow other enabled conduits to
perform their custom drawing code.
</param>
            <returns>
True if the function completed successfully. If this function returns false,
something bad occured and drawing of the current frame stops.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayConduit.ChannelSupported(System.UInt32)">
            <param name="channel">[in] CSupportChannel or a list of CSupportChannels that are or'd together</param>
            <returns>
True if this conduit supports given channel or list of channels. The supported
channels are the ones that were defined in the conduit's constructor
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayConduit.#ctor(RMA.Rhino.MSupportChannels)">
            <param name="channel_mask">[in] Set of CSupportChannels that this conduit is interested in.</param>
            <remarks>
Do not use SC_POSTPROCESSFRAMEBUFFER unless you absolutely need to. The
display pipeline will check to see if it has any conduits that require this
phase of drawing and will only perform a postprocess if one exists. Post
processing of the frame buffer requires multiple dib copies at the end of
drawing a frame and will cause a *constant* performance hit on display speed.

Since most of the time a conduit needs to only implement 1 to 2 channels at
at time, it is also recommended that you do NOT use SC_ALL_CHANNELS to construct
your conduit...This will make your counduit (and the pipeline) very inefficient.
</remarks>
            <example>
If you had a conduit subclass that wanted to pay attention to object drawing
and foreground drawing, you would set up the constructor as follows
 
CMyDisplayConduit::CMyDisplayConduit()
: CRhinoDisplayConduit( CSupportChannels::SC_DRAWOBJECT | CSupportChannels::SC_DRAWFOREGROUND )
{
...set up some other class variables
}
</example>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayConduit.#ctor(RMA.Rhino.MSupportChannels,System.Boolean)">
            <param name="channel_mask">[in] Set of CSupportChannels that this conduit is interested in.</param>
            <param name="enable">[in] Should the conduit initially be enabled?</param>
            <remarks>
Do not use SC_POSTPROCESSFRAMEBUFFER unless you absolutely need to. The
display pipeline will check to see if it has any conduits that require this
phase of drawing and will only perform a postprocess if one exists. Post
processing of the frame buffer requires multiple dib copies at the end of
drawing a frame and will cause a *constant* performance hit on display speed.

Since most of the time a conduit needs to only implement 1 to 2 channels at
at time, it is also recommended that you do NOT use SC_ALL_CHANNELS to construct
your conduit...This will make your counduit (and the pipeline) very inefficient.
</remarks>
            <example>
If you had a conduit subclass that wanted to pay attention to object drawing
and foreground drawing, you would set up the constructor as follows
 
CMyDisplayConduit::CMyDisplayConduit()
: CRhinoDisplayConduit( CSupportChannels::SC_DRAWOBJECT | CSupportChannels::SC_DRAWFOREGROUND )
{
...set up some other class variables
}
</example>
        </member>
        <member name="T:RMA.Rhino.MRhinoDisplayConduit">
            <summary>
Display conduits provide support for adding custom display functionality during
drawing inside of a display pipeline/viewport.

A subclass of a conduit specifies what channels or "phases" of drawing that it
wants to be involved in.

Conduits may be "bound" to specific display pipelines or viewports which means
that they will only operate with the objects they are bound to. If a binding is
not defined, the conduit will operate in all display pipelines.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayConduit.BindingCount">
            <returns>number of viewports that this conduit is bound to</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayConduit.BindingsExist">
            <returns>true if this conduit is bound to any specific viewport</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayConduit.IsBound(RMA.OpenNURBS.IOnViewport)">
            <summary>Determines if this conduit is bound to a specific pipeline or viewport</summary>
            <param name="viewport">[in] the viewport to check binding against</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayConduit.IsBound(RMA.OpenNURBS.IOnViewport,System.Boolean)">
            <summary>Determines if this conduit is bound to a specific pipeline or viewport</summary>
            <param name="viewport">[in] the viewport to check binding against</param>
            <param name="ignore_state">
[in] determines if whether or not the "constant binding" state should be ignored.
(See comments for "EnableConstantBinding()"). In other words, if this conduit is using constant
binding (default), then it doesn't really matter if it is bound to anything since constant binding
means "always bind to everything". However, most of the time it is neccessary to pay attention to
the state since conduits can be manually bound and programs need to know which pipelines this
conduit is bound to. There are certain conditions where the display pipeline need not pay attention
to the constant binding state, but most likely all other programs do...It is recommended that if you
do not understand exactly what is going on here, that you just use the default.
</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayConduit.IsBound(RMA.Rhino.IRhinoView)">
            <summary>Determines if this conduit is bound to a specific pipeline or viewport</summary>
            <param name="view">[in] the view to check binding against</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayConduit.IsBound(RMA.Rhino.IRhinoView,System.Boolean)">
            <summary>Determines if this conduit is bound to a specific pipeline or viewport</summary>
            <param name="view">[in] the view to check binding against</param>
            <param name="ignore_state">
[in] determines if whether or not the "constant binding" state should be ignored.
(See comments for "EnableConstantBinding()"). In other words, if this conduit is using constant
binding (default), then it doesn't really matter if it is bound to anything since constant binding
means "always bind to everything". However, most of the time it is neccessary to pay attention to
the state since conduits can be manually bound and programs need to know which pipelines this
conduit is bound to. There are certain conditions where the display pipeline need not pay attention
to the constant binding state, but most likely all other programs do...It is recommended that if you
do not understand exactly what is going on here, that you just use the default.
</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayConduit.IsBound(RMA.Rhino.IRhinoViewport)">
            <summary>Determines if this conduit is bound to a specific pipeline or viewport</summary>
            <param name="viewport">[in] the viewport to check binding against</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayConduit.IsBound(RMA.Rhino.IRhinoViewport,System.Boolean)">
            <summary>Determines if this conduit is bound to a specific pipeline or viewport</summary>
            <param name="viewport">[in] the viewport to check binding against</param>
            <param name="ignore_state">
[in] determines if whether or not the "constant binding" state should be ignored.
(See comments for "EnableConstantBinding()"). In other words, if this conduit is using constant
binding (default), then it doesn't really matter if it is bound to anything since constant binding
means "always bind to everything". However, most of the time it is neccessary to pay attention to
the state since conduits can be manually bound and programs need to know which pipelines this
conduit is bound to. There are certain conditions where the display pipeline need not pay attention
to the constant binding state, but most likely all other programs do...It is recommended that if you
do not understand exactly what is going on here, that you just use the default.
</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayConduit.IsBound(RMA.Rhino.IRhinoDisplayPipeline)">
            <summary>Determines if this conduit is bound to a specific pipeline or viewport</summary>
            <param name="pipeline">[in] the pipeline to check binding against</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayConduit.IsBound(RMA.Rhino.IRhinoDisplayPipeline,System.Boolean)">
            <summary>Determines if this conduit is bound to a specific pipeline or viewport</summary>
            <param name="pipeline">[in] the pipeline to check binding against</param>
            <param name="ignore_state">
[in] determines if whether or not the "constant binding" state should be ignored.
(See comments for "EnableConstantBinding()"). In other words, if this conduit is using constant
binding (default), then it doesn't really matter if it is bound to anything since constant binding
means "always bind to everything". However, most of the time it is neccessary to pay attention to
the state since conduits can be manually bound and programs need to know which pipelines this
conduit is bound to. There are certain conditions where the display pipeline need not pay attention
to the constant binding state, but most likely all other programs do...It is recommended that if you
do not understand exactly what is going on here, that you just use the default.
</param>
        </member>
        <member name="T:RMA.Rhino.IRhinoDisplayConduit">
            <summary>
Display conduits provide support for adding custom display functionality during
drawing inside of a display pipeline/viewport.

A subclass of a conduit specifies what channels or "phases" of drawing that it
wants to be involved in.

Conduits may be "bound" to specific display pipelines or viewports which means
that they will only operate with the objects they are bound to. If a binding is
not defined, the conduit will operate in all display pipelines.
</summary>
        </member>
        <member name="P:RMA.Rhino.MSupportChannels.SC_DRAWMIDDLEGROUND">
            <value>
Helper masks that make some things a little easier...
Note: These are not channels, but a combination of
     different channels...You should always use the
     specific channels above when defining or referring
     to channel values.
</value>
        </member>
        <member name="T:RMA.Rhino.MSupportChannels">
            <summary>
Specialiazed UINT class that ensures "supported" values only...

The display pipeline calls conduits during specific phases of drawing (channels)
During the drawing of a single frame the channels are called in the following order

[Begin Drawing of a Frame]
  SC_CALCBOUNDINGBOX
  SC_CALCCLIPPINGPLANES
  SC_SETUPFRUSTUM
  SC_SETUPLIGHTING
  SC_INITFRAMEBUFFER
  SC_DRAWBACKGROUND
  If this is a layout and detail objects exist the channels are called in the
  same order for each detail object (drawn as a nested viewport)
  SC_PREDRAWOBJECTS

  For Each Visible Non Highlighted Object
    SC_OBJECTDISPLAYATTRS
    SC_PREOBJECTDRAW
    SC_DRAWOBJECT
    SC_POSTOBJECTDRAW
  Next Object

  SC_POSTDRAWOBJECTS
  SC_DRAWFOREGROUND

  For Each Visible Highlighted Object
    SC_OBJECTDISPLAYATTRS
    SC_PREOBJECTDRAW
    SC_DRAWOBJECT
    SC_POSTOBJECTDRAW
  Next Object

  SC_POSTPROCESSFRAMEBUFFER - If a conduit exists that requires this
  SC_DRAWOVERLAY - If Rhino is in a feedback mode
[End of Drawing of a Frame]

      happen would be with a shaded sphere. The shaded mesh is first drawn and these channels would
      be processed; then at a later time the isocurves for the sphere would be drawn.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.DrawSprite(RMA.UI.IRhinoUiDib,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
Draws a specified sub-image located within a specified dib.
A sprite is an implied transparent dib that consists of N x 1 images 

Where:
 N = dib.Width() / sprite_width

Thus,
 sprite_width = dib.Width() / N

N is specified by "nCount", and the current sprite or "cell"
is calculated automatically from the dib's information.

 +------+------+------+------+------+------+
 | Cell | Cell |      |      |      | Cell |      
 |  0   |  1   | ...  | ...  | ...  |  N   |    
 |      |      |      |      |      |      |      
 +------+------+------+------+------+------+

Note: If the dib does not have a 32bit depth, then transparency
      is obtained by using the upper left most pixel in each cell  
      as the transparency mask color.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.MeasureString(System.Drawing.Rectangle@,System.String,RMA.OpenNURBS.IOn2dPoint)">
            <summary>
Determine screen rectangle that would be drawn to using the DrawString(..) function
with the same parameters.
</summary>
            <param name="rect">[out] rectangle in the viewport's screen coordinates on success</param>
            <param name="text">[in] text to measure</param>
            <param name="point">[in] definition point, either lower-left or middle</param>
            <returns>true on success, false on failure</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.MeasureString(System.Drawing.Rectangle@,System.String,RMA.OpenNURBS.IOn2dPoint,System.Boolean)">
            <summary>
Determine screen rectangle that would be drawn to using the DrawString(..) function
with the same parameters.
</summary>
            <param name="rect">[out] rectangle in the viewport's screen coordinates on success</param>
            <param name="text">[in] text to measure</param>
            <param name="point">[in] definition point, either lower-left or middle</param>
            <param name="bMiddle">
[in] if true, text is centered on point, (default false)
if false, point defines lower left corner of text
</param>
            <returns>true on success, false on failure</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.MeasureString(System.Drawing.Rectangle@,System.String,RMA.OpenNURBS.IOn2dPoint,System.Boolean,System.Int32)">
            <summary>
Determine screen rectangle that would be drawn to using the DrawString(..) function
with the same parameters.
</summary>
            <param name="rect">[out] rectangle in the viewport's screen coordinates on success</param>
            <param name="text">[in] text to measure</param>
            <param name="point">[in] definition point, either lower-left or middle</param>
            <param name="bMiddle">
[in] if true, text is centered on point, (default false)
if false, point defines lower left corner of text
</param>
            <param name="rotation">[in] Text rotation in 1/10 degrees (default 0)</param>
            <returns>true on success, false on failure</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.MeasureString(System.Drawing.Rectangle@,System.String,RMA.OpenNURBS.IOn2dPoint,System.Boolean,System.Int32,System.Int32)">
            <summary>
Determine screen rectangle that would be drawn to using the DrawString(..) function
with the same parameters.
</summary>
            <param name="rect">[out] rectangle in the viewport's screen coordinates on success</param>
            <param name="text">[in] text to measure</param>
            <param name="point">[in] definition point, either lower-left or middle</param>
            <param name="bMiddle">
[in] if true, text is centered on point, (default false)
if false, point defines lower left corner of text
</param>
            <param name="rotation">[in] Text rotation in 1/10 degrees (default 0)</param>
            <param name="height">[in] height in pixels (default 12)</param>
            <returns>true on success, false on failure</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.MeasureString(System.Drawing.Rectangle@,System.String,RMA.OpenNURBS.IOn2dPoint,System.Boolean,System.Int32,System.Int32,System.String)">
            <summary>
Determine screen rectangle that would be drawn to using the DrawString(..) function
with the same parameters.
</summary>
            <param name="rect">[out] rectangle in the viewport's screen coordinates on success</param>
            <param name="text">[in] text to measure</param>
            <param name="point">[in] definition point, either lower-left or middle</param>
            <param name="bMiddle">
[in] if true, text is centered on point, (default false)
if false, point defines lower left corner of text
</param>
            <param name="rotation">[in] Text rotation in 1/10 degrees (default 0)</param>
            <param name="height">[in] height in pixels (default 12)</param>
            <param name="fontface">[in] font to use for text (default Arial)</param>
            <returns>true on success, false on failure</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.DrawPolygon(RMA.OpenNURBS.IOn3dPointArray,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Boolean)">
            <summary>Draw a closed shape.</summary>
            <param name="points">[in] array of world coordinate points that are connected by lines to form a closed shape</param>
            <param name="color">[in] draw color used for the polygon</param>
            <param name="filled">
[in] true if the closed area should be filled with color.
false if you want to draw just the border of the closed shape
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.DrawPolyline(RMA.OpenNURBS.IOnPolyline,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32)">
            <summary>Draw a solid polyline with a given color and thickness</summary>
            <param name="polyline">[in] polyline to draw in world coordinates</param>
            <param name="color">[in] color of polyline</param>
            <param name="thickness">[in] thickness in pixels</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.DrawPolyline(RMA.OpenNURBS.IOnPolyline,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32,System.UInt32)">
            <summary>Draw a polyline with a given color, thickness, and pattern</summary>
            <param name="polyline">[in] polyline to draw in world coordinates</param>
            <param name="color">[in] color of polyline</param>
            <param name="thickness">[in] thickness in pixels</param>
            <param name="pattern">
[in] bit pattern for polyline. 0xFFFFFFFF is a solid polyline
see glLineStipple documentation online for a description of pattern
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.DrawLine(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32)">
            <summary>Draw a solid line with a given color and thickness</summary>
            <param name="from">[in] start of line in world coordinates</param>
            <param name="to">[in] end of line in world coordinates</param>
            <param name="color">[in] color of line</param>
            <param name="thickness">[in] thickness in pixels</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.DrawLine(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32,System.UInt32)">
            <summary>Draw a line with a given color, thickness, and pattern</summary>
            <param name="from">[in] start of line in world coordinates</param>
            <param name="to">[in] end of line in world coordinates</param>
            <param name="color">[in] color of line</param>
            <param name="thickness">[in] thickness in pixels</param>
            <param name="pattern">
[in] bit pattern for line. 0xFFFFFFFF is a solid line
see glLineStipple documentation online for a description of pattern
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.DrawLine(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Draw a line using the current display attributes object color and line
thickness (m_ObjectColor, m_nLineThickness)
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.DrawPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Draw a point using the current display attributes point size, point style
and object color (m_nPointSize, m_ePointStyle, m_ObjectColor)
</summary>
            <param name="point">[in] location of point in world coordinates</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.DrawObject(RMA.Rhino.IRhinoObject)">
            <summary>
Feedback drawing routines...Note: These methods should really only be used
for drawing objects while inside feedback operations...calling them from
outside the pipeline will have unknown results.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.DrawObject(RMA.Rhino.IRhinoObject,RMA.OpenNURBS.IOnXform)">
            <summary>
Feedback drawing routines...Note: These methods should really only be used
for drawing objects while inside feedback operations...calling them from
outside the pipeline will have unknown results.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.BlendMaterialWithColor(RMA.Rhino.MDisplayPipelineMaterial@,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Modifies the passed in display material object so that it draws
blended with the passed in color...
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.BlendMaterialWithColor(RMA.Rhino.MDisplayPipelineMaterial@,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Double)">
            <summary>
Modifies the passed in display material object so that it draws
blended with the passed in color...
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.PushModelTransform(RMA.OpenNURBS.IOnXform)">
            <summary>
Push a model transoformation on the engine's model transform stack
See CRhinoDisplayEngine::PushModelTransform
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.SetStereoMode(System.Boolean)">
            <summary>Turn on/off stereo mode for the pipeline</summary>
            <returns>
true on success
false if you are attempting to turn on stereo mode for an engine that does not support stereo drawing
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.SetPrintingMode(System.Boolean)">
            <summary>
Set this to true to inform the pipeline that the purpose of drawing future frames is
for printing.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.SetCapture">
            <summary>
Tells the pipeline that it needs to copy the frame buffer contents to the pipeline managed frame buffer DIB
at the end of drawing the current frame
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.SetCapture(System.Boolean)">
            <summary>
Tells the pipeline that it needs to copy the frame buffer contents to the pipeline managed frame buffer DIB
at the end of drawing the current frame
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.ShadingRequired">
            <summary>
If the pipeline is currently not using a render engine that supports shading and during
the drawing of a frame it is determined that something needs to be shaded, this flag is set
to inform the redraw mechanism that it should redraw and attempt to switch to a pipeline/engine
that supports shading
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.SetShadingRequired">
            <summary>
The "ShadingRequired" flag gets set inside the pipeline when a request is
made to draw a shaded mesh but the current render engine doesn't support shaded
mesh drawing...at this point the redraw mechanism will make sure everything will
work the next time around.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.SetShadingRequired(System.Boolean)">
            <summary>
The "ShadingRequired" flag gets set inside the pipeline when a request is
made to draw a shaded mesh but the current render engine doesn't support shaded
mesh drawing...at this point the redraw mechanism will make sure everything will
work the next time around.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.SetModelTransform(RMA.OpenNURBS.IOnXform)">
            <summary>Set the model transformation that is applied to geometry being drawn.</summary>
            <returns>Old model transformation that the engine was using</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.SetFrameSize(System.Int32,System.Int32)">
            <summary>
Set the viewport size for this pipeline. This function does affect the CRhinoViewport that this
pipeline uses.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.SetRedraw(System.Boolean)">
            <summary>
Sets a flag in the pipeline to tell it that it needs to redraw itself.
During the drawing of a frame, the pipeline may decide that it needs to run through the frame buffer
drawing code again and does this by setting the redraw flag in the pipeline.

If you want to tell a pipeline to redraw outside the scope of drawing a frame, call CRhinoView::Redraw
or CRhinoDoc::Redraw
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.SetObjectTransform(System.Int32,RMA.OpenNURBS.IOnXform)">
            <summary>Sets a model space transformation on an object in the display list at index</summary>
            <returns>true on success</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.AddObjectTransform(System.Int32,RMA.OpenNURBS.IOnXform)">
            <summary>
Adds(multiplies) a model space transformation on an object in the display list at index
If the frame is currently in a dynamic display mode, then no transformation will be set
</summary>
            <returns>true on success</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.DrawingSurfaces">
            <returns>true if the pipeline is currently in a surface drawing operation</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.DrawingGrips">
            <returns>true if the pipeline is currently in a grip drawing operation</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.DrawingWires">
            <returns>true if the pipeline is currently in a curve drawing operation</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.NestLevel">
            <summary>
Returns the current nested viewport drawing level. This is used to know if you are currently inside the drawing
of a nested viewport (detail object in Rhino).
Nest level = 0 Drawing is occuring in a standard Rhino viewport or on the page viewport
Nest level = 1 Drawing is occuring inside a detail view object
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.RenderPass">
            <summary>
Returns the current pass that the pipeline is in for drawing a frame. Typically drawing a frame requires
a single pass through the DrawFrameBuffer function, but some special display effects can be achived through
drawing with multiple passes.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.Redraw">
            <summary>
Returns true if this pipeline has set a flag that tells it that it needs to redraw itself.
During the drawing of a frame, the pipeline may decide that it needs to run through the frame buffer
drawing code again and does this by setting the redraw flag in the pipeline.
 
This DOES NOT set the redraw flag. For this use SetRedraw.
If you want to tell a pipeline to redraw outside the scope of drawing a frame, call CRhinoView::Redraw
or CRhinoDoc::Redraw
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.DisplayAttrs">
            <returns>
The current display pipeline attributes used by the pipeline to define how objects are drawn
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.GetObjectDisplayAttrs(RMA.Rhino.IRhinoObject)">
            <summary>
Returns the display pipeline drawing attributes that will be used to draw a given rhino object in this pipeline
</summary>
            <param name="pObject">[in] the object to look up display pipeline attributes for</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.GetObjectDisplayAttrs(RMA.Rhino.IRhinoObject,RMA.Rhino.IRhinoObjectAttributes)">
            <summary>
Returns the display pipeline drawing attributes that will be used to draw a given rhino object in this pipeline
</summary>
            <param name="pObject">[in] the object to look up display pipeline attributes for</param>
            <param name="pAttributes">
[in] if you want to use something other than the object's current attributes, pass in a different object attributes.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.GetObjectAttributes(System.Int32)">
            <summary>
The pipeline maintains a list of objects that it draws during a single frame. This function retrieves
the attributes for an object from this list.
</summary>
            <param name="index">[in] index in object list &gt;= 0 and less than GetObjectCount()</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.GetObjectTransform(System.Int32)">
            <summary>
If the object at index has a model space transformation associated with it, return that transformation.
If no transformation is associated, then NULL is returned
</summary>
            <param name="index">[in] index in list for the object in question. See GetObject(int index)</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.ObjectHasTransform(System.Int32)">
            <summary>
Returns true if the object at index has a model space transformation associated with it
</summary>
            <param name="index">[in] index in list for the object in question. See GetObject(int index)</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.GetObjectOwner(System.Int32)">
            <summary>
The pipeline maintains a list of objects that it draws during a single frame. Instance definition objects in this
are broken into individual objects in this list. If an object is part of an instance definition, this function
returns the objects "parent" instance definition
</summary>
            <param name="index">[in] index in list for the object in question. See GetObject(int index)</param>
            <returns>the parent instance definition object if the object at index is part of an instance definition. NULL otherwise</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.GetObjectCount">
            <summary>
Retrieve the number of CRhinoObjects that this pipeline iterates through and draws
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.GetFrameBuffer">
            <summary>
The display pipeline stores a copy of the front color buffer (frame buffer) that is used to draw to the screen. This
is updated every frame.
</summary>
            <returns>The bitmap that represents what is blitted to the screen</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.GetFrameTickDelta">
            <summary>
Retrieve the amount of time that has elapsed since the current frame draw operation has begun
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.GetFrameETA">
            <summary>
Retrieve the estimated time that this frame drawing operation will complete. This is based off of previous frame drawing.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.GetFrameTick">
            <summary>
Just calls the standard C++ clock function which retrieves the number of clock ticks that have elapsed
since Rhino was launched
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.ViewInDynamicDisplay">
            <summary>
Dynamic display is the state a viewport is in when it is rapidly redrawing because of an operation like panning or rotating.
The pipeline will drop some level of detail while inside a dynamic display state to keep the frame rate as high as possible.
</summary>
            <returns>true if the current frame drawing is for a dynamic display viewport state.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.InterruptDrawing">
            <summary>
Tests to see if the pipeline should stop drawing more geometry and just show what it has so far.
If a drawing operation is taking a long time, this function will return true and tell Rhino it should just
finish up and show the frame buffer. This is used in dynamic drawing operations.
</summary>
            <returns>true if the pipeline should stop attempting to draw more geometry and just show the frame buffer</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.IsActive(RMA.Rhino.IRhinoObject)">
            <summary>
Determines if an object can be visible in this viewport based on it's object type and display attributes.
This test does not check for visibility based on location of the object.

NOTE: Use CRhinoDisplayPipeline::IsVisible() to perform "visibility"
tests based on location (is some part of the object in the view frustum).
Use CRhinoDisplayPipeline::IsActive() to perform "visibility"
tests based on object type.
</summary>
            <returns>
true if this object can be drawn in the pipeline's viewport based on it's object type and display attributes
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.IsVisible(RMA.OpenNURBS.IOnBoundingBox)">
            <returns>
True if some portion of a 3d world coordinate bounding box is inside the view frustum under the current
viewport and model transformation settings
</returns>
            <param name="bbox">[in] the box to test for visibility</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.IsVisible(RMA.Rhino.IRhinoObject)">
            <returns>
True if this object is inside the view frustum under the current viewport and model
transformation settings. This function calls a virtual IsVisibleFinal function that
subclassed pipelines can add extra tests to. In the base class, this test only tests
visibility based on the objects world coordinates location and does not pay attention
to the object's attributes

NOTE: Use CRhinoDisplayPipeline::IsVisible() to perform "visibility"
tests based on location (is some part of the object in the view frustum).
Use CRhinoDisplayPipeline::IsActive() to perform "visibility"
tests based on object type.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.IsVisible(RMA.OpenNURBS.IOn3dPoint)">
            <returns>
True if a given 3d world coordinate point is inside the view frustum under the current
viewport and model transformation settings
</returns>
            <param name="world_coordinate">[in] the point to test for visibility</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.ModelTransform">
            <returns>The current model transformation that is applied to vertices when drawing.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.VP">
            <returns>The viewport that this pipeline uses to define projection information when drawing</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.ActiveStereoProjection">
            <returns>
The current stereo projection if stereo mode is on
0 = left, 1 = right
If stereo mode is not enable, this just returns 0
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.InStereoMode">
            <returns>
True if this pipeline is currently using an engine that is performing stereo style drawing
Stereo drawing is for providing an "enhanced 3-D" effect through stereo viewing devices
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.IsPrinting">
            <returns>True if this pipeline is currently drawing for printing purposes</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.IsAccelerated">
            <returns>True if this pipeline is using an engine that takes advantage of hardware acceleration</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.InFeedbackMode">
            <returns>
True if the pipeline is currently drawing a feedback type display.
Feedback mode is defined as being in a GetPoint or in some kind of
overlay conduit... but not in a dynamic view command
(Pan, Rotate, Zoom, RotateCamera)
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.InOverlayMode">
            <summary>
Get list of display conduits bound to this pipeline
</summary>
            <returns>
True if the pipeline is currently in overlay mode. The overlay stage of drawing
occurs after everything else has been drawn in a frame. It is used to draw things
like highlighted geometry.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.GetLevelOfDetail">
            <returns>Current level of detail value used by this pipeline for drawing a frame</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.GetFramesPerSecond">
            <returns>
The average frames per second interval for drawing with the current set of geometry
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.GetDesiredSingleFrameRate">
            <returns>
The desired amount of time to stay under for drawing a frame
The pipeline makes decisions on level of detail when the frame rate
exceeds this desired value.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.GetSingleFrameRate">
            <returns>The average amount of time required to draw a single frame</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.GetFrameSize">
            <returns>The size of the framebuffer that this pipeline is drawing to</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.Engine">
            <summary>
Every pipeline contains an instance of a display engine. The engine is used to perform
the low level drawing operations for the pipeline.
</summary>
            <returns>the engine associated to this pipeline</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.GetRhinoVP">
            <returns>
The viewport that this pipeline uses to define projections and what gets drawn. It is
assumed that a pipeline always has an associated viewport.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.GetDrawDC">
            <summary>
attempts to "locate" the DC that is currently being used to render...
This can either be the pipeline's DC, the Engine's DC, or a DC created from
the pipeline's attached window (if one exists).
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.GetOutputDC">
            <summary>
returns the Pipeline's m_pDC member...
this is usually the final "output" DC
and not necessarily the "draw" DC.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.ClearAllBindings(RMA.Rhino.IRhinoViewport)">
            <summary>
Unbinds all registered conduits from a given viewport.
See CRhinoDisplayConduit::Bind and Unbind
</summary>
            <param name="pViewport">[in] the viewport to remove conduit bindings from</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.MeshGenerationEnabled">
            <returns>
static state determining if pipelines should automatically generate meshes
for surfaces when needed in shaded display modes
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.EnableMeshGeneration">
            <summary>Turn on automatic mesh generation for surfaces in shaded display modes.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.EnableMeshGeneration(System.Boolean)">
            <summary>Turn on/off automatic mesh generation for surfaces in shaded display modes.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.UnregisterConduit(RMA.Rhino.MRhinoDisplayConduit)">
            <summary>
Display conduits are maintained in lists that are accessed by pipelines and
iterated through at the appropriate time during the drawing of a frame.
This function removes a given display conduit from these lists. Typically you would
call CRhinoDisplayConduit::Disable to perform this operation instead of calling
this static function (Disable just calls UnregisterConduit(this)).
</summary>
            <param name="conduit">[in] the conduit to unregister</param>
            <returns>Always returns true</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplayPipeline.RegisterConduit(RMA.Rhino.MRhinoDisplayConduit)">
            <summary>
Display conduits are maintained in lists that are accessed by pipelines and
iterated through at the appropriate time during the drawing of a frame.
This function adds a given display conduit to these lists. Typically you would
call CRhinoDisplayConduit::Enable to perform this operation instead of calling
this static function (Enable just calls RegisterConduit(this)).
</summary>
            <param name="conduit">[in] the conduit to register</param>
            <returns>Always returns true</returns>
        </member>
        <member name="P:RMA.Rhino.MRhinoDisplayPipeline.m_layout_tile">
            <value>
Tiled position on high-res display
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoDisplayPipeline.m_nLayoutHeight">
            <value>
Height of high-res display (-1 if not in high-res operation)
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoDisplayPipeline.m_nLayoutWidth">
            <value>
reserved...note: always keep this padded
</value>
            <value>
Width of high-res display (-1 if not in high-res operation)
</value>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.BlendMaterialWithColor(RMA.Rhino.MDisplayPipelineMaterial@,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Modifies the passed in display material object so that it draws
blended with the passed in color...
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.BlendMaterialWithColor(RMA.Rhino.MDisplayPipelineMaterial@,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Double)">
            <summary>
Modifies the passed in display material object so that it draws
blended with the passed in color...
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.ShadingRequired">
            <summary>
If the pipeline is currently not using a render engine that supports shading and during
the drawing of a frame it is determined that something needs to be shaded, this flag is set
to inform the redraw mechanism that it should redraw and attempt to switch to a pipeline/engine
that supports shading
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.DrawingSurfaces">
            <returns>true if the pipeline is currently in a surface drawing operation</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.DrawingGrips">
            <returns>true if the pipeline is currently in a grip drawing operation</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.DrawingWires">
            <returns>true if the pipeline is currently in a curve drawing operation</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.NestLevel">
            <summary>
Returns the current nested viewport drawing level. This is used to know if you are currently inside the drawing
of a nested viewport (detail object in Rhino).
Nest level = 0 Drawing is occuring in a standard Rhino viewport or on the page viewport
Nest level = 1 Drawing is occuring inside a detail view object
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.RenderPass">
            <summary>
Returns the current pass that the pipeline is in for drawing a frame. Typically drawing a frame requires
a single pass through the DrawFrameBuffer function, but some special display effects can be achived through
drawing with multiple passes.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.Redraw">
            <summary>
Returns true if this pipeline has set a flag that tells it that it needs to redraw itself.
During the drawing of a frame, the pipeline may decide that it needs to run through the frame buffer
drawing code again and does this by setting the redraw flag in the pipeline.
 
This DOES NOT set the redraw flag. For this use SetRedraw.
If you want to tell a pipeline to redraw outside the scope of drawing a frame, call CRhinoView::Redraw
or CRhinoDoc::Redraw
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.DisplayAttrs">
            <returns>
The current display pipeline attributes used by the pipeline to define how objects are drawn
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.GetObjectDisplayAttrs(RMA.Rhino.IRhinoObject)">
            <summary>
Returns the display pipeline drawing attributes that will be used to draw a given rhino object in this pipeline
</summary>
            <param name="pObject">[in] the object to look up display pipeline attributes for</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.GetObjectDisplayAttrs(RMA.Rhino.IRhinoObject,RMA.Rhino.IRhinoObjectAttributes)">
            <summary>
Returns the display pipeline drawing attributes that will be used to draw a given rhino object in this pipeline
</summary>
            <param name="pObject">[in] the object to look up display pipeline attributes for</param>
            <param name="pAttributes">
[in] if you want to use something other than the object's current attributes, pass in a different object attributes.
</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.GetObjectAttributes(System.Int32)">
            <summary>
The pipeline maintains a list of objects that it draws during a single frame. This function retrieves
the attributes for an object from this list.
</summary>
            <param name="index">[in] index in object list &gt;= 0 and less than GetObjectCount()</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.GetObjectTransform(System.Int32)">
            <summary>
If the object at index has a model space transformation associated with it, return that transformation.
If no transformation is associated, then NULL is returned
</summary>
            <param name="index">[in] index in list for the object in question. See GetObject(int index)</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.ObjectHasTransform(System.Int32)">
            <summary>
Returns true if the object at index has a model space transformation associated with it
</summary>
            <param name="index">[in] index in list for the object in question. See GetObject(int index)</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.GetObjectOwner(System.Int32)">
            <summary>
The pipeline maintains a list of objects that it draws during a single frame. Instance definition objects in this
are broken into individual objects in this list. If an object is part of an instance definition, this function
returns the objects "parent" instance definition
</summary>
            <param name="index">[in] index in list for the object in question. See GetObject(int index)</param>
            <returns>the parent instance definition object if the object at index is part of an instance definition. NULL otherwise</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.GetObjectCount">
            <summary>
Retrieve the number of CRhinoObjects that this pipeline iterates through and draws
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.GetFrameBuffer">
            <summary>
The display pipeline stores a copy of the front color buffer (frame buffer) that is used to draw to the screen. This
is updated every frame.
</summary>
            <returns>The bitmap that represents what is blitted to the screen</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.GetFrameTickDelta">
            <summary>
Retrieve the amount of time that has elapsed since the current frame draw operation has begun
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.GetFrameETA">
            <summary>
Retrieve the estimated time that this frame drawing operation will complete. This is based off of previous frame drawing.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.GetFrameTick">
            <summary>
Just calls the standard C++ clock function which retrieves the number of clock ticks that have elapsed
since Rhino was launched
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.IsActive(RMA.Rhino.IRhinoObject)">
            <summary>
Determines if an object can be visible in this viewport based on it's object type and display attributes.
This test does not check for visibility based on location of the object.

NOTE: Use CRhinoDisplayPipeline::IsVisible() to perform "visibility"
tests based on location (is some part of the object in the view frustum).
Use CRhinoDisplayPipeline::IsActive() to perform "visibility"
tests based on object type.
</summary>
            <returns>
true if this object can be drawn in the pipeline's viewport based on it's object type and display attributes
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.IsVisible(RMA.OpenNURBS.IOnBoundingBox)">
            <returns>
True if some portion of a 3d world coordinate bounding box is inside the view frustum under the current
viewport and model transformation settings
</returns>
            <param name="bbox">[in] the box to test for visibility</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.IsVisible(RMA.Rhino.IRhinoObject)">
            <returns>
True if this object is inside the view frustum under the current viewport and model
transformation settings. This function calls a virtual IsVisibleFinal function that
subclassed pipelines can add extra tests to. In the base class, this test only tests
visibility based on the objects world coordinates location and does not pay attention
to the object's attributes

NOTE: Use CRhinoDisplayPipeline::IsVisible() to perform "visibility"
tests based on location (is some part of the object in the view frustum).
Use CRhinoDisplayPipeline::IsActive() to perform "visibility"
tests based on object type.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.IsVisible(RMA.OpenNURBS.IOn3dPoint)">
            <returns>
True if a given 3d world coordinate point is inside the view frustum under the current
viewport and model transformation settings
</returns>
            <param name="world_coordinate">[in] the point to test for visibility</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.ModelTransform">
            <returns>The current model transformation that is applied to vertices when drawing.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.VP">
            <returns>The viewport that this pipeline uses to define projection information when drawing</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.ActiveStereoProjection">
            <returns>
The current stereo projection if stereo mode is on
0 = left, 1 = right
If stereo mode is not enable, this just returns 0
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.InStereoMode">
            <returns>
True if this pipeline is currently using an engine that is performing stereo style drawing
Stereo drawing is for providing an "enhanced 3-D" effect through stereo viewing devices
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.IsPrinting">
            <returns>True if this pipeline is currently drawing for printing purposes</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.IsAccelerated">
            <returns>True if this pipeline is using an engine that takes advantage of hardware acceleration</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.InFeedbackMode">
            <returns>
True if the pipeline is currently drawing a feedback type display.
Feedback mode is defined as being in a GetPoint or in some kind of
overlay conduit... but not in a dynamic view command
(Pan, Rotate, Zoom, RotateCamera)
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.InOverlayMode">
            <returns>
True if the pipeline is currently in overlay mode. The overlay stage of drawing
occurs after everything else has been drawn in a frame. It is used to draw things
like highlighted geometry.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.GetLevelOfDetail">
            <returns>Current level of detail value used by this pipeline for drawing a frame</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.GetFramesPerSecond">
            <returns>
The average frames per second interval for drawing with the current set of geometry
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.GetDesiredSingleFrameRate">
            <returns>
The desired amount of time to stay under for drawing a frame
The pipeline makes decisions on level of detail when the frame rate
exceeds this desired value.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.GetSingleFrameRate">
            <returns>The average amount of time required to draw a single frame</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.GetFrameSize">
            <returns>The size of the framebuffer that this pipeline is drawing to</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.GetRhinoVP">
            <returns>
The viewport that this pipeline uses to define projections and what gets drawn. It is
assumed that a pipeline always has an associated viewport.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.GetWnd">
            <returns>The window that this pipeline is associated with.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.GetDrawDC">
            <summary>
attempts to "locate" the DC that is currently being used to render...
This can either be the pipeline's DC, the Engine's DC, or a DC created from
the pipeline's attached window (if one exists).
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplayPipeline.GetOutputDC">
            <summary>
returns the Pipeline's m_pDC member...
this is usually the final "output" DC
and not necessarily the "draw" DC.
</summary>
        </member>
        <member name="P:RMA.Rhino.IRhinoDisplayPipeline.m_layout_tile">
            <value>
Tiled position on high-res display
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoDisplayPipeline.m_nLayoutHeight">
            <value>
Height of high-res display (-1 if not in high-res operation)
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoDisplayPipeline.m_nLayoutWidth">
            <value>
reserved...note: always keep this padded
</value>
            <value>
Width of high-res display (-1 if not in high-res operation)
</value>
        </member>
        <member name="T:RMA.Rhino.IRhinoDisplayPipeline">
            <summary>
Drawing in Rhino is performed by a display pipeline / display engine
pair. The pipeline feeds geometry for drawing to an engine and also
controls the order to drawing operations.
</summary>
        </member>
        <member name="P:RMA.Rhino.MDisplayPipelineAttributes.m_bUseDefaultMeshEdges">
            <value>
edges....
</value>
        </member>
        <member name="P:RMA.Rhino.MDisplayPipelineAttributes.m_bDegradeIsoDensity">
            <value>
experimental
</value>
        </member>
        <member name="P:RMA.Rhino.MDisplayPipelineAttributes.m_bUseDefaultIso">
            <value>
iso's...
</value>
        </member>
        <member name="P:RMA.Rhino.IDisplayPipelineAttributes.m_bUseDefaultMeshEdges">
            <value>
edges....
</value>
        </member>
        <member name="P:RMA.Rhino.IDisplayPipelineAttributes.m_bDegradeIsoDensity">
            <value>
experimental
</value>
        </member>
        <member name="P:RMA.Rhino.IDisplayPipelineAttributes.m_bUseDefaultIso">
            <value>
iso's...
</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_pFrameBuffer">
            <value>Post Processing Frame Buffer conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_bFrameBufferModified">
            <value>Post Processing Frame Buffer conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_MeshingParms">
            <value>Meshing Parameters conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_bUseMeshingParms">
            <value>Meshing Parameters conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_bDrawWorldAxes">
            <value>Draw foreground conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_bWorldAxesDrawn">
            <value>Draw foreground conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_pObject">
            <value>Draw object AND Object Culling conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_nObjectIndex">
            <value>Draw object AND Object Culling conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_bObjectColorOverridden">
            <value>Draw object AND Object Culling conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_bObjectReplaced">
            <value>Draw object AND Object Culling conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_bDrawObject">
            <value>Draw object AND Object Culling conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_bHiddenLineRemoval">
            <value>Draw middleground conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_bSortByDistance">
            <value>Draw middleground conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_Lights">
            <value>Setup Lighting conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_eLightingScheme">
            <value>Setup Lighting conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_BgBitmapDib">
            <value>Draw background conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_sBgBitmapFilename">
            <value>Draw background conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_bBgBitmapDrawn">
            <value>Draw background conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_bBgBitmapProvided">
            <value>Draw background conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_WallpaperDib">
            <value>Draw background conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_sWallpaperFilename">
            <value>Draw background conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_bWallpaperDrawn">
            <value>Draw background conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_bWallpaperProvided">
            <value>Draw background conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_bDrawBackgroundBitmap">
            <value>Draw background conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_bDrawWallpaper">
            <value>Draw background conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_bAxesDrawn">
            <value>Draw background conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_bDrawConstructionAxes">
            <value>Draw background conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_bGridDrawn">
            <value>Draw background conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_bDrawZAxis">
            <value>Draw background conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_bDrawConstructionGrid">
            <value>Draw background conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_bDrawConstructionGridOnTop">
            <value>Draw background conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_dBottom">
            <value>Setup Frustum conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_dTop">
            <value>Setup Frustum conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_dRight">
            <value>Setup Frustum conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_dLeft">
            <value>Setup Frustum conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_ClippingPlanes">
            <value>Calc clipping planes conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_dFar">
            <value>Calc clipping planes conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_dNear">
            <value>Calc clipping planes conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_BoundingBox">
            <value>Calc BoundingBox conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_bUseExclusiveBBox">
            <value>Calc BoundingBox conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_pBgBitmap">
            <value>Init framebuffer conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_GradBotRight">
            <value>Init framebuffer conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_GradTopRight">
            <value>Init framebuffer conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_GradBotLeft">
            <value>Init framebuffer conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_GradTopLeft">
            <value>Init framebuffer conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_SolidColor">
            <value>Init framebuffer conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_eFrameBufferFillMode">
            <value>Init framebuffer conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.MChannelAttributes.m_bFramebufferCleared">
            <value>Init framebuffer conduit channel attributes...</value>
        </member>
        <member name="T:RMA.Rhino.MChannelAttributes">
            <summary>
Flags and attributes need to be provided to pass back and forth to the
conduits based on all of the default stuff the pipeline draws in 
its channels.

Reason: Conduits may want to override the default behavior (eg. DrawGrid),
       so we need a way for conduits to tell the pipeline what is being
       done, as well as let other conduits know what has already been 
       done.  

Note: These are all based on what Rhino's pipeline does...there is no
     way to second guess what other pipelines will or won't do, so all
     we can do for now is tell conduits as much as we can about Rhino's
     pipeline attributes...
Note: accessing and/or setting attributes outside their
     required channel is an unknown behavior or operation.
     Besides, the pipeline initializes these attributes on 
     a per-channel basis, so for example, setting an attribute
     designated for DrawMiddleground channels from within a
     DrawBackground channel has no affect.
</summary>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_pFrameBuffer">
            <value>Post Processing Frame Buffer conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_bFrameBufferModified">
            <value>Post Processing Frame Buffer conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_MeshingParms">
            <value>Meshing Parameters conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_bUseMeshingParms">
            <value>Meshing Parameters conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_bDrawWorldAxes">
            <value>Draw foreground conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_bWorldAxesDrawn">
            <value>Draw foreground conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_pObject">
            <value>Draw object AND Object Culling conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_nObjectIndex">
            <value>Draw object AND Object Culling conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_bObjectColorOverridden">
            <value>Draw object AND Object Culling conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_bObjectReplaced">
            <value>Draw object AND Object Culling conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_bDrawObject">
            <value>Draw object AND Object Culling conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_bHiddenLineRemoval">
            <value>Draw middleground conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_bSortByDistance">
            <value>Draw middleground conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_Lights">
            <value>Setup Lighting conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_eLightingScheme">
            <value>Setup Lighting conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_BgBitmapDib">
            <value>Draw background conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_sBgBitmapFilename">
            <value>Draw background conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_bBgBitmapDrawn">
            <value>Draw background conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_bBgBitmapProvided">
            <value>Draw background conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_WallpaperDib">
            <value>Draw background conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_sWallpaperFilename">
            <value>Draw background conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_bWallpaperDrawn">
            <value>Draw background conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_bWallpaperProvided">
            <value>Draw background conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_bDrawBackgroundBitmap">
            <value>Draw background conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_bDrawWallpaper">
            <value>Draw background conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_bAxesDrawn">
            <value>Draw background conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_bDrawConstructionAxes">
            <value>Draw background conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_bGridDrawn">
            <value>Draw background conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_bDrawZAxis">
            <value>Draw background conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_bDrawConstructionGrid">
            <value>Draw background conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_bDrawConstructionGridOnTop">
            <value>Draw background conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_dBottom">
            <value>Setup Frustum conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_dTop">
            <value>Setup Frustum conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_dRight">
            <value>Setup Frustum conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_dLeft">
            <value>Setup Frustum conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_ClippingPlanes">
            <value>Calc clipping planes conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_dFar">
            <value>Calc clipping planes conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_dNear">
            <value>Calc clipping planes conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_BoundingBox">
            <value>Calc BoundingBox conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_bUseExclusiveBBox">
            <value>Calc BoundingBox conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_pBgBitmap">
            <value>Init framebuffer conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_GradBotRight">
            <value>Init framebuffer conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_GradTopRight">
            <value>Init framebuffer conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_GradBotLeft">
            <value>Init framebuffer conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_GradTopLeft">
            <value>Init framebuffer conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_SolidColor">
            <value>Init framebuffer conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_eFrameBufferFillMode">
            <value>Init framebuffer conduit channel attributes...</value>
        </member>
        <member name="P:RMA.Rhino.IChannelAttributes.m_bFramebufferCleared">
            <value>Init framebuffer conduit channel attributes...</value>
        </member>
        <member name="T:RMA.Rhino.IChannelAttributes">
            <summary>
Flags and attributes need to be provided to pass back and forth to the
conduits based on all of the default stuff the pipeline draws in 
its channels.

Reason: Conduits may want to override the default behavior (eg. DrawGrid),
       so we need a way for conduits to tell the pipeline what is being
       done, as well as let other conduits know what has already been 
       done.  

Note: These are all based on what Rhino's pipeline does...there is no
     way to second guess what other pipelines will or won't do, so all
     we can do for now is tell conduits as much as we can about Rhino's
     pipeline attributes...
Note: accessing and/or setting attributes outside their
     required channel is an unknown behavior or operation.
     Besides, the pipeline initializes these attributes on 
     a per-channel basis, so for example, setting an attribute
     designated for DrawMiddleground channels from within a
     DrawBackground channel has no affect.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoMorphControl.EnableGrips(System.Boolean)">
            <summary>
virtual CRhinoObject::EnableGrips override
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoMorphControl.Control">
            <summary>Get a pointer to the object's NURBS control.</summary>
            <returns>Pointer to the object's ON_NurbsControl.</returns>
            <remarks>~CRhinoMorphControl deletes this pointer.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoMorphControl.SetControl(RMA.OpenNURBS.OnMorphControl)">
            <summary>
Sets the object's m_control to be the input paramter.
~CRhinoMorphControl will delete the pointer.
</summary>
            <param name="control">[in]</param>
            <returns>True if input is valid.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoMorphControl.SetControl(RMA.OpenNURBS.IOnMorphControl)">
            <summary>Sets the object's m_control to be a copy of the input paramter.</summary>
            <param name="control">[in] copied.</param>
            <returns>True if input is valid.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoMorphControl.#ctor(RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <summary>
assigns a new object UUID
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoMorphControl.#ctor">
            <summary>
assigns a new object UUID
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoMorphControl.Control">
            <summary>Get a pointer to the object's NURBS control.</summary>
            <returns>Pointer to the object's ON_NurbsControl.</returns>
            <remarks>~CRhinoMorphControl deletes this pointer.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoCageObject.EnableGrips(System.Boolean)">
            <summary>
virtual CRhinoObject::EnableGrips override
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoCageObject.Cage">
            <summary>Get a pointer to the object's NURBS cage.</summary>
            <returns>Pointer to the object's ON_NurbsCage.</returns>
            <remarks>~CRhinoCageObject deletes this pointer.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoCageObject.SetCage(RMA.OpenNURBS.OnNurbsCage)">
            <summary>
Sets the object's m_control to be the input paramter.
~CRhinoCageObject will delete the pointer.
</summary>
            <param name="cage">[in]</param>
            <returns>True if input is valid.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoCageObject.SetCage(RMA.OpenNURBS.IOnNurbsCage)">
            <summary>Sets the object's m_control to be a copy of the input paramter.</summary>
            <param name="cage">[in] copied.</param>
            <returns>True if input is valid.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoCageObject.#ctor(RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <summary>
assigns a new object UUID
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoCageObject.#ctor">
            <summary>
assigns a new object UUID
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoCageObject.Cage">
            <summary>Get a pointer to the object's NURBS cage.</summary>
            <returns>Pointer to the object's ON_NurbsCage.</returns>
            <remarks>~CRhinoCageObject deletes this pointer.</remarks>
        </member>
        <member name="T:RMA.Rhino.MRhinoWireframeObject">
            <summary>
CRhinoWireframeObject is a pure virtual class for wireframe
objects that do not have to support subobject picking.
</summary>
        </member>
        <member name="T:RMA.Rhino.IRhinoWireframeObject">
            <summary>
CRhinoWireframeObject is a pure virtual class for wireframe
objects that do not have to support subobject picking.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPolyEdgeSegment.TrimDomain">
            <returns>
subdomain of the trim that this segment uses. This can be different than the
domain returned by this-&gt;Domain().
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPolyEdgeSegment.EdgeDomain">
            <returns>
subdomain of the edge that this segment uses. This can be different than the
domain returned by this-&gt;Domain().
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPolyEdgeSegment.ReversedTrimDir">
            <returns>
True if this segment has an ON_BrepTrim and the direction of the ON_BrepTrim
is the reverse of the direction of the segment.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPolyEdgeSegment.ReversedEdgeDir">
            <returns>
True if this segment has an ON_BrepEdge and the direction of the ON_BrepEdge
is the reverse of the direction of the segment.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPolyEdgeSegment.SurfaceParameter(System.Double)">
            <summary>
Sets and returns m_srf_uv to the surface parameters at segment param t
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPolyEdgeSegment.Create(RMA.OpenNURBS.IOnCurve)">
            <summary>
Creates a polyedge segment that uses the entire curve and has the same domain as the curve.
</summary>
            <param name="curve">[in]</param>
            <remarks>
Use ON_Curve::SetDomain, ON_Curve::Trim, ON_Curve::Reverse, etc., to tweak the domain,
support, direction etc.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoPolyEdgeSegment.Create(RMA.OpenNURBS.IOnCurve,RMA.Rhino.IRhinoObject)">
            <summary>
Creates a polyedge segment that uses the entire curve and has the same domain as the curve.
</summary>
            <param name="curve">[in]</param>
            <remarks>
Use ON_Curve::SetDomain, ON_Curve::Trim, ON_Curve::Reverse, etc.,
to tweak the domain, support, direction etc.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoPolyEdgeSegment.Create(RMA.OpenNURBS.IOnBrepTrim)">
            <summary>
Creates a polyedge segment that uses the entire edge and has the same domain as the edge.
</summary>
            <param name="trim">[in]</param>
            <returns>true if successful (edge was valid and trim_index was valid)</returns>
            <remarks>
Use ON_Curve::SetDomain, ON_Curve::Trim, ON_Curve::Reverse, etc., to tweak the domain,
support, direction etc.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoPolyEdgeSegment.Create(RMA.OpenNURBS.IOnBrepTrim,RMA.Rhino.IRhinoObject)">
            <summary>
Creates a polyedge segment that uses the entire edge and has the same domain as the edge.
</summary>
            <param name="trim">[in]</param>
            <returns>true if successful (edge was valid and trim_index was valid)</returns>
            <remarks>
Use ON_Curve::SetDomain, ON_Curve::Trim, ON_Curve::Reverse, etc., to tweak the
domain, support, direction etc.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoPolyEdgeSegment.#ctor">
            <summary>
construction
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoPolyEdgeSegment.TrimDomain">
            <returns>
subdomain of the trim that this segment uses. This can be different than the
domain returned by this-&gt;Domain().
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoPolyEdgeSegment.EdgeDomain">
            <returns>
subdomain of the edge that this segment uses. This can be different than the
domain returned by this-&gt;Domain().
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoPolyEdgeSegment.ReversedTrimDir">
            <returns>
True if this segment has an ON_BrepTrim and the direction of the ON_BrepTrim
is the reverse of the direction of the segment.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoPolyEdgeSegment.ReversedEdgeDir">
            <returns>
True if this segment has an ON_BrepEdge and the direction of the ON_BrepEdge
is the reverse of the direction of the segment.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoPolyEdgeSegment.SurfaceParameter(System.Double)">
            <summary>
Sets and returns m_srf_uv to the surface parameters at segment param t
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPolyEdge.Remove">
            <summary>
remove last
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPolyEdge.FindCurve(RMA.OpenNURBS.IOnCurve)">
            <summary>See if this polyedge has a wire curve as one of its segments</summary>
            <param name="curve">[in] the curve to look for</param>
            <returns>
-1: trim is not in the polyedge
&gt;=0: index of first segment that uses the curve
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPolyEdge.FindTrim(RMA.OpenNURBS.IOnBrepTrim)">
            <summary>See if this polyedge has a trim as one of its segments</summary>
            <param name="trim">[in] the trim to look for</param>
            <returns>
-1: trim is not in the polyedge
&gt;=0: index of first segment that uses the trim
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPolyEdge.FindEdge(RMA.OpenNURBS.IOnBrepEdge)">
            <summary>See if this polyedge has an edge as one of its segments</summary>
            <param name="edge">[in] the edge to look for</param>
            <returns>
-1: edge is not in the polyedge
&gt;=0: index of first segment that uses the edge
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPolyEdge.EvSrfDerivatives(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate surface derivatives.</summary>
            <param name="t">[in] CRhinoPolyEdge curve parameter</param>
            <param name="srfpoint">[out] location on surface</param>
            <param name="du">[out]</param>
            <param name="dv">[out]</param>
            <param name="duu">[out]</param>
            <param name="duv">[out]</param>
            <param name="dvv">[out]</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoPolyEdge.EvSrfNormalCurvature(System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate surface normal curvature</summary>
            <param name="t">[in] CRhinoPolyEdge curve parameter</param>
            <param name="srftangent">[in] tangent to the surface</param>
            <param name="srfnormalcurvature">[out] normal curvature</param>
            <param name="srfnormal">[out] normal to surface</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoPolyEdge.EvSrfTangent(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate surface binormal and normal.</summary>
            <param name="t">[in] CRhinoPolyEdge curve parameter</param>
            <param name="srfpoint">[out] location on surface</param>
            <param name="srftangent">
[out] "binormal" tangent to the surface. The direction of this
tangent is controled by the surface tangent mode setting.
</param>
            <param name="srfnormal">[out] normal to surface</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoPolyEdge.SetSrfTangentMode(RMA.Rhino.IRhinoPolyEdge.eTanMode)">
            <summary>
The CRhinoPolyEdge EvSrf... tools can evaulate the "binormal" surface
tangent direction in several different ways.
</summary>
            <param name="tm">
[in] mode for CRhinoPolyEdge::EvSrf... tools to use when computing value of srftangent parameter.
See Also: CRhinoPolyEdge::SrfTangentMode
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoPolyEdge.SrfTangentMode">
            <summary>
The CRhinoPolyEdge EvSrf... tools can evaulate the "binormal" surface
tangent direction in several different ways.
</summary>
            <returns>
Current value of mode by CRhinoPolyEdge::EvSrf... tools when
computing value of srftangent parameter.
See Also: CRhinoPolyEdge::SrfTangentMode
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPolyEdge.ContainsAllEdges">
            <summary>
Test if all segments of the polyedge are surface edges
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPolyEdge.ContainsAnyEdges">
            <summary>
Test if there are any surface edges in the polyedge
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPolyEdge.EdgeAt(System.Double)">
            <summary>
if the segment is an edge, the following
return non-NULL pointers.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPolyEdge.Append(RMA.Rhino.MRhinoPolyEdgeSegment)">
            <summary>
Append curve.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPolyEdge.Prepend(RMA.Rhino.MRhinoPolyEdgeSegment)">
            <summary>
Prepend curve.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPolyEdge.Create(RMA.Rhino.IRhinoObjRef)">
            <summary>
Create a one segment CRhinoPolyEdge curve.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPolyEdge.Create(RMA.OpenNURBS.IOnCurve)">
            <summary>
Create a one segment CRhinoPolyEdge curve that uses a single curve.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPolyEdge.Create(RMA.OpenNURBS.IOnCurve,RMA.Rhino.IRhinoObject)">
            <summary>
Create a one segment CRhinoPolyEdge curve that uses a single curve.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPolyEdge.Create(RMA.OpenNURBS.IOnBrepTrim)">
            <summary>
Create a one segment CRhinoPolyEdge curve that uses a single edge.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPolyEdge.Create(RMA.OpenNURBS.IOnBrepTrim,RMA.Rhino.IRhinoObject)">
            <summary>
Create a one segment CRhinoPolyEdge curve that uses a single edge.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoPolyEdge.FindCurve(RMA.OpenNURBS.IOnCurve)">
            <summary>See if this polyedge has a wire curve as one of its segments</summary>
            <param name="curve">[in] the curve to look for</param>
            <returns>
-1: trim is not in the polyedge
&gt;=0: index of first segment that uses the curve
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoPolyEdge.FindTrim(RMA.OpenNURBS.IOnBrepTrim)">
            <summary>See if this polyedge has a trim as one of its segments</summary>
            <param name="trim">[in] the trim to look for</param>
            <returns>
-1: trim is not in the polyedge
&gt;=0: index of first segment that uses the trim
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoPolyEdge.FindEdge(RMA.OpenNURBS.IOnBrepEdge)">
            <summary>See if this polyedge has an edge as one of its segments</summary>
            <param name="edge">[in] the edge to look for</param>
            <returns>
-1: edge is not in the polyedge
&gt;=0: index of first segment that uses the edge
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoPolyEdge.EvSrfDerivatives(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate surface derivatives.</summary>
            <param name="t">[in] CRhinoPolyEdge curve parameter</param>
            <param name="srfpoint">[out] location on surface</param>
            <param name="du">[out]</param>
            <param name="dv">[out]</param>
            <param name="duu">[out]</param>
            <param name="duv">[out]</param>
            <param name="dvv">[out]</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoPolyEdge.EvSrfNormalCurvature(System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate surface normal curvature</summary>
            <param name="t">[in] CRhinoPolyEdge curve parameter</param>
            <param name="srftangent">[in] tangent to the surface</param>
            <param name="srfnormalcurvature">[out] normal curvature</param>
            <param name="srfnormal">[out] normal to surface</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoPolyEdge.EvSrfTangent(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate surface binormal and normal.</summary>
            <param name="t">[in] CRhinoPolyEdge curve parameter</param>
            <param name="srfpoint">[out] location on surface</param>
            <param name="srftangent">
[out] "binormal" tangent to the surface. The direction of this
tangent is controled by the surface tangent mode setting.
</param>
            <param name="srfnormal">[out] normal to surface</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoPolyEdge.SrfTangentMode">
            <summary>
The CRhinoPolyEdge EvSrf... tools can evaulate the "binormal" surface
tangent direction in several different ways.
</summary>
            <returns>
Current value of mode by CRhinoPolyEdge::EvSrf... tools when
computing value of srftangent parameter.
See Also: CRhinoPolyEdge::SrfTangentMode
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoPolyEdge.ContainsAllEdges">
            <summary>
Test if all segments of the polyedge are surface edges
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoPolyEdge.ContainsAnyEdges">
            <summary>
Test if there are any surface edges in the polyedge
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoPolyEdge.EdgeAt(System.Double)">
            <summary>
if the segment is an edge, the following
return non-NULL pointers.
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoFair.SetIterationCount(System.Int32)">
            <summary>Set the number of iterations to use in adjusting the curve</summary>
            <param name="count">Number of iterations</param>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoFair.IterationCount">
            <summary>Get the number of iterations to use in adjusting the curve</summary>
            <returns>Number of iterations</returns>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoFair.SetClampEnd(System.Int32)">
            <summary>Set the nunber of CV's on the end to keep in place</summary>
            <param name="dercount">Number of derivatives to fix</param>
            <remarks>0: position, 1: tangency, 2: curvature</remarks>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoFair.ClampEnd">
            <summary>Get the nunber of CV's on the end to keep in place</summary>
            <returns>Number of derivatives fixed</returns>
            <remarks>0: position, 1: tangency, 2: curvature</remarks>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoFair.SetClampStart(System.Int32)">
            <summary>Set the nunber of CV's on the start to keep in place</summary>
            <param name="dercount">Number of derivatives to fix</param>
            <remarks>0: position, 1: tangency, 2: curvature</remarks>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoFair.ClampStart">
            <summary>Get the nunber of CV's on the start to keep in place</summary>
            <returns>Number of derivatives fixed</returns>
            <remarks>0: position, 1: tangency, 2: curvature</remarks>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoFair.SetAngleTolerance(System.Double)">
            <summary>Set the angle tolerance</summary>
            <param name="tol">the new tolerance</param>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoFair.AngleTolerance">
            <summary>Get the angle tolerance</summary>
            <returns>the angle tolerance Remarks: Kinks less than this will be removed</returns>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoFair.SetTolerance(System.Double)">
            <summary>set the fairing position tolerance</summary>
            <param name="tol">the new tolerance</param>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoFair.Tolerance">
            <summary>Get the fairing position tolerance</summary>
            <returns>the fairing tolerance Remarks: The faired curve can deviate from the input by this much</returns>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoFair.SetInputCurve(RMA.OpenNURBS.IOnCurve)">
            <summary>Set the input curve to fair</summary>
            <param name="pC">pointer to the curve Returns: a new faired version of the curve</param>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoFair.InputCurve">
            <summary>Get the input curve to fair</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoFair.IterationCount">
            <summary>Get the number of iterations to use in adjusting the curve</summary>
            <returns>Number of iterations</returns>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoFair.ClampEnd">
            <summary>Get the nunber of CV's on the end to keep in place</summary>
            <returns>Number of derivatives fixed</returns>
            <remarks>0: position, 1: tangency, 2: curvature</remarks>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoFair.ClampStart">
            <summary>Get the nunber of CV's on the start to keep in place</summary>
            <returns>Number of derivatives fixed</returns>
            <remarks>0: position, 1: tangency, 2: curvature</remarks>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoFair.AngleTolerance">
            <summary>Get the angle tolerance</summary>
            <returns>the angle tolerance Remarks: Kinks less than this will be removed</returns>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoFair.Tolerance">
            <summary>Get the fairing position tolerance</summary>
            <returns>the fairing tolerance Remarks: The faired curve can deviate from the input by this much</returns>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoFair.InputCurve">
            <summary>Get the input curve to fair</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoLoft.#ctor">
            <summary>
Arguments to the Rhino SDK Loft function
------------------------------------------------------------------------------
</summary>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoLoft.m_bRevCurve">
            <value>
shape curves reversed from input direction
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoLoft.m_end_condition">
            <value>
eLoftEnds
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoLoft.m_simplify_method">
            <value>
eLoftSimplify
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoLoft.m_loft_type">
            <value>
eLoftType
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoLoft.m_bAllowEndTangent">
            <value>
set if the end curve is an edge
</value>
        </member>
        <member name="P:RMA.Rhino.MArgsRhinoLoft.m_bAllowStartTangent">
            <value>
set if the start curve is an edge
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoLoft.m_bRevCurve">
            <value>
shape curves reversed from input direction
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoLoft.m_end_condition">
            <value>
eLoftEnds
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoLoft.m_simplify_method">
            <value>
eLoftSimplify
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoLoft.m_loft_type">
            <value>
eLoftType
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoLoft.m_bAllowEndTangent">
            <value>
set if the end curve is an edge
</value>
        </member>
        <member name="P:RMA.Rhino.IArgsRhinoLoft.m_bAllowStartTangent">
            <value>
set if the start curve is an edge
</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoLoftCurve.CloserEnd">
            <summary>
flip so that the curve starts nearest the pick point
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDib.FileTypeFromFileName(System.String)">
            <summary>Call this method to get supported file type from file name.</summary>
            <param name="lpsFileName">
[in] File name, extension will be extracted from the end of this string
and compared to supported bitmap file types.
</param>
            <returns>a valid bitmap_file_type on success or unsupported_file_type if the file type is not supported.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDib.Print">
            <summary>
Description: Read bitmap from a memory buffer. Parameters: buffer - [in] sizeof_buffer - [in] number of bytes in the buffer Returns: TRUE - Image was read from buffer FALSE - Error reading buffer
</summary>
            <summary>Display print dialog</summary>
            <returns>
TRUE - DIB sent to printer
FALSE - Print dialog cancelled or error writing to printer.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDib.Print(System.Windows.Forms.IWin32Window)">
            <summary>
Description: Read bitmap from a memory buffer. Parameters: buffer - [in] sizeof_buffer - [in] number of bytes in the buffer Returns: TRUE - Image was read from buffer FALSE - Error reading buffer
</summary>
            <summary>Display print dialog</summary>
            <param name="hWnd">[in] Parent window for print dialog. If NULL will use Rhino frame window.</param>
            <returns>
TRUE - DIB sent to printer
FALSE - Print dialog cancelled or error writing to printer.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDib.Print(System.Windows.Forms.IWin32Window,System.Boolean)">
            <summary>
Description: Read bitmap from a memory buffer. Parameters: buffer - [in] sizeof_buffer - [in] number of bytes in the buffer Returns: TRUE - Image was read from buffer FALSE - Error reading buffer
</summary>
            <summary>Display print dialog</summary>
            <param name="hWnd">[in] Parent window for print dialog. If NULL will use Rhino frame window.</param>
            <returns>
TRUE - DIB sent to printer
FALSE - Print dialog cancelled or error writing to printer.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDib.ReadFromFile(System.String)">
            <summary>Read bitmap from disk.</summary>
            <param name="lpsFileName">
[in] Name of file to read. Uses CRhinoFileUtilities::FindFile(...) to validate file name.
</param>
            <returns>
TRUE - File was read from disk.
FALSE - Error reading file or invalid file type.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDib.ReadFromFile">
            <summary>Display Rhino bitmap open dialog prompting for name then read bitmap from disk.</summary>
            <returns>
TRUE - File name specified and writen to disk.
FALSE - File dialog cancelled or error writing file.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDib.ReadFromFile(System.Windows.Forms.IWin32Window)">
            <summary>Display Rhino bitmap open dialog prompting for name then read bitmap from disk.</summary>
            <param name="hWnd">
[in] Parent window for file dialog. If NULL will use Rhino frame window.
</param>
            <returns>
TRUE - File name specified and writen to disk.
FALSE - File dialog cancelled or error writing file.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDib.ReadFromFile(System.Windows.Forms.IWin32Window,System.Boolean)">
            <summary>Display Rhino bitmap open dialog prompting for name then read bitmap from disk.</summary>
            <param name="hWnd">
[in] Parent window for file dialog. If NULL will use Rhino frame window.
</param>
            <param name="bUseDialogs">[in] If true then display file dialog otherwise prompt for name on command line.</param>
            <returns>
TRUE - File name specified and writen to disk.
FALSE - File dialog cancelled or error writing file.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDib.WriteToFile(System.String)">
            <summary>Write bitmap to disk.</summary>
            <param name="lpsFileName">[in] Name of file to write.</param>
            <returns>
TRUE - Specified File name writen to disk.
FALSE - Error writing file or invalid file type.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDib.WriteToFile">
            <summary>
Display Rhino bitmap save dialog prompting for name then write bitmap to disk.
</summary>
            <returns>
TRUE - File name specified and writen to disk.
FALSE - File dialog cancelled or error writing file.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDib.WriteToFile(System.Windows.Forms.IWin32Window)">
            <summary>
Display Rhino bitmap save dialog prompting for name then write bitmap to disk.
</summary>
            <param name="hWnd">[in] Parent window for file dialog. If NULL will use Rhino frame window.</param>
            <returns>
TRUE - File name specified and writen to disk.
FALSE - File dialog cancelled or error writing file.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDib.WriteToFile(System.Windows.Forms.IWin32Window,System.Boolean)">
            <summary>
set Dib to specified BITMAPINFO pointer
</summary>
            <summary>
create Dib from hbitmap
</summary>
            <summary>
Display Rhino bitmap save dialog prompting for name then write bitmap to disk.
</summary>
            <param name="hWnd">[in] Parent window for file dialog. If NULL will use Rhino frame window.</param>
            <param name="bUseDialogs">
[in] If true then display file dialog otherwise prompt for name on command line.
</param>
            <returns>
TRUE - File name specified and writen to disk.
FALSE - File dialog cancelled or error writing file.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDib.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
create bitmap with sepcified width, height and color depth
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDib.#ctor(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
create bitmap with sepcified width, height and color depth
</summary>
            <summary>
create bitmap with sepcified width, height and color depth
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDib.#ctor">
            <summary>
Construction
</summary>
        </member>
        <member name="M:RMA.UI.MRhinoUiDib.SaveBmp(System.String)">
            <summary>
Read and write *.bmp Windows bitmap files.
</summary>
        </member>
        <member name="M:RMA.UI.MRhinoUiDib.WindowYtoDibY(System.Int32)">
            <summary>
Convert Y value from window display Y to bitmap Y
</summary>
        </member>
        <member name="M:RMA.UI.MRhinoUiDib.ShiftRight">
            <summary>
shift a dib right by one pixel - wraps other side around
only works on a 24 and 32 bit dibs right now.
</summary>
        </member>
        <member name="M:RMA.UI.MRhinoUiDib.ShiftLeft">
            <summary>
shift a dib left by one pixel - wraps other side around
only works on a 24 and 32 bit dibs right now.
</summary>
        </member>
        <member name="M:RMA.UI.MRhinoUiDib.ShiftDown">
            <summary>
shift a dib down by one pixel - wraps other side around
only works on a 24 and 32 bit dibs right now.
note that since a DIB is flipped in y from what you'd
expect, the guts of this does what you'd usually think to do to
shift it up by one pixel
</summary>
        </member>
        <member name="M:RMA.UI.MRhinoUiDib.ShiftUp">
            <summary>
shift a dib up by one pixel - wraps other side around
only works on a 24 and 32 bit dibs right now.
note that since a DIB is flipped in y from what you'd
expect, the guts of this does what you'd usually think to do to
shift it down by one pixel
</summary>
        </member>
        <member name="M:RMA.UI.MRhinoUiDib.FillSolid(System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Fills the entire dib with the specified color...Note: if it's a 32
bit dib, then the high-order byte of the passed in color is considered
to be an alpha value, and thus will also be included in the fill
operation (normal GDI operations will strip this out).
</summary>
        </member>
        <member name="M:RMA.UI.MRhinoUiDib.FloodFill(System.Int32,System.Int32,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Goofy edit functions
</summary>
        </member>
        <member name="M:RMA.UI.MRhinoUiDib.FloodFill(System.Int32,System.Int32,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32)">
            <summary>
Goofy edit functions
</summary>
        </member>
        <member name="M:RMA.UI.MRhinoUiDib.GetPixel(System.Int32!System.Runtime.CompilerServices.IsLong,System.Int32!System.Runtime.CompilerServices.IsLong,System.Single@,System.Single@,System.Single@)">
            <summary>
Functions call FindDIBBits and validate x and y
</summary>
        </member>
        <member name="M:RMA.UI.MRhinoUiDib.SetPixel(System.Int32!System.Runtime.CompilerServices.IsLong,System.Int32!System.Runtime.CompilerServices.IsLong,System.Single,System.Single,System.Single)">
            <summary>
Functions call FindDIBBits and validate x and y
</summary>
        </member>
        <member name="M:RMA.UI.MRhinoUiDib.SetPixel(System.Int32!System.Runtime.CompilerServices.IsLong,System.Int32!System.Runtime.CompilerServices.IsLong,System.Single,System.Single,System.Single,System.Single)">
            <summary>
Functions call FindDIBBits and validate x and y
</summary>
        </member>
        <member name="M:RMA.UI.MRhinoUiDib.Size">
            <summary>
Bitmap information
</summary>
        </member>
        <member name="M:RMA.UI.MRhinoUiDib.Stretch(System.Drawing.IDeviceContext,System.Drawing.Rectangle,System.Boolean,System.Boolean)">
            <summary>
Blit functions funtions
</summary>
        </member>
        <member name="M:RMA.UI.MRhinoUiDib.CopyToClipboard(System.Windows.Forms.IWin32Window)">
            <summary>
Clipboard operations
</summary>
        </member>
        <member name="M:RMA.UI.MRhinoUiDib.BltToDib(RMA.UI.MRhinoUiDib,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
DIB or HBITMAP creation functions
</summary>
            <summary>
DIB or HBITMAP creation functions
</summary>
            <summary>
DIB or HBITMAP creation functions
</summary>
            <summary>
Create HBITMAP and set m_hBitmap
</summary>
            <summary>
Create HBITMAP and set m_hBitmap
</summary>
            <summary>
Destroy existing m_bitmapinfo and m_hBitmap, set them to specified dib.
If Bitmap() was non NULL then a new HBITMAP is created from the new dib
</summary>
            <summary>
Destroy existing m_bitmapinfo and m_hBitmap, set them to specified dib.
If Bitmap() was non NULL then a new HBITMAP is created from the new dib
</summary>
            <summary>
Create dib from hBitmap, if dib created successfully m_hBitmap is set
to a new HBITMAP created from Dib()
</summary>
            <summary>
If DIB and HBITMAP exists will update the DIB bits with what was draw into
the HBITMAP
</summary>
            <summary>
Return copy of existing dib, you are responsible for destroying this object
</summary>
            <summary>
Copy bmi to m_bitmapinfo
</summary>
            <summary>
Return copy of the current Dib().  If Bitmap() is NULL then one is created
from Dib() and returned.  m_hBitmap is not set if Bitmap was NULL.
You are responsible for destroying this object.
</summary>
            <summary>
Copy dib bits from Dib to destination
</summary>
        </member>
        <member name="M:RMA.UI.MRhinoUiDib.ConvertToGrayScale">
            <summary>
Converts the dib into a grayscale image...and promotes it to a
24 bit dib if need be...
</summary>
        </member>
        <member name="M:RMA.UI.MRhinoUiDib.IncreaseColorDepth(System.Int32)">
            <summary>
If color depth is less than the requested color depth create a new
bitmap of the desired color depth and copy old bits to it
</summary>
        </member>
        <member name="M:RMA.UI.MRhinoUiDib.Clear(System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Clears (fills) the entire dib with the passed in color...
</summary>
        </member>
        <member name="M:RMA.UI.MRhinoUiDib.GetHdc">
            <summary>
Copy source bitmap, if m_hBitmap is non NULL then create destroy current and 
create new hBitmap
</summary>
        </member>
        <member name="M:RMA.UI.MRhinoUiDib.DestroyDib">
            <summary>
Destroy dib &amp;&amp; hbitmap and zero out pointers
</summary>
        </member>
        <member name="M:RMA.UI.MRhinoUiDib.#ctor(System.Drawing.Bitmap)">
            <summary>
create Dib from bitmap
</summary>
        </member>
        <member name="M:RMA.UI.MRhinoUiDib.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
create bitmap with sepcified width, height and color depth
</summary>
        </member>
        <member name="M:RMA.UI.MRhinoUiDib.#ctor(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
create bitmap with sepcified width, height and color depth
</summary>
            <summary>
create bitmap with sepcified width, height and color depth
</summary>
        </member>
        <member name="M:RMA.UI.MRhinoUiDib.#ctor">
            <summary>
Construction
</summary>
        </member>
        <member name="M:RMA.UI.IRhinoUiDib.WindowYtoDibY(System.Int32)">
            <summary>
Functions take bits and assume x and y are within range
</summary>
            <summary>
Convert Y value from window display Y to bitmap Y
</summary>
        </member>
        <member name="M:RMA.UI.IRhinoUiDib.GetPixel(System.Int32!System.Runtime.CompilerServices.IsLong,System.Int32!System.Runtime.CompilerServices.IsLong,System.Single@,System.Single@,System.Single@)">
            <summary>
Functions call FindDIBBits and validate x and y
</summary>
        </member>
        <member name="M:RMA.UI.IRhinoUiDib.GetPixel(System.Int32!System.Runtime.CompilerServices.IsLong,System.Int32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong@)">
            <summary>
Description: Get Windows bitmap bits.
Returns: A pointer to the bits. Look but do not change. See Also: CRhinoUiDib::BitmapInfo
</summary>
        </member>
        <member name="M:RMA.UI.IRhinoUiDib.Size">
            <summary>
Bitmap information
</summary>
        </member>
        <member name="M:RMA.UI.IRhinoUiDib.CopyToClipboard(System.Windows.Forms.IWin32Window)">
            <summary>
Return copy of existing dib, you are responsible for destroying this object
</summary>
            <summary>
Clipboard operations
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetDirection.Direction">
            <summary>
If GetDirection() returned CRhinoGet::Direction, Call Direction() to get the Direction value.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetDirection.GetDirection">
            <summary>Call GetDirection() to get a Direction.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetDirection.SetDefault(RMA.OpenNURBS.On3dVector@)">
            <summary>Set a default value to use if user presses ENTER</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetDirection.SetBase(RMA.OpenNURBS.On3dPoint@)">
            <summary>
Set a basepoint to use for mouse input. If none is set and
mouse is used for input, the first point picked becomes the base
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetDirection.SetSecondPrompt(System.String)">
            <summary>
Use SetSecondPrompt() if you want to specify a different prompt for the second picked point.
</summary>
        </member>
        <member name="T:RMA.Rhino.MRhinoGetDirection">
            <summary>helper classes for SDK tools RhinoGetDirection()</summary>
        </member>
        <member name="T:RMA.Rhino.IRhinoGetDirection">
            <summary>helper classes for SDK tools RhinoGetDirection()</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetDistance.Distance">
            <summary>
If GetDistance() returned CRhinoGet::distance, Call Distance() to get the distance value.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetDistance.GetDistance">
            <summary>Call GetDistance() to get a distance.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetDistance.AllowNegativeDistance">
            <summary>
Set this option if you want the user to be able to enter a
negative distance value from the keyboard. The default is
settting is not to allow negative input from the keyboard.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetDistance.AllowNegativeDistance(System.Boolean)">
            <summary>
Set this option if you want the user to be able to enter a
negative distance value from the keyboard. The default is
settting is not to allow negative input from the keyboard.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetDistance.SetDefault(System.Double)">
            <summary>Set a default value to use if user presses ENTER</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetDistance.SetBase(RMA.OpenNURBS.On3dPoint@)">
            <summary>
Set a basepoint to use for mouse input. If none is set and
mouse is used for input, the first point picked becomes the base
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetDistance.SetSecondPrompt(System.String)">
            <summary>
Use SetSecondPrompt() if you want to specify a different prompt for the second picked point.
</summary>
        </member>
        <member name="T:RMA.Rhino.MRhinoGetDistance">
            <summary>helper classes for SDK tools RhinoGetDistance()</summary>
        </member>
        <member name="T:RMA.Rhino.IRhinoGetDistance">
            <summary>helper classes for SDK tools RhinoGetDistance()</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoEventWatcher.SerialNumber">
            <summary>
Each instance of a CRhinoEventWatcher gets a unique
runtime serial number to prevent multiple registrations.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoEventWatcher.UndoEvent(RMA.Rhino.IRhinoEventWatcher.undo_event,System.UInt32,RMA.Rhino.IRhinoCommand)">
            <summary>Used to monitor Rhino's built in undo/redo support.</summary>
            <param name="undo_event">[in] Reports what is happening:</param>
            <param name="undo_record_serialnumber">[in] Runtime serial number of the undo event</param>
            <param name="cmd">
[in] (can be NULL)
If not NULL, this is the command whose activity is being recorded for possible undo.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoEventWatcher.HatchPatternTableEvent(RMA.Rhino.IRhinoEventWatcher.hatchpattern_event,RMA.Rhino.IRhinoHatchPatternTable,System.Int32,RMA.OpenNURBS.IOnHatchPattern)">
            <summary>HatchPatternTableEvent() is called whenever the hatchpattern table is changed.</summary>
            <param name="h_event">[in] type of event</param>
            <param name="hatchpattern_table">[in] hatch pattern table</param>
            <param name="hatchpattern_index">
[in] index of hatchpattern. If the event is hatchpattern_sorted, then hatchpattern_index is 0.
</param>
            <param name="old_settings">
[in] If the event is hatchpattern_modified, then the old hatchpattern definition is passed here.
Otherwise, this parameter is NULL.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoEventWatcher.DimStyleTableEvent(RMA.Rhino.IRhinoEventWatcher.dimstyle_event,RMA.Rhino.IRhinoDimStyleTable,System.Int32,RMA.OpenNURBS.IOnDimStyle)">
            <summary>DimStyleTableEvent() is called whenever the dimstyle table is changed.</summary>
            <param name="d_event">[in] type of event</param>
            <param name="dimstyle_table">[in] dimstyle table</param>
            <param name="dimstyle_index">
[in] index of dimstyle. If the event is dimstyle_sorted, then dimstyle_index is 0.
</param>
            <param name="old_settings">
[in] If the event is dimstyle_modified, then the old dimstyle definition is passed here.
Otherwise, this parameter is NULL.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoEventWatcher.FontTableEvent(RMA.Rhino.IRhinoEventWatcher.font_event,RMA.Rhino.IRhinoFontTable,System.Int32,RMA.OpenNURBS.IOnFont)">
            <summary>FontTableEvent() is called whenever the font table is changed.</summary>
            <param name="f_event">[in] type of event</param>
            <param name="font_table">[in] font table</param>
            <param name="font_index">[in] index of font. If the event is font_sorted, then font_index is 0.</param>
            <param name="old_settings">
[in] If the event is font_modified, then the old font definition is passed here.
Otherwise, this parameter is NULL.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoEventWatcher.GroupTableEvent(RMA.Rhino.IRhinoEventWatcher.group_event,RMA.Rhino.IRhinoGroupTable,System.Int32,RMA.OpenNURBS.IOnGroup)">
            <summary>GroupTableEvent() is called whenever the group table is changed.</summary>
            <param name="g_event">[in] type of event</param>
            <param name="group_table">[in] group table</param>
            <param name="group_index">[in] index of group. If the event is group_sorted, then group_index is 0.</param>
            <param name="old_settings">
[in] If the event is group_modified, then the old group definition is passed here.
Otherwise, this parameter is NULL.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoEventWatcher.TextureMappingTableEvent(RMA.Rhino.IRhinoEventWatcher.texture_mapping_event,RMA.Rhino.IRhinoTextureMappingTable,System.Int32,RMA.OpenNURBS.IOnTextureMapping)">
            <summary>TextureMappingTableEvent() is called whenever the texture_mapping table is changed.</summary>
            <param name="t_event">[in] type of event</param>
            <param name="texture_mapping_table">[in] texture_mapping table</param>
            <param name="texture_mapping_index">
[in] index of texture_mapping. If the event is texture_mapping_sorted, then texture_mapping_index is 0.
</param>
            <param name="old_settings">
[in] If the event is texture_mapping_modified, then the old texture_mapping definition is 
passed here. Otherwise, this parameter is NULL.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoEventWatcher.MaterialTableEvent(RMA.Rhino.IRhinoEventWatcher.material_event,RMA.Rhino.IRhinoMaterialTable,System.Int32,RMA.OpenNURBS.IOnMaterial)">
            <summary>MaterialTableEvent() is called whenever the material table is changed.</summary>
            <param name="m_event">[in] type of event</param>
            <param name="material_table">[in] material table</param>
            <param name="material_index">[in] index of material. If the event is material_sorted, then material_index is 0.</param>
            <param name="old_settings">
[in] If the event is material_modified, then the old material definition is 
passed here. Otherwise, this parameter is NULL.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoEventWatcher.LightTableEvent(RMA.Rhino.IRhinoEventWatcher.light_event,RMA.Rhino.IRhinoLightTable,System.Int32,RMA.OpenNURBS.IOnLight)">
            <summary>LightTableEvent() is called whenever the light table is changed.</summary>
            <param name="l_event">[in] type of event</param>
            <param name="light_table">[in] light table</param>
            <param name="light_index">[in] light of light. If the event is light_sorted, then light_index is 0.</param>
            <param name="old_settings">
[in] If the event is light_modified, then the old light definition is
passed here. Otherwise, this parameter is NULL.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoEventWatcher.InstanceDefinitionTableEvent(RMA.Rhino.IRhinoEventWatcher.idef_event,RMA.Rhino.IRhinoInstanceDefinitionTable,System.Int32,RMA.OpenNURBS.IOnInstanceDefinition)">
            <summary>InstanceDefinitionTableEvent() is called whenever the idef table is changed.</summary>
            <param name="l_event">[in] type of event</param>
            <param name="idef_table">[in] instance definition table</param>
            <param name="idef_index">[in] index of idef. If the event is idef_sorted, then idef_index is 0.</param>
            <param name="old_settings">
[in] If the event is idef_modified, then the old idef definition is 
passed here. Otherwise, this parameter is NULL.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoEventWatcher.LinetypeTableEvent(RMA.Rhino.IRhinoEventWatcher.linetype_event,RMA.Rhino.IRhinoLinetypeTable,System.Int32,RMA.OpenNURBS.IOnLinetype)">
            <summary>LinetypeTableEvent() is called whenever the linetype table is changed.</summary>
            <param name="l_event">[in] type of event</param>
            <param name="linetype_table">[in] linetype table</param>
            <param name="linetype_index">[in] index of linetype. If the event is linetype_sorted, then linetype_index is 0.</param>
            <param name="old_settings">
[in] If the event is linetype_modified, then the old linetype definition is 
passed here. Otherwise, this parameter is NULL.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoEventWatcher.LayerTableEvent(RMA.Rhino.IRhinoEventWatcher.layer_event,RMA.Rhino.IRhinoLayerTable,System.Int32,RMA.OpenNURBS.IOnLayer)">
            <summary>LayerTableEvent() is called whenever the layer table is changed.</summary>
            <param name="l_event">[in] type of event</param>
            <param name="layer_table">[in] layer table</param>
            <param name="layer_index">[in] index of layer. If the event is layer_sorted, then layer_index is 0.</param>
            <param name="old_settings">
[in] If the event is layer_modified, then the old layer definition is 
passed here. Otherwise, this parameter is NULL.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoEventWatcher.OnUpdateObjectMesh(RMA.Rhino.MRhinoDoc@,RMA.Rhino.MRhinoObject@,RMA.OpenNURBS.IOn.mesh_type)">
            <summary>Called if the object's render mesh or analysis mesh is updated.</summary>
            <param name="doc">[in] object's document</param>
            <param name="object">[in] object whose mesh was updated. The new mesh is attached to the object.</param>
            <param name="mesh_type">[in] type of mesh (ON::render_mesh or ON::analysis_mesh)</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoEventWatcher.OnModifyObjectAttributes(RMA.Rhino.MRhinoDoc@,RMA.Rhino.MRhinoObject@,RMA.Rhino.IRhinoObjectAttributes)">
            <summary>Called if an object's attributes change.</summary>
            <param name="doc">[in] object's document</param>
            <param name="object">
[in] object whose attributes were changed.  The new attributes are object.Attributes().
</param>
            <param name="old_attributes">[in] attributes before the change.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoEventWatcher.OnDeselectAllObjects(RMA.Rhino.MRhinoDoc@,System.Int32)">
            <summary>Called if a all objects are begin deselected.</summary>
            <param name="doc">[in] object's document</param>
            <param name="count">[in] number of object's that were deselected.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoEventWatcher.OnDeselectObjects(RMA.Rhino.MRhinoDoc@,RMA.Rhino.IRhinoObject[])">
            <summary>Called when a collection of objects is deselected.</summary>
            <param name="doc">[in] object's document</param>
            <param name="objects">[in] object that were deselected</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoEventWatcher.OnDeselectObject(RMA.Rhino.MRhinoDoc@,RMA.Rhino.IRhinoObject)">
            <summary>Called if an object is being deselected.</summary>
            <param name="doc">[in] object's document</param>
            <param name="object">[in] object that was deselected.</param>
            <remarks>
If all objects are being deselected, then a single notification is sent to 
OnDeselectAllObjects.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoEventWatcher.OnSelectObjects(RMA.Rhino.MRhinoDoc@,RMA.Rhino.IRhinoObject[])">
            <summary>Called when a collection of objects is selected.</summary>
            <param name="doc">[in] object's document</param>
            <param name="objects">[in] objects that were selected</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoEventWatcher.OnSelectObject(RMA.Rhino.MRhinoDoc@,RMA.Rhino.IRhinoObject)">
            <summary>Called if an object is being selected.</summary>
            <param name="doc">[in] object's document</param>
            <param name="object">[in] object to be selected.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoEventWatcher.OnPurgeObject(RMA.Rhino.MRhinoDoc@,RMA.Rhino.MRhinoObject@)">
            <summary>
Called if an object is begin purged from a document.
The object will cease to exist forever.
</summary>
            <param name="doc">[in] object's document</param>
            <param name="object">[in] object to be purged.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoEventWatcher.OnUnDeleteObject(RMA.Rhino.MRhinoDoc@,RMA.Rhino.MRhinoObject@)">
            <summary>Called if an object is un-deleted.</summary>
            <param name="doc">[in] object's document</param>
            <param name="object">[in] object that was deleted and is now active.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoEventWatcher.OnReplaceObject(RMA.Rhino.MRhinoDoc@,RMA.Rhino.MRhinoObject@,RMA.Rhino.MRhinoObject@)">
            <summary>Called if an object is about to be replaced</summary>
            <param name="doc">[in] object's document</param>
            <param name="old_object">
[in] existing object - about to be deleted. At the time OnReplaceObject() is called, old_object has not been deleted.
</param>
            <param name="new_object">
[in] new object - about to be added. At the time OnReplaceObject() is called, new_object has not been added to doc.
</param>
            <remarks>
Immediatedly after OnReplaceObject(doc,old_object,new_object)
is called there will be a call to OnDeleteObject(doc,old_object)
and then a call to OnAddObject(doc,new_object).

If both CRhinoDoc::UndoActive() and CRhinoDoc::RedoActive() are 
false, then immediatedly after OnReplaceObject(doc,old_object,new_object)
is called there will be a call to OnDeleteObject(doc,old_object)
and then a call to OnUnDeleteObject(doc,new_object).
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoEventWatcher.OnDeleteObject(RMA.Rhino.MRhinoDoc@,RMA.Rhino.MRhinoObject@)">
            <summary>
Called if an object is deleted.  At some later point the object can be un-deleted.
</summary>
            <param name="doc">[in] object's document</param>
            <param name="object">[in] object that was deleted.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoEventWatcher.DeleteLayerCheck(RMA.OpenNURBS.Arrayint@,System.Boolean)">
            <summary>Asks if a layers can be deleted.</summary>
            <param name="layer_index_list">[in] indices of layers to be deleted.</param>
            <returns>
0 - Delete no layers
1 - Delete all layers in list
2 - Delete layers in layer_index_list[]
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoEventWatcher.OnEndCommand(RMA.Rhino.IRhinoCommand,RMA.Rhino.IRhinoCommandContext,RMA.Rhino.IRhinoCommand.result)">
            <summary>Called immediately after command.RunCommand().</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoEventWatcher.OnBeginCommand(RMA.Rhino.IRhinoCommand,RMA.Rhino.IRhinoCommandContext)">
            <summary>Called just before command.RunCommand().</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoEventWatcher.OnAppSettingsChanged(RMA.Rhino.IRhinoAppSettings)">
            <summary>Called after a value in CRhinoApp::AppSettings() changes.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoEventWatcher.OnCloseRhino(RMA.Rhino.MRhinoApp@)">
            <summary>Called when Rhino stops.</summary>
            <param name="app">[in] instance of Rhino begin closed.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoEventWatcher.OnInitRhino(RMA.Rhino.MRhinoApp@)">
            <summary>Called when Rhino starts.</summary>
            <param name="app">[in] instance of Rhino begin started.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoEventWatcher.OnEnableEventWatcher(System.Boolean)">
            <summary>Called when this event watcher is enabled/disabled.</summary>
            <param name="b">[in] TRUE means event watcher is being enabled.</param>
            <remarks>For advanced users.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoEventWatcher.Enable">
            <summary>
You will only be notified if your event watcher is reistered and enabled.
You must explicitly register and then enable your even watcher.
</summary>
            <returns>TRUE if the event manager is registered and enabled.</returns>
            <remarks>
Enable() is fast and efficient. Use it when you need to repeatedly enable/disable
your event watcher. Call UnRegister() when you are done watching events.
See Also: CRhinoEventWatcher::Register();
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoEventWatcher.Enable(System.Boolean)">
            <summary>
You will only be notified if your event watcher is reistered and enabled.
You must explicitly register and then enable your even watcher.
</summary>
            <param name="b">[in] TRUE enables the event watcher and FALSE disables the event watcher.</param>
            <returns>TRUE if the event manager is registered and enabled.</returns>
            <remarks>
Enable() is fast and efficient. Use it when you need to repeatedly enable/disable
your event watcher. Call UnRegister() when you are done watching events.
See Also: CRhinoEventWatcher::Register();
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoEventWatcher.IsEnabled">
            <summary>
You will only be notified if your event watcher is reistered and enabled.
You must explicitly register and then enable your even watcher.
</summary>
            <returns>
TRUE if the event manager is registered and enabled.
See Also: CRhinoEventWatcher::Register();
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoEventWatcher.UnRegister">
            <summary>Removes event watcher from Rhino.</summary>
            <remarks>
Registration is computationally expensive and should be done sparingly.
Enable is fast and can be used to quickly enable/disable an event watcher.
See Also: CRhinoEventWatcher::Register();
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoEventWatcher.Register">
            <summary>Adds event watcher to Rhino.</summary>
            <returns>TRUE if registration succeeds.</returns>
            <remarks>
Registration is computationally expensive and should be done sparingly.
Enable is fast and can be used to quickly enable/disable an event watcher.
</remarks>
        </member>
        <member name="T:RMA.Rhino.MRhinoEventWatcher">
            <summary>
This class is a virtual base class that defines the interface for watching events in Rhino. If
you want to watch one or more events, derive a class from CRhinoEventWatcher and override the
virtual functions that correspond to the events you want to watch.

You will only be notified if your event watcher is registered and enabled.  You must explicitly
register your event watcher by calling Register() and then enable your event watcher by calling
Enable(true).
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoEventWatcher.SerialNumber">
            <summary>
Each instance of a CRhinoEventWatcher gets a unique
runtime serial number to prevent multiple registrations.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoEventWatcher.IsEnabled">
            <summary>
You will only be notified if your event watcher is reistered and enabled.
You must explicitly register and then enable your even watcher.
</summary>
            <returns>
TRUE if the event manager is registered and enabled.
See Also: CRhinoEventWatcher::Register();
</returns>
        </member>
        <member name="T:RMA.Rhino.IRhinoEventWatcher">
            <summary>
This class is a virtual base class that defines the interface for watching events in Rhino. If
you want to watch one or more events, derive a class from CRhinoEventWatcher and override the
virtual functions that correspond to the events you want to watch.

You will only be notified if your event watcher is registered and enabled.  You must explicitly
register your event watcher by calling Register() and then enable your event watcher by calling
Enable(true).
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistoryRecordTable.HistoryRecordCount">
            <summary>Temporary - probably never needed.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistoryRecordTable.GetHistoryDescendants(RMA.Rhino.IRhinoObject,System.Guid[]@)">
            <summary>
Object history tool that returns the list of objects that used this object during their construction.
</summary>
            <param name="antecedent_object">[in]</param>
            <param name="uuid_list">[out]</param>
            <returns>Number of ids appended to uuid_list[]</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistoryRecordTable.IsHistoryDescendant(RMA.Rhino.IRhinoObject,System.Guid)">
            <summary>Object history tool that checks to see if an id is in the list of descendants.</summary>
            <param name="descendant_uuid">[in] id to look for in the descendant list.</param>
            <returns>True if descendant_uuid was found in the list of descendants.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistoryRecordTable.CreateObjectHistory(RMA.Rhino.MRhinoObject,RMA.Rhino.MRhinoHistory)">
            <summary>
Command authors fill in a CRhinoHistory, create CRhinoObjects,
and call SaveObjectHistory to put the information in the document.    
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistoryRecordTable.Document">
            <returns>CRhinoDoc that owns this history record table.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoHistoryRecordTable.HistoryRecordCount">
            <summary>Temporary - probably never needed.</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoHistoryRecordTable.GetHistoryDescendants(RMA.Rhino.IRhinoObject,System.Guid[]@)">
            <summary>
Object history tool that returns the list of objects that used this object during their construction.
</summary>
            <param name="antecedent_object">[in]</param>
            <param name="uuid_list">[out]</param>
            <returns>Number of ids appended to uuid_list[]</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoHistoryRecordTable.IsHistoryDescendant(RMA.Rhino.IRhinoObject,System.Guid)">
            <summary>Object history tool that checks to see if an id is in the list of descendants.</summary>
            <param name="descendant_uuid">[in] id to look for in the descendant list.</param>
            <returns>True if descendant_uuid was found in the list of descendants.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoHistoryRecordTable.Document">
            <returns>CRhinoDoc that owns this history record table.</returns>
        </member>
        <member name="P:RMA.Rhino.MRhinoHistoryRecord.m_remap_index">
            <value>Runtime index used when marking records for import/export</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistoryRecord.RecordIndex">
            <summary>
Index of this record in the CRhinoDoc.m_history_record_table[]
array.  This index will change during a session.  This function is
here for creating reports used to study history bugs.
</summary>
            <returns>
Index of this record in the CRhinoDoc.m_history_record_table[] array.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistoryRecord.Report(RMA.OpenNURBS.OnTextLog@)">
            <summary>
Get a technical description of the values stored in the history record. This list is
not localized and never will be. It is intended to be used by developers and technical support staff.
</summary>
            <param name="text_log">[out]</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistoryRecord.GetAntecedents(RMA.OpenNURBS.OnUuidList@)">
            <summary>
Get a list of the antecedent (input) object ids in this history record.
</summary>
            <param name="uuid_list">[out] Antecedent ids are appended to the uuid_list[] array</param>
            <returns>the number of uuids appended to uuid_list[] array.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistoryRecord.GetAntecedents(System.Guid[]@)">
            <summary>
Get a list of the antecedent (input) object ids in this history record.
</summary>
            <param name="uuid_list">[out] Antecedent ids are appended to the uuid_list[] array</param>
            <returns>the number of uuids appended to uuid_list[] array.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistoryRecord.IsAntecedent(System.Guid)">
            <summary>Determine if object is an antecedent (input) in this history record</summary>
            <param name="object_uuid">[in]</param>
            <returns>true if object_uuid is the id of an input object</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistoryRecord.HistoryRecordId">
            <summary>
Each history record has a unique id that Rhino assigns when it adds the
history record to the history record table.
</summary>
            <returns>History record id.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistoryRecord.HistoryVersion">
            <summary>
ReplayHistory overrides check the version number to insure the information saved
in the history record is compatible with the current implementation of ReplayHistory.
</summary>
            <returns>History record version number.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistoryRecord.Command">
            <returns>The command associated with this history record.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistoryRecord.GetRhinoPointOnObject(RMA.Rhino.IRhinoObjRef,RMA.OpenNURBS.On3dPoint@)">
            <summary>
In ReplayHistory overrides, use GetRhinoPointOnObject to use the information in
m_hr to find the CRhinoObject and evaluate it to get the point.
</summary>
            <param name="or">[in] ON_ObjRef from m_hr.</param>
            <param name="point">[out]</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistoryRecord.GetRhinoPointOnObject(RMA.OpenNURBS.IOnObjRef,RMA.OpenNURBS.On3dPoint@)">
            <summary>
In ReplayHistory overrides, use GetRhinoPointOnObject to use the information in
m_hr to find the CRhinoObject and evaluate it to get the point.
</summary>
            <param name="or">[in] ON_ObjRef from m_hr.</param>
            <param name="point">[out]</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistoryRecord.GetRhinoPointOnObject(System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>
In ReplayHistory overrides, use GetRhinoPointOnObject to use the information in
m_hr to find the CRhinoObject and evaluate it to get the point.
</summary>
            <param name="value_id">[in] History record value id</param>
            <param name="point">[out]</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistoryRecord.GetRhinoObjRefList(System.Int32,RMA.Rhino.ArrayMRhinoObjRef@)">
            <summary>
In ReplayHistory overrides, use GetRhinoObjRefList to convert the information in m_hr into
an array CRhinoObjRefs that has up to date CRhinoObject pointers.
</summary>
            <param name="value_id">[in] History record value id</param>
            <param name="objref_list">[out] Object references are appended to this list.</param>
            <returns>Number of elements appended to objref_list[].</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistoryRecord.GetRhinoObjRef(RMA.OpenNURBS.IOnObjRef,RMA.Rhino.MRhinoObjRef@)">
            <summary>
In ReplayHistory overrides, use GetRhinoObjRef to convert the information in m_hr into
a CRhinoObjRef that has up to date CRhinoObject pointers.
</summary>
            <param name="or">[in] ON_ObjRef from m_hr.</param>
            <param name="objref">[out]</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistoryRecord.GetRhinoObjRef(System.Int32,RMA.Rhino.MRhinoObjRef@)">
            <summary>
In ReplayHistory overrides, use GetRhinoObjRef to convert the information in m_hr into
a CRhinoObjRef that has up to date CRhinoObject pointers.
</summary>
            <param name="value_id">[in] History record value id</param>
            <param name="objref">[out]</param>
            <returns>True if successful</returns>
        </member>
        <member name="P:RMA.Rhino.IRhinoHistoryRecord.m_remap_index">
            <value>Runtime index used when marking records for import/export</value>
        </member>
        <member name="M:RMA.Rhino.IRhinoHistoryRecord.RecordIndex">
            <summary>
Index of this record in the CRhinoDoc.m_history_record_table[]
array.  This index will change during a session.  This function is
here for creating reports used to study history bugs.
</summary>
            <returns>
Index of this record in the CRhinoDoc.m_history_record_table[] array.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoHistoryRecord.Report(RMA.OpenNURBS.OnTextLog@)">
            <summary>
Get a technical description of the values stored in the history record. This list is
not localized and never will be. It is intended to be used by developers and technical support staff.
</summary>
            <param name="text_log">[out]</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoHistoryRecord.GetAntecedents(RMA.OpenNURBS.OnUuidList@)">
            <summary>
Get a list of the antecedent (input) object ids in this history record.
</summary>
            <param name="uuid_list">[out] Antecedent ids are appended to the uuid_list[] array</param>
            <returns>the number of uuids appended to uuid_list[] array.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoHistoryRecord.GetAntecedents(System.Guid[]@)">
            <summary>
Get a list of the antecedent (input) object ids in this history record.
</summary>
            <param name="uuid_list">[out] Antecedent ids are appended to the uuid_list[] array</param>
            <returns>the number of uuids appended to uuid_list[] array.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoHistoryRecord.IsAntecedent(System.Guid)">
            <summary>Determine if object is an antecedent (input) in this history record</summary>
            <param name="object_uuid">[in]</param>
            <returns>true if object_uuid is the id of an input object</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoHistoryRecord.HistoryRecordId">
            <summary>
Each history record has a unique id that Rhino assigns when it adds the
history record to the history record table.
</summary>
            <returns>History record id.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoHistoryRecord.HistoryVersion">
            <summary>
ReplayHistory overrides check the version number to insure the information saved
in the history record is compatible with the current implementation of ReplayHistory.
</summary>
            <returns>History record version number.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoHistoryRecord.Command">
            <returns>The command associated with this history record.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoHistoryRecord.GetRhinoPointOnObject(RMA.Rhino.IRhinoObjRef,RMA.OpenNURBS.On3dPoint@)">
            <summary>
In ReplayHistory overrides, use GetRhinoPointOnObject to use the information in
m_hr to find the CRhinoObject and evaluate it to get the point.
</summary>
            <param name="or">[in] ON_ObjRef from m_hr.</param>
            <param name="point">[out]</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoHistoryRecord.GetRhinoPointOnObject(RMA.OpenNURBS.IOnObjRef,RMA.OpenNURBS.On3dPoint@)">
            <summary>
In ReplayHistory overrides, use GetRhinoPointOnObject to use the information in
m_hr to find the CRhinoObject and evaluate it to get the point.
</summary>
            <param name="or">[in] ON_ObjRef from m_hr.</param>
            <param name="point">[out]</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoHistoryRecord.GetRhinoPointOnObject(System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>
In ReplayHistory overrides, use GetRhinoPointOnObject to use the information in
m_hr to find the CRhinoObject and evaluate it to get the point.
</summary>
            <param name="value_id">[in] History record value id</param>
            <param name="point">[out]</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoHistoryRecord.GetRhinoObjRefList(System.Int32,RMA.Rhino.ArrayMRhinoObjRef@)">
            <summary>
In ReplayHistory overrides, use GetRhinoObjRefList to convert the information in m_hr into
an array CRhinoObjRefs that has up to date CRhinoObject pointers.
</summary>
            <param name="value_id">[in] History record value id</param>
            <param name="objref_list">[out] Object references are appended to this list.</param>
            <returns>Number of elements appended to objref_list[].</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoHistoryRecord.GetRhinoObjRef(RMA.OpenNURBS.IOnObjRef,RMA.Rhino.MRhinoObjRef@)">
            <summary>
In ReplayHistory overrides, use GetRhinoObjRef to convert the information in m_hr into
a CRhinoObjRef that has up to date CRhinoObject pointers.
</summary>
            <param name="or">[in] ON_ObjRef from m_hr.</param>
            <param name="objref">[out]</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoHistoryRecord.GetRhinoObjRef(System.Int32,RMA.Rhino.MRhinoObjRef@)">
            <summary>
In ReplayHistory overrides, use GetRhinoObjRef to convert the information in m_hr into
a CRhinoObjRef that has up to date CRhinoObject pointers.
</summary>
            <param name="value_id">[in] History record value id</param>
            <param name="objref">[out]</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistoryManager.DeleteObjectHelper(RMA.Rhino.IRhinoObject)">
            <summary>Called by Trim and Split when using replace object is not feasable.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistoryManager.RecordSettingStackCount">
            <returns>Number of values in the record setting stack.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistoryManager.PopRecordSetting">
            <summary>Sets the current value of the record setting to the value on the stack.</summary>
            <returns>Value of the record setting after the pop.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistoryManager.PushRecordSetting">
            <returns>
true if the history manager is in the process of updating
objects because their antecedents were modified.
</returns>
            <summary>Puts a the current value of the record setting on a private stack.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistoryManager.HistoryObjectLockingEnabled">
            <summary>
When history update is enabled, dependant objects are automatically updated when
an antecedent is modified.
</summary>
            <returns>true if history update is enabled.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistoryManager.HistoryUpdateEnabled">
            <summary>
When history update is enabled, dependant objects are automatically updated when
an antecedent is modified.
</summary>
            <returns>true if history update is enabled.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistoryManager.HistoryRecordingEnabled">
            <summary>
When history recording is enabled, new objects keep a record of how they were
constructed so that they can be updated if an input object changes.
</summary>
            <returns>
The current history recording setting. If a command is running, the current
setting is true only when the master switch is on and the command has recording
enabled.
</returns>
            <remarks>
This reports the CURRENT APPLICATION setting. In order for history to be recorded
during a command, both the application setting and the command setting have to be true.    
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistoryManager.EnableHistoryObjectLocking(System.Boolean)">
            <summary>
When history object locking is enabled, objects with history on them act as
if they were locked and the only way to modify these objects is to edit their inputs.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistoryManager.EnableHistoryUpdate(System.Boolean)">
            <summary>
When history update is enabled, dependant objects are
automatically updated when an antecedent is modified.
</summary>
            <param name="bEnableHistoryUpdate">[in] true to enable history update</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistoryManager.EnableHistoryRecording(System.Boolean)">
            <summary>
Sets switch for history recording. If the master history recording switch is off, 
then no history is recorded. If the master history recording switch is on,
the the command's history recording setting determines if a command records
history.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoView.FloatRhinoView(System.Boolean)">
            <summary>
Description:
This is a test method.  It may not be available in the final SDK release.
Call this method to set the window placement and show mode when turning a 
standard Rhino view into a floating Rhino view.
Parameters:
</summary>
            <summary>
Description:
This is a test method.  It may not be available in the final SDK release.
Call this method to get the window placement information from the last time
this view was floated.
Returns:
Returns a WINDOWPLACEMENT pointer if this view has been floated before or NULL
if it has not.
</summary>
            <summary>Call this method to change parent container for this view.</summary>
            <param name="bFloat">
[in] If true then the view will be embeded in a floating frame window otherwise
the view will be embeded in a CMDIChildWnd.
</param>
            <returns>a pointer to the views parent container on success otherwise NULL.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoView.IsFloatingRhinoView">
            <summary>
Used by Rhino main frame and doc/view manager to determine if this view is
in a floating frame or a child of the MDIClient window associated with the
Rhino main frame window.
</summary>
            <returns>true If this view is embedded in a free floating frame window.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoView.RecreateHWND">
            <summary>
Creates a new window handle for the CRhinoView. This is needed for
setting up window pixel formats (which can only be performed once
on a HWND). All child windows are reparented to the new HWND.
Subclasses that wish to override this function should call this base
class version of the function first.
</summary>
            <returns>true on success</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoView.SetupDisplayPipeline">
            <summary>
Sets up the default display pipeline based on current display settings
(eg. GDI vs. OpenGL), and attaches it to "this" view.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoView.RhinoViewType">
            <summary>Identifies what type of CRhinoView or CRhinoView derived class this is.</summary>
            <returns>
a CRhinoView::rhino_view_type indicating what kind of view this is.
See Also: class CRhinoPageView
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoView.GetVisibleObjects(System.Drawing.Rectangle,RMA.Rhino.IRhinoObject[]@)">
            <summary>Gets a list of objects that are visible in the view.</summary>
            <param name="pick_rect">
[in] if non-empty, then this rect defines a view window coordinate rectangle to use.
If empty, then the entire view is searched.
</param>
            <param name="visible_objects">[out] visible objects are appended to this list.</param>
            <returns>Number of objects appended to visible_objects[] array.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoView.MaximizeRestoreView">
            <summary>call to toggle views maximized/restore state.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoView.UpdateTitle(System.Boolean)">
            <summary>call when view gets/looses focus</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoView.SetDragPlane(RMA.Rhino.IRhinoView.drag_plane)">
            <summary>
Set the plane used for dynamic mouse dragging. See Also: CRhinoView::DragPlane
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoView.DragPlane">
            <summary>
Returns: Plane used for dynamic mouse dragging. See Also: CRhinoView::SetDragPlane
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoView.Position">
            <summary>returns relative position in main frame client rect</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoView.ActiveViewportID">
            <returns>
viewport ID for the active viewport. Faster than ActiveViewport function when
working with page views.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoView.ActiveViewport">
            <summary>
The ActiveViewport is the same as the MainViewport for standard CRhinoViews. In
a CRhinoPageView, the active viewport may be the CRhinoViewport of a child detail object.
Most of the time, you will use ActiveViewport unless you explicitly need to work with
the main viewport.
NOTE: This is typically the function you will use as a replacement for the deprecated
    Viewport() function.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoView.MainViewport">
            <summary>
A CRhinoView contains a "main viewport" that fills the entire view client window.
CRhinoPageViews may also contain nested child CRhinoViewports for implementing
detail viewports.
The MainViewport will always return this CRhinoView's m_vp
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoView.SetProjection(RMA.OpenNURBS.IOn3dmView,System.Boolean)">
            <summary>all 3d projection information and drawing tools are provided by m_vp</summary>
            <param name="view">[in] the view information to set</param>
            <param name="bMainViewport">
[in] if true, view is set on the MainViewport()
if false, view is set on the ActiveViewport()
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoView.InterruptDrawing">
            <summary>
During dynamic view changes, the mouse sometimes moves
faster than the view can update.  If you are drawing
something that may take a long time, periodically call
InterruptDrawing() to see if you should stop.
</summary>
            <returns>true if you should stop drawing and return.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoView.IsMaximized">
            <summary>
Return true if this view is maximized.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoView.ScreenCaptureToBitmap(System.Drawing.Bitmap@)">
            <summary>Copy current screen view to a bitmap.</summary>
            <param name="dib">[out] 24 Bit color DIB contaning screen capture of this view</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoView.ScreenCaptureToBitmap(System.Drawing.Bitmap@,System.Boolean)">
            <summary>Copy current screen view to a bitmap.</summary>
            <param name="dib">[out] 24 Bit color DIB contaning screen capture of this view</param>
            <param name="bIncludeCursor">
[in] If (bIncludeCursor == true) and cursor is over this view then "dib" will include cursor.
</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoView.ScreenCaptureToBitmap(System.Drawing.Bitmap@,System.Boolean,System.Boolean)">
            <summary>Copy current screen view to a bitmap.</summary>
            <param name="dib">[out] 24 Bit color DIB contaning screen capture of this view</param>
            <param name="bIncludeCursor">
[in] If (bIncludeCursor == true) and cursor is over this view then "dib" will include cursor.
</param>
            <param name="bClientAreaOnly">[in] do not capture the parent frame</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoView.IsDrawingEnabled">
            <summary>
Check to see if drawing is enabled. By default, drawing is enabled. There
are some rare situations where scipts want to disable drawing for a while.
</summary>
            <returns>
true if drawing is enabled; otherwise false.
See Also: CRhinoView::EnableDrawing
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoView.EnableDrawing">
            <summary>
Enables drawing. By default, drawing is enabled. There are some rare
situations where scipts want to disable drawing for a while.
</summary>
            <returns>
Previous drawing state.
See Also: CRhinoView::IsDrawingEnabled
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoView.EnableDrawing(System.Boolean)">
            <summary>
Enables drawing. By default, drawing is enabled. There are some rare
situations where scipts want to disable drawing for a while.
</summary>
            <param name="bEnableDrawing">[in] true to enable drawing.</param>
            <returns>
Previous drawing state.
See Also: CRhinoView::IsDrawingEnabled
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoView.SetRedrawDisplayHint(System.UInt32)">
            <summary>Expert user tool to set flags used by CRhinoView::OnDraw()</summary>
            <param name="display_hint">[in] a CRhinoView::DISPLAY_HINT value</param>
            <remarks>
You probably want to use CRhinoDoc::SetRedrawDisplayHint() instead of
CRhinoView::SetRedrawDisplayHint()
See Also: CRhinoDoc::SetRedrawDisplayHint
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoView.Redraw">
            <summary>Redraw this view.</summary>
            <remarks>
If you change something in "this" view like the projection,
construction plane, background bitmap, etc., then you need to call
CRhinoView::Redraw to redraw "this" view. The other views
will not be changed. If you change something in the document (like
adding new geometry to the model), then you need to call CRhinoDoc::Redraw
to redraw all the views. CRhinoView::Redraw updates some internal flags
and then calls CView::InvalidateRect(NULL,false) to get a WM_PAINT
message posted. NEVER CALL CView::InvalidateRect.
See Also CRhinoDoc::Redraw
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoView.Redraw(System.UInt32)">
            <summary>Redraw this view.</summary>
            <param name="view_redraw_display_hint">[in] a CRhinoView::DISPLAY_HINT value</param>
            <remarks>
If you change something in "this" view like the projection,
construction plane, background bitmap, etc., then you need to call
CRhinoView::Redraw to redraw "this" view. The other views
will not be changed. If you change something in the document (like
adding new geometry to the model), then you need to call CRhinoDoc::Redraw
to redraw all the views. CRhinoView::Redraw updates some internal flags
and then calls CView::InvalidateRect(NULL,false) to get a WM_PAINT
message posted. NEVER CALL CView::InvalidateRect.
See Also CRhinoDoc::Redraw
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoView.PlugInID">
            <summary>
Return the UUID for the plug-in that created this view. Use CRhinoApp::IsRhinoUUID()
to determine if this is a view created by Rhino.
</summary>
            <returns>
Returns UUID of the plug-in that originally created this view.
See Also CRhinoDoc::CreateDerivedRhinoView CRhinoApp::IsRhinoUUID
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoView.IsFloatingRhinoView">
            <summary>
Used by Rhino main frame and doc/view manager to determine if this view is
in a floating frame or a child of the MDIClient window associated with the
Rhino main frame window.
</summary>
            <returns>true If this view is embedded in a free floating frame window.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoView.RhinoViewType">
            <summary>Identifies what type of CRhinoView or CRhinoView derived class this is.</summary>
            <returns>
a CRhinoView::rhino_view_type indicating what kind of view this is.
See Also: class CRhinoPageView
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoView.Position">
            <summary>returns relative position in main frame client rect</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoView.ActiveViewportID">
            <returns>
viewport ID for the active viewport. Faster than ActiveViewport function when
working with page views.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoView.ActiveViewport">
            <summary>
The ActiveViewport is the same as the MainViewport for standard CRhinoViews. In
a CRhinoPageView, the active viewport may be the CRhinoViewport of a child detail object.
Most of the time, you will use ActiveViewport unless you explicitly need to work with
the main viewport.
NOTE: This is typically the function you will use as a replacement for the deprecated
    Viewport() function.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoView.MainViewport">
            <summary>
A CRhinoView contains a "main viewport" that fills the entire view client window.
CRhinoPageViews may also contain nested child CRhinoViewports for implementing
detail viewports.
The MainViewport will always return this CRhinoView's m_vp
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoView.InterruptDrawing">
            <summary>
During dynamic view changes, the mouse sometimes moves
faster than the view can update.  If you are drawing
something that may take a long time, periodically call
InterruptDrawing() to see if you should stop.
</summary>
            <returns>true if you should stop drawing and return.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoView.SetRedrawDisplayHint(System.UInt32)">
            <summary>
Description: Expert user tool to set flags used by CRhinoView::OnDraw() Paramters: view_redraw_display_hint - [in] a CRhinoView::DISPLAY_HINT value Remarks: You probably want to use CRhinoDoc::SetRedrawDisplayHint() instead of CRhinoView::SetRedrawDisplayHint() See Also: CRhinoDoc::SetRedrawDisplayHint
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoView.PlugInID">
            <summary>
Return the UUID for the plug-in that created this view. Use CRhinoApp::IsRhinoUUID()
to determine if this is a view created by Rhino.
</summary>
            <returns>
Returns UUID of the plug-in that originally created this view.
See Also CRhinoDoc::CreateDerivedRhinoView CRhinoApp::IsRhinoUUID
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectIterator.Next">
            <summary>
Returns the next object in list. Returns NULL when no more objects are in the list.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectIterator.First">
            <summary>
Returns the first object in list. The next call to CRhinoObjectIterator::Next
will return the second object in the list.
Example: CRhinoObjectIterator it; CRhinoObject* obj; for ( obj = it.First(); obj; obj = it.Next() ) { ... }
Returns: First object in the list. See Also: CRhinoObjectIterator::Next
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectIterator.SetViewportIdFilter(System.Boolean,System.Guid,System.Boolean)">
            <summary>
The object space filter can be used to filter on the value of ON_3dmObjectAttributes.m_viewport_id.
</summary>
            <param name="bEnable">[in] true to enable this filter. (default is false).</param>
            <param name="viewport_id">[in]</param>
            <param name="bFilter">
[in] If bEnable is true, then the object will be included in the iteration if
and only if bFilter == ( viewport_id == object_attributes.m_viewport_id).
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectIterator.SetSpaceFilter(System.Boolean,RMA.OpenNURBS.IOn.active_space,System.Boolean)">
            <summary>
The object space filter can be used to filter on the value of ON_3dmObjectAttributes.m_space.
</summary>
            <param name="bEnable">[in] true to enable this filter. (default is false).</param>
            <param name="space">[in]</param>
            <param name="bFilter">
[in] If bEnable is true, then the object will be included in the iteration if
and only if bFilter == ( space == object_attributes.m_space).
</param>
            <example>
If you want to iterate through the list of objects that are in model space
CRhinoObjectIterator it();
it.SetObjectSpaceFilter(true,ON::model_space,true);
CRhino3Object* pObject;
for ( pObject = it.First(); pObject; pObject = it.Next() ) { ... }
If you want to iterate through the list of objects that are active in a specific page view.
CRhinoObjectIterator it();
it.SetObjectSpaceFilter(true,ON::page_space,true);
const CRhinoViewport* page_viewport = ...;
it.SetViewportIdFilter( true, page_viewport-&gt;ViewportId(), true);
CRhino3Object* pObject;
for ( pObject = it.First(); pObject; pObject = it.Next() ) { ... }
</example>
            <remarks>
Model space objects and model views are not special. Page view objects,
like title block annotation, are marked as special and page views are
marked as special views. This filter is primarily used to limit the
iteration to objects that are only in a certain page view or objects
that are in model space.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectIterator.SetActiveInViewportFilter(System.Boolean,RMA.Rhino.IRhinoViewport,System.Boolean)">
            <summary>Filter on value of object-&gt;IsActiveInViewport()</summary>
            <param name="bEnable">[in] true to enable the filter</param>
            <param name="viewport">
[in] The caller is responsible for making sure this class persists until the iterator
is no longer needed. Otherwise, you will crash.
</param>
            <param name="bFilter">
[in] An object is included in the iteration only if 
bFilter = object-&gt;IsActiveInViewport(viewport) is active in that view.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectIterator.SetViewportFilter(RMA.Rhino.IRhinoViewport)">
            <summary>
Filter out objects that can never be seen in viewport. For example,
if the viewport is a model space view, the page view objects will be
skipped. If the viewport is a page view, then only objects on that
page will be included.
</summary>
            <param name="viewport">
[in] The values of viewport.m_bSpecialView and viewport.ViewportId() are used
to set up the filter. All other viewport settings are ignored.
</param>
            <remarks>
This filter is commonly used in display and mouse picking code when an
action is happening relative to a viewport and objects that can never
be displayed in the viewport need to be skipped. SetViewportFilter()
uses SetSpecialViewportFilter() and SetDisplayMaterialRefFilter() to
perform the actual filtering, so you explicitly use either of these
filters if you use SetViewportFilter().
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectIterator.SetLayerFilter(System.Int32)">
            <summary>
The layer filter can be used to limit the iteration to objects on a specific layer.
</summary>
            <param name="layer_index">[in] index of layer or -1 do disable layer filtering.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectIterator.SetObjectFilter(System.UInt32)">
            <summary>The object filter can be used to limit the iteration to specific types of geometry.</summary>
            <param name="object_filter">
[in] an unsigned int made by or-ing ( | ) values from the ON::object_type enum.
If you pass 0, then all objects will be iterated.
</param>
            <example>
If you want to interate through the list of mesh and brep objects,
then you would do something like:
CRhinoObjectIterator it();
it.SetObjectFilter( ON::brep_object | ON::mesh_object );
CRhino3Object* pObject;
for ( pObject = it.First(); pObject; pObject = it.Next() ) { ... }
</example>
            <remarks>
If object_filter has the ON::light_object bit set, then iterating
throught lights is automatically enabled.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectIterator.EnableVisibleFilter">
            <summary>
If the visible filter is enabled, then the iterator will limit itself to visible objects.
The default is to ignore visibility.
</summary>
            <remarks>Hidden objects and objects on layers that are turned off are not visible.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectIterator.EnableVisibleFilter(System.Boolean)">
            <summary>
If the visible filter is enabled, then the iterator will limit itself to visible objects.
The default is to ignore visibility.
</summary>
            <param name="b">[in] true limits the iteration to visible objects.</param>
            <remarks>Hidden objects and objects on layers that are turned off are not visible.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectIterator.EnableSelectedFilter">
            <summary>
If the selected filter is enabled, then the iterator will limit itself to selected
objects. The default is to ignore selection state.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectIterator.EnableSelectedFilter(System.Boolean)">
            <summary>
If the selected filter is enabled, then the iterator will limit itself to selected
objects. The default is to ignore selection state.
</summary>
            <param name="b">[in] true limits the iteration to selected objects.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectIterator.EnableSelectedFilter(System.Boolean,System.Boolean)">
            <summary>
If the selected filter is enabled, then the iterator will limit itself to selected
objects. The default is to ignore selection state.
</summary>
            <param name="b">[in] true limits the iteration to selected objects.</param>
            <param name="bCheckSubObjects">
[in] if true and b=true, then the iteration will include objects that
have some subset of the object selected, like some edges of a surface.
The default is ignore objects where the entire object is not selected.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectIterator.IncludePhantoms">
            <summary>
The default object iterator does not iterate through phantom objects. If you
want the iterator to include phantoms, then call IncludePhantoms(true).
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectIterator.IncludePhantoms(System.Boolean)">
            <summary>
The default object iterator does not iterate through phantom objects. If you
want the iterator to include phantoms, then call IncludePhantoms(true).
</summary>
            <param name="bIncludePhantoms">[in] true to include phantom objects in the iteration</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectIterator.IncludeGrips">
            <summary>
The default object iterator does not iterate through grip objects. If you want
the iterator to include lights, then call IncludeGrips(true).
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectIterator.IncludeGrips(System.Boolean)">
            <summary>
The default object iterator does not iterate through grip objects. If you want
the iterator to include lights, then call IncludeGrips(true).
</summary>
            <param name="bIncludeGrips">[in] true to include grips in the iteration</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectIterator.IncludeLights">
            <summary>
The default object iterator does not iterate through render light objects.
If you want the iterator to include lights, then call IncludeLights(true).
</summary>
            <remarks>
If you just want to look at render lights, it may be easier to use the CRhinoDoc::m_light_table[] array.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectIterator.IncludeLights(System.Boolean)">
            <summary>
The default object iterator does not iterate through render light objects.
If you want the iterator to include lights, then call IncludeLights(true).
</summary>
            <param name="bIncludeLights">[in] true to include lights in the iteration</param>
            <remarks>
If you just want to look at render lights, it may be easier to use the CRhinoDoc::m_light_table[] array.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectIterator.#ctor(RMA.Rhino.IRhinoDoc,RMA.Rhino.IRhinoObjectIterator.object_state)">
            <param name="s">[in] specifies what object states should be iterated</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectIterator.#ctor(RMA.Rhino.IRhinoDoc,RMA.Rhino.IRhinoObjectIterator.object_state,RMA.Rhino.IRhinoObjectIterator.object_category)">
            <param name="s">[in] specifies what object states should be iterated</param>
            <param name="c">[in] specifies what object categories should be iterated</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectIterator.#ctor">
            <summary>This constructor iteratates through RhinoApp().ActiveDoc().</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectIterator.#ctor(RMA.Rhino.IRhinoObjectIterator.object_state)">
            <summary>This constructor iteratates through RhinoApp().ActiveDoc().</summary>
            <param name="s">[in] specifies what object states should be iterated</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectIterator.#ctor(RMA.Rhino.IRhinoObjectIterator.object_state,RMA.Rhino.IRhinoObjectIterator.object_category)">
            <summary>This constructor iteratates through RhinoApp().ActiveDoc().</summary>
            <param name="s">[in] specifies what object states should be iterated</param>
            <param name="c">[in] specifies what object categories should be iterated</param>
        </member>
        <member name="T:RMA.Rhino.MRhinoObjectIterator">
            <summary>
The CRhinoObjectIterator class is used to interate through
the objects in a CRhinoDoc.
</summary>
        </member>
        <member name="T:RMA.Rhino.IRhinoObjectIterator.object_category">
            <summary>
There are 2 mutually exclusive object categories: active and reference.
By default objects are active.  If a Rhino file is loaded as a
reference model, it's objects are reference objects.  Reference
objects cannot be modified and are never saved.
</summary>
        </member>
        <member name="T:RMA.Rhino.IRhinoObjectIterator.object_state">
            <summary>
There are 5 mutually exclusive object states: normal, locked, hidden,
instance, and deleted.  The "instance" objects are the objects used
to define the geometry of an instance definition.  The instance
references (instance objects) are in the normal, locked, hidden 
or deleted state.
</summary>
        </member>
        <member name="T:RMA.Rhino.IRhinoObjectIterator">
            <summary>
The CRhinoObjectIterator class is used to interate through
the objects in a CRhinoDoc.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.EndWaitCursor">
            <summary>Call this function after you have called the BeginWaitCursor member function to return from the hourglass cursor to the previous cursor</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.BeginWaitCursor">
            <summary>Call this function to display the cursor as an hourglass when you expect a command to take a noticeable time interval to execute.</summary>
            <remarks>Call EndWaitCursor to restore the previous cursor</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.SetTitle(System.String)">
            <summary>Call this function to specify the document's title (the string displayed in the title bar of a frame window).</summary>
            <param name="title">Points to the string to be used as the document's title.</param>
            <remarks>Calling this function updates the titles of all frame windows that display the document.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.SetModifiedFlag(System.Boolean)">
            <summary>Call this function after you have made any modifications to the document</summary>
            <param name="bModified">Flag indicating whether the document has been modified</param>
            <remarks>
By calling this function consistently, you ensure that the framework prompts the user to
save changes before closing a document. Typically you should use the default value of TRUE
for the bModified parameter. To mark a document as clean (unmodified), call this function
with a value of FALSE.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.IsModified">
            <summary>Call this function to determine whether the document has been modified since it was last saved.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.GetTitle">
            <summary>Call this function to get the document's title, which is usually derived from the document's filename.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.GetPathName">
            <summary>Call this function to get the fully qualified path of the document's disk file.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.ConstructionPlaneCount">
            <summary>Universal construction plane stack operators</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.PrevConstructionPlane(RMA.OpenNURBS.OnPlane@)">
            <summary>Universal construction plane stack operators</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.NextConstructionPlane(RMA.OpenNURBS.OnPlane@)">
            <summary>Universal construction plane stack operators</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.ActiveConstructionPlane(RMA.OpenNURBS.OnPlane@)">
            <summary>Universal construction plane stack operators</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.PushConstructionPlane(RMA.OpenNURBS.IOnPlane)">
            <summary>Universal construction plane stack operators</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.ChangeTitleToUnNamed">
            <summary>
Returns: Number of undo records.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.HasUndoRecords">
            <summary>
Returns true if document contains undo records.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.CullUndoRecords(System.Int32,System.UInt32)">
            <summary>Culls the undo list to release memory.</summary>
            <param name="min_step_count">[in] minimum number of undo steps to keep.</param>
            <param name="max_memory_size_bytes">[in] maximum amount of memory, in bytes, for undo list to use.</param>
            <returns>Number of culled records.</returns>
            <remarks>
In the version with no arguments, the settings in RhinoApp().AppSettings().GeneralSettings() are used.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.CullUndoRecords">
            <summary>Culls the undo list to release memory.</summary>
            <returns>Number of culled records.</returns>
            <remarks>
In the version with no arguments, the settings in RhinoApp().AppSettings().GeneralSettings() are used.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.UndoRecordMemorySize">
            <summary>
Returns: Number bytes in used by undo records
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.UndoRecordCount">
            <summary>
Returns: Record being actively recorded.
</summary>
            <summary>
Returns: Number of undo records.
</summary>
            <summary>
Returns: Number of undo records.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.AddCustomUndoEvent(RMA.Rhino.MRhinoUndoEventHandler)">
            <summary>
If you want to your plug-in to do something when the Rhino
Undo/Redo command runs, the call AddCustomUndoEvent during your command

This function is for expert plug-in developers. If you
don't do a good job here, you will really break Rhino.
</summary>
            <returns>
If a non zero number is returned, then this is the runtime
serial number Rhino has assigned to this undo event.
If zero is returned, then the user has disabled undo
and undo_event_handler was deleted.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.BeginUndoRecord(System.String)">
            <summary>
Used to begin recording undo information when the document is changed outside of a command.
An example begin changes caused by the modeless layer or object properties dialogs when
commands are not running.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.UndoRecordingIsActive">
            <summary>
true if actually happening now
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.UndoRecordingIsEnabled">
            <summary>
true if permitted
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.TemplateFileUsed">
            <summary>
Call this method to get the name of the template file used to create this document.
This is a runtime value only present if the document was newly created.
</summary>
            <returns>Returns full path to template used to create this document on File/New</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.IsSendingMail">
            <summary>
Determine if Rhino is in the process of sending this document as an email attachment.
</summary>
            <returns>Returns true if in OnFileSendMail otherwise; false.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.RecreateRhinoViewHWnds">
            <summary>
Creates new window handles for every CRhinoView associated with this document.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.CloseRhinoView(RMA.Rhino.MRhinoView)">
            <summary>Close specified Rhino view.</summary>
            <param name="pView">View to close</param>
            <returns>Returns true on success; otherwise false</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.EnableCameraIcon(RMA.Rhino.MRhinoView)">
            <summary>Use to turn camera icon on and off.</summary>
            <param name="view">
[in] If NULL, any camera icon is turned off. If not NULL, the camera icon for that view is turned on.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.InGetMeshes">
            <returns>Returns non-null if currently in a CRhinoGetString::GetString()</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.InGetColor">
            <returns>Returns non-null if currently in a CRhinoGetString::GetString()</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.InGetOption">
            <returns>Returns non-null if currently in a CRhinoGetString::GetString()</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.InGetNumber">
            <returns>Returns non-null if currently in a CRhinoGetString::GetString()</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.InGetString">
            <returns>Returns non-null if currently in a CRhinoGetString::GetString()</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.InGetObject">
            <returns>Returns non-null if currently in a CRhinoGetString::GetObject()</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.InGetPoint">
            <returns>Returns non-null if currently in a CRhinoGetPoint::GetPoint()</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.InGet">
            <summary>
Returns non-null if currently in a CRhinoGetPoint::GetPoint(),
CRhinoGetObject::GetObject(), or CRhinoGetString::GetString()
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.SetRedrawDisplayHint(System.UInt32)">
            <summary>Expert user tool to set flags used by CRhinoDoc::Redraw().</summary>
            <param name="display_hint">
[in] one of
CRhinoView::regenerate_display_hint
CRhinoView::mark_display_hint
CRhinoView::refresh_display_hint
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.SetRedrawDisplayHint(System.UInt32,RMA.OpenNURBS.IOn.display_mode)">
            <summary>
Expert user tool to set flags used by CRhinoDoc::Redraw(). Paramters: display_hint - [in] one of CRhinoView::regenerate_display_hint CRhinoView::mark_display_hint CRhinoView::refresh_display_hint dm - [in] If the display hint only applies to a certain display mode, set dm to that mode. Otherwise the display hint will be applied to all views.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.ClearMarks(RMA.Rhino.MRhinoObjectIterator@)">
            <summary>
Set all object marks to mark_value.  See CRhinoObject::Mark() and
CRhinoObject::IsMarked().  The mark values are for general runtime
use and do not persist through save or copy operations.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.ClearMarks(RMA.Rhino.MRhinoObjectIterator@,System.Int32)">
            <summary>
Set all object marks to mark_value.  See CRhinoObject::Mark() and
CRhinoObject::IsMarked().  The mark values are for general runtime
use and do not persist through save or copy operations.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.UnselectAll">
            <summary>Unselect objects.</summary>
            <returns>
Number of object that were unselected.
See Also: CRhinoObject::Select CRhinoObject::IsSelected
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.UnselectAll(System.Boolean)">
            <summary>Unselect objects.</summary>
            <param name="bIgnorePersistentSelections">
[in] if true, then objects that are persistently selected will not be unselected.
</param>
            <returns>
Number of object that were unselected.
See Also: CRhinoObject::Select CRhinoObject::IsSelected
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.MorphObject(RMA.Rhino.IRhinoObject,RMA.OpenNURBS.IOnSpaceMorph,System.Boolean,System.Boolean)">
            <summary>
Creates a new object that is the morph of the existing
object and deletes the existing object if bDeleteOriginal is true.
</summary>
            <param name="old_object">
[in] reference to object to morph. The object objref.Object() will be deleted if bDeleteOriginal is true.
</param>
            <param name="morph">[in] space morph to apply</param>
            <param name="bAddNewObjectToDoc">
if true, the new object is added to the document.
if false, the new object is not added to the document.
</param>
            <param name="bDeleteOriginal">
if true, the original object is deleted
if false, the original object is not deleted
</param>
            <returns>
New object that is the morph of the existing_object.
The new object has identical attributes.
</returns>
            <remarks>
If the object is locked or on a locked layer, then it cannot be transformed.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.TransformObjects(RMA.Rhino.MRhinoObjectIterator@,RMA.OpenNURBS.IOnXform)">
            <summary>Transforms every object in a list.</summary>
            <param name="it">[in] iterates through list of objects to transform</param>
            <param name="xform">[in] transformation to apply</param>
            <returns>Number of objects that were transformed.</returns>
            <remarks>
This is similar to calling TransformObject() for each object int the list
except that this function will modify locked and hidden objects. It is used
for things like scaling the entire model when a unit system is changed.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.TransformObjects(RMA.Rhino.MRhinoObjectIterator@,RMA.OpenNURBS.IOnXform,System.Boolean)">
            <summary>Transforms every object in a list.</summary>
            <param name="it">[in] iterates through list of objects to transform</param>
            <param name="xform">[in] transformation to apply</param>
            <param name="bDeleteOriginal">
[in] if true, the original objects are deleted if false, the original objects are not deleted
</param>
            <returns>Number of objects that were transformed.</returns>
            <remarks>
This is similar to calling TransformObject() for each object int the list
except that this function will modify locked and hidden objects. It is used
for things like scaling the entire model when a unit system is changed.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.TransformObjects(RMA.Rhino.MRhinoObjectIterator@,RMA.OpenNURBS.IOnXform,System.Boolean,System.Boolean)">
            <summary>Transforms every object in a list.</summary>
            <param name="it">[in] iterates through list of objects to transform</param>
            <param name="xform">[in] transformation to apply</param>
            <param name="bDeleteOriginal">
[in] if true, the original objects are deleted if false, the original objects are not deleted
</param>
            <param name="bIgnoreModes">
[in] If true, locked and hidden objects are transformed.
If false objects that are locked, hidden, or on locked or hidden layers are not transformed.
</param>
            <returns>Number of objects that were transformed.</returns>
            <remarks>
This is similar to calling TransformObject() for each object int the list
except that this function will modify locked and hidden objects. It is used
for things like scaling the entire model when a unit system is changed.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.TransformObjects(RMA.Rhino.MRhinoObjectIterator@,RMA.OpenNURBS.IOnXform,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Transforms every object in a list.</summary>
            <param name="it">[in] iterates through list of objects to transform</param>
            <param name="xform">[in] transformation to apply</param>
            <param name="bDeleteOriginal">
[in] if true, the original objects are deleted if false, the original objects are not deleted
</param>
            <param name="bIgnoreModes">
[in] If true, locked and hidden objects are transformed.
If false objects that are locked, hidden, or on locked or hidden layers are not transformed.
</param>
            <returns>Number of objects that were transformed.</returns>
            <remarks>
This is similar to calling TransformObject() for each object int the list
except that this function will modify locked and hidden objects. It is used
for things like scaling the entire model when a unit system is changed.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.TransformObject(RMA.Rhino.IRhinoObject,RMA.OpenNURBS.IOnXform,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
Creates a new object that is the transformation of the
existing object and deletes the existing object if 
bDeleteOriginal is true.
</summary>
            <param name="old_object">
[in] reference to object to morph. The object objref.Object() will be deleted if bDeleteOriginal is true.
</param>
            <param name="xform">[in] transformation to apply</param>
            <param name="bAddNewObjectToDoc">
if true, the new object is added to the document.
if false, the new object is not added to the document.
</param>
            <param name="bDeleteOriginal">
if true, the original object is deleted
if false, the original object is not deleted
</param>
            <param name="bAddTransformHistory">
If true and history recording is turned on, then transformation history is recorded.
This will be adequate for simple transformation commands like rotate, move, scale,
and so on that do not have auxillary input objects. For fancier commands, that have
an auxillary object, like the spine curve in ArrayAlongCrv, set bAddTransformHistory
to false.
</param>
            <returns>
New object that is the morph of the existing_object.
The new object has identical attributes.
</returns>
            <remarks>
If the object is locked or on a locked layer, then it cannot be transformed.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.TransformObject(RMA.Rhino.MRhinoObjRef@,RMA.OpenNURBS.IOnXform)">
            <summary>
Creates a new object that is the transformation of the existing object and deletes
the existing object if bDeleteOriginal is true.
</summary>
            <param name="objref">
[in] reference to object to transform. The object objref.Object() will be
deleted if bDeleteOriginal is true.
</param>
            <param name="xform">[in] transformation to apply</param>
            <returns>
New object that is the transformation of the existing_object.
The new object has identical attributes.
</returns>
            <remarks>If the object is locked or on a locked layer, then it cannot be transformed.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.TransformObject(RMA.Rhino.MRhinoObjRef@,RMA.OpenNURBS.IOnXform,System.Boolean)">
            <summary>
Creates a new object that is the transformation of the existing object and deletes
the existing object if bDeleteOriginal is true.
</summary>
            <param name="objref">
[in] reference to object to transform. The object objref.Object() will be
deleted if bDeleteOriginal is true.
</param>
            <param name="xform">[in] transformation to apply</param>
            <param name="bDeleteOriginal">
[in] if true, the original object is deleted if false, the original object is not deleted
</param>
            <returns>
New object that is the transformation of the existing_object.
The new object has identical attributes.
</returns>
            <remarks>If the object is locked or on a locked layer, then it cannot be transformed.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.TransformObject(RMA.Rhino.MRhinoObjRef@,RMA.OpenNURBS.IOnXform,System.Boolean,System.Boolean)">
            <summary>
Creates a new object that is the transformation of the existing object and deletes
the existing object if bDeleteOriginal is true.
</summary>
            <param name="objref">
[in] reference to object to transform. The object objref.Object() will be
deleted if bDeleteOriginal is true.
</param>
            <param name="xform">[in] transformation to apply</param>
            <param name="bDeleteOriginal">
[in] if true, the original object is deleted if false, the original object is not deleted
</param>
            <param name="bIgnoreModes">
[in] If true, locked and hidden objects are transformed.
If false objects that are locked, hidden, or on locked or hidden layers are not transformed.
</param>
            <returns>
New object that is the transformation of the existing_object.
The new object has identical attributes.
</returns>
            <remarks>If the object is locked or on a locked layer, then it cannot be transformed.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.ReplaceObject(RMA.Rhino.IRhinoObjRef,RMA.OpenNURBS.IOnMesh)">
            <summary>Replace one object with new mesh object.</summary>
            <param name="objref">[in] reference to old object to be replaced. The object objref.Object() will be deleted.</param>
            <param name="mesh">
[in] new mesh to be added. A duplicate of the mesh is added to the Rhino model.
If the mesh parameter is on the heap, then the caller is responsible for deleting
the mesh parameter after the call. If this will be inefficient, use the version
of ReplaceObject that takes a CRhinoObject* as the second argument.
</param>
            <returns>If successful, a pointer to the new CRhinoMeshObject is returned.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.ReplaceObject(RMA.Rhino.IRhinoObjRef,RMA.OpenNURBS.IOnBrep)">
            <summary>Replace one object with new brep object.</summary>
            <param name="objref">
[in] reference to old object to be replaced. The object objref.Object() will be deleted.
</param>
            <param name="brep">
[in] new brep to be added. A duplicate of the brep is added to the Rhino model.
If the brep parameter is on the heap, then the caller is responsible for deleting
the brep parameter after the call. If this will be inefficient, use the version
of ReplaceObject that takes a CRhinoObject* as the second argument.
</param>
            <returns>If successful, a pointer to the new CRhinoBrepObject is returned.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.ReplaceObject(RMA.Rhino.IRhinoObjRef,RMA.OpenNURBS.IOnSurface)">
            <summary>Replace one object with new surface object.</summary>
            <param name="objref">
[in] reference to old object to be replaced. The object objref.Object() will be deleted.
</param>
            <param name="surface">
[in] new surface to be added. A duplicate of the surface is added to the Rhino model.
If the surface parameter is on the heap, then the caller is responsible for deleting
the surface parameter after the call. If this will be inefficient, use the version
of ReplaceObject that takes a CRhinoObject* as the second argument.
</param>
            <returns>If successful, a pointer to the new CRhinoSurfaceObject is returned.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.ReplaceObject(RMA.Rhino.IRhinoObjRef,RMA.OpenNURBS.IOnCurve)">
            <summary>Replace one object with new curve object.</summary>
            <param name="objref">
[in] reference to old object to be replaced. The object objref.Object() will be deleted.
</param>
            <param name="curve">
[in] new curve to be added. A duplicate of the curve is added to the Rhino model.
If the curve parameter is on the heap, then the caller is responsible for deleting
the curve parameter after the call. If this will be inefficient, use the version
of ReplaceObject that takes a CRhinoObject* as the second argument.
</param>
            <returns>If successful, a pointer to the new CRhinoCurveObject is returned.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.ReplaceObject(RMA.Rhino.IRhinoObjRef,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Replace one object with new point object.</summary>
            <param name="objref">
[in] reference to old object to be replaced. The object objref.Object() will be deleted.
</param>
            <param name="point">[in] new point to be added. The point is copied.</param>
            <returns>If successful, a pointer to the new CRhinoPointObject is returned.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.ReplaceObject(RMA.Rhino.IRhinoObjRef,RMA.Rhino.MRhinoObject)">
            <summary>
Replace one object with another. Conceptually, this function is the same as calling
Setting new_object attributes = old_object attributes
DeleteObject(old_object);
AddObject(old_object);
</summary>
            <param name="objref">[in] reference to old object to be replaced. The object objref.Object() will be deleted.</param>
            <param name="new_object">[in] new object to be activated - must not be in document.</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.ReplaceObject(RMA.Rhino.IRhinoObjRef,RMA.Rhino.MRhinoObject,System.Boolean)">
            <summary>
Replace one object with another. Conceptually, this function is the same as calling
Setting new_object attributes = old_object attributes
DeleteObject(old_object);
AddObject(old_object);
</summary>
            <param name="objref">[in] reference to old object to be replaced. The object objref.Object() will be deleted.</param>
            <param name="new_object">[in] new object to be activated - must not be in document.</param>
            <param name="bIgnoreModes">
[in] If true, locked and hidden objects are transformed.
If false objects that are locked, hidden, or on locked or hidden layers are not transformed.
</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.ModifyObjectAttributes(RMA.Rhino.IRhinoObjRef,RMA.Rhino.IRhinoObjectAttributes)">
            <summary>Modifies an object's attributes.  Cannot be used to change object id.</summary>
            <param name="objref">[in] reference to object to modify</param>
            <param name="new_attributes">[in] new attributes</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.ModifyObjectAttributes(RMA.Rhino.IRhinoObjRef,RMA.Rhino.IRhinoObjectAttributes,System.Boolean)">
            <summary>Modifies an object's attributes.  Cannot be used to change object id.</summary>
            <param name="objref">[in] reference to object to modify</param>
            <param name="new_attributes">[in] new attributes</param>
            <param name="bQuiet">[in] if true, then warning message boxes are disabled.</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.PurgeObject(RMA.Rhino.MRhinoObject@)">
            <summary>Removes object from document and deletes the pointer.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.UndeleteObject(RMA.Rhino.IRhinoObject)">
            <summary>If object-&gt;IsDeleted() is true, then the object is undeleted.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.DeleteObject(RMA.Rhino.IRhinoObjRef)">
            <summary>Deletes objref.Object(). The deletion can be undone by calling UndeleteObject().</summary>
            <param name="objref">[in] objref.Object() will be deleted</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.DeleteObject(RMA.Rhino.IRhinoObjRef,System.Boolean)">
            <summary>Deletes objref.Object(). The deletion can be undone by calling UndeleteObject().</summary>
            <param name="objref">[in] objref.Object() will be deleted</param>
            <param name="bQuiet">[in] if false, a message box will appear when an object cannot be deleted.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.DeleteObject(RMA.Rhino.IRhinoObjRef,System.Boolean,System.Boolean)">
            <summary>Deletes objref.Object(). The deletion can be undone by calling UndeleteObject().</summary>
            <param name="objref">[in] objref.Object() will be deleted</param>
            <param name="bQuiet">[in] if false, a message box will appear when an object cannot be deleted.</param>
            <param name="bIgnoreModes">
[in] If true, locked and hidden objects are transformed.
If false objects that are locked, hidden, or on locked or hidden layers are not transformed.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.UnlockObject(RMA.Rhino.IRhinoObjRef)">
            <summary>
If objref.Object()-&gt;IsLocked() is true, then the object will be returned to normal (visible and selectable) mode.
</summary>
            <param name="objref">[in] reference to locked object to unlock</param>
            <returns>
true if the object was successfully unlocked.
See Also: CRhinoDoc::HideObject
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.UnlockObject(RMA.Rhino.IRhinoObjRef,System.Boolean)">
            <summary>
If objref.Object()-&gt;IsLocked() is true, then the object will be returned to normal (visible and selectable) mode.
</summary>
            <param name="objref">[in] reference to locked object to unlock</param>
            <param name="bIgnoreLayerMode">
[in] if true, the object will be unlocked even if it is on a layer that is locked or off.
</param>
            <returns>
true if the object was successfully unlocked.
See Also: CRhinoDoc::HideObject
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.LockObject(RMA.Rhino.IRhinoObjRef)">
            <summary>If objref.Object()-&gt;IsNormal() is true, then the object will be locked.</summary>
            <param name="objref">[in] reference to normal object to lock</param>
            <returns>
true if the object was successfully hidden.
See Also: CRhinoDoc::UnlockObject CRhinoDoc::HideObject
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.LockObject(RMA.Rhino.IRhinoObjRef,System.Boolean)">
            <summary>If objref.Object()-&gt;IsNormal() is true, then the object will be locked.</summary>
            <param name="objref">[in] reference to normal object to lock</param>
            <param name="bIgnoreLayerMode">
[in] if true, the object will be locked even if it is on a layer that is locked or off.
</param>
            <returns>
true if the object was successfully hidden.
See Also: CRhinoDoc::UnlockObject CRhinoDoc::HideObject
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.ShowObject(RMA.Rhino.IRhinoObjRef)">
            <summary>
If objref.Object()-&gt;IsHidden() is true, then the object will be returned to normal (visible and selectable) mode.
</summary>
            <param name="objref">[in] reference to normal object to show</param>
            <returns>
true if the object was successfully shown.
See Also: CRhinoDoc::HideObject
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.ShowObject(RMA.Rhino.IRhinoObjRef,System.Boolean)">
            <summary>
If objref.Object()-&gt;IsHidden() is true, then the object will be returned to normal (visible and selectable) mode.
</summary>
            <param name="objref">[in] reference to normal object to show</param>
            <param name="bIgnoreLayerMode">
[in] if true, the object will be shown even if it is on a layer that is locked or off.
</param>
            <returns>
true if the object was successfully shown.
See Also: CRhinoDoc::HideObject
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.HideObject(RMA.Rhino.IRhinoObjRef)">
            <summary>If objref.Object()-&gt;IsNormal() is true, then the object will be hidden.</summary>
            <param name="objref">[in] reference to object to hide</param>
            <returns>
true if the object was successfully hidden.
See Also: CRhinoDoc::ShowObject CRhinoDoc::LockObject
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.HideObject(RMA.Rhino.IRhinoObjRef,System.Boolean)">
            <summary>If objref.Object()-&gt;IsNormal() is true, then the object will be hidden.</summary>
            <param name="objref">[in] reference to object to hide</param>
            <param name="bIgnoreLayerMode">
[in] if true, the object will be hidden even if it is on a layer that is locked or off.
</param>
            <returns>
true if the object was successfully hidden.
See Also: CRhinoDoc::ShowObject CRhinoDoc::LockObject
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.AddObject(RMA.Rhino.MRhinoObject)">
            <summary>
Adds an object to the document. The attributes need to be set before you add the object.
Use GetDefaultObjectAttributes() to get the current default attributes. 
</summary>
            <param name="object">[in]</param>
            <remarks>
The object that is being added must be created by calling new to instantiate
a class derived from CRhinoObject. Classes like CRhinoPointObject,
CRhinoCurveObject, CRhinoSurfaceObject, CRhinoMeshObject, and CRhinoBrepObject
can be used.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.AddObject(RMA.Rhino.MRhinoObject,System.Boolean)">
            <summary>
Adds an object to the document. The attributes need to be set before you add the object.
Use GetDefaultObjectAttributes() to get the current default attributes. 
</summary>
            <param name="object">[in]</param>
            <param name="bReferenceObject">
[in] if true, the object is added as a reference object that will not be saved
</param>
            <remarks>
The object that is being added must be created by calling new to instantiate
a class derived from CRhinoObject. Classes like CRhinoPointObject,
CRhinoCurveObject, CRhinoSurfaceObject, CRhinoMeshObject, and CRhinoBrepObject
can be used.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.AddObject(RMA.Rhino.MRhinoObject,System.Boolean,System.Boolean)">
            <summary>
Adds an object to the document. The attributes need to be set before you add the object.
Use GetDefaultObjectAttributes() to get the current default attributes. 
</summary>
            <param name="object">[in]</param>
            <param name="bReferenceObject">
[in] if true, the object is added as a reference object that will not be saved
</param>
            <param name="bInstanceDefinition">
[in] if true, the object is added to the instance definition geometry list.
The instance definition geometry objects are never directly displayed.
They are are referenced by CRhinoInstanceObjects.
</param>
            <remarks>
The object that is being added must be created by calling new to instantiate
a class derived from CRhinoObject. Classes like CRhinoPointObject,
CRhinoCurveObject, CRhinoSurfaceObject, CRhinoMeshObject, and CRhinoBrepObject
can be used.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.AddBrepObject(RMA.OpenNURBS.IOnBrep)">
            <summary>Add a brep object to Rhino.</summary>
            <param name="brep">[in] A duplicate of this brep is added to Rhino.</param>
            <remarks>This is an easy to use wrapper that creates a new CRhinoBrepObject and calls CRhinoDoc::AddObject.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.AddBrepObject(RMA.OpenNURBS.IOnBrep,RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <summary>Add a brep object to Rhino.</summary>
            <param name="brep">[in] A duplicate of this brep is added to Rhino.</param>
            <param name="pAttributes">[in] (optional) attributes. If NULL, the current default attributes are used.</param>
            <remarks>This is an easy to use wrapper that creates a new CRhinoBrepObject and calls CRhinoDoc::AddObject.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.AddMeshObject(RMA.OpenNURBS.IOnMesh)">
            <summary>Add a mesh object to Rhino.</summary>
            <param name="mesh">[in] A duplicate of this mesh is added to Rhino.</param>
            <remarks>This is an easy to use wrapper that creates a new CRhinoMeshObject and calls CRhinoDoc::AddObject.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.AddMeshObject(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <summary>Add a mesh object to Rhino.</summary>
            <param name="mesh">[in] A duplicate of this mesh is added to Rhino.</param>
            <param name="pAttributes">[in] (optional) attributes. If NULL, the current default attributes are used.</param>
            <remarks>This is an easy to use wrapper that creates a new CRhinoMeshObject and calls CRhinoDoc::AddObject.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.AddSurfaceObject(RMA.OpenNURBS.IOnSurface)">
            <summary>Add a surface object to Rhino.</summary>
            <param name="surface">[in] A duplicate of this surface is added to Rhino.</param>
            <remarks>This is an easy to use wrapper that creates a new CRhinoSurfaceObject and calls CRhinoDoc::AddObject.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.AddSurfaceObject(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <summary>Add a surface object to Rhino.</summary>
            <param name="surface">[in] A duplicate of this surface is added to Rhino.</param>
            <param name="pAttributes">[in] (optional) attributes. If NULL, the current default attributes are used.</param>
            <remarks>This is an easy to use wrapper that creates a new CRhinoSurfaceObject and calls CRhinoDoc::AddObject.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.AddCurveObject(RMA.OpenNURBS.IOnCurve)">
            <summary>Add a curve object to Rhino.</summary>
            <param name="curve">[in] A duplicate of this curve is added to Rhino.</param>
            <remarks>
This is an easy to use wrapper that creates a new CRhinoCurveObject and calls CRhinoDoc::AddObject.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.AddCurveObject(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <summary>Add a curve object to Rhino.</summary>
            <param name="curve">[in] A duplicate of this curve is added to Rhino.</param>
            <param name="pAttributes">[in] (optional) attributes. If NULL, the current default attributes are used.</param>
            <remarks>
This is an easy to use wrapper that creates a new CRhinoCurveObject and calls CRhinoDoc::AddObject.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.AddCurveObject(RMA.OpenNURBS.IOnBezierCurve)">
            <summary>Add an bezier curve object to Rhino.</summary>
            <param name="bezier_curve">[in]</param>
            <remarks>
This is an easy to use wrapper that creates a new CRhinoCurveObject and calls CRhinoDoc::AddObject.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.AddCurveObject(RMA.OpenNURBS.IOnBezierCurve,RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <summary>Add an bezier curve object to Rhino.</summary>
            <param name="bezier_curve">[in]</param>
            <param name="pAttributes">[in] (optional) attributes. If NULL, the current default attributes are used.</param>
            <remarks>
This is an easy to use wrapper that creates a new CRhinoCurveObject and calls CRhinoDoc::AddObject.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.AddCurveObject(RMA.OpenNURBS.IOnCircle)">
            <summary>Add an circle object to Rhino.</summary>
            <param name="circle">[in]</param>
            <remarks>
This is an easy to use wrapper that creates a new CRhinoCurveObject and calls CRhinoDoc::AddObject.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.AddCurveObject(RMA.OpenNURBS.IOnCircle,RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <summary>Add an circle object to Rhino.</summary>
            <param name="circle">[in]</param>
            <param name="pAttributes">[in] (optional) attributes. If NULL, the current default attributes are used.</param>
            <remarks>
This is an easy to use wrapper that creates a new CRhinoCurveObject and calls CRhinoDoc::AddObject.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.AddCurveObject(RMA.OpenNURBS.IOnArc)">
            <summary>Add an arc object to Rhino.</summary>
            <param name="arc">[in]</param>
            <remarks>
This is an easy to use wrapper that creates a new CRhinoCurveObject and calls CRhinoDoc::AddObject.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.AddCurveObject(RMA.OpenNURBS.IOnArc,RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <summary>Add an arc object to Rhino.</summary>
            <param name="arc">[in]</param>
            <param name="pAttributes">[in] (optional) attributes. If NULL, the current default attributes are used.</param>
            <remarks>
This is an easy to use wrapper that creates a new CRhinoCurveObject and calls CRhinoDoc::AddObject.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.AddCurveObject(RMA.OpenNURBS.IOnPolyline)">
            <summary>Add a polyline object to Rhino.</summary>
            <param name="polyline">[in]</param>
            <remarks>
This is an easy to use wrapper that creates a new CRhinoCurveObject and calls CRhinoDoc::AddObject.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.AddCurveObject(RMA.OpenNURBS.IOnPolyline,RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <summary>Add a polyline object to Rhino.</summary>
            <param name="polyline">[in]</param>
            <param name="pAttributes">[in] (optional) attributes. If NULL, the current default attributes are used.</param>
            <remarks>
This is an easy to use wrapper that creates a new CRhinoCurveObject and calls CRhinoDoc::AddObject.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.AddCurveObject(RMA.OpenNURBS.IOnLine)">
            <summary>Add a line object to Rhino.</summary>
            <param name="line">[in] (line is copied)</param>
            <remarks>
This is an easy to use wrapper that creates a new CRhinoCurveObject and calls CRhinoDoc::AddObject.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.AddCurveObject(RMA.OpenNURBS.IOnLine,RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <summary>Add a line object to Rhino.</summary>
            <param name="line">[in] (line is copied)</param>
            <param name="pAttributes">[in] (optional) attributes.  If NULL, the current default attributes are used.</param>
            <remarks>
This is an easy to use wrapper that creates a new CRhinoCurveObject and calls CRhinoDoc::AddObject.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.AddPointCloudObject(RMA.OpenNURBS.IArrayOn3dPoint)">
            <summary>Add a point cloud object to Rhino.</summary>
            <param name="points">[in] array of 3d points</param>
            <remarks>
This is an easy to use wrapper that creates a new CRhinoCurveObject and calls CRhinoDoc::AddObject.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.AddPointCloudObject(RMA.OpenNURBS.IArrayOn3dPoint,RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <summary>Add a point cloud object to Rhino.</summary>
            <param name="points">[in] array of 3d points</param>
            <param name="pAttributes">[in] (optional) attributes. If NULL, the current default attributes are used.</param>
            <remarks>
This is an easy to use wrapper that creates a new CRhinoCurveObject and calls CRhinoDoc::AddObject.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.AddPointObject(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Add a point object to Rhino.</summary>
            <param name="point">[in] (point is copied)</param>
            <remarks>
This is an easy to use wrapper that creates a new CRhinoCurveObject and calls CRhinoDoc::AddObject.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.AddPointObject(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <summary>Add a point object to Rhino.</summary>
            <param name="point">[in] (point is copied)</param>
            <param name="pAttributes">
[in] (optional) attributes. If NULL, the current default attributes are used.
</param>
            <remarks>
This is an easy to use wrapper that creates a new CRhinoCurveObject and calls CRhinoDoc::AddObject.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.LookupObjectByRuntimeSerialNumber(System.UInt32,RMA.Rhino.MRhinoObjectIterator@)">
            <summary>
Use the object runtime serial number to find a rhino_object. This is the value
stored on CRhinoObject::m_runtime_object_serial_number. In a single document,
no two objects have the same uuid. If an object is replaced with a new object,
then the new object will have a different runtime serial number. Deleted objects
begin stored in the undo list maintain their runtime serial numbers and this funtion
will return pointers to these objects. Call CRhinoObject::IsDeleted() if you need
to determine if the returned object is active. The runtime serial number is not
saved in files.
</summary>
            <param name="runtime_serial_number">[in]</param>
            <param name="it">
[in] optional iterator to use when searching for the object.
The default is the iterator constructed by
  CRhinoObjectIterator it( CRhinoObjectIterator::all_objects,
                           CRhinoObjectIterator::active_and_reference_objects );
  it.IncludeLights(true);
Using a more restricted iterator can speed the search substantially.
</param>
            <returns>
NULL or a pointer to the rhino object with the runtime serial number.
See Also: CRhionDoc::LookupObject
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.LookupObjectByRuntimeSerialNumber(System.UInt32)">
            <summary>
Use the object runtime serial number to find a rhino_object. This is the value
stored on CRhinoObject::m_runtime_object_serial_number. In a single document,
no two objects have the same uuid. If an object is replaced with a new object,
then the new object will have a different runtime serial number. Deleted objects
begin stored in the undo list maintain their runtime serial numbers and this funtion
will return pointers to these objects. Call CRhinoObject::IsDeleted() if you need
to determine if the returned object is active. The runtime serial number is not
saved in files.
</summary>
            <param name="runtime_serial_number">[in]</param>
            <returns>
NULL or a pointer to the rhino object with the runtime serial number.
See Also: CRhionDoc::LookupObject
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.LookupDocumentObject(System.Guid,System.Boolean)">
            <summary>
Lookup any document object (geometry, layers, materials, fonts, ...) by id.
</summary>
            <returns>NULL or a pointer to the document object.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.LookupObject(System.Guid)">
            <summary>
Use the object uuid to find a rhino_object. The uuid is the value This is the value
stored on CRhinoObject::Attributes().m_uuid. In a single document, no two objects
have the same uuid. If an object is replaced with a new object, then the uuid persists.
For example, if the Move command moves an object, then the moved object inherits
it's uuid from the starting object. If the Copy command copies an object, then
the copy gets a new uuid. This uuid persists through file saving/openning operations.
Deleted objects do not have uuids.
</summary>
            <param name="object_uuid">[in]</param>
            <returns>
NULL or a pointer to the rhino object with the uuid.
See Also: CRhionDoc::LookupObjectByRuntimeSerialNumber
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.ReadFileVersion">
            <summary>
Return file version extracted by CRhinoDoc::Read3dm().
Will not return values from referenced or merged files.
</summary>
            <returns>
Less than zero means no file has been read
otherwise 1 (V1.x), 2( V2.x) or 3
See Also: CRhinoDoc::Read3DM
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.IsDocumentLocked">
            <summary>
Check to see if the file associated with this document is locked.
If it is locked then this is the only document that will be able to write the file.
Other instances of Rhino will fail to write this document.
</summary>
            <returns>
Returns true if the document is locked otherwise false.
See Also: CRhinoDoc::LockDocument CRhinoDoc::UnLockDocument
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.IsDocumentReadOnly">
            <summary>This method identifies the current read-only mode for this document.</summary>
            <returns>
true if the document is can be viewed but NOT saved.
false if document can be viewed and saved.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.ViewModified(RMA.Rhino.MRhinoView)">
            <summary>If you change a view, then call ViewModified.</summary>
            <param name="view">[in] view that was modified.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.Audit(RMA.OpenNURBS.OnTextLog,System.Boolean)">
            <summary>
Audit the contents of the model.  Returns true if model is valid.
If an error is detected and the ON_TextLog pointer is not NULL,
then a description of the error is logged.  If bAttemptRepair
is true, than Audit attempts to repair any problems it detects.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.UnitSystem">
            <returns>Model space unit system.</returns>
            <remarks>Use DocProperties().PageUnitsAndTolerances() for page space.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.AngleToleranceDegrees">
            <returns>Model space angle tolerance.</returns>
            <remarks>Use DocProperties().PageUnitsAndTolerances() for page space.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.AngleToleranceRadians">
            <returns>Model space angle tolerance.</returns>
            <remarks>Use DocProperties().PageUnitsAndTolerances() for page space.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.AbsoluteTolerance">
            <summary>Model space absolute tolerance.</summary>
            <remarks>Use DocProperties().PageUnitsAndTolerances() for page space.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.Read3DM(RMA.OpenNURBS.OnBinaryArchive,System.String,System.Boolean,System.Boolean,System.Int32,System.Int32,System.Double@)">
            <summary>Read objects from an opennurbs archive and put them into the active Rhino document.</summary>
            <param name="archive">[in] archive to read from</param>
            <param name="sFileName">[in] filename used for error messages</param>
            <param name="bMerge">[in] true to import geometry into existing document false to load geometry into new document</param>
            <param name="bReference">[in] true if objects should be reference objects false if objects should be active objects</param>
            <param name="mark_value">
[in] all the objects read from the file will have their mark set to this value. Use CRhinoObject::IsMarked() to get this value.
</param>
            <param name="scale_question">
[in] Scaling happens when the unit system in an imported (bMerge = true or bReference = true) archive
does not match the unit system of the current model. The scale_mode parameter controls what happens in this case.
 1 (default) = pop up a message box informing the user that the unit systems differ and ask if the imported objects should be scaled.
 0 = do not scale (and don't ask the user).
 2 = apply an necessary scaling (and don't ask the user)
</param>
            <param name="scale_value">
[out] The scale that was applied is returned here. If 0.0 is returned, it means
that the unit systems differed but scaling was not performed because scale_mode=0 or because the user
answered NO to the scale_mode=1 question.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.Write3DM(RMA.OpenNURBS.OnBinaryArchive,System.String,RMA.Rhino.IRhinoFileWriteOptions)">
            <summary>Write active objects in the current document to an opennurbs archive.</summary>
            <param name="archive">[in] archive to write to</param>
            <param name="sFileName">[in] filename used for error messages</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.Write3DM(RMA.OpenNURBS.OnBinaryArchive,System.String,System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RMA.OpenNURBS.IOnXform,System.Boolean,System.Boolean)">
            <summary>Write active objects in the current document to an opennurbs archive.</summary>
            <param name="archive">[in] archive to write to</param>
            <param name="sFileName">[in] filename used for error messages</param>
            <param name="file_version">[in] 2, 3 or 4.  Opennurbs archive version.</param>
            <param name="bSaveUserData">[in] if true, user data attached to CRhinoObject.m_geometry will be saved.</param>
            <param name="bExportSelected">[in] if true, only selected active objects will be exported.</param>
            <param name="bSaveMeshes">[in] if true, render and analysis meshes attached to brep objects will be saved.</param>
            <param name="bPreviewImage">[in] if true, a small thumbnail preview image will be saved.</param>
            <param name="bSaveBitmaps">[in] if true, bitmaps will be saved in the 3dm archive. Otherwise the bitmap filename is all that gets saved.</param>
            <param name="xform">
[in] if not NULL, this transformation is applied to the objects saved in the archive. The original objects are not modified.
</param>
            <param name="bSaveHistory">[in] if true, history information is saved.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.BoundingBox">
            <summary>
Get a bounding box of all the visible geometry in the model.
The wireframe icons used to display render lights are NOT included.
</summary>
            <returns>
bounding box
See Also CRhinoLightTable::WireframeIconsBoundingBox( const CRhinoView* )
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.GetDefaultObjectAttributes(RMA.OpenNURBS.On3dmObjectAttributes@)">
            <summary>
attributes to use for new object
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.FindView(System.String,RMA.OpenNURBS.On3dmView@)">
            <summary>
Find the first view in the view list that has the same viewport title.
Note the the title string is not guaranteed unique
</summary>
            <param name="title">[in] viewport title to search for</param>
            <param name="view">[out] if a view is found it is copied into this</param>
            <returns>true if a view is found with the matching title</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.FindView(System.String,RMA.OpenNURBS.On3dmView@,System.Boolean)">
            <summary>
Find the first view in the view list that has the same viewport title.
Note the the title string is not guaranteed unique
</summary>
            <param name="title">[in] viewport title to search for</param>
            <param name="view">[out] if a view is found it is copied into this</param>
            <param name="include_standard_views">[in] look at standard rhino views when searching</param>
            <returns>true if a view is found with the matching title</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.FindView(System.String,RMA.OpenNURBS.On3dmView@,System.Boolean,System.Boolean)">
            <summary>
Find the first view in the view list that has the same viewport title.
Note the the title string is not guaranteed unique
</summary>
            <param name="title">[in] viewport title to search for</param>
            <param name="view">[out] if a view is found it is copied into this</param>
            <param name="include_standard_views">[in] look at standard rhino views when searching</param>
            <param name="include_page_views">[in] look at page views when searching</param>
            <returns>true if a view is found with the matching title</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.CreateViewLayout(RMA.OpenNURBS.On3dmView[])">
            <summary>
Destroy all existing views and create a new set of views based
on a  set of ON_3dmView objects. Similar to ReplaceModelViews,
except this function removes all existing views.
</summary>
            <param name="views">[in] array of ON_3dmViews</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.ReplaceModelViews(RMA.OpenNURBS.On3dmView[])">
            <summary>
Replace the standard rhino views with new rhino views based on a
set of ON_3dmView objects. All other views are left unchanged
(page and detail views are untouched).
</summary>
            <param name="views">[in] array of ON_3dmViews</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.GetViewList(RMA.Rhino.MRhinoView[]@)">
            <summary>Gets an array of all the views.</summary>
            <param name="view_list">[out] list of views</param>
            <returns>Number of views.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.GetViewList(RMA.Rhino.MRhinoView[]@,System.Boolean)">
            <summary>Gets an array of all the views.</summary>
            <param name="view_list">[out] list of views</param>
            <param name="include_standard_views">[in] add standard views to the view_list</param>
            <returns>Number of views.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.GetViewList(RMA.Rhino.MRhinoView[]@,System.Boolean,System.Boolean)">
            <summary>Gets an array of all the views.</summary>
            <param name="view_list">[out] list of views</param>
            <param name="include_standard_views">[in] add standard views to the view_list</param>
            <param name="include_page_views">[in] add page views to the view list</param>
            <returns>Number of views.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.FlashObjectList(RMA.Rhino.IRhinoObject[])">
            <summary>
Cause objects selection state to change momentarily so the object appears to
flash on the screen. This version will flash using selected color
</summary>
            <param name="obj_list">[in] list of objects to flash</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.FlashObjectList(RMA.Rhino.IRhinoObject[],System.Int32)">
            <summary>
Cause objects selection state to change momentarily so the object appears to
flash on the screen
</summary>
            <param name="obj_list">[in] list of objects to flash</param>
            <param name="flash_style">
0 = invisible - visible flash
1 = object color - selected color
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.ResetViewPipelines">
            <summary>
Resets all of the view pipelines to make sure they're all using the expected
default pipeline (ie. GetDefaultDisplayPipelineClass()). Certain situations arise
where the pipeline class gets switched out to be something different than the
default class...an example would be a shaded analysis mode getting set in a view
that is currently using GDI wireframe...When the analysis mode is cancelled, the
view needs to return back to the GDI wireframe (ie. the default display class).
This routine simply ensures that all views are configured to their appropriate
default display class.
</summary>
            <remarks>The routine basically iterates through all views calling: CRhinoView::SetupDisplayPipeline()</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.DeferredRedraw">
            <summary>
Redraw all views of the active document with a regenerate display hint.
This version of Redraw will cause all views to update, but not in any
particular order or any specific time. All you can be assured of is that
the views will eventually update...
</summary>
            <remarks>
The routine basically iterates through all views calling CRhinoView::Redraw()...
See Also CRhinoView::Redraw()
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.Redraw(System.UInt32)">
            <summary>
Redraw all views of the active document with an explicit display hint.
This version of Redraw is intended for expert users doing custom drawing.
</summary>
            <param name="display_hint">
[in] one of
CRhinoView::regenerate_display_hint
CRhinoView::mark_display_hint
CRhinoView::refresh_display_hint
</param>
            <remarks>
Calling CRhinoDoc::Redraw(display_hint) is the same as making the two calls
SetRedrawDisplayHint( display_hint )
Redraw()
If you do not know what display hint to use, the just call Redraw() and it
will automatically use the appropriate type of redraw. NEVER CALL
UpdateAllViews() IN RHINO.
See Also CRhinoView::Redraw() CRhinoView::SetRedrawDisplayHint
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.Regen">
            <summary>
Redraw all views of the active document with display hint == regenerate_display_hint.
Good for a complete cleanup of the screen after a command that did a bunch of
temporary drawing finishes
</summary>
            <remarks>
Same as CRhinoDoc::Redraw( CRhinoView::regenerate_display_hint).
CRhinoDoc::Regen can be MUCH SLOWER than calling CRhinoDoc:Redraw()
and should be used sparingly. When developing a command, it is best
to call Redraw() to see if it will do the trick, and then resort to
Regen() if nothing else works. Most commands should not need to call Regen().
See Also CRhinoView::Redraw() CRhinoView::SetRedrawDisplayHint
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.Redraw">
            <summary>Redraw all views of the active document.</summary>
            <remarks>
If you change something in the active document -- like adding objects,
deleting objects, modifying layer or object display attributes, etc.,
then you need to call CRhinoDoc::Redraw to redraw all the views. If
you change something in a particular view like the projection,
construction plane, background bitmap, etc., then you need to call
CRhinoView::Redraw to redraw that particular view. Calling CRhinoDoc::Redraw
is conceptually like calling CDoc::UpdateAllViews() but Redraw is faster
and draws the active view first. NEVER CALL UpdateAllViews() IN RHINO. See Also
CRhinoView::SetRedrawDisplayHint CRhinoView::Redraw( unsigned int display_hint )
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.RenderToDC(RMA.Rhino.MRhinoObjectIterator,System.Drawing.IDeviceContext,System.Int32,System.Int32,RMA.OpenNURBS.IOn3dmView)">
            <summary>Render view to a device context.</summary>
            <param name="it">[in] iterates through objects to be drawn. When in doubt, use CRhinoObjectIterator it( *this, CRhinoObjectIterator::normal_or_locked_objects, CRhinoObjectIterator::active_and_reference_objects);</param>
            <param name="view_info">[in] View projection and decoration information. When in doubt, use RhinoApp().ActiveView()-&gt;MainViewport().View().</param>
            <remarks>
This is useful for creating preview bitmaps, printing, etc.
NOTE: Using this method to generate metafiles can/will result in very large files,
since it renders to a bitmap and then transfers the bitmap to the passed in DC,
rather than just drawing directly to the DC.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.RenderToDC(RMA.Rhino.MRhinoObjectIterator,System.Drawing.IDeviceContext,System.Int32,System.Int32,RMA.OpenNURBS.IOn3dmView,System.Boolean)">
            <summary>Render view to a device context.</summary>
            <param name="it">[in] iterates through objects to be drawn. When in doubt, use CRhinoObjectIterator it( *this, CRhinoObjectIterator::normal_or_locked_objects, CRhinoObjectIterator::active_and_reference_objects);</param>
            <param name="view_info">[in] View projection and decoration information. When in doubt, use RhinoApp().ActiveView()-&gt;MainViewport().View().</param>
            <param name="bIgnoreHighlights">[in] If true, highlight status is ignored.</param>
            <remarks>
This is useful for creating preview bitmaps, printing, etc.
NOTE: Using this method to generate metafiles can/will result in very large files,
since it renders to a bitmap and then transfers the bitmap to the passed in DC,
rather than just drawing directly to the DC.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.RenderToDC(RMA.Rhino.MRhinoObjectIterator,System.Drawing.IDeviceContext,System.Int32,System.Int32,RMA.OpenNURBS.IOn3dmView,System.Boolean,System.Boolean)">
            <summary>Render view to a device context.</summary>
            <param name="it">[in] iterates through objects to be drawn. When in doubt, use CRhinoObjectIterator it( *this, CRhinoObjectIterator::normal_or_locked_objects, CRhinoObjectIterator::active_and_reference_objects);</param>
            <param name="view_info">[in] View projection and decoration information. When in doubt, use RhinoApp().ActiveView()-&gt;MainViewport().View().</param>
            <param name="bIgnoreHighlights">[in] If true, highlight status is ignored.</param>
            <remarks>
This is useful for creating preview bitmaps, printing, etc.
NOTE: Using this method to generate metafiles can/will result in very large files,
since it renders to a bitmap and then transfers the bitmap to the passed in DC,
rather than just drawing directly to the DC.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.RenderToDC(RMA.Rhino.MRhinoObjectIterator,System.Drawing.IDeviceContext,System.Int32,System.Int32,RMA.OpenNURBS.IOn3dmView,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Render view to a device context.</summary>
            <param name="it">[in] iterates through objects to be drawn. When in doubt, use CRhinoObjectIterator it( *this, CRhinoObjectIterator::normal_or_locked_objects, CRhinoObjectIterator::active_and_reference_objects);</param>
            <param name="view_info">[in] View projection and decoration information. When in doubt, use RhinoApp().ActiveView()-&gt;MainViewport().View().</param>
            <param name="bIgnoreHighlights">[in] If true, highlight status is ignored.</param>
            <remarks>
This is useful for creating preview bitmaps, printing, etc.
NOTE: Using this method to generate metafiles can/will result in very large files,
since it renders to a bitmap and then transfers the bitmap to the passed in DC,
rather than just drawing directly to the DC.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.RenderToDC(RMA.Rhino.MRhinoObjectIterator,System.Drawing.IDeviceContext,System.Int32,System.Int32,RMA.OpenNURBS.IOn3dmView,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Render view to a device context.</summary>
            <param name="it">[in] iterates through objects to be drawn. When in doubt, use CRhinoObjectIterator it( *this, CRhinoObjectIterator::normal_or_locked_objects, CRhinoObjectIterator::active_and_reference_objects);</param>
            <param name="view_info">[in] View projection and decoration information. When in doubt, use RhinoApp().ActiveView()-&gt;MainViewport().View().</param>
            <param name="bIgnoreHighlights">[in] If true, highlight status is ignored.</param>
            <remarks>
This is useful for creating preview bitmaps, printing, etc.
NOTE: Using this method to generate metafiles can/will result in very large files,
since it renders to a bitmap and then transfers the bitmap to the passed in DC,
rather than just drawing directly to the DC.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.RenderToDC(RMA.Rhino.MRhinoObjectIterator,System.Drawing.IDeviceContext,System.Int32,System.Int32,RMA.OpenNURBS.IOn3dmView,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Render view to a device context.</summary>
            <param name="it">[in] iterates through objects to be drawn. When in doubt, use CRhinoObjectIterator it( *this, CRhinoObjectIterator::normal_or_locked_objects, CRhinoObjectIterator::active_and_reference_objects);</param>
            <param name="view_info">[in] View projection and decoration information. When in doubt, use RhinoApp().ActiveView()-&gt;MainViewport().View().</param>
            <param name="bIgnoreHighlights">[in] If true, highlight status is ignored.</param>
            <remarks>
This is useful for creating preview bitmaps, printing, etc.
NOTE: Using this method to generate metafiles can/will result in very large files,
since it renders to a bitmap and then transfers the bitmap to the passed in DC,
rather than just drawing directly to the DC.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.DrawToDC(RMA.Rhino.MRhinoObjectIterator,System.Drawing.IDeviceContext,System.Int32,System.Int32,RMA.OpenNURBS.IOn3dmView)">
            <summary>Draw to a device context.</summary>
            <param name="it">[in] iterates through objects to be drawn. When in doubt, use CRhinoObjectIterator it( *this, CRhinoObjectIterator::normal_or_locked_objects, CRhinoObjectIterator::active_and_reference_objects);</param>
            <param name="view_info">[in] View projection and decoration information. When in doubt, use RhinoApp().ActiveView()-&gt;MainViewport().View().</param>
            <remarks>
This is useful for creating metafiles, printing, etc.
NOTE: This will DRAW to ANY type of DC, and will ONLY draw in Wireframe.
Drawing bitmaps to metafiles generates much larger than needed .WMF files.
To get rendered and/or preview bitmaps, see RenderToDC...
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.DrawToDC(RMA.Rhino.MRhinoObjectIterator,System.Drawing.IDeviceContext,System.Int32,System.Int32,RMA.OpenNURBS.IOn3dmView,System.Boolean)">
            <summary>Draw to a device context.</summary>
            <param name="it">[in] iterates through objects to be drawn. When in doubt, use CRhinoObjectIterator it( *this, CRhinoObjectIterator::normal_or_locked_objects, CRhinoObjectIterator::active_and_reference_objects);</param>
            <param name="view_info">[in] View projection and decoration information. When in doubt, use RhinoApp().ActiveView()-&gt;MainViewport().View().</param>
            <param name="bIgnoreHighlights">[in] If true, highlight status is ignored.</param>
            <remarks>
This is useful for creating metafiles, printing, etc.
NOTE: This will DRAW to ANY type of DC, and will ONLY draw in Wireframe.
Drawing bitmaps to metafiles generates much larger than needed .WMF files.
To get rendered and/or preview bitmaps, see RenderToDC...
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.DrawToDC(RMA.Rhino.MRhinoObjectIterator,System.Drawing.IDeviceContext,System.Int32,System.Int32,RMA.OpenNURBS.IOn3dmView,System.Boolean,System.Boolean)">
            <summary>Draw to a device context.</summary>
            <param name="it">[in] iterates through objects to be drawn. When in doubt, use CRhinoObjectIterator it( *this, CRhinoObjectIterator::normal_or_locked_objects, CRhinoObjectIterator::active_and_reference_objects);</param>
            <param name="view_info">[in] View projection and decoration information. When in doubt, use RhinoApp().ActiveView()-&gt;MainViewport().View().</param>
            <param name="bIgnoreHighlights">[in] If true, highlight status is ignored.</param>
            <remarks>
This is useful for creating metafiles, printing, etc.
NOTE: This will DRAW to ANY type of DC, and will ONLY draw in Wireframe.
Drawing bitmaps to metafiles generates much larger than needed .WMF files.
To get rendered and/or preview bitmaps, see RenderToDC...
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.DrawToDC(RMA.Rhino.MRhinoObjectIterator,System.Drawing.IDeviceContext,System.Int32,System.Int32,RMA.OpenNURBS.IOn3dmView,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Draw to a device context.</summary>
            <param name="it">[in] iterates through objects to be drawn. When in doubt, use CRhinoObjectIterator it( *this, CRhinoObjectIterator::normal_or_locked_objects, CRhinoObjectIterator::active_and_reference_objects);</param>
            <param name="view_info">[in] View projection and decoration information. When in doubt, use RhinoApp().ActiveView()-&gt;MainViewport().View().</param>
            <param name="bIgnoreHighlights">[in] If true, highlight status is ignored.</param>
            <remarks>
This is useful for creating metafiles, printing, etc.
NOTE: This will DRAW to ANY type of DC, and will ONLY draw in Wireframe.
Drawing bitmaps to metafiles generates much larger than needed .WMF files.
To get rendered and/or preview bitmaps, see RenderToDC...
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDoc.DrawToDC(RMA.Rhino.MRhinoObjectIterator,System.Drawing.IDeviceContext,System.Int32,System.Int32,RMA.OpenNURBS.IOn3dmView,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Draw to a device context.</summary>
            <param name="it">[in] iterates through objects to be drawn. When in doubt, use CRhinoObjectIterator it( *this, CRhinoObjectIterator::normal_or_locked_objects, CRhinoObjectIterator::active_and_reference_objects);</param>
            <param name="view_info">[in] View projection and decoration information. When in doubt, use RhinoApp().ActiveView()-&gt;MainViewport().View().</param>
            <param name="bIgnoreHighlights">[in] If true, highlight status is ignored.</param>
            <remarks>
This is useful for creating metafiles, printing, etc.
NOTE: This will DRAW to ANY type of DC, and will ONLY draw in Wireframe.
Drawing bitmaps to metafiles generates much larger than needed .WMF files.
To get rendered and/or preview bitmaps, see RenderToDC...
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.GetTitle">
            <summary>Call this function to get the document's title, which is usually derived from the document's filename.</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.GetPathName">
            <summary>Call this function to get the fully qualified path of the document's disk file.</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.ConstructionPlaneCount">
            <summary>
Returns: Number of undo records.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.HasUndoRecords">
            <summary>
Returns true if document contains undo records.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.UndoRecordMemorySize">
            <summary>
Returns: Number bytes in used by undo records
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.UndoRecordCount">
            <summary>
Returns: Record being actively recorded.
</summary>
            <summary>
Returns: Number of undo records.
</summary>
            <summary>
Returns: Number of undo records.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.UndoRecordingIsActive">
            <summary>
true if actually happening now
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.UndoRecordingIsEnabled">
            <summary>
true if permitted
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.TemplateFileUsed">
            <summary>
Call this method to get the name of the template file used to create this document.
This is a runtime value only present if the document was newly created.
</summary>
            <returns>Returns full path to template used to create this document on File/New</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.IsSendingMail">
            <summary>
Determine if Rhino is in the process of sending this document as an email attachment.
</summary>
            <returns>Returns true if in OnFileSendMail otherwise; false.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.InGetMeshes">
            <returns>Returns non-null if currently in a CRhinoGetString::GetString()</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.InGetColor">
            <returns>Returns non-null if currently in a CRhinoGetString::GetString()</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.InGetOption">
            <returns>Returns non-null if currently in a CRhinoGetString::GetString()</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.InGetNumber">
            <returns>Returns non-null if currently in a CRhinoGetString::GetString()</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.InGetString">
            <returns>Returns non-null if currently in a CRhinoGetString::GetString()</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.InGetObject">
            <returns>Returns non-null if currently in a CRhinoGetPoint::GetObject()</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.InGetPoint">
            <returns>Returns non-null if currently in a CRhinoGetPoint::GetPoint()</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.InGet">
            <summary>
Returns non-null if currently in a CRhinoGetPoint::GetPoint(),
CRhinoGetObject::GetObject(), or CRhinoGetString::GetString()
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.SetRedrawDisplayHint(System.UInt32)">
            <summary>
Expert user tool to set flags used by CRhinoDoc::Redraw(). Paramters: display_hint - [in] one of CRhinoView::regenerate_display_hint CRhinoView::mark_display_hint CRhinoView::refresh_display_hint dm - [in] If the display hint only applies to a certain display mode, set dm to that mode. Otherwise the display hint will be applied to all views.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.SetRedrawDisplayHint(System.UInt32,RMA.OpenNURBS.IOn.display_mode)">
            <summary>
Expert user tool to set flags used by CRhinoDoc::Redraw(). Paramters: display_hint - [in] one of CRhinoView::regenerate_display_hint CRhinoView::mark_display_hint CRhinoView::refresh_display_hint dm - [in] If the display hint only applies to a certain display mode, set dm to that mode. Otherwise the display hint will be applied to all views.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.LookupObjectByRuntimeSerialNumber(System.UInt32,RMA.Rhino.MRhinoObjectIterator@)">
            <summary>
Use the object runtime serial number to find a rhino_object. This is the value
stored on CRhinoObject::m_runtime_object_serial_number. In a single document,
no two objects have the same uuid. If an object is replaced with a new object,
then the new object will have a different runtime serial number. Deleted objects
begin stored in the undo list maintain their runtime serial numbers and this funtion
will return pointers to these objects. Call CRhinoObject::IsDeleted() if you need
to determine if the returned object is active. The runtime serial number is not
saved in files.
</summary>
            <param name="runtime_serial_number">[in]</param>
            <param name="it">
[in] optional iterator to use when searching for the object.
The default is the iterator constructed by
  CRhinoObjectIterator it( CRhinoObjectIterator::all_objects,
                           CRhinoObjectIterator::active_and_reference_objects );
  it.IncludeLights(true);
Using a more restricted iterator can speed the search substantially.
</param>
            <returns>
NULL or a pointer to the rhino object with the runtime serial number.
See Also: CRhionDoc::LookupObject
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.LookupObjectByRuntimeSerialNumber(System.UInt32)">
            <summary>
Use the object runtime serial number to find a rhino_object. This is the value
stored on CRhinoObject::m_runtime_object_serial_number. In a single document,
no two objects have the same uuid. If an object is replaced with a new object,
then the new object will have a different runtime serial number. Deleted objects
begin stored in the undo list maintain their runtime serial numbers and this funtion
will return pointers to these objects. Call CRhinoObject::IsDeleted() if you need
to determine if the returned object is active. The runtime serial number is not
saved in files.
</summary>
            <param name="runtime_serial_number">[in]</param>
            <returns>
NULL or a pointer to the rhino object with the runtime serial number.
See Also: CRhionDoc::LookupObject
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.LookupDocumentObject(System.Guid,System.Boolean)">
            <summary>
Lookup any document object (geometry, layers, materials, fonts, ...) by id.
</summary>
            <returns>NULL or a pointer to the document object.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.LookupObject(System.Guid)">
            <summary>
Use the object uuid to find a rhino_object. The uuid is the value This is the value
stored on CRhinoObject::Attributes().m_uuid. In a single document, no two objects
have the same uuid. If an object is replaced with a new object, then the uuid persists.
For example, if the Move command moves an object, then the moved object inherits
it's uuid from the starting object. If the Copy command copies an object, then
the copy gets a new uuid. This uuid persists through file saving/openning operations.
Deleted objects do not have uuids.
</summary>
            <param name="object_uuid">[in]</param>
            <returns>
NULL or a pointer to the rhino object with the uuid.
See Also: CRhionDoc::LookupObjectByRuntimeSerialNumber
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.ReadFileVersion">
            <summary>
Return file version extracted by CRhinoDoc::Read3dm().
Will not return values from referenced or merged files.
</summary>
            <returns>
Less than zero means no file has been read
otherwise 1 (V1.x), 2( V2.x) or 3
See Also: CRhinoDoc::Read3DM
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.IsDocumentLocked">
            <summary>
Check to see if the file associated with this document is locked.
If it is locked then this is the only document that will be able to write the file.
Other instances of Rhino will fail to write this document.
</summary>
            <returns>
Returns true if the document is locked otherwise false.
See Also: CRhinoDoc::LockDocument CRhinoDoc::UnLockDocument
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.IsDocumentReadOnly">
            <summary>This method identifies the current read-only mode for this document.</summary>
            <returns>
true if the document is can be viewed but NOT saved.
false if document can be viewed and saved.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.UnitSystem">
            <returns>Model space unit system.</returns>
            <remarks>Use DocProperties().PageUnitsAndTolerances() for page space.</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.AngleToleranceDegrees">
            <returns>Model space angle tolerance.</returns>
            <remarks>Use DocProperties().PageUnitsAndTolerances() for page space.</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.AngleToleranceRadians">
            <returns>Model space angle tolerance.</returns>
            <remarks>Use DocProperties().PageUnitsAndTolerances() for page space.</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.AbsoluteTolerance">
            <returns>Model space absolute tolerance.</returns>
            <remarks>Use DocProperties().PageUnitsAndTolerances() for page space.</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.BoundingBox">
            <summary>
Get a bounding box of all the visible geometry in the model.
The wireframe icons used to display render lights are NOT included.
</summary>
            <returns>
bounding box
See Also CRhinoLightTable::WireframeIconsBoundingBox( const CRhinoView* )
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.RenderToDC(RMA.Rhino.MRhinoObjectIterator,System.Drawing.IDeviceContext,System.Int32,System.Int32,RMA.OpenNURBS.IOn3dmView)">
            <summary>Render view to a device context.</summary>
            <param name="it">[in] iterates through objects to be drawn. When in doubt, use CRhinoObjectIterator it( *this, CRhinoObjectIterator::normal_or_locked_objects, CRhinoObjectIterator::active_and_reference_objects);</param>
            <param name="view_info">[in] View projection and decoration information. When in doubt, use RhinoApp().ActiveView()-&gt;MainViewport().View().</param>
            <remarks>
This is useful for creating preview bitmaps, printing, etc.
NOTE: Using this method to generate metafiles can/will result in very large files,
since it renders to a bitmap and then transfers the bitmap to the passed in DC,
rather than just drawing directly to the DC.
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.RenderToDC(RMA.Rhino.MRhinoObjectIterator,System.Drawing.IDeviceContext,System.Int32,System.Int32,RMA.OpenNURBS.IOn3dmView,System.Boolean)">
            <summary>Render view to a device context.</summary>
            <param name="it">[in] iterates through objects to be drawn. When in doubt, use CRhinoObjectIterator it( *this, CRhinoObjectIterator::normal_or_locked_objects, CRhinoObjectIterator::active_and_reference_objects);</param>
            <param name="view_info">[in] View projection and decoration information. When in doubt, use RhinoApp().ActiveView()-&gt;MainViewport().View().</param>
            <param name="bIgnoreHighlights">[in] If true, highlight status is ignored.</param>
            <remarks>
This is useful for creating preview bitmaps, printing, etc.
NOTE: Using this method to generate metafiles can/will result in very large files,
since it renders to a bitmap and then transfers the bitmap to the passed in DC,
rather than just drawing directly to the DC.
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.RenderToDC(RMA.Rhino.MRhinoObjectIterator,System.Drawing.IDeviceContext,System.Int32,System.Int32,RMA.OpenNURBS.IOn3dmView,System.Boolean,System.Boolean)">
            <summary>Render view to a device context.</summary>
            <param name="it">[in] iterates through objects to be drawn. When in doubt, use CRhinoObjectIterator it( *this, CRhinoObjectIterator::normal_or_locked_objects, CRhinoObjectIterator::active_and_reference_objects);</param>
            <param name="view_info">[in] View projection and decoration information. When in doubt, use RhinoApp().ActiveView()-&gt;MainViewport().View().</param>
            <param name="bIgnoreHighlights">[in] If true, highlight status is ignored.</param>
            <remarks>
This is useful for creating preview bitmaps, printing, etc.
NOTE: Using this method to generate metafiles can/will result in very large files,
since it renders to a bitmap and then transfers the bitmap to the passed in DC,
rather than just drawing directly to the DC.
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.RenderToDC(RMA.Rhino.MRhinoObjectIterator,System.Drawing.IDeviceContext,System.Int32,System.Int32,RMA.OpenNURBS.IOn3dmView,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Render view to a device context.</summary>
            <param name="it">[in] iterates through objects to be drawn. When in doubt, use CRhinoObjectIterator it( *this, CRhinoObjectIterator::normal_or_locked_objects, CRhinoObjectIterator::active_and_reference_objects);</param>
            <param name="view_info">[in] View projection and decoration information. When in doubt, use RhinoApp().ActiveView()-&gt;MainViewport().View().</param>
            <param name="bIgnoreHighlights">[in] If true, highlight status is ignored.</param>
            <remarks>
This is useful for creating preview bitmaps, printing, etc.
NOTE: Using this method to generate metafiles can/will result in very large files,
since it renders to a bitmap and then transfers the bitmap to the passed in DC,
rather than just drawing directly to the DC.
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.RenderToDC(RMA.Rhino.MRhinoObjectIterator,System.Drawing.IDeviceContext,System.Int32,System.Int32,RMA.OpenNURBS.IOn3dmView,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Render view to a device context.</summary>
            <param name="it">[in] iterates through objects to be drawn. When in doubt, use CRhinoObjectIterator it( *this, CRhinoObjectIterator::normal_or_locked_objects, CRhinoObjectIterator::active_and_reference_objects);</param>
            <param name="view_info">[in] View projection and decoration information. When in doubt, use RhinoApp().ActiveView()-&gt;MainViewport().View().</param>
            <param name="bIgnoreHighlights">[in] If true, highlight status is ignored.</param>
            <remarks>
This is useful for creating preview bitmaps, printing, etc.
NOTE: Using this method to generate metafiles can/will result in very large files,
since it renders to a bitmap and then transfers the bitmap to the passed in DC,
rather than just drawing directly to the DC.
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.RenderToDC(RMA.Rhino.MRhinoObjectIterator,System.Drawing.IDeviceContext,System.Int32,System.Int32,RMA.OpenNURBS.IOn3dmView,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Render view to a device context.</summary>
            <param name="it">[in] iterates through objects to be drawn. When in doubt, use CRhinoObjectIterator it( *this, CRhinoObjectIterator::normal_or_locked_objects, CRhinoObjectIterator::active_and_reference_objects);</param>
            <param name="view_info">[in] View projection and decoration information. When in doubt, use RhinoApp().ActiveView()-&gt;MainViewport().View().</param>
            <param name="bIgnoreHighlights">[in] If true, highlight status is ignored.</param>
            <remarks>
This is useful for creating preview bitmaps, printing, etc.
NOTE: Using this method to generate metafiles can/will result in very large files,
since it renders to a bitmap and then transfers the bitmap to the passed in DC,
rather than just drawing directly to the DC.
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.DrawToDC(RMA.Rhino.MRhinoObjectIterator,System.Drawing.IDeviceContext,System.Int32,System.Int32,RMA.OpenNURBS.IOn3dmView)">
            <summary>Draw to a device context.</summary>
            <param name="it">[in] iterates through objects to be drawn. When in doubt, use CRhinoObjectIterator it( *this, CRhinoObjectIterator::normal_or_locked_objects, CRhinoObjectIterator::active_and_reference_objects);</param>
            <param name="view_info">[in] View projection and decoration information. When in doubt, use RhinoApp().ActiveView()-&gt;MainViewport().View().</param>
            <remarks>
This is useful for creating metafiles, printing, etc.
NOTE: This will DRAW to ANY type of DC, and will ONLY draw in Wireframe.
Drawing bitmaps to metafiles generates much larger than needed .WMF files.
To get rendered and/or preview bitmaps, see RenderToDC...
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.DrawToDC(RMA.Rhino.MRhinoObjectIterator,System.Drawing.IDeviceContext,System.Int32,System.Int32,RMA.OpenNURBS.IOn3dmView,System.Boolean)">
            <summary>Draw to a device context.</summary>
            <param name="it">[in] iterates through objects to be drawn. When in doubt, use CRhinoObjectIterator it( *this, CRhinoObjectIterator::normal_or_locked_objects, CRhinoObjectIterator::active_and_reference_objects);</param>
            <param name="view_info">[in] View projection and decoration information. When in doubt, use RhinoApp().ActiveView()-&gt;MainViewport().View().</param>
            <param name="bIgnoreHighlights">[in] If true, highlight status is ignored.</param>
            <remarks>
This is useful for creating metafiles, printing, etc.
NOTE: This will DRAW to ANY type of DC, and will ONLY draw in Wireframe.
Drawing bitmaps to metafiles generates much larger than needed .WMF files.
To get rendered and/or preview bitmaps, see RenderToDC...
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.DrawToDC(RMA.Rhino.MRhinoObjectIterator,System.Drawing.IDeviceContext,System.Int32,System.Int32,RMA.OpenNURBS.IOn3dmView,System.Boolean,System.Boolean)">
            <summary>Draw to a device context.</summary>
            <param name="it">[in] iterates through objects to be drawn. When in doubt, use CRhinoObjectIterator it( *this, CRhinoObjectIterator::normal_or_locked_objects, CRhinoObjectIterator::active_and_reference_objects);</param>
            <param name="view_info">[in] View projection and decoration information. When in doubt, use RhinoApp().ActiveView()-&gt;MainViewport().View().</param>
            <param name="bIgnoreHighlights">[in] If true, highlight status is ignored.</param>
            <remarks>
This is useful for creating metafiles, printing, etc.
NOTE: This will DRAW to ANY type of DC, and will ONLY draw in Wireframe.
Drawing bitmaps to metafiles generates much larger than needed .WMF files.
To get rendered and/or preview bitmaps, see RenderToDC...
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.DrawToDC(RMA.Rhino.MRhinoObjectIterator,System.Drawing.IDeviceContext,System.Int32,System.Int32,RMA.OpenNURBS.IOn3dmView,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Draw to a device context.</summary>
            <param name="it">[in] iterates through objects to be drawn. When in doubt, use CRhinoObjectIterator it( *this, CRhinoObjectIterator::normal_or_locked_objects, CRhinoObjectIterator::active_and_reference_objects);</param>
            <param name="view_info">[in] View projection and decoration information. When in doubt, use RhinoApp().ActiveView()-&gt;MainViewport().View().</param>
            <param name="bIgnoreHighlights">[in] If true, highlight status is ignored.</param>
            <remarks>
This is useful for creating metafiles, printing, etc.
NOTE: This will DRAW to ANY type of DC, and will ONLY draw in Wireframe.
Drawing bitmaps to metafiles generates much larger than needed .WMF files.
To get rendered and/or preview bitmaps, see RenderToDC...
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoDoc.DrawToDC(RMA.Rhino.MRhinoObjectIterator,System.Drawing.IDeviceContext,System.Int32,System.Int32,RMA.OpenNURBS.IOn3dmView,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Draw to a device context.</summary>
            <param name="it">[in] iterates through objects to be drawn. When in doubt, use CRhinoObjectIterator it( *this, CRhinoObjectIterator::normal_or_locked_objects, CRhinoObjectIterator::active_and_reference_objects);</param>
            <param name="view_info">[in] View projection and decoration information. When in doubt, use RhinoApp().ActiveView()-&gt;MainViewport().View().</param>
            <param name="bIgnoreHighlights">[in] If true, highlight status is ignored.</param>
            <remarks>
This is useful for creating metafiles, printing, etc.
NOTE: This will DRAW to ANY type of DC, and will ONLY draw in Wireframe.
Drawing bitmaps to metafiles generates much larger than needed .WMF files.
To get rendered and/or preview bitmaps, see RenderToDC...
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoUndoEventHandler.Undo(RMA.Rhino.IRhinoCommand,System.String,System.Boolean,System.UInt32)">
            <summary>
The Rhino Undo command will call this virtual Undo function when the event needs to be undone.
You should override this function to undo changes in your plug-in data,

NEVER change any setting in the Rhino document or application. Rhino handles ALL changes to the
application and document and you will break the Undo/Redo commands if you make any changes to
the application or document.
</summary>
            <param name="cmd">[in] Command being undone. Can be NULL.</param>
            <param name="action_description">[in] Description of what is being undone. Can be NULL.</param>
            <param name="bCreatedByRedo">[in] True if a "Redo" was responsible for creating this record.</param>
            <param name="undo_event_sn">[in] Runtime serial number Rhino assigned to the event.</param>
        </member>
        <member name="P:RMA.Rhino.MRhinoUndoEventHandler.m_description">
            <value>
The AuditUndo command prints this description.
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoUndoEventHandler.m_description">
            <value>
The AuditUndo command prints this description.
</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetFileDialog.UpdateEmbededInstanceDefinitions">
            <summary>
Reports status of update embedded_def instance definitions. If this is true
then definitions marked as embedded_def are automatically otherwise they do
not get updated. Returns: true if defintions are to be updated in scripting mode.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetFileDialog.EnableUpdateEmbededInstanceDefinitions(System.Boolean)">
            <summary>
This is only meaningfull when scripting the file open command. This is used
to let the user decide how to handle embedded_def instance definitions.
</summary>
            <param name="b">[in] true mean embedded_def instance defintions will update when file open is done.</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoGetFileDialog.UpdateEmbededInstanceDefinitions">
            <summary>
Description: Reports status of update embedded_def instance definitions. If this is true then definitions marked as embedded_def are automatically otherwise they do not get updated. Returns: true if defintions are to be updated in scripting mode. See Also: CRhFileDialog::EnableUpdateEmbededInstanceDefinitions Remarks: Added 3 March 2006 by John Morse so we could add command line option that would open files and let the user specify what to do with embeded instance definitions.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetMeshes.Mesh(System.Int32)">
            <summary>
Mesh(i) (0 &lt;= i &lt; MeshCount() to get the meshes. Note that the
meshes will automatically be destroyed by ~CRhinoGetMeshes(), so you
must copy them if you need them after ~CRhinoGetMeshes().
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetMeshes.MeshCount">
            <summary>call MeshCount() to see how many meshes you have</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetMeshes.GetExportMeshes(System.Boolean)">
            <param name="arg1">set to true to mesh only selected objects</param>
        </member>
        <member name="T:RMA.Rhino.MRhinoGetMeshes">
            <summary>
Interactively gets meshes for commands that export meshes to other file formats.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGetMeshes.MeshCount">
            <summary>call MeshCount() to see how many meshes you have</summary>
        </member>
        <member name="T:RMA.Rhino.IRhinoGetMeshes">
            <summary>
Interactively gets meshes for commands that export meshes to other file formats.
</summary>
        </member>
        <member name="T:RMA.Rhino.MRhinoMeshRef">
            <summary>CRhinoMeshRef is used to return mesh objects</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoMeshRef.Mesh">
            <summary>
mesh object
</summary>
        </member>
        <member name="T:RMA.Rhino.IRhinoMeshRef">
            <summary>CRhinoMeshRef is used to return mesh objects</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.ClearObjects">
            <summary>
This is a low level geek tool for emptying the selected object list.
Calling GetObjects() automatically clears this list, so the situations
where this function is needed are very rare.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.EnableUnselectObjectsOnExit">
            <summary>
By default any objects in the object list are unselected when CRhinoGetObject::GetObjects()
exits with any return code besides CRhinoGet::object. If you want to leave the objects 
selected when non-object input is returned, then call EnableClearObjectsOnExit(false)
before calling GetObjects().
</summary>
            <remarks>
If you pass false to this fuction, then you are responsible for making
sure the selection state of the objects in the object list is correct.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.EnableUnselectObjectsOnExit(System.Boolean)">
            <summary>
By default any objects in the object list are unselected when CRhinoGetObject::GetObjects()
exits with any return code besides CRhinoGet::object. If you want to leave the objects 
selected when non-object input is returned, then call EnableClearObjectsOnExit(false)
before calling GetObjects().
</summary>
            <remarks>
If you pass false to this fuction, then you are responsible for making
sure the selection state of the objects in the object list is correct.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.EnableClearObjectsOnEntry">
            <summary>
By default the picked object list is cleared when CRhinoGetObject::GetObjects()
is called. If you are reusing a CRhinoGetObject class and do not want the existing
object list cleared when you call GetObjects, then call EnableClearObjectsOnEntry(false)
before calling GetObjects().
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.EnableClearObjectsOnEntry(System.Boolean)">
            <summary>
By default the picked object list is cleared when CRhinoGetObject::GetObjects()
is called. If you are reusing a CRhinoGetObject class and do not want the existing
object list cleared when you call GetObjects, then call EnableClearObjectsOnEntry(false)
before calling GetObjects().
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.SerialNumber">
            <summary>
Each instanct of CRhinoGetObject has a unique runtime serial number that is
used to identify object selection events associated with that instance.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.ObjectsWerePreSelected">
            <returns>True if CRhinoGetObjects::GetObjects() retuned preselected objects.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.Object(System.Int32)">
            <param name="index">0 based index</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.ObjectCount">
            <returns>number of objects selected</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.GetObjects">
            <summary>Call to select objects.</summary>
            <returns>
CRhinoGet::success - objects selected.
CRhinoGet::cancel - user pressed ESCAPE to cancel the get.
See CRhinoGet::result for other possible values that may be returned when options,
numbers, etc., are acceptable responses.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.GetObjects(System.Int32)">
            <summary>Call to select objects.</summary>
            <param name="minimum_number">[in] minimum number of objects to select.</param>
            <returns>
CRhinoGet::success - objects selected.
CRhinoGet::cancel - user pressed ESCAPE to cancel the get.
See CRhinoGet::result for other possible values that may be returned when options,
numbers, etc., are acceptable responses.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.GetObjects(System.Int32,System.Int32)">
            <summary>Call to select objects.</summary>
            <param name="minimum_number">[in] minimum number of objects to select.</param>
            <param name="maximum_number">
[in] maximum number of objects to select.
If 0, then the user must press enter to finish object selection.
If -1, then object selection stops as soon as there are at least minimum_number of object selected.
If &gt;0, then the picking stops when there are maximum_number objects.
If a window pick, crossing pick, or Sel* command attempts to add more than maximum_number,
then the attempt is ignored.
</param>
            <returns>
CRhinoGet::success - objects selected.
CRhinoGet::cancel - user pressed ESCAPE to cancel the get.
See CRhinoGet::result for other possible values that may be returned when options,
numbers, etc., are acceptable responses.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.SetPressEnterWhenDonePrompt(System.String)">
            <summary>
The default prompt when EnablePressEnterWhenDonePrompt is enabled is
"Press Enter when done". Use this function to specify a different
string to be appended.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.EnablePressEnterWhenDonePrompt">
            <summary>
By default, when CRhinoGetObject::GetObjects is called with minimum_number &gt; 0
and maximum_number = 0, the command prompt automatically includes
"Press Enter when done" after the user has selected at least minimum_number
of objects. If you want to prohibit the addition of the "Press Enter when done",
then call EnablePressEnterWhenDonePrompt(false).
</summary>
            <returns>Previous value.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.EnablePressEnterWhenDonePrompt(System.Boolean)">
            <summary>
By default, when CRhinoGetObject::GetObjects is called with minimum_number &gt; 0
and maximum_number = 0, the command prompt automatically includes
"Press Enter when done" after the user has selected at least minimum_number
of objects. If you want to prohibit the addition of the "Press Enter when done",
then call EnablePressEnterWhenDonePrompt(false).
</summary>
            <returns>Previous value.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.EnableIgnoreGrips">
            <summary>
By default, post selection will select objects with grips on.
If you do not want to be able to post select objects with grips on,
then call EnableIgnoreGrips(false). The ability to preselect an
object with grips on is determined by the value returned by the
virtual CRhinoObject::IsSelectableWithGripsOn.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.EnableIgnoreGrips(System.Boolean)">
            <summary>
By default, post selection will select objects with grips on.
If you do not want to be able to post select objects with grips on,
then call EnableIgnoreGrips(false). The ability to preselect an
object with grips on is determined by the value returned by the
virtual CRhinoObject::IsSelectableWithGripsOn.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.EnableReferenceObjectSelect">
            <summary>
By default, reference objects can be selected.
If you do not want to be able to select reference
objects, then call EnableReferenceObjectSelect(false).
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.EnableReferenceObjectSelect(System.Boolean)">
            <summary>
By default, reference objects can be selected.
If you do not want to be able to select reference
objects, then call EnableReferenceObjectSelect(false).
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.EnableHighlight">
            <summary>
By default, any object post-pick selected by GetObject() 
is highlighted.  If you want to post-pick objects and
not have them automatically highlight, then call
EnableHighlight(false).
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.EnableHighlight(System.Boolean)">
            <summary>
By default, any object post-pick selected by GetObject() 
is highlighted.  If you want to post-pick objects and
not have them automatically highlight, then call
EnableHighlight(false).
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.EnableSelPrev">
            <summary>
By default, any object selected during a command becomes
part of the "previous selection set" and can be reselected
by the SelPrev command.  If you need to select objects
but do not want them to be selected by a subsquent call
to SelPrev, then call EnableSelPrev(false).
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.EnableSelPrev(System.Boolean)">
            <summary>
By default, any object selected during a command becomes
part of the "previous selection set" and can be reselected
by the SelPrev command.  If you need to select objects
but do not want them to be selected by a subsquent call
to SelPrev, then call EnableSelPrev(false).
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.EnableGroupSelect">
            <summary>
By default, groups are ignored in GetObject. If you want your call to
GetObjects() to select every object in a group that has any objects
selected, then enable group selection.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.EnableGroupSelect(System.Boolean)">
            <summary>
By default, groups are ignored in GetObject. If you want your call to
GetObjects() to select every object in a group that has any objects
selected, then enable group selection.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.EnableBottomObjectPreference(System.Boolean)">
            <summary>
By default, if a call to GetObject is permitted to select different parts of the
same object, like a polysurface, a surface and an edge, then the top-most object is
prefered. (polysurface beats face beats edge). If you want the bottom most object
to be prefered, then call EnableBottomObjectPreference(true) before calling GetObjects().
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.EnableChooseOneQuestion">
            <summary>
By default, if a call to GetObject is permitted to select different parts for
the same object, like a polysurface and an edge of that polysurface, then the
top-most object is automatically selected. If you want the choose-one-object
mechanism to include pop up in these cases, then call EnableChooseOneQuestion(true)
before calling GetObjects().
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.EnableChooseOneQuestion(System.Boolean)">
            <summary>
By default, if a call to GetObject is permitted to select different parts for
the same object, like a polysurface and an edge of that polysurface, then the
top-most object is automatically selected. If you want the choose-one-object
mechanism to include pop up in these cases, then call EnableChooseOneQuestion(true)
before calling GetObjects().
</summary>
            <param name="bEnableChooseOneQuestion">
By default, if a call to GetObject is permitted to select different parts of the
same object, like a polysurface and an edge of that polysurface, then the
top/bottom-most object is automatically selected.  If you want the choose-one-object
mechanism to include pop up in these cases, then call EnableChooseOneQuestion(true)
before calling GetObjects().
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.SubObjectSelect">
            <summary>
By default, CRhinoGetObject::GetObjects will permit a user to select sub-objects
(like a curve in a b-rep or a curve in a group). If you only want the user to
select "top" level objects, then call EnableSubObjectSelect(false).
</summary>
            <returns>true if selection of sub-objects is permitted.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.EnableSubObjectSelect">
            <summary>
By default, CRhinoGetObject::GetObjects will permit a user to select sub-objects
(like a curve in a b-rep or a curve in a group). If you only want the user to
select "top" level objects, then call EnableSubObjectSelect(false).
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.EnableSubObjectSelect(System.Boolean)">
            <summary>
By default, CRhinoGetObject::GetObjects will permit a user to select sub-objects
(like a curve in a b-rep or a curve in a group). If you only want the user to
select "top" level objects, then call EnableSubObjectSelect(false).
</summary>
            <param name="bEnableSubObjectSelect">
[in] true to enable sub-object selection false to disable sub-object selection.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.OneByOnePostSelect">
            <summary>
In one-by-one post selection, the user is forced to select objects by post picking them one at a time.
</summary>
            <returns>true if one-by-one post selection mode is enabled.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.EnableOneByOnePostSelect">
            <summary>
If you want to force objects to be post selected one by one, then enable
one-by-one post selection by calling EnableOneByOnePostSelect(true).
</summary>
            <remarks>
By default, CRhinoGetObject::GetObjects() permits multiple objects to be
selected using any combination of single pick selection and window crossing selection.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.EnableOneByOnePostSelect(System.Boolean)">
            <summary>
If you want to force objects to be post selected one by one, then enable
one-by-one post selection by calling EnableOneByOnePostSelect(true).
</summary>
            <param name="bEnableOneByOnePostSelect">
[in] if true, GetObjects() one-by-one post selection mode will be used.
If false, the selection mode specified by EnablePostSelect()/EnablePostSelect()
will be used.
</param>
            <remarks>
By default, CRhinoGetObject::GetObjects() permits multiple objects to be
selected using any combination of single pick selection and window crossing selection.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.DeselectAllBeforePostSelect">
            <summary>
True if pre-selected input will be deselected before post-selection begins
when no pre-selected input is valid.
</summary>
            <remarks>The default is true.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.EnableDeselectAllBeforePostSelect">
            <summary>Controls the deselection of preselected input when no valid input is pre-selected.</summary>
            <remarks>
By default, if post selection is enabled and no valid input is pre-selected
when GetObjects is called, then anything that was preselected is deselected
before post selection begins. If there are objects selected and highlighted
from a previous operation that you want to have stay that way when GetObject()
is called, Call EnableDeselectAllBeforePostSelect( false) to make that happen.
Otherwise the second GetObject will deselect and unhighlight the already seelcted
and highlighted objects.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.EnableDeselectAllBeforePostSelect(System.Boolean)">
            <summary>Controls the deselection of preselected input when no valid input is pre-selected.</summary>
            <remarks>
By default, if post selection is enabled and no valid input is pre-selected
when GetObjects is called, then anything that was preselected is deselected
before post selection begins. If there are objects selected and highlighted
from a previous operation that you want to have stay that way when GetObject()
is called, Call EnableDeselectAllBeforePostSelect( false) to make that happen.
Otherwise the second GetObject will deselect and unhighlight the already seelcted
and highlighted objects.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.EnablePostSelect">
            <summary>Control the availability of post selection in GetObjects.</summary>
            <remarks>
By default, if no valid input is pre-selected when GetObjects is called,
then the user is given the chance to post select. If you want to force
the user to pre-select, then call EnablePostSelect(false).
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.EnablePostSelect(System.Boolean)">
            <summary>Control the availability of post selection in GetObjects.</summary>
            <remarks>
By default, if no valid input is pre-selected when GetObjects is called,
then the user is given the chance to post select. If you want to force
the user to pre-select, then call EnablePostSelect(false).
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.EnablePreSelect">
            <summary>Control the pre selection behavior GetObjects.</summary>
            <remarks>
By default, if valid input is pre-selected when GetObjects() is called, then
that input is returned and the user is not given the opportunity to post-select.
If you want to force the user to post-select, then call EnablePreSelect(false).
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.EnablePreSelect(System.Boolean)">
            <summary>Control the pre selection behavior GetObjects.</summary>
            <param name="bEnablePreSelect">[in] if true, pre-selection is enabled.</param>
            <remarks>
By default, if valid input is pre-selected when GetObjects() is called, then
that input is returned and the user is not given the opportunity to post-select.
If you want to force the user to post-select, then call EnablePreSelect(false).
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.EnablePreSelect(System.Boolean,System.Boolean)">
            <summary>Control the pre selection behavior GetObjects.</summary>
            <param name="bEnablePreSelect">[in] if true, pre-selection is enabled.</param>
            <param name="bIgnoreUnacceptablePreSelectedObjects">
[in] If true and some acceptable objects are pre-selected, then any
unacceptable pre-selected objects are ignored. If false and any unacceptable
are pre-selected, then the user is forced to post-select.
</param>
            <remarks>
By default, if valid input is pre-selected when GetObjects() is called, then
that input is returned and the user is not given the opportunity to post-select.
If you want to force the user to post-select, then call EnablePreSelect(false).
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.PassesGeometryAttributeFilter(RMA.Rhino.IRhinoObject,RMA.OpenNURBS.IOnGeometry,RMA.OpenNURBS.OnCOMPONENT_INDEX)">
            <summary>Checks geometry to see if it passes the basic GeometryAttributeFilter.</summary>
            <param name="object">[in] parent object being considered.</param>
            <param name="geometry">[in] geometry being considered.</param>
            <param name="component_index">
[in] if &gt;= 0, geometry is a proper sub-part of object-&gt;Geometry() with component_index.
</param>
            <remarks>
The default simply checks that the geometry passes the filter returned by GeometryAttributeFilter().
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.CustomGeometryFilter(RMA.Rhino.IRhinoObject,RMA.OpenNURBS.IOnGeometry,RMA.OpenNURBS.OnCOMPONENT_INDEX)">
            <summary>
Checks geometry to see if it can be selected. The default always returns true.
Override to provide fancy filtering.
</summary>
            <param name="rh_object">[in] parent object being considered.</param>
            <param name="geometry">[in] geometry being considered.</param>
            <param name="component_index">
[in] if &gt;= 0, geometry is a proper sub-part of object-&gt;Geometry() with component_index.
</param>
            <remarks>
The default simply returns true.  All obvious geometry filter checks have
been performed by the time CustomGeometryFilter() is called.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.GeometryAttributeFilter">
            <summary>
The geometry attribute filter provides a secondary filter can be used to restrict
which objects can be selected. Control of the type of geometry (points, curves,
surfaces, meshes, etc.) is provided by CRhinoGetObject::SetGeometryFilter. The
geometry attribute filter is used to require the selected geometry to have certain
attributes (open, closed, etc.). The default attribute filter permits selection of
all types of geometry.
</summary>
            <returns>An unsigned int "object_attribute_filter". If the bit from an
GEOMETRY_ATTRIBUTE_FILTER enum value is set in the geometry_attribute_filter, then
GetObjects() will permit selection of object's that have that geometric attribute.
If geometry_attribute_filter is 0xFFFFFFFF, then GetObjects() can select all types
of geometry.
</returns>
            <example>
If (GeometryAttributeFilter() | closed_curve) != 0,
then any curve selected by GetObjects() will be closed.
</example>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.SetGeometryAttributeFilter(&lt;unknown type&gt;[])">
            <summary>
The geometry attribute filter provides a secondary filter can be used to restrict
which objects can be selected. Control of the type of geometry (points, curves,
surfaces, meshes, etc.) is provided by CRhinoGetObject::SetGeometryFilter. The
geometry attribute filter is used to require the selected geometry to have certain
attributes (open, closed, etc.). The default attribute filter permits selection
of all types of geometry.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.SetGeometryAttributeFilter(&lt;unknown type&gt;)">
            <summary>
The geometry attribute filter provides a secondary filter can be used to restrict
which objects can be selected. Control of the type of geometry (points, curves,
surfaces, meshes, etc.) is provided by CRhinoGetObject::SetGeometryFilter. The
geometry attribute filter is used to require the selected geometry to have certain
attributes (open, closed, etc.). The default attribute filter permits selection
of all types of geometry.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.SetGeometryAttributeFilter(System.UInt32)">
            <summary>
The geometry attribute filter provides a secondary filter can be used to restrict
which objects can be selected. Control of the type of geometry (points, curves,
surfaces, meshes, etc.) is provided by CRhinoGetObject::SetGeometryFilter. The
geometry attribute filter is used to require the selected geometry to have certain
attributes (open, closed, etc.). The default attribute filter permits selection
of all types of geometry.
</summary>
            <param name="geometry_attribute_filter">
[in] an unsigned int made by bitwise or-ing ( | ) values from the GEOMETRY_ATTRIBUTE_FILTER enum.
If you pass 0, then all geometry attributes will be acceptable.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.GeometryFilter">
            <summary>
The geometry type filter controls which types of geometry (points, curves, surfaces, meshes, etc.)
can be selected. The default geometry type filter permits selection of all types of geometry.
</summary>
            <returns>An unsigned int "object_filter". If the bit from an GEOMETRY_TYPE_FILTER
enum value is set in the geometry_filter, then GetObjects() will permit selection of
object's that have that type of geometry. If geometry_filter is 0xFFFFFFFF, then
GetObjects() can select all types of geometry.
</returns>
            <example>
If (GeometryFilter() | curve_object) != 0, then GetObjects()
will permit curves to be selected.
</example>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.SetGeometryFilter(&lt;unknown type&gt;[])">
            <summary>
The geometry type filter controls which types of geometry (points, curves, surfaces, meshes, etc.)
can be selected. The default geometry type filter permits selection of all types of geometry.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.SetGeometryFilter(&lt;unknown type&gt;)">
            <summary>
The geometry type filter controls which types of geometry (points, curves, surfaces, meshes, etc.)
can be selected. The default geometry type filter permits selection of all types of geometry.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetObject.SetGeometryFilter(System.UInt32)">
            <summary>
The geometry type filter controls which types of geometry (points, curves, surfaces, meshes, etc.)
can be selected. The default geometry type filter permits selection of all types of geometry.
</summary>
            <param name="geometry_type_filter">
[in] an unsigned int made by or-ing ( | ) values from the GEOMETRY_TYPE_FILTER enum.
If you pass 0, then all geometry will be acceptable.
</param>
            <example>
If you want to be able to select curves and meshes, then you would make a call like
unsigned int geometry_type_filter = 0;
geometry_filter |= CRhinoGetObject::curve_object;
geometry_filter |= CRhinoGetObject::mesh_object;
SetGeometryFilter( geometry_type_filter );
</example>
        </member>
        <member name="T:RMA.Rhino.MRhinoGetObject">
            <summary>
The CRhinoGetObject class is the tool commands use to interactively select objects.
</summary>
            <remarks>
The behavior of CRhinoGetObject::GetObject() can be highly customized
to accept many kinds of alternative input, to restrict what kinds of
object may be selected, to control how many object may be selected,
etc.  See the detailed comments in the declarations of CRhinoGet
and CRhinoGetObject for more information.
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoGetObject.SerialNumber">
            <summary>
Each instanct of CRhinoGetObject has a unique runtime serial number that is
used to identify object selection events associated with that instance.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGetObject.ObjectsWerePreSelected">
            <summary>
Returns: True if CRhinoGetObjects::GetObjects() retuned preselected objects.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGetObject.Object(System.Int32)">
            <param name="index">0 based index</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoGetObject.ObjectCount">
            <returns>number of objects selected</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoGetObject.SubObjectSelect">
            <summary>
By default, CRhinoGetObject::GetObjects will permit a user to select sub-objects
(like a curve in a b-rep or a curve in a group). If you only want the user to
select "top" level objects, then call EnableSubObjectSelect(false).
</summary>
            <returns>true if selection of sub-objects is permitted.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoGetObject.OneByOnePostSelect">
            <summary>
In one-by-one post selection, the user is forced to select objects by post picking them one at a time.
</summary>
            <returns>true if one-by-one post selection mode is enabled.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoGetObject.DeselectAllBeforePostSelect">
            <summary>
True if pre-selected input will be deselected before post-selection begins
when no pre-selected input is valid.
</summary>
            <remarks>The default is true.</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoGetObject.PassesGeometryAttributeFilter(RMA.Rhino.IRhinoObject,RMA.OpenNURBS.IOnGeometry,RMA.OpenNURBS.OnCOMPONENT_INDEX)">
            <summary>Checks geometry to see if it passes the basic GeometryAttributeFilter.</summary>
            <param name="object">[in] parent object being considered.</param>
            <param name="geometry">[in] geometry being considered.</param>
            <param name="component_index">
[in] if &gt;= 0, geometry is a proper sub-part of object-&gt;Geometry() with component_index.
</param>
            <remarks>
The default simply checks that the geometry passes the filter returned by GeometryAttributeFilter().
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoGetObject.GeometryAttributeFilter">
            <summary>
The geometry attribute filter provides a secondary filter can be used to restrict
which objects can be selected. Control of the type of geometry (points, curves,
surfaces, meshes, etc.) is provided by CRhinoGetObject::SetGeometryFilter. The
geometry attribute filter is used to require the selected geometry to have certain
attributes (open, closed, etc.). The default attribute filter permits selection of
all types of geometry.
</summary>
            <returns>An unsigned int "object_attribute_filter". If the bit from an
GEOMETRY_ATTRIBUTE_FILTER enum value is set in the geometry_attribute_filter, then
GetObjects() will permit selection of object's that have that geometric attribute.
If geometry_attribute_filter is 0xFFFFFFFF, then GetObjects() can select all types
of geometry.
</returns>
            <example>
If (GeometryAttributeFilter() | closed_curve) != 0,
then any curve selected by GetObjects() will be closed.
</example>
        </member>
        <member name="M:RMA.Rhino.IRhinoGetObject.GeometryFilter">
            <summary>
The geometry type filter controls which types of geometry (points, curves, surfaces, meshes, etc.)
can be selected. The default geometry type filter permits selection of all types of geometry.
</summary>
            <returns>An unsigned int "object_filter". If the bit from an GEOMETRY_TYPE_FILTER
enum value is set in the geometry_filter, then GetObjects() will permit selection of
object's that have that type of geometry. If geometry_filter is 0xFFFFFFFF, then
GetObjects() can select all types of geometry.
</returns>
            <example>
If (GeometryFilter() | curve_object) != 0, then GetObjects()
will permit curves to be selected.
</example>
        </member>
        <member name="T:RMA.Rhino.IRhinoGetObject.GEOMETRY_ATTRIBUTE_FILTER">
            <summary>
If an object passes the geometry TYPE filter,then the
geometry ATTRIBUTE filter is applied.
The geometry attributes filter is set
by calling CRhinoGetObject::SetGeometryFilter.
</summary>
        </member>
        <member name="T:RMA.Rhino.IRhinoGetObject.GEOMETRY_TYPE_FILTER">
            <summary>
The GEOMETRY_TYPE_FILTER enum values are bitwise or-ed
together to create a filter used to specify acceptable
geometry types.  The geometry type filter is set
by calling CRhinoGetObject::SetGeometryFilter.
values &lt;= 0x0000FFFF are the same as the ON::object_type
enum value
</summary>
        </member>
        <member name="T:RMA.Rhino.IRhinoGetObject">
            <summary>
The CRhinoGetObject class is the tool commands use to interactively select objects.
</summary>
            <remarks>
The behavior of CRhinoGetObject::GetObject() can be highly customized
to accept many kinds of alternative input, to restrict what kinds of
object may be selected, to control how many object may be selected,
etc.  See the detailed comments in the declarations of CRhinoGet
and CRhinoGetObject for more information.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetInteger.#ctor(RMA.Rhino.IRhinoGet)">
            <summary>
prompt and options inherited
</summary>
        </member>
        <member name="T:RMA.Rhino.MRhinoGetInteger">
            <summary>CRhinoGetInteger is used to get integer numbers</summary>
        </member>
        <member name="T:RMA.Rhino.IRhinoGetInteger">
            <summary>CRhinoGetInteger is used to get integer numbers</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetNumber.SetUpperLimit(System.Double)">
            <summary>
Set a upper limit on the number that can be returned. By default there is no upper limit.
</summary>
            <param name="upper_limit">
[in] largest acceptable number. Pass ON_UNSET_VALUE if you want to disable
a previously set upper_limit.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetNumber.SetUpperLimit(System.Double,System.Boolean)">
            <summary>
Set a upper limit on the number that can be returned. By default there is no upper limit.
</summary>
            <param name="upper_limit">
[in] largest acceptable number. Pass ON_UNSET_VALUE if you want to disable
a previously set upper_limit.
</param>
            <param name="bStrictlyLessThan">
[in] (default=FALSE) If TRUE, then the returned number will be &lt; upper_limit.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetNumber.SetLowerLimit(System.Double)">
            <summary>
Set a lower limit on the number that can be returned. By default there is no lower limit.
</summary>
            <param name="lower_limit">
[in] smallest acceptable number. Pass ON_UNSET_VALUE if you want to disable
a previously set lower_limit.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetNumber.SetLowerLimit(System.Double,System.Boolean)">
            <summary>
Set a lower limit on the number that can be returned. By default there is no lower limit.
</summary>
            <param name="lower_limit">
[in] smallest acceptable number. Pass ON_UNSET_VALUE if you want to disable
a previously set lower_limit.
</param>
            <param name="bStrictlyGreaterThan">
[in] (default=FALSE) If TRUE, then the returned number will be &gt; lower_limit.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetNumber.#ctor(RMA.Rhino.IRhinoGet)">
            <summary>
prompt and options inherited
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetOption.GetOption">
            <summary>
A return value of CRhinoGet::option means the user selected a
valid option.  Use CRhinoGet::Option() to determine which option
was selected.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetOption.#ctor(RMA.Rhino.IRhinoGet)">
            <summary>
prompt and options inherited
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetString.GetString">
            <summary>Call GetString() to get a string.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetString.#ctor(RMA.Rhino.IRhinoGet)">
            <summary>
prompt and options inherited
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.ArgsType">
            <summary>
return type of args class circle, cone, cylinder, sphere
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.AroundDirectionCount">
            <summary>
number of faces in the around direction
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.AroundMeshDensityDirectionPrompt">
            <summary>
prompt for number of faces in the around direction
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.VerticalDirectionCount">
            <summary>
number of faces in the vertical direction
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.VerticalMeshDensityDirectionPrompt">
            <summary>
prompt for number of faces in the vertical direction
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.SetPromptForMeshDensity">
            <summary>
Interface to allow primitive mesh creation to use 
RhinoGetPlane, RhinoGetBox, RhinoGetCircle etc.
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.SetPromptForMeshDensity(System.Boolean)">
            <summary>
Interface to allow primitive mesh creation to use 
RhinoGetPlane, RhinoGetBox, RhinoGetCircle etc.
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.SetPointCount(System.Int32)">
            <summary>Set number of CVs in nurbs curve used for deformable circle</summary>
            <param name="count">[in] CV count</param>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.SetDegree(System.Int32)">
            <summary>Set degree of nurbs curve used for deformable circle</summary>
            <param name="degree">[in] curve degree</param>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.SetDeformable">
            <summary>Set deformable flag</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.SetDeformable(System.Boolean)">
            <summary>Set deformable flag</summary>
            <param name="bDeformable">[in] whether or not circle is to be mad deformable</param>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.SetAllowDeformable">
            <summary>Set state of allowing deformable options to be processed.</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.SetAllowDeformable(System.Boolean)">
            <summary>Set state of allowing deformable options to be processed.</summary>
            <param name="b">[in] whether or not to display a Deformable prompt</param>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.SetCircleType(RMA.Rhino.IArgsRhinoGetCircle.eCircleResult)">
            <summary>Set mode of circle creation.</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.EnableDynamicDrawSphere">
            <summary>Set DynamicDrawSphere state.</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.EnableDynamicDrawSphere(System.Boolean)">
            <summary>Set DynamicDrawSphere state.</summary>
            <param name="bDrawSphere">[in] TRUE to draw a sphere instead of a circle</param>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.DynamicDrawSphere">
            <summary>
If TRUE, then during the interactive part of RhinoGetCircle, a sphere is drawn.
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.EnableConeCylOption">
            <summary>
If the vertical cone/cyl option is available, then the "Vertical"
option applies to a cone/cyl base circle and appears at the initial point pick.
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.EnableConeCylOption(System.Boolean)">
            <summary>
If the vertical cone/cyl option is available, then the "Vertical"
option applies to a cone/cyl base circle and appears at the initial point pick.
</summary>
            <param name="bAvailable">
[in] TRUE to make the "Vertical" option available on the
first pick and have it apply as a cone/cyl option.
</param>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.SetConeCylConstraint">
            <summary>Set the state of the vertical cone/cyl option.</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.SetConeCylConstraint(System.Int32)">
            <summary>Set the state of the vertical cone/cyl option.</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.ConeCylConstraint">
            <summary>
Returns the state of the cone/cyl constraint option.
When the cone/cyl option is selected, the circle is
being made as a base for a cone/cyl. By default the
vertical cone/cyl option not available but is not
selected. By default the "Vertical" option
applies to VerticalCircle.
</summary>
            <returns>0 for None, 1 for Vertical and 2 for AroundCurve</returns>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.EnableVerticalCircleOption">
            <summary>
If the vertical circle option is available, then the "Vertical"
option applies to circles and appears at the initial point pick.
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.EnableVerticalCircleOption(System.Boolean)">
            <summary>
If the vertical circle option is available, then the "Vertical"
option applies to circles and appears at the initial point pick.
</summary>
            <param name="bAvailable">
[in] TRUE to make the "Vertical" option available on
the first pick and have it apply as a vertical circle option.
</param>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.SetVerticalCircle">
            <summary>Set the state of the vertical circle option.</summary>
            <remarks>
Use EnableVerticalCircleOption to control if the "Vertical"
applies to circles and appears at the initial point pick.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.SetVerticalCircle(System.Boolean)">
            <summary>Set the state of the vertical circle option.</summary>
            <param name="bSelected">[in] TRUE to select this option.</param>
            <remarks>
Use EnableVerticalCircleOption to control if the "Vertical"
applies to circles and appears at the initial point pick.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.VerticalCircle">
            <summary>
Returns the state of the vertical circle option.
When the vertical circle option is selected, the circle is made
vertical to the current cplane with the axis in the cplane. By
default the vertical circle option is available but is not selected.
</summary>
            <returns>TRUE if the vertical circle option is selected.</returns>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.SetUseDiameterMode">
            <summary>
Use Diameter mode (instead of radius mode) for getting the size
Also qualifies the meaning of m_size
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.SetUseDiameterMode(System.Boolean)">
            <summary>
Use Diameter mode (instead of radius mode) for getting the size
Also qualifies the meaning of m_size
</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.SetUsePlane">
            <summary>Constrain the circle to a plane - Center/radius, 2point, 3point only</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.SetUsePlane(System.Boolean)">
            <summary>Constrain the circle to a plane - Center/radius, 2point, 3point only</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.SetUsePoint1">
            <summary>Use the second point and don't ask for one</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.SetUsePoint1(System.Boolean)">
            <summary>Use the second point and don't ask for one</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.SetUsePoint0">
            <summary>Use the first point and don't ask for one</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.SetUsePoint0(System.Boolean)">
            <summary>Use the first point and don't ask for one</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.SetUseDefaultSize">
            <summary>Use the default size when getting diameter/radius</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.SetUseDefaultSize(System.Boolean)">
            <summary>Use the default size when getting diameter/radius</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.SetDefaultSize(System.Double)">
            <summary>Set the default size to use - diameter or radius depending on m_bUseDiameter</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.SetPlane(RMA.OpenNURBS.IOnPlane)">
            <summary>Set a plane</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.SetPoint2(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Set the third point to use instead of asking for one</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.SetPoint1(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Set the second point to use instead of asking for one</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.SetPoint0(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Set the first point to use instead of asking for one</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.SetDiameterPrompt(System.String)">
            <summary>Set a custom prompt to use for getting the diameter</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.SetRadiusPrompt(System.String)">
            <summary>Set a custom prompt to use for getting the radius</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.SetPrompt2(System.String)">
            <summary>Set a custom prompt to use for getting third point</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.SetPrompt1(System.String)">
            <summary>Set a custom prompt to use for getting the second point</summary>
        </member>
        <member name="M:RMA.Rhino.MArgsRhinoGetCircle.SetPrompt0(System.String)">
            <summary>Set a custom prompt to use for getting the first (center) point</summary>
        </member>
        <member name="T:RMA.Rhino.MArgsRhinoGetCircle">
            <summary>Input to the RhinoGetCircle()</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetCircle.ArgsType">
            <summary>
return type of args class circle, cone, cylinder, sphere
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetCircle.AroundDirectionCount">
            <summary>
number of faces in the around direction
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetCircle.AroundMeshDensityDirectionPrompt">
            <summary>
prompt for number of faces in the around direction
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetCircle.VerticalDirectionCount">
            <summary>
number of faces in the vertical direction
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetCircle.VerticalMeshDensityDirectionPrompt">
            <summary>
prompt for number of faces in the vertical direction
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetCircle.DynamicDrawSphere">
            <summary>
If TRUE, then during the interactive part of RhinoGetCircle, a sphere is drawn.
</summary>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetCircle.ConeCylConstraint">
            <summary>
Returns the state of the cone/cyl constraint option.
When the cone/cyl option is selected, the circle is
being made as a base for a cone/cyl. By default the
vertical cone/cyl option not available but is not
selected. By default the "Vertical" option
applies to VerticalCircle.
</summary>
            <returns>0 for None, 1 for Vertical and 2 for AroundCurve</returns>
        </member>
        <member name="M:RMA.Rhino.IArgsRhinoGetCircle.VerticalCircle">
            <summary>
Returns the state of the vertical circle option.
When the vertical circle option is selected, the circle is made
vertical to the current cplane with the axis in the cplane. By
default the vertical circle option is available but is not selected.
</summary>
            <returns>TRUE if the vertical circle option is selected.</returns>
        </member>
        <member name="T:RMA.Rhino.IArgsRhinoGetCircle.eCircleResult">
            <summary>Results of main Circle Command function</summary>
        </member>
        <member name="T:RMA.Rhino.IArgsRhinoGetCircle">
            <summary>Input to the RhinoGetCircle()</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.GetPointOnMouseUp">
            <summary>
true if getting point on mouse up event
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.EnableNoRedrawOnExit">
            <summary>
This setting turns off automatic redraw at the end of GetPoint. May be
needed in some commands for flicker free feedback. When true the caller
is responsible for cleaning up the screen after GetPoint. The default is false.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.EnableNoRedrawOnExit(System.Boolean)">
            <summary>
This setting turns off automatic redraw at the end of GetPoint. May be
needed in some commands for flicker free feedback. When true the caller
is responsible for cleaning up the screen after GetPoint. The default is false.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.MouseMoved">
            <summary>
Returns: True if mouse moved during the call to GetPoint();
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.PointOnBrep(System.Double@,System.Double@)">
            <summary>Use to determine if point was on a brep (face).</summary>
            <param name="u">[out]</param>
            <param name="v">
[out] if the point was on a face, then the (*u,*v) are the face parameters for the point.
</param>
            <returns>pointer to a brep or NULL if the point was not on a brep.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.PointOnSurface(System.Double@,System.Double@)">
            <summary>Use to determine if point was on a surface.</summary>
            <param name="u">[out]</param>
            <param name="v">
[out] if the point was on a surface, then the (*u,*v) are the surface parameters
for the point. The point returned by Point() is the same as surface-&gt;PointAt(*u,*v).
</param>
            <returns>pointer to a surface or NULL if the point was not on a surface.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.PointOnEdge(System.Double@,RMA.OpenNURBS.IOnBrepTrim@)">
            <summary>Use to determine if point was on an edge curve of a brep.</summary>
            <param name="edge_parameter">[out] edge parameter of pick point</param>
            <param name="pTrim">[out] the associated trim</param>
            <remarks>
An edge can be a boundary or interior edge. Boundary edges have a
single trim.  Interior edges have multiple trims. If you need
information about the surface, then examine the trim.

If you do not need trim or surface information, then use CRhinoGetPoint::PointOnCurve.
</remarks>
            <returns>NULL or edge the point was on.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.PointOnCurve(System.Double@)">
            <summary>Use to determine if point was on a curve.</summary>
            <param name="t">
[out] if the point was on a curve, then the *t is the curve parameter
for the point. The point returned by CRhinoGetPoint::Point() is the
same as curve-&gt;PointAt(*t).
</param>
            <returns>pointer to a curve or NULL if the point was not on a curve.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.PointOnObject(RMA.Rhino.MRhinoObjRef@)">
            <summary>
Call this function to see if the point was on an object.  If
PointOnObject() returns true, then the object is returned
in the CRhinoObjRef parameter.  Use CRhinoObjRef::CurveParameter() or
CRhinoObjRef::SurfaceParameter() to get the parameter values for
the point.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.Point">
            <summary>
returns 3d point in world coordinates
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.Get2dLine">
            <summary>
After setting up options and so on, call CRhinoGetPoint::Get2dLine to get a 2d line in a view window.
</summary>
            <returns>
The type of input that was specified.  If CRhinoGet::rect2d is
returned, then use CRhinoGetPoint::Rectangle2d to get the value
of the 2d point and CRhinoGetPoint::View() to get the view
that contains the 2d point.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.Get2dLine(RMA.Rhino.MRhinoView)">
            <summary>
After setting up options and so on, call CRhinoGetPoint::Get2dLine to get a 2d line in a view window.
</summary>
            <param name="pView">
[in] if pView is not NULL, then the 2d line will be in this view.
Otherwise, the 2d line can be in any view.
</param>
            <returns>
The type of input that was specified.  If CRhinoGet::rect2d is
returned, then use CRhinoGetPoint::Rectangle2d to get the value
of the 2d point and CRhinoGetPoint::View() to get the view
that contains the 2d point.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.Get2dLine(RMA.Rhino.MRhinoView,System.ValueType!System.Drawing.Point!System.Runtime.CompilerServices.IsBoxed)">
            <summary>
After setting up options and so on, call CRhinoGetPoint::Get2dLine to get a 2d line in a view window.
</summary>
            <param name="pView">
[in] if pView is not NULL, then the 2d line will be in this view.
Otherwise, the 2d line can be in any view.
</param>
            <param name="corner">
[in] if pView is not NULL and corner is not NULL, then corner will be the location of the start point
</param>
            <returns>
The type of input that was specified.  If CRhinoGet::rect2d is
returned, then use CRhinoGetPoint::Rectangle2d to get the value
of the 2d point and CRhinoGetPoint::View() to get the view
that contains the 2d point.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.Get2dLine(RMA.Rhino.MRhinoView,System.ValueType!System.Drawing.Point!System.Runtime.CompilerServices.IsBoxed,System.Boolean)">
            <summary>
After setting up options and so on, call CRhinoGetPoint::Get2dLine to get a 2d line in a view window.
</summary>
            <param name="pView">
[in] if pView is not NULL, then the 2d line will be in this view.
Otherwise, the 2d line can be in any view.
</param>
            <param name="corner">
[in] if pView is not NULL and corner is not NULL, then corner will be the location of the start point
</param>
            <param name="bCentered">[in] if true, the first point will be the center of the line.</param>
            <returns>
The type of input that was specified.  If CRhinoGet::rect2d is
returned, then use CRhinoGetPoint::Rectangle2d to get the value
of the 2d point and CRhinoGetPoint::View() to get the view
that contains the 2d point.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.Get2dLine(RMA.Rhino.MRhinoView,System.ValueType!System.Drawing.Point!System.Runtime.CompilerServices.IsBoxed,System.Boolean,System.Int32)">
            <summary>
After setting up options and so on, call CRhinoGetPoint::Get2dLine to get a 2d line in a view window.
</summary>
            <param name="pView">
[in] if pView is not NULL, then the 2d line will be in this view.
Otherwise, the 2d line can be in any view.
</param>
            <param name="corner">
[in] if pView is not NULL and corner is not NULL, then corner will be the location of the start point
</param>
            <param name="bCentered">[in] if true, the first point will be the center of the line.</param>
            <param name="pen_style">
[in] pen style used to draw dynamic line. If PS_NULL, then no dynamic line is drawn
PS_SOLID            0
PS_DASH             1
PS_DOT              2
PS_DASHDOT          3
PS_DASHDOTDOT       4
PS_NULL             5
</param>
            <returns>
The type of input that was specified.  If CRhinoGet::rect2d is
returned, then use CRhinoGetPoint::Rectangle2d to get the value
of the 2d point and CRhinoGetPoint::View() to get the view
that contains the 2d point.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.Get2dLine(RMA.Rhino.MRhinoView,System.ValueType!System.Drawing.Point!System.Runtime.CompilerServices.IsBoxed,System.Boolean,System.Int32,System.Boolean)">
            <summary>
After setting up options and so on, call CRhinoGetPoint::Get2dLine to get a 2d line in a view window.
</summary>
            <param name="pView">
[in] if pView is not NULL, then the 2d line will be in this view.
Otherwise, the 2d line can be in any view.
</param>
            <param name="corner">
[in] if pView is not NULL and corner is not NULL, then corner will be the location of the start point
</param>
            <param name="bCentered">[in] if true, the first point will be the center of the line.</param>
            <param name="pen_style">
[in] pen style used to draw dynamic line. If PS_NULL, then no dynamic line is drawn
PS_SOLID            0
PS_DASH             1
PS_DOT              2
PS_DASHDOT          3
PS_DASHDOTDOT       4
PS_NULL             5
</param>
            <param name="bClampToView">
[in] if true, then the endpoints are constrained to be in the view.
If false, then the endpoints can be outside of the view.
</param>
            <returns>
The type of input that was specified.  If CRhinoGet::rect2d is
returned, then use CRhinoGetPoint::Rectangle2d to get the value
of the 2d point and CRhinoGetPoint::View() to get the view
that contains the 2d point.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.Get2dRectangle">
            <summary>
After setting up options and so on, call CRhinoGetPoint::Get2dRectangle
to get a 2d rectanble in a view window.
</summary>
            <returns>
The type of input that was specified.  If CRhinoGet::rect2d is
returned, then use CRhinoGetPoint::Rectangle2d to get the value
of the 2d point and CRhinoGetPoint::View() to get the view
that contains the 2d point.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.Get2dRectangle(RMA.Rhino.MRhinoView)">
            <summary>
After setting up options and so on, call CRhinoGetPoint::Get2dRectangle
to get a 2d rectanble in a view window.
</summary>
            <param name="pView">
[in] if pView is not NULL, then the 2d rectangle will be in this view.
Otherwise, the 2d rectangle can be in any view.
</param>
            <returns>
The type of input that was specified.  If CRhinoGet::rect2d is
returned, then use CRhinoGetPoint::Rectangle2d to get the value
of the 2d point and CRhinoGetPoint::View() to get the view
that contains the 2d point.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.Get2dRectangle(RMA.Rhino.MRhinoView,System.ValueType!System.Drawing.Point!System.Runtime.CompilerServices.IsBoxed)">
            <summary>
After setting up options and so on, call CRhinoGetPoint::Get2dRectangle
to get a 2d rectanble in a view window.
</summary>
            <param name="pView">
[in] if pView is not NULL, then the 2d rectangle will be in this view.
Otherwise, the 2d rectangle can be in any view.
</param>
            <param name="corner">
[in] if pView is not NULL and corner is not NULL, then corner will be the location of the first corner.
</param>
            <returns>
The type of input that was specified.  If CRhinoGet::rect2d is
returned, then use CRhinoGetPoint::Rectangle2d to get the value
of the 2d point and CRhinoGetPoint::View() to get the view
that contains the 2d point.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.Get2dRectangle(RMA.Rhino.MRhinoView,System.ValueType!System.Drawing.Point!System.Runtime.CompilerServices.IsBoxed,System.Boolean)">
            <summary>
After setting up options and so on, call CRhinoGetPoint::Get2dRectangle
to get a 2d rectanble in a view window.
</summary>
            <param name="pView">
[in] if pView is not NULL, then the 2d rectangle will be in this view.
Otherwise, the 2d rectangle can be in any view.
</param>
            <param name="corner">
[in] if pView is not NULL and corner is not NULL, then corner will be the location of the first corner.
</param>
            <param name="bCentered">[in] if true, the first point will be the center of the rectangle.</param>
            <returns>
The type of input that was specified.  If CRhinoGet::rect2d is
returned, then use CRhinoGetPoint::Rectangle2d to get the value
of the 2d point and CRhinoGetPoint::View() to get the view
that contains the 2d point.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.Get2dRectangle(RMA.Rhino.MRhinoView,System.ValueType!System.Drawing.Point!System.Runtime.CompilerServices.IsBoxed,System.Boolean,System.Int32)">
            <summary>
After setting up options and so on, call CRhinoGetPoint::Get2dRectangle
to get a 2d rectanble in a view window.
</summary>
            <param name="pView">
[in] if pView is not NULL, then the 2d rectangle will be in this view.
Otherwise, the 2d rectangle can be in any view.
</param>
            <param name="corner">
[in] if pView is not NULL and corner is not NULL, then corner will be the location of the first corner.
</param>
            <param name="bCentered">[in] if true, the first point will be the center of the rectangle.</param>
            <param name="pen_style">
[in] pen style used to draw dynamic rectangle
This is the GDI hard coded pen style value
PS_SOLID            0
PS_DASH             1
PS_DOT              2
PS_DASHDOT          3
PS_DASHDOTDOT       4
</param>
            <returns>
The type of input that was specified.  If CRhinoGet::rect2d is
returned, then use CRhinoGetPoint::Rectangle2d to get the value
of the 2d point and CRhinoGetPoint::View() to get the view
that contains the 2d point.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.Get2dRectangle(RMA.Rhino.MRhinoView,System.ValueType!System.Drawing.Point!System.Runtime.CompilerServices.IsBoxed,System.Boolean,System.Int32,System.Boolean)">
            <summary>
After setting up options and so on, call CRhinoGetPoint::Get2dRectangle
to get a 2d rectanble in a view window.
</summary>
            <param name="pView">
[in] if pView is not NULL, then the 2d rectangle will be in this view.
Otherwise, the 2d rectangle can be in any view.
</param>
            <param name="corner">
[in] if pView is not NULL and corner is not NULL, then corner will be the location of the first corner.
</param>
            <param name="bCentered">[in] if true, the first point will be the center of the rectangle.</param>
            <param name="pen_style">
[in] pen style used to draw dynamic rectangle
This is the GDI hard coded pen style value
PS_SOLID            0
PS_DASH             1
PS_DOT              2
PS_DASHDOT          3
PS_DASHDOTDOT       4
</param>
            <returns>
The type of input that was specified.  If CRhinoGet::rect2d is
returned, then use CRhinoGetPoint::Rectangle2d to get the value
of the 2d point and CRhinoGetPoint::View() to get the view
that contains the 2d point.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.Get2dRectangle(RMA.Rhino.MRhinoView,System.ValueType!System.Drawing.Point!System.Runtime.CompilerServices.IsBoxed,System.Boolean,System.Int32,System.Boolean,System.String)">
            <summary>
After setting up options and so on, call CRhinoGetPoint::Get2dRectangle
to get a 2d rectanble in a view window.
</summary>
            <param name="pView">
[in] if pView is not NULL, then the 2d rectangle will be in this view.
Otherwise, the 2d rectangle can be in any view.
</param>
            <param name="corner">
[in] if pView is not NULL and corner is not NULL, then corner will be the location of the first corner.
</param>
            <param name="bCentered">[in] if true, the first point will be the center of the rectangle.</param>
            <param name="pen_style">
[in] pen style used to draw dynamic rectangle
This is the GDI hard coded pen style value
PS_SOLID            0
PS_DASH             1
PS_DOT              2
PS_DASHDOT          3
PS_DASHDOTDOT       4
</param>
            <param name="second_prompt">
[in] default automatically comes up with the right string.
If you are very hard to satisfy, you can supply your own.
</param>
            <returns>
The type of input that was specified.  If CRhinoGet::rect2d is
returned, then use CRhinoGetPoint::Rectangle2d to get the value
of the 2d point and CRhinoGetPoint::View() to get the view
that contains the 2d point.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.Get2dPoint">
            <summary>
After setting up options and so on, call CRhinoGetPoint::Get2dPoint to get a 2d point in a view window. 
</summary>
            <returns>
The type of input that was specified. If CRhinoGet::point2d is returned, then use
CRhinoGetPoint::Point2d to get the value of the 2d point and CRhinoGetPoint::View()
to get the view that contains the 2d point.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.Get2dPoint(RMA.Rhino.MRhinoView)">
            <summary>
After setting up options and so on, call CRhinoGetPoint::Get2dPoint to get a 2d point in a view window. 
</summary>
            <param name="pView">
[in] if pView is not NULL, then the 2d point will be in this view. Otherwise, the 2d point can be in any view.
</param>
            <returns>
The type of input that was specified. If CRhinoGet::point2d is returned, then use
CRhinoGetPoint::Point2d to get the value of the 2d point and CRhinoGetPoint::View()
to get the view that contains the 2d point.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.Get2dPoint(RMA.Rhino.MRhinoView,System.Boolean)">
            <summary>
After setting up options and so on, call CRhinoGetPoint::Get2dPoint to get a 2d point in a view window. 
</summary>
            <param name="pView">
[in] if pView is not NULL, then the 2d point will be in this view. Otherwise, the 2d point can be in any view.
</param>
            <param name="bOnMouseUp">default=false [in] if true, the point will be returned on the mouse up event.</param>
            <returns>
The type of input that was specified. If CRhinoGet::point2d is returned, then use
CRhinoGetPoint::Point2d to get the value of the 2d point and CRhinoGetPoint::View()
to get the view that contains the 2d point.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.GetPoint">
            <summary>
After setting up options and so on, call CRhinoGetPoint::GetPoint to get a 3d point.
</summary>
            <returns>
The type of input that was specified.  If CRhinoGet::point is returned, then
use CRhinoGetPoint::Point to get the value of the 3d point.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.GetPoint(System.Boolean)">
            <summary>
After setting up options and so on, call CRhinoGetPoint::GetPoint to get a 3d point.
</summary>
            <param name="bOnMouseUp">
default is false
[in] if false, the point is returned when the left mouse button goes down. 
If true, the point is returned when the left mouse button goes up.
</param>
            <returns>
The type of input that was specified.  If CRhinoGet::point is returned, then
use CRhinoGetPoint::Point to get the value of the 3d point.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.EnableObjectSnapCursors">
            <summary>By default, object snap cursors are enabled.</summary>
            <returns>
True if object snap cursors (plus sign with "near", "end", etc.)
are used when the point snaps to a object.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.EnableObjectSnapCursors(System.Boolean)">
            <summary>By default, object snap cursors are enabled.</summary>
            <param name="bEnableObjectSnapCursors">[in]</param>
            <returns>
True if object snap cursors (plus sign with "near", "end", etc.)
are used when the point snaps to a object.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.GetPointCursor">
            <summary>Gets the default get point cursor. Returns: The default GetPoint cursor.</summary>
            <remarks>
When CRhinoGetPoint::GetPoint is called, the cursor is changed to the cursor
specified in CRhinoGetPoint::SetGetPointCursor. If a snap happens during
GetPoint, the cursor is changed to the appropriate snap cursor while the snap
is active. The default get point cursor is RhinoApp().m_cross_hair_cursor.
See Also: CRhinoGetPoint::SetGetPointCursor CRhinoGetPoint::CurrentCursor RhinoSetCursor
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.CurrentCursor">
            <summary>
Gets cursor that will be used when GetPoint() is called. This is either the get
point cursor or a snap cursor.
</summary>
            <returns>The current GetPoint cursor (may be a snap cursor or the get point cursor).</returns>
            <remarks>
When CRhinoGetPoint::GetPoint is called, the cursor is changed to the
cursor specified in CRhinoGetPoint::SetGetPointCursor. If a snap happens
during GetPoint, the cursor is changed to the appropriate snap cursor while
the snap is active. The default get point cursor is RhinoApp().m_cross_hair_cursor.
See Also: CRhinoGetPoint::SetGetPointCursor CRhinoGetPoint::GetPointCursor RhinoSetCursor
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.SetGetPointCursor(System.Windows.Forms.Cursor)">
            <summary>
Sets cursor that will be used when GetPoint() is called and a snap is not happening.
</summary>
            <param name="getpoint_cursor">[in]</param>
            <returns>Previous get point cursor.</returns>
            <remarks>
When CRhinoGetPoint::GetPoint is called, the cursor is changed to getpoint_cursor.
The default is RhinoApp().m_cross_hair_cursor.
See Also: CRhinoGetPoint::CurrentCursor CRhinoGetPoint::GetPointCursor RhinoSetCursor
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.DynamicDraw(System.IntPtr,RMA.Rhino.MRhinoViewport,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Optional - override CRhinoGetPoint::DynamicDraw() if you want to dynamically
draw things as the mouse/digitizer moves. Every time the mouse moves,
DynamicDraw() will be called once per viewport. The calls to DynamicDraw()
happen AFTER the call to OnMouseMove().

Use the CRhinoView::Draw* tools to draw things. Use Rhino::LayerColor(),
etc., to get Rhino system colors.

If you are drawing anything that takes a long time, periodically
call InterruptMouseMove() to see if you should stop.
 
If you override both OnMouseMove() and DynamicDraw(), then every
time the mouse moves you will first get a single call to
OnMouseMove() and then get a call to DynamicDraw() for each viewport.

If you override dynamic draw, you should call CRhinoGetPoint::DynamicDraw()
at the end of your override.
</summary>
            <param name="pt">current mouse/digitizer location</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.OnMouseDown(RMA.Rhino.MRhinoViewport,System.UInt32,RMA.OpenNURBS.IOn3dPoint,System.Drawing.Point)">
            <summary>
This virtual function CRhinoGetPoint::OnMouseDown is called during CRhinoGetPoint::Get2dRectangle,
RhinoGetPoint::Get2dLine, and CRhinoGetPoint::GetPoint(..,true) when the mouse down event
for the initial point occurs. The default does nothing.  This function is not called during
ordinary point getting because the mouse down event terminates an ordinary point get and 
returns a CRhinoGet::point result.
</summary>
            <param name="vp">[in] active view</param>
            <param name="nFlags">[in] standard windows OnMouseMove event flags</param>
            <param name="view_wnd_point">
[in] If the point is coming from a "mouse" pointing device,
view_wnd_point is the CRhinoView window coordinates of mouse location.
If the point is coming from a 3d digitizer pointing device, view_wnd_point is NULL.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.OnMouseMove(RMA.Rhino.MRhinoViewport,System.UInt32,RMA.OpenNURBS.IOn3dPoint,System.Drawing.Point)">
            <summary>If you want to be called every time the mouse moves, override this function.</summary>
            <param name="vp">[in] active view</param>
            <param name="nFlags">[in] standard windows OnMouseMove event flags</param>
            <param name="point">[in] 3d world location ( May be uninitialized)</param>
            <param name="view_wnd_point">
[in] If the point is coming from a "mouse" pointing device,
view_wnd_point is the CRhinoView window coordinates of mouse location.
If the point is coming from a 3d digitizer pointing device, view_wnd_point is NULL.
</param>
            <remarks>
CRhinoGetPoint::OnMouseMove is called once per mouse move and is called BEFORE any calls to
CRhinoGetPoint::OnDynamicDraw. If you are doing anything that takes a long time, periodically
call InterruptMouseMove() to see if you should stop. If the view is such that the 2d screen
point can't be mapped to a 3d point, the 'point' argument will be ON_unset_point
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.InterruptMouseMove">
            <summary>
If you have lengthy computations in OnMouseMove() and/or DymanicDraw()
overrides, then periodically call InterruptMouseMove() to see if you should
interrrupt your work because the mouse has moved again.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.ClearConstraints">
            <summary>
Remove any explicit constraints added by calls to
CRhinoGetPoint::Constraint() and enable the built-in
constraint options.
See Also: CRhinoGetPoint::PermitConstraintOptions
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.ConstrainToVirtualCPlaneIntersection(RMA.OpenNURBS.IOnPlane)">
            <summary>
If enabled, the picked point is constrained to be on the 
intersection of the plane and the virtual CPlane going through
the plane origin.
If the planes are parallel, the constraint works just like planar constraint.
</summary>
            <param name="arg1">The plane used for the plane - virtual CPlane intersection.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.ConstrainToTargetPlane">
            <summary>
Constrain point to lie on a plane that is parallel to the
viewing plane and passes through the view's target point.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.ConstrainToConstructionPlane">
            <summary>
If enabled, the picked point is constrained to be on the 
active construction plane.  If the base point is set, then the 
point is constrained to be on the plane that contains the base 
point and is parallel to the active construction plane.  
By default this constraint is enabled.
</summary>
            <remarks>
Planar mode is on if RhinoApp().AppSettings().Planar() is true.
See Also: SetBasePoint.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.ConstrainToConstructionPlane(System.Boolean)">
            <summary>
If enabled, the picked point is constrained to be on the 
active construction plane.  If the base point is set, then the 
point is constrained to be on the plane that contains the base 
point and is parallel to the active construction plane.  
By default this constraint is enabled.
</summary>
            <param name="bThroughBasePoint">
[in] if true and the base point is set, then the point is constrained to be
on the plane parallel to the construction plane that passes through the base
point, even when planar mode is off. If bThroughBasePoint is false, then the
base point shift only happens if planar mode is on.
</param>
            <remarks>
Planar mode is on if RhinoApp().AppSettings().Planar() is true.
See Also: SetBasePoint.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.Constrain(RMA.OpenNURBS.IOnBrep)">
            <summary>
When face_index &lt;0, constrain to whole brep. When face_index &gt;=0, constrain to individual face.
When wire_density&lt;0, isocurve intersection snapping is turned off, when wire_density&gt;=0, the value
defines the isocurve density used for isocurve intersection snapping.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.Constrain(RMA.OpenNURBS.IOnBrep,System.Int32)">
            <summary>
When face_index &lt;0, constrain to whole brep. When face_index &gt;=0, constrain to individual face.
When wire_density&lt;0, isocurve intersection snapping is turned off, when wire_density&gt;=0, the value
defines the isocurve density used for isocurve intersection snapping.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.Constrain(RMA.OpenNURBS.IOnBrep,System.Int32,System.Int32)">
            <summary>
When face_index &lt;0, constrain to whole brep. When face_index &gt;=0, constrain to individual face.
When wire_density&lt;0, isocurve intersection snapping is turned off, when wire_density&gt;=0, the value
defines the isocurve density used for isocurve intersection snapping.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.Constrain(RMA.OpenNURBS.IOnBrep,System.Int32,System.Int32,System.Boolean)">
            <summary>
When face_index &lt;0, constrain to whole brep. When face_index &gt;=0, constrain to individual face.
When wire_density&lt;0, isocurve intersection snapping is turned off, when wire_density&gt;=0, the value
defines the isocurve density used for isocurve intersection snapping.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.Constrain(RMA.OpenNURBS.IOnSurface,System.Boolean)">
            <summary>
bAllowPickingPointOffObject defines whether the point pick is allowed to 
happen off object. When false, a "no no" cursor is shown when the cursor is not
on the object. When true, a normal point picking cursor is used and the marker
is visible also when the cursor is not on the object.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.Constrain(RMA.OpenNURBS.IOnCurve,System.Boolean)">
            <summary>
bAllowPickingPointOffObject defines whether the point pick is allowed to 
happen off object. When false, a "no no" cursor is shown when the cursor is not
on the object. When true, a normal point picking cursor is used and the marker
is visible also when the cursor is not on the object.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.Constrain(RMA.OpenNURBS.IOnCylinder)">
            <summary>
constrain point to lie on a cylinder
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.Constrain(RMA.OpenNURBS.IOnSphere)">
            <summary>
constrain point to lie on a sphere
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.Constrain(RMA.OpenNURBS.IOnPlane)">
            <summary>
constrain point to lie on a plane
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.Constrain(RMA.OpenNURBS.IOnPlane,System.Boolean)">
            <summary>
constrain point to lie on a plane
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.Constrain(RMA.OpenNURBS.IOnCircle)">
            <summary>
constrain point to lie on a circle
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.Constrain(RMA.OpenNURBS.IOnArc)">
            <summary>
constrain point to lie on an arc
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.Constrain(RMA.OpenNURBS.IOnLine)">
            <summary>
constrain to a line
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.Constrain(RMA.OpenNURBS.IOnLine,System.Boolean)">
            <summary>
constrain to a line
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.Constrain(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
constrain to a line
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.EnableSnapToCurves">
            <summary>
If you want GetPoint() to try to snap to curves when the mouse is near
a curve (like the center point in the Circle command when the
AroundCurve option is on), then enable the snap to curves option.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.EnableSnapToCurves(System.Boolean)">
            <summary>
If you want GetPoint() to try to snap to curves when the mouse is near
a curve (like the center point in the Circle command when the
AroundCurve option is on), then enable the snap to curves option.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.EnableCurveSnapArrow">
            <summary>Controls display of the curve snap arrow icon.</summary>
            <remarks>
The tangent bar is drawn by CRhinoGetPoint::DynamicDraw. If you override
CRhinoGetPoint::DynamicDraw, then you must call the base class function.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.EnableCurveSnapArrow(System.Boolean)">
            <summary>Controls display of the curve snap arrow icon.</summary>
            <param name="bDrawDirectionArrowAtSnapPoint">
[in] true to draw arrow icon whenever GetPoint snaps to a curve.
</param>
            <remarks>
The tangent bar is drawn by CRhinoGetPoint::DynamicDraw. If you override
CRhinoGetPoint::DynamicDraw, then you must call the base class function.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.EnableCurveSnapArrow(System.Boolean,System.Boolean)">
            <summary>Controls display of the curve snap arrow icon.</summary>
            <param name="bDrawDirectionArrowAtSnapPoint">
[in] true to draw arrow icon whenever GetPoint snaps to a curve.
</param>
            <param name="bReverseArrow">
[in] true if arrow icon direction should be the reverse of the first derivative direction.
</param>
            <remarks>
The tangent bar is drawn by CRhinoGetPoint::DynamicDraw. If you override
CRhinoGetPoint::DynamicDraw, then you must call the base class function.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.EnableCurveSnapPerpBar">
            <summary>Controls display of the curve snap perpindicular bar icon.</summary>
            <remarks>
The tangent bar is drawn by CRhinoGetPoint::DynamicDraw. If you override
CRhinoGetPoint::DynamicDraw, then you must call the base class function.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.EnableCurveSnapPerpBar(System.Boolean)">
            <summary>Controls display of the curve snap perpindicular bar icon.</summary>
            <param name="bDrawPerpBarAtSnapPoint">
[in] true to draw a tangent bar icon whenever GetPoint snaps to a curve.
</param>
            <remarks>
The tangent bar is drawn by CRhinoGetPoint::DynamicDraw. If you override
CRhinoGetPoint::DynamicDraw, then you must call the base class function.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.EnableCurveSnapPerpBar(System.Boolean,System.Boolean)">
            <summary>Controls display of the curve snap perpindicular bar icon.</summary>
            <param name="bDrawPerpBarAtSnapPoint">
[in] true to draw a tangent bar icon whenever GetPoint snaps to a curve.
</param>
            <param name="bDrawEndPoints">[in] true to draw points at the end of the tangent bar.</param>
            <remarks>
The tangent bar is drawn by CRhinoGetPoint::DynamicDraw. If you override
CRhinoGetPoint::DynamicDraw, then you must call the base class function.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.EnableCurveSnapTangentBar">
            <summary>Controls display of the curve snap tangent bar icon.</summary>
            <remarks>
The tangent bar is drawn by CRhinoGetPoint::DynamicDraw. If you override
CRhinoGetPoint::DynamicDraw, then you must call the base class function.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.EnableCurveSnapTangentBar(System.Boolean)">
            <summary>Controls display of the curve snap tangent bar icon.</summary>
            <param name="bDrawTangentBarAtSnapPoint">
[in] true to draw a tangent bar icon whenever GetPoint snaps to a curve.
</param>
            <remarks>
The tangent bar is drawn by CRhinoGetPoint::DynamicDraw. If you override
CRhinoGetPoint::DynamicDraw, then you must call the base class function.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.EnableCurveSnapTangentBar(System.Boolean,System.Boolean)">
            <summary>Controls display of the curve snap tangent bar icon.</summary>
            <param name="bDrawTangentBarAtSnapPoint">
[in] true to draw a tangent bar icon whenever GetPoint snaps to a curve.
</param>
            <param name="bDrawEndPoints">[in] true to draw points at the end of the tangent bar.</param>
            <remarks>
The tangent bar is drawn by CRhinoGetPoint::DynamicDraw. If you override
CRhinoGetPoint::DynamicDraw, then you must call the base class function.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.GetConstructionPoints(RMA.OpenNURBS.ArrayOn3dPoint@)">
            <summary>Get current construction points.</summary>
            <param name="construction_points">[out]</param>
            <returns>number of construction points</returns>
            <remarks>
Construction points are like snap points except that they get snapped
to even when point osnap is off. Typically, there are only a few
construction points while there can be many snap points. For example,
when polylines are drawn the start point is a construction point and
the other points are snap points.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.ClearConstructionPoints">
            <summary>Remove all construction points.</summary>
            <remarks>
Construction points are like snap points except that they get snapped
to even when point osnap is off. Typically, there are only a few
construction points while there can be many snap points. For example,
when polylines are drawn the start point is a construction point and
the other points are snap points.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.AddConstructionPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Add a point to the list of construction points</summary>
            <param name="construction_point">[in]</param>
            <returns>Total number of construction points</returns>
            <remarks>
Construction points are like snap points except that they get snapped
to even when point osnap is off. Typically, there are only a few construction
points while there can be many snap points. For example, when polylines are
drawn the start point is a construction point and the other points are snap points.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.GetSnapPoints(RMA.OpenNURBS.ArrayOn3dPoint@)">
            <summary>Get current snap points.</summary>
            <param name="snap_points">[out]</param>
            <returns>number of snap points</returns>
            <remarks>
See CRhinoGetPoint::EnableSnapToSnapPoints for a description of snap points.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.ClearSnapPoints">
            <summary>Remove all snap points.</summary>
            <remarks>
When point osnap is enabled, GetPoint will snap to points in the Rhino model.
If you want the user to be able to snap to additional points, then use
CRhinoGetPoint::AddSnapPoints to specify the locations of these additional points.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.AddSnapPoints(RMA.OpenNURBS.IArrayOn3dPoint)">
            <summary>Add points to the list of snap points.</summary>
            <returns>Total number of snap points</returns>
            <remarks>
When point osnap is enabled, GetPoint will snap to points in
the Rhino model.  If you want the user to be able to snap to
additional points, then use CRhinoGetPoint::AddSnapPoints to 
specify the locations of these additional points.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.AddSnapPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Add a point to the list of osnap points</summary>
            <param name="snap_point">[in]</param>
            <returns>Total number of snap points</returns>
            <remarks>
When point osnap is enabled, GetPoint will snap to points in the Rhino model.
If you want the user to be able to snap to additional points, then use
CRhinoGetPoint::AddSnapPoints to specify the locations of these additional points.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.ProhibitObjectSnap(RMA.Rhino.IRhinoObject)">
            <summary>Used to prevent snapping to a specific object.</summary>
            <param name="object">[in] object that should not be snapped to.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.PermitObjectSnap">
            <summary>
By default, object snaps like "end", "near", etc. are controled by the user.
If you want to disable this ability, then call PermitObjectSnap(false).
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.PermitObjectSnap(System.Boolean)">
            <summary>
By default, object snaps like "end", "near", etc. are controled by the user.
If you want to disable this ability, then call PermitObjectSnap(false).
</summary>
            <param name="bPermitObjectSnap">[in] true to permit snapping to objects.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.PermitElevatorMode">
            <summary>Permit use of the control key to define a line constraint.</summary>
            <remarks>By default, mode 1 is enabled.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.PermitElevatorMode(System.Int32)">
            <summary>Permit use of the control key to define a line constraint.</summary>
            <param name="permit_elevator_mode">
0: no elevator modes are permitted
1: fixed plane elevator mode (like the Line command)
2: cplane elevator mode (like object dragging)
</param>
            <remarks>By default, mode 1 is enabled.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.PermitTabMode">
            <summary>Permit use of the tab key to define a line constraint.</summary>
            <remarks>By default, use of the tab key is supported.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.PermitTabMode(System.Boolean)">
            <summary>Permit use of the tab key to define a line constraint.</summary>
            <param name="bPermitTabMode">[in] if true, then the built-in tab key mode is available.</param>
            <remarks>By default, use of the tab key is supported.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.PermitConstraintOptions">
            <summary>
Control the availability of the built-in linear, planar, curve, and surface
constraint options like "Along", "AlongPerp",
"AlongTan", "AlongParallel", "Between", "OnCrv",
"OnSrf", ".x", ".y", ".z", ".xy", etc.
</summary>
            <remarks>
By default, these built-in constraint options are availble unless an explicit constraint
is added by calling one of the CRhinoGetPoint::Constrain functions. Calling
CRhinoGetPoint::ClearConstraints automatically enables the built-in constraint options.
The built-in constraint options are never visible on the command line and the user must
type the complete option name to activate these options.
See Also: CRhinoGetPoint::SetBasePoint CRhinoGetPoint::PermitOrthoSnap CRhinoGetPoint::PermitFromOption
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.PermitConstraintOptions(System.Boolean)">
            <summary>
Control the availability of the built-in linear, planar, curve, and surface
constraint options like "Along", "AlongPerp",
"AlongTan", "AlongParallel", "Between", "OnCrv",
"OnSrf", ".x", ".y", ".z", ".xy", etc.
</summary>
            <param name="bPermitConstraintOptions">
[in] if true, then the built-in contraint options are automatically avaiable in GetPoint.
</param>
            <remarks>
By default, these built-in constraint options are availble unless an explicit constraint
is added by calling one of the CRhinoGetPoint::Constrain functions. Calling
CRhinoGetPoint::ClearConstraints automatically enables the built-in constraint options.
The built-in constraint options are never visible on the command line and the user must
type the complete option name to activate these options.
See Also: CRhinoGetPoint::SetBasePoint CRhinoGetPoint::PermitOrthoSnap CRhinoGetPoint::PermitFromOption
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.PermitFromOption">
            <summary>
Control the availability of the built-in "From" option. By default,
the "From" option is enabled.
</summary>
            <remarks>
The GetPoint "From" option is never visible on the command line
and the user must type the complete option name to activate the "From"
option. When the GetPoint "From" snap is enabled, the user set/change
the base point during GetPoint by typing "From" and picking a point.
A related option is the builit-in distance from base point constraint that is
can be set before GetPoint is called by passing a value to
CRhinoGetPoint::ConstrainDistanceFromBasePoint or during GetPoint by entering a
number.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.PermitFromOption(System.Boolean)">
            <summary>
Control the availability of the built-in "From" option. By default,
the "From" option is enabled.
</summary>
            <param name="bPermitFromOption">
[in] if true, then the "From" option is automatically avaiable in GetPoint.
</param>
            <remarks>
The GetPoint "From" option is never visible on the command line
and the user must type the complete option name to activate the "From"
option. When the GetPoint "From" snap is enabled, the user set/change
the base point during GetPoint by typing "From" and picking a point.
A related option is the builit-in distance from base point constraint that is
can be set before GetPoint is called by passing a value to
CRhinoGetPoint::ConstrainDistanceFromBasePoint or during GetPoint by entering a
number.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.PermitOrthoSnap">
            <summary>Controls availability of ortho snap.  Default is true.</summary>
            <remarks>
The base point must be set and ortho snapping must be permitted
and RhinoApp().AppSettings().Ortho() must be true for ortho snapping to work.
See Also: SetBasePoint, PermitFromOption.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.PermitOrthoSnap(System.Boolean)">
            <summary>Controls availability of ortho snap.  Default is true.</summary>
            <param name="bPermitOrthoSnap">
[in] if true, then GetPoint pays attention to the Rhino "ortho snap"
and "planar snap" settings reported by RhinoApp().AppSettings().Ortho()
and RhinoApp().AppSettings().Planar().
</param>
            <remarks>
The base point must be set and ortho snapping must be permitted
and RhinoApp().AppSettings().Ortho() must be true for ortho snapping to work.
See Also: SetBasePoint, PermitFromOption.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.EnableDrawLineFromPoint">
            <summary>Controls drawing of dynamic a line from the start point.</summary>
            <remarks>
Use DrawLineFromPoint to specify the start point, color,
and status bar behavior.
See Also: DrawLineFromPoint, SetBasePoint.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.EnableDrawLineFromPoint(System.Boolean)">
            <summary>Controls drawing of dynamic a line from the start point.</summary>
            <param name="bDrawLineFromPoint">
[in] if true, a dynamic line is drawn from the DrawLineFromPoint
start_point to the point being picked.
</param>
            <remarks>
Use DrawLineFromPoint to specify the start point, color,
and status bar behavior.
See Also: DrawLineFromPoint, SetBasePoint.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.DrawLineFromPoint(RMA.OpenNURBS.IOn3dPoint,System.Boolean)">
            <summary>
Use DrawLineFromPoint() if you want a dynamic line drawn from a point to the point being picked.
</summary>
            <param name="start_point">
[in] The line is drawn from start_point to the point being picked.
If the base point has not been set, then it is set to start_point.
</param>
            <param name="bShowDistanceInStatusBar">
[in] if true, the distance from the base_point to the point begin picked is
shown in the status bar.
</param>
            <remarks>
Calling DrawLineFromPoint automatically enables drawing the line.
Use EnableDrawLineFromPoint() to toggle the line drawing state.
See Also: EnableDrawLineFromPoint, SetBasePoint.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.DynamicDrawColor">
            <summary>
The color used by CRhinoGetPoint::DynamicDraw to draw the current point
and the line from the base point to the current point.
</summary>
            <returns>
Current dynamic draw color.
See Also: CRhinoGetPoint::SetDynamicDrawColor
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.SetDynamicDrawColor(System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Set the color used by CRhinoGetPoint::DynamicDraw to draw the current point
and the line from the base point to the current point.
</summary>
            <returns>previous dynamic color</returns>
            <remarks>
The default is RhinoApp().AppSettings().ActiveLayerColor().
See Also: CRhinoGetPoint::DynamicDrawColor CRhinoGetPoint::EnableDrawLineFromPoint
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.GetPlanarConstraint(RMA.Rhino.IRhinoViewport,RMA.OpenNURBS.OnPlane@)">
            <summary>Check if point is constrained to be on a plane.</summary>
            <param name="vp">[in] NULL or viewport to use for construction plane.</param>
            <param name="plane">
[out] If GetPlanarConstraint() returns true, then the planar constraint is returned here.
</param>
            <returns>true if there is an active planar constraint.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.ConstrainDistanceFromBasePoint(System.Double)">
            <summary>Set distance constraint from base point</summary>
            <param name="distance_from_basepoint">
[in] pass ON_UNSET_VALUE to clear this constraint.
Pass 0.0 to disable the ability to set this constraint by typing a number during GetPoint.
</param>
            <remarks>
If the base point is set and the distance from base point constraint is &gt; 0,
then the picked point is constrained to be this distance from the base point.
See Also: CRhinoGetPoint::BasePoint CRhinoGetPoint::PermitFromOption
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.HasBasePoint">
            <summary>Returns true if SetBasePonint has been called</summary>
            <returns>
true  - SetBasePoint has been called.
false - SetBasePoint has not been called.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.BasePoint">
            <summary>
Location of base point used by ortho snap, from snap, etc., and DrawLineFromPoint().
</summary>
            <returns>
Location of base point.  If value is ON_unset_point, then the base point is not set.
</returns>
            <remarks>Default base_point is world (0,0,0)</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.SetBasePoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Set base point used by ortho snap, from snap, planar snap, etc.</summary>
            <param name="base_point">[in]</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.SetBasePoint(RMA.OpenNURBS.IOn3dPoint,System.Boolean)">
            <summary>Set base point used by ortho snap, from snap, planar snap, etc.</summary>
            <param name="base_point">[in]</param>
            <param name="bShowDistanceInStatusBar">
[in] if true, then the distance from base_point to the current point will
be in the status bar distance pane.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoGetPoint.#ctor(RMA.Rhino.IRhinoGet)">
            <summary>
prompt and options copied
</summary>
        </member>
        <member name="T:RMA.Rhino.MRhinoGetPoint">
            <summary>
CRhinoGetPoint is the Rhino SDK user interface tool used to get points.
It is derived from CRhinoGet which is used to provide the command prompt
and option setting tools that are common to all the Rhino SDK getting
tools.

Step 1:
Use the CRhinoGet member functions to specify command prompt, 
command options, and what types of non-point input are acceptable.
For example, if you want the user to be able to either pick a point
or type a number, then you would call CRhinoGet::AcceptNumber(true).
The default command prompt is a localized "Pick point" prompt.

Step 2:
Use the CRhinoGetPoint member functions to customize point picking behavior.

Step 3:
Call CRhinoGetPoint::GetPoint();

Step 4:
Examine the value returned by CRhinoGet::Result() and react accordingly.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGetPoint.GetPointOnMouseUp">
            <summary>
true if getting point on mouse up event
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGetPoint.MouseMoved">
            <summary>
Returns: True if mouse moved during the call to GetPoint();
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGetPoint.PointOnBrep(System.Double@,System.Double@)">
            <summary>Use to determine if point was on a brep (face).</summary>
            <param name="u">[out]</param>
            <param name="v">
[out] if the point was on a face, then the (*u,*v) are the face parameters for the point.
</param>
            <returns>pointer to a brep or NULL if the point was not on a brep.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoGetPoint.PointOnSurface(System.Double@,System.Double@)">
            <summary>Use to determine if point was on a surface.</summary>
            <param name="u">[out]</param>
            <param name="v">
[out] if the point was on a surface, then the (*u,*v) are the surface parameters
for the point. The point returned by Point() is the same as surface-&gt;PointAt(*u,*v).
</param>
            <returns>pointer to a surface or NULL if the point was not on a surface.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoGetPoint.PointOnEdge(System.Double@,RMA.OpenNURBS.IOnBrepTrim@)">
            <summary>Use to determine if point was on an edge curve of a brep.</summary>
            <param name="edge_parameter">[out] edge parameter of pick point</param>
            <param name="pTrim">[out] the associated trim</param>
            <remarks>
An edge can be a boundary or interior edge. Boundary edges have a
single trim.  Interior edges have multiple trims. If you need
information about the surface, then examine the trim.

If you do not need trim or surface information, then use CRhinoGetPoint::PointOnCurve.
</remarks>
            <returns>NULL or edge the point was on.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoGetPoint.PointOnCurve(System.Double@)">
            <summary>Use to determine if point was on a curve.</summary>
            <param name="t">
[out] if the point was on a curve, then the *t is the curve parameter
for the point. The point returned by CRhinoGetPoint::Point() is the
same as curve-&gt;PointAt(*t).
</param>
            <returns>pointer to a curve or NULL if the point was not on a curve.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoGetPoint.PointOnObject(RMA.Rhino.MRhinoObjRef@)">
            <summary>
Call this function to see if the point was on an object.  If
PointOnObject() returns true, then the object is returned
in the CRhinoObjRef parameter.  Use CRhinoObjRef::CurveParameter() or
CRhinoObjRef::SurfaceParameter() to get the parameter values for
the point.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGetPoint.Point">
            <summary>
returns 3d point in world coordinates
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGetPoint.GetPointCursor">
            <summary>Gets the default get point cursor. Returns: The default GetPoint cursor.</summary>
            <remarks>
When CRhinoGetPoint::GetPoint is called, the cursor is changed to the cursor
specified in CRhinoGetPoint::SetGetPointCursor. If a snap happens during
GetPoint, the cursor is changed to the appropriate snap cursor while the snap
is active. The default get point cursor is RhinoApp().m_cross_hair_cursor.
See Also: CRhinoGetPoint::SetGetPointCursor CRhinoGetPoint::CurrentCursor RhinoSetCursor
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoGetPoint.CurrentCursor">
            <summary>
Gets cursor that will be used when GetPoint() is called. This is either the get
point cursor or a snap cursor.
</summary>
            <returns>The current GetPoint cursor (may be a snap cursor or the get point cursor).</returns>
            <remarks>
When CRhinoGetPoint::GetPoint is called, the cursor is changed to the
cursor specified in CRhinoGetPoint::SetGetPointCursor. If a snap happens
during GetPoint, the cursor is changed to the appropriate snap cursor while
the snap is active. The default get point cursor is RhinoApp().m_cross_hair_cursor.
See Also: CRhinoGetPoint::SetGetPointCursor CRhinoGetPoint::GetPointCursor RhinoSetCursor
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoGetPoint.InterruptMouseMove">
            <summary>
tool for use in
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGetPoint.GetConstructionPoints(RMA.OpenNURBS.ArrayOn3dPoint@)">
            <summary>Get current construction points.</summary>
            <param name="construction_points">[out]</param>
            <returns>number of construction points</returns>
            <remarks>
Construction points are like snap points except that they get snapped
to even when point osnap is off. Typically, there are only a few
construction points while there can be many snap points. For example,
when polylines are drawn the start point is a construction point and
the other points are snap points.
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoGetPoint.GetSnapPoints(RMA.OpenNURBS.ArrayOn3dPoint@)">
            <summary>Get current snap points.</summary>
            <param name="snap_points">[out]</param>
            <returns>number of snap points</returns>
            <remarks>
See CRhinoGetPoint::EnableSnapToSnapPoints for a description of snap points.
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoGetPoint.DynamicDrawColor">
            <summary>
The color used by CRhinoGetPoint::DynamicDraw to draw the current point
and the line from the base point to the current point.
</summary>
            <returns>
Current dynamic draw color.
See Also: CRhinoGetPoint::SetDynamicDrawColor
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoGetPoint.GetPlanarConstraint(RMA.Rhino.IRhinoViewport,RMA.OpenNURBS.OnPlane@)">
            <summary>Check if point is constrained to be on a plane.</summary>
            <param name="vp">[in] NULL or viewport to use for construction plane.</param>
            <param name="plane">
[out] If GetPlanarConstraint() returns true, then the planar constraint is returned here.
</param>
            <returns>true if there is an active planar constraint.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoGetPoint.HasBasePoint">
            <summary>Returns true if SetBasePonint has been called</summary>
            <returns>
true  - SetBasePoint has been called.
false - SetBasePoint has not been called.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoGetPoint.BasePoint">
            <summary>
Location of base point used by ortho snap, from snap, etc., and DrawLineFromPoint().
</summary>
            <returns>
Location of base point.  If value is ON_unset_point, then the base point is not set.
</returns>
            <remarks>Default base_point is world (0,0,0)</remarks>
        </member>
        <member name="T:RMA.Rhino.IRhinoGetPoint">
            <summary>
CRhinoGetPoint is the Rhino SDK user interface tool used to get points.
It is derived from CRhinoGet which is used to provide the command prompt
and option setting tools that are common to all the Rhino SDK getting
tools.

Step 1:
Use the CRhinoGet member functions to specify command prompt, 
command options, and what types of non-point input are acceptable.
For example, if you want the user to be able to either pick a point
or type a number, then you would call CRhinoGet::AcceptNumber(true).
The default command prompt is a localized "Pick point" prompt.

Step 2:
Use the CRhinoGetPoint member functions to customize point picking behavior.

Step 3:
Call CRhinoGetPoint::GetPoint();

Step 4:
Examine the value returned by CRhinoGet::Result() and react accordingly.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.SetVector(RMA.OpenNURBS.IOn3dVector)">
            <summary>Set m_vector field.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AddHiddenCommandOptionAlias(System.Int32,System.String)">
            <summary>
low level tool
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AddHiddenCommandOptionAlias(System.Int32,System.String,System.String)">
            <summary>
low level tool
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AddHiddenCommandOptionAlias(System.Int32,System.String,System.String,System.String)">
            <summary>
low level tool
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AddHiddenCommandOptionAlias(System.Int32,System.String,System.String,System.String,System.String)">
            <summary>
low level tool
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.SerialNumber">
            <summary>
Description: Used to get Windows message if Get*() returns CRhinoGet::winmsg. Returns: Windows message.
</summary>
            <summary>
low level tool used to identify the get
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.Line2d(System.Drawing.Point@,System.Drawing.Point@)">
            <summary>
Location in view window of 2d line selected in CRhinoGetPoint::Get2dLine().
(0,0) = upper left corner of window
</summary>
            <remarks>Call CRhinoGet::View() to get the view window.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.Rectangle2d">
            <summary>
Location in view of 2d rectangle selected in CRhinoGetPoint::Get2dRectangle().
rect.left &lt; rect.right and rect.top &lt; rect.bottom
(0,0) = upper left corner of window
</summary>
            <remarks>Call CRhinoGet::View() to get the view window.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.Point2d">
            <summary>
Location in view of point in selected in CRhinoGetPoint::GetPoint() or
CRhinoGetPoint::Get2dPoint(). (0,0) = upper left corner of window
</summary>
            <remarks>Call CRhinoGet::View() to get the view window.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.PickRect">
            <summary>
If the get was a GetObjects() and the mouse was used to select the objects,
then the returned rect has left &lt; right and top &lt; bottom. This rect
is the Windows GDI screen coordinates of the picking rectangle.
View()-&gt;Viewport().GetPickXform( m_pick_rect, pick_xform ) will calculate
the picking transformation that was used. In all other cases, left=right=top=bottom=0;
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.View">
            <summary>
Used to get view user clicked in during CRhinoGetPoint::GetPoint(),
CRhinoGetObject::GetObject(), etc.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.Color">
            <summary>Used to get color if Get*() returns CRhinoGet::color.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.Vector">
            <summary>
Used to get direction if Get*() returns CRhinoGet::point.
(Set by some digitizers, but in general it's (0,0,0);
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.Point">
            <summary>Used to get point if Get*() returns CRhinoGet::point.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.String">
            <summary>
Used to get string if CRhinoGetPoint::GetPoint(),
RhinoGetObject::GetObject(), etc., returns CRhinoGet::string.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.Number">
            <summary>
Used to get number if CRhinoGetPoint::GetPoint(),
CRhinoGetObject::GetObject(), etc., returns CRhinoGet::number.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.Option">
            <summary>
Used to get option if CRhinoGetPoint::GetPoint(),
CRhinoGetObject::GetObject(), etc., returns CRhinoGet::option.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.CommandResult">
            <summary>Handy tool for getting command result value from getter results.</summary>
            <returns>
CRhinoCommand::cancel if CRhinoGet::Result() == CRhinoGet::cancel
CRhinoCommand::exit_rhino if CRhinoGet::Result() == CRhinoGet::exit_rhino
CRhinoCommand::success otherwise
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.GetResult">
            <summary>
Used to get result code returned by CRhinoGetPoint::GetPoint(),
CRhinoGetObject::GetObject(), etc.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.SetWaitDuration(System.Double)">
            <summary>
Expert user function to limit the amount of time GetPoint, GetObjects,
GetString, etc., will wait for input.
</summary>
            <param name="seconds">[in] number of seconds to wait. By default the getters will wait indefinitely.</param>
            <remarks>
If a getter times out, then CRhinoGet::timeout is returned by GetPoint, GetObjects, GetString, etc.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.PostCustomWindowsMessage(System.UInt32,System.UInt32,System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>Posts a Windows message that can terminate a call tooGetPoint, GetObject, GetString, etc.</summary>
            <param name="Msg">[in] Windows message id in the range 0xC000 throught 0xFFFF.</param>
            <param name="wParam">[in]</param>
            <param name="lParam">[in]</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AcceptCustomWindowsMessage(System.UInt32)">
            <summary>
Expert user tool that allows GetPoint, GetObject, GetString, etc.,
to return if a registered Windows message is posted by the static
function CRhinoGet::PostCustomWindowsMessage
</summary>
            <param name="winmsg_id">[in] Windows message id in the range 0xC000 throught 0xFFFF.</param>
            <returns>true if the message id is in the permitted range.</returns>
            <remarks>
Study the Windows documentation for RegisterWindowMessage. AcceptWindowsMessage
is intended to be used by experts. Support is not available. If Windows posts
a message with matching id while GetPoint, etc., is waiting for input, the the
getter returns CRhinoGet::winmsg. Call CRhinoGet::WndMsg() to get the message.
See Also: CRhinoGet::PostCustomWindowsMessage ::RegisterWindowMessage
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AcceptString">
            <summary>
If you want to allow the user to be able to type in a string
during CRhinoGetPoint::GetPoint(), CRhinoGetObject::GetObject(), etc.,
then call AcceptString() before calling GetPoint()/GetObject().
If the user chooses to type in a string, then the result code
CRhinoGet::string is returned and you can use CRhinoGet::String()
to get the value of the string.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AcceptString(System.Boolean)">
            <summary>
If you want to allow the user to be able to type in a string
during CRhinoGetPoint::GetPoint(), CRhinoGetObject::GetObject(), etc.,
then call AcceptString() before calling GetPoint()/GetObject().
If the user chooses to type in a string, then the result code
CRhinoGet::string is returned and you can use CRhinoGet::String()
to get the value of the string.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AcceptColor">
            <summary>
If you want to allow the user to be able to type in a color
r,g,b or name during CRhinoGetPoint::GetPoint(), 
CRhinoGetObject::GetObject(), etc.,
then call AcceptNumber() before calling GetPoint()/GetObject().
If the user chooses to type in a color, then the result code
CRhinoGet::color is returned and you can use CRhinoGet::Color()
to get the value of the color.  If the get accepts points,
then the user will not be able to type in r,g,b colors but will
be able to type color names.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AcceptColor(System.Boolean)">
            <summary>
If you want to allow the user to be able to type in a color
r,g,b or name during CRhinoGetPoint::GetPoint(), 
CRhinoGetObject::GetObject(), etc.,
then call AcceptNumber() before calling GetPoint()/GetObject().
If the user chooses to type in a color, then the result code
CRhinoGet::color is returned and you can use CRhinoGet::Color()
to get the value of the color.  If the get accepts points,
then the user will not be able to type in r,g,b colors but will
be able to type color names.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AcceptPoint">
            <summary>
If you want to allow the user to be able to type in a point
then call AcceptNumber() before calling GetPoint()/GetObject().
If the user chooses to type in a number, then the result code
CRhinoGet::point is returned and you can use CRhinoGet::Point()
to get the value of the point.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AcceptPoint(System.Boolean)">
            <summary>
If you want to allow the user to be able to type in a point
then call AcceptNumber() before calling GetPoint()/GetObject().
If the user chooses to type in a number, then the result code
CRhinoGet::point is returned and you can use CRhinoGet::Point()
to get the value of the point.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AcceptNumber">
            <summary>
If you want to allow the user to be able to type in a number
during CRhinoGetPoint::GetPoint(), CRhinoGetObject::GetObject(),
etc., then call AcceptNumber() before calling GetPoint()/GetObject().
If the user chooses to type in a number, then the result code
CRhinoGet::number is returned and you can use CRhinoGet::Number()
to get the value of the number.  If you are using GetPoint and
you want "0" to return (0,0,0) instead of the number zero, then
set bAcceptZero = false.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AcceptNumber(System.Boolean)">
            <summary>
If you want to allow the user to be able to type in a number
during CRhinoGetPoint::GetPoint(), CRhinoGetObject::GetObject(),
etc., then call AcceptNumber() before calling GetPoint()/GetObject().
If the user chooses to type in a number, then the result code
CRhinoGet::number is returned and you can use CRhinoGet::Number()
to get the value of the number.  If you are using GetPoint and
you want "0" to return (0,0,0) instead of the number zero, then
set bAcceptZero = false.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AcceptNumber(System.Boolean,System.Boolean)">
            <summary>
If you want to allow the user to be able to type in a number
during CRhinoGetPoint::GetPoint(), CRhinoGetObject::GetObject(),
etc., then call AcceptNumber() before calling GetPoint()/GetObject().
If the user chooses to type in a number, then the result code
CRhinoGet::number is returned and you can use CRhinoGet::Number()
to get the value of the number.  If you are using GetPoint and
you want "0" to return (0,0,0) instead of the number zero, then
set bAcceptZero = false.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AcceptUndo">
            <summary>
If you want to allow the user to have an undo option in
CRhinoGetPoint::GetPoint(), CRhinoGetObject::GetObject(), etc.,
then call AcceptUndo() before calling GetPoint()/GetObject().
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AcceptUndo(System.Boolean)">
            <summary>
If you want to allow the user to have an undo option in
CRhinoGetPoint::GetPoint(), CRhinoGetObject::GetObject(), etc.,
then call AcceptUndo() before calling GetPoint()/GetObject().
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AcceptNothing">
            <summary>
If you want to allow the user to be able to press enter in order
to skip selecting a something in CRhinoGetPoint::GetPoint(),
CRhinoGetObject::GetObject(), etc., then call AcceptNothing() before
calling GetPoint()/GetObject().
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AcceptNothing(System.Boolean)">
            <summary>
If you want to allow the user to be able to press enter in order
to skip selecting a something in CRhinoGetPoint::GetPoint(),
CRhinoGetObject::GetObject(), etc., then call AcceptNothing() before
calling GetPoint()/GetObject().
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.EnableTransparentCommands(System.Boolean)">
            <summary>Control the availability of transparent commands during the get.</summary>
            <param name="bEnableTransparentCommands">
[in] If true, then transparent commands can be run during the get.
If false, then transparent commands cannot be run during the get.
</param>
            <remarks>
Some Rhino commands are "transparent" and can be run inside of other commands.
Examples of transparent commands include the view manipulation commands like
ZoomExtents, Top, etc., and the selection commands like SelAll, SelPoint, etc.
By default transparent commands can be run during any get. If you want to disable
this feature, then call EnableTransparentCommands(false) before calling GetString,
GetPoint, GetObject, etc.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.ClearCommandOptions">
            <summary>
clear all command options
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AddCommandOptionList(RMA.Rhino.IRhinoCommandOptionName,RMA.Rhino.MRhinoCommandOptionValue[],System.Int32)">
            <summary>Add a command line list option</summary>
            <param name="option_name">[in] english option description</param>
            <param name="list_values">[in] array of english option values</param>
            <param name="list_current_index">[in] zero based index of current option</param>
            <returns>option index value (&gt;0) or 0 if option cannot be added.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AddCommandOptionToggle(RMA.Rhino.IRhinoCommandOptionName,RMA.Rhino.IRhinoCommandOptionValue,RMA.Rhino.IRhinoCommandOptionValue,System.Boolean)">
            <summary>Add a command line option to toggle a setting.</summary>
            <param name="option_name">[in] english option description</param>
            <param name="option_off_value">[in] english "off" value</param>
            <param name="option_on_value">[in] english "on" value</param>
            <param name="bToggleState">[in] current toggle state (true = on)</param>
            <returns>option index value (&gt;0) or 0 if option cannot be added.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AddCommandOptionToggle(RMA.Rhino.IRhinoCommandOptionName,RMA.Rhino.IRhinoCommandOptionValue,RMA.Rhino.IRhinoCommandOptionValue,System.Boolean,RMA.Rhino.MRhinoGet.BooleanOption)">
            <summary>Add a command line option to toggle a setting.</summary>
            <param name="option_name">[in] english option description</param>
            <param name="option_off_value">[in] english "off" value</param>
            <param name="option_on_value">[in] english "on" value</param>
            <param name="bToggleState">[in] current toggle state (true = on)</param>
            <param name="bCurrentToggleState">
[in/out] if not NULL, then the value of 
*pbCurrentState is kept set to the current state.
</param>
            <returns>option index value (&gt;0) or 0 if option cannot be added.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AddCommandOptionColor(RMA.Rhino.IRhinoCommandOptionName,RMA.OpenNURBS.OnColor)">
            <summary>Add a command line option to get colors and automatically save the value.</summary>
            <param name="option_name">[in] english option description</param>
            <param name="color_value">
[in/out] pointer to current value of the number.
If the user changes the integer's value, the value of 
*integer_value is changed but the current call to 
GetPoint/GetString/... does not return.
</param>
            <returns>
option index value (&gt;0) or 0 if option cannot be added.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AddCommandOptionColor(RMA.Rhino.IRhinoCommandOptionName,RMA.OpenNURBS.OnColor,System.String)">
            <summary>Add a command line option to get colors and automatically save the value.</summary>
            <param name="option_name">[in] english option description</param>
            <param name="color_value">
[in/out] pointer to current value of the number.
If the user changes the integer's value, the value of 
*integer_value is changed but the current call to 
GetPoint/GetString/... does not return.
</param>
            <param name="option_prompt">
[in] option prompt shown if the user selects this option.
If NULL, then option_name.m_local_option_name is used as the get number prompt.
</param>
            <returns>
option index value (&gt;0) or 0 if option cannot be added.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AddCommandOptionInteger(RMA.Rhino.IRhinoCommandOptionName,RMA.Rhino.MRhinoGet.IntegerOption)">
            <summary>Add a command line option to get integers and automatically save the value.</summary>
            <param name="option_name">[in] english option description.</param>
            <param name="integer_value">
[in/out] pointer to current value of the number.
If the user changes the integer's value, the value of 
*integer_value is changed but the current call to 
GetPoint/GetString/... does not return.
</param>
            <returns>option index value (&gt;0) or 0 if option cannot be added.</returns>
            <remarks>
If you need to explicitly react to a changed number, then use 
override of CRhinoGet::AddCommandOption that takes a number
as an option value.  See the CRhinoGet::AddCommandOption examples.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AddCommandOptionInteger(RMA.Rhino.IRhinoCommandOptionName,RMA.Rhino.MRhinoGet.IntegerOption,System.String)">
            <summary>Add a command line option to get integers and automatically save the value.</summary>
            <param name="option_name">[in] english option description.</param>
            <param name="integer_value">
[in/out] pointer to current value of the number.
If the user changes the integer's value, the value of 
*integer_value is changed but the current call to 
GetPoint/GetString/... does not return.
</param>
            <param name="option_prompt">
[in] option prompt shown if the user selects this option.
If NULL, then option_name.m_local_option_name is used as the get number prompt.
</param>
            <returns>option index value (&gt;0) or 0 if option cannot be added.</returns>
            <remarks>
If you need to explicitly react to a changed number, then use 
override of CRhinoGet::AddCommandOption that takes a number
as an option value.  See the CRhinoGet::AddCommandOption examples.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AddCommandOptionInteger(RMA.Rhino.IRhinoCommandOptionName,RMA.Rhino.MRhinoGet.IntegerOption,System.String,System.Double)">
            <summary>Add a command line option to get integers and automatically save the value.</summary>
            <param name="option_name">[in] english option description.</param>
            <param name="integer_value">
[in/out] pointer to current value of the number.
If the user changes the integer's value, the value of 
*integer_value is changed but the current call to 
GetPoint/GetString/... does not return.
</param>
            <param name="option_prompt">
[in] option prompt shown if the user selects this option.
If NULL, then option_name.m_local_option_name is used as the get number prompt.
</param>
            <param name="lower_limit">
[in] (default=ON_UNSET_VALUE which means no lower limit)
if set, the returned integer  must be &gt;= lower_limit
</param>
            <returns>option index value (&gt;0) or 0 if option cannot be added.</returns>
            <remarks>
If you need to explicitly react to a changed number, then use 
override of CRhinoGet::AddCommandOption that takes a number
as an option value.  See the CRhinoGet::AddCommandOption examples.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AddCommandOptionInteger(RMA.Rhino.IRhinoCommandOptionName,RMA.Rhino.MRhinoGet.IntegerOption,System.String,System.Double,System.Double)">
            <summary>Add a command line option to get integers and automatically save the value.</summary>
            <param name="option_name">[in] english option description.</param>
            <param name="integer_value">
[in/out] pointer to current value of the number.
If the user changes the integer's value, the value of 
*integer_value is changed but the current call to 
GetPoint/GetString/... does not return.
</param>
            <param name="option_prompt">
[in] option prompt shown if the user selects this option.
If NULL, then option_name.m_local_option_name is used as the get number prompt.
</param>
            <param name="lower_limit">
[in] (default=ON_UNSET_VALUE which means no lower limit)
if set, the returned integer  must be &gt;= lower_limit
</param>
            <param name="upper_limit">
[in] (default=ON_UNSET_VALUE which means no upper limit)
if set, the returned integer  must be &lt;= upper_limit
</param>
            <returns>option index value (&gt;0) or 0 if option cannot be added.</returns>
            <remarks>
If you need to explicitly react to a changed number, then use 
override of CRhinoGet::AddCommandOption that takes a number
as an option value.  See the CRhinoGet::AddCommandOption examples.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AddCommandOptionNumber(RMA.Rhino.IRhinoCommandOptionName,RMA.Rhino.MRhinoGet.DoubleOption)">
            <summary>
Add a command line option to get numbers and automatically save the value.
</summary>
            <param name="option_name">[in] english option description</param>
            <param name="number_value">
[in/out] pointer to current value of the number.
If the user changes the nubmer's value, the value of 
*number_value is changed but the current call to 
GetPoint/GetString/... does not return.
</param>
            <returns>option index value (&gt;0) or 0 if option cannot be added.</returns>
            <remarks>
If you need to explicitly react to a changed number, then use 
override of CRhinoGet::AddCommandOption that takes a number
as an option value.  See the CRhinoGet::AddCommandOption examples.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AddCommandOptionNumber(RMA.Rhino.IRhinoCommandOptionName,RMA.Rhino.MRhinoGet.DoubleOption,System.String)">
            <summary>
Add a command line option to get numbers and automatically save the value.
</summary>
            <param name="option_name">[in] english option description</param>
            <param name="number_value">
[in/out] pointer to current value of the number.
If the user changes the nubmer's value, the value of 
*number_value is changed but the current call to 
GetPoint/GetString/... does not return.
</param>
            <param name="option_prompt">
[in] option prompt shown if the user selects this option.
If NULL, then option_name.m_local_option_name is used as the get number prompt.
</param>
            <returns>option index value (&gt;0) or 0 if option cannot be added.</returns>
            <remarks>
If you need to explicitly react to a changed number, then use 
override of CRhinoGet::AddCommandOption that takes a number
as an option value.  See the CRhinoGet::AddCommandOption examples.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AddCommandOptionNumber(RMA.Rhino.IRhinoCommandOptionName,RMA.Rhino.MRhinoGet.DoubleOption,System.String,System.Boolean)">
            <summary>
Add a command line option to get numbers and automatically save the value.
</summary>
            <param name="option_name">[in] english option description</param>
            <param name="number_value">
[in/out] pointer to current value of the number.
If the user changes the nubmer's value, the value of 
*number_value is changed but the current call to 
GetPoint/GetString/... does not return.
</param>
            <param name="option_prompt">
[in] option prompt shown if the user selects this option.
If NULL, then option_name.m_local_option_name is used as the get number prompt.
</param>
            <param name="bIntegerValue">[in] (default=false) if true, number must be an integer</param>
            <returns>option index value (&gt;0) or 0 if option cannot be added.</returns>
            <remarks>
If you need to explicitly react to a changed number, then use 
override of CRhinoGet::AddCommandOption that takes a number
as an option value.  See the CRhinoGet::AddCommandOption examples.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AddCommandOptionNumber(RMA.Rhino.IRhinoCommandOptionName,RMA.Rhino.MRhinoGet.DoubleOption,System.String,System.Boolean,System.Double)">
            <summary>
Add a command line option to get numbers and automatically save the value.
</summary>
            <param name="option_name">[in] english option description</param>
            <param name="number_value">
[in/out] pointer to current value of the number.
If the user changes the nubmer's value, the value of 
*number_value is changed but the current call to 
GetPoint/GetString/... does not return.
</param>
            <param name="option_prompt">
[in] option prompt shown if the user selects this option.
If NULL, then option_name.m_local_option_name is used as the get number prompt.
</param>
            <param name="bIntegerValue">[in] (default=false) if true, number must be an integer</param>
            <param name="lower_limit">
[in] (default=ON_UNSET_VALUE which means no lower limit)
if set, the returned number  must be &gt;= lower_limit
</param>
            <returns>option index value (&gt;0) or 0 if option cannot be added.</returns>
            <remarks>
If you need to explicitly react to a changed number, then use 
override of CRhinoGet::AddCommandOption that takes a number
as an option value.  See the CRhinoGet::AddCommandOption examples.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AddCommandOptionNumber(RMA.Rhino.IRhinoCommandOptionName,RMA.Rhino.MRhinoGet.DoubleOption,System.String,System.Boolean,System.Double,System.Double)">
            <summary>
Add a command line option to get numbers and automatically save the value.
</summary>
            <param name="option_name">[in] english option description</param>
            <param name="number_value">
[in/out] pointer to current value of the number.
If the user changes the nubmer's value, the value of 
*number_value is changed but the current call to 
GetPoint/GetString/... does not return.
</param>
            <param name="option_prompt">
[in] option prompt shown if the user selects this option.
If NULL, then option_name.m_local_option_name is used as the get number prompt.
</param>
            <param name="bIntegerValue">[in] (default=false) if true, number must be an integer</param>
            <param name="lower_limit">
[in] (default=ON_UNSET_VALUE which means no lower limit)
if set, the returned number  must be &gt;= lower_limit
</param>
            <param name="upper_limit">
[in] (default=ON_UNSET_VALUE which means no upper limit)
if set, the returned number  must be &lt;= upper_limit
</param>
            <returns>option index value (&gt;0) or 0 if option cannot be added.</returns>
            <remarks>
If you need to explicitly react to a changed number, then use 
override of CRhinoGet::AddCommandOption that takes a number
as an option value.  See the CRhinoGet::AddCommandOption examples.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AddCommandOptionNumber(RMA.Rhino.IRhinoCommandOptionName,RMA.Rhino.MRhinoGet.DoubleOption,System.String,System.Boolean,System.Double,System.Double,System.Int32)">
            <summary>
Add a command line option to get numbers and automatically save the value.
</summary>
            <param name="option_name">[in] english option description</param>
            <param name="number_value">
[in/out] pointer to current value of the number.
If the user changes the nubmer's value, the value of 
*number_value is changed but the current call to 
GetPoint/GetString/... does not return.
</param>
            <param name="option_prompt">
[in] option prompt shown if the user selects this option.
If NULL, then option_name.m_local_option_name is used as the get number prompt.
</param>
            <param name="bIntegerValue">[in] (default=false) if true, number must be an integer</param>
            <param name="lower_limit">
[in] (default=ON_UNSET_VALUE which means no lower limit)
if set, the returned number  must be &gt;= lower_limit
</param>
            <param name="upper_limit">
[in] (default=ON_UNSET_VALUE which means no upper limit)
if set, the returned number  must be &lt;= upper_limit
</param>
            <param name="number_format">
[in]  This controls how strings are parsed to get a number
and how the number is displayed in the command prompt.
0 = general - RhinoParseNumber - decimal display
1 = distance - RhinoParseNumber - decimal display with doc units
2 = angle in degrees - RhinoParseAngleDegrees - decimal degrees display
3 = angle in radians - RhinoParseAngle - decimal radians display
</param>
            <returns>option index value (&gt;0) or 0 if option cannot be added.</returns>
            <remarks>
If you need to explicitly react to a changed number, then use 
override of CRhinoGet::AddCommandOption that takes a number
as an option value.  See the CRhinoGet::AddCommandOption examples.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AddCommandOption(RMA.Rhino.IRhinoCommandOptionName,System.Double)">
            <summary>Add a simple command line option with a number as a value.</summary>
            <param name="option_name">
[in] english option description automatic localization uses command option string table
</param>
            <param name="number_value">[in] current value</param>
            <returns>option index value (&gt;0) or 0 if option cannot be added.</returns>
            <remarks>In most cases it is easier to use AddCommandOptionNumber().</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AddCommandOption(RMA.Rhino.IRhinoCommandOptionName)">
            <summary>
Add a command line option. If you are adding an option to get a number,
string, toggle, or list value, then use the tools listed in the see also section.
</summary>
            <param name="option_name">[in]</param>
            <returns>option index value (&gt;0) or 0 if option cannot be added.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AddCommandOption(RMA.Rhino.IRhinoCommandOptionName,RMA.Rhino.IRhinoCommandOptionValue)">
            <summary>
Add a command line option. If you are adding an option to get a number,
string, toggle, or list value, then use the tools listed in the see also section.
</summary>
            <param name="option_name">[in]</param>
            <param name="option_value">[in] optional description of current value (not automaically localized)</param>
            <returns>option index value (&gt;0) or 0 if option cannot be added.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.AddCommandOption(RMA.Rhino.IRhinoCommandOptionName,RMA.Rhino.IRhinoCommandOptionValue,System.Boolean)">
            <summary>
Add a command line option. If you are adding an option to get a number,
string, toggle, or list value, then use the tools listed in the see also section.
</summary>
            <param name="option_name">[in]</param>
            <param name="option_value">[in] optional description of current value (not automaically localized)</param>
            <param name="bHiddenOption">
[in] if true, the option is not displayed on the command line and the
full option name must be typed in order to activate the option.
</param>
            <returns>option index value (&gt;0) or 0 if option cannot be added.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.GotDefault">
            <returns>
true if user pressed ENTER to accept a default point, number, or string set
using SetDefaultPoint, SetDefaultNumber, or SetDefaultString.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.ClearDefault">
            <summary>
Clears any defaults set using SetDefaultPoint, SetDefaultNumber, SetDefaultString,
or SetCommandPromptDefault
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.SetDefaultColor(RMA.OpenNURBS.IOnColor)">
            <summary>
Set a color as default value that will be returned if the user presses ENTER key during the get.
</summary>
            <param name="default_color">[in] value for default color</param>
            <remarks>
Calling SetDefaultColor will automatically handle setting the command
prompt default and reacting to the user pressing ENTER. If the user presses
ENTER to accept the default color, CRhinoGet::color is returned and
CRhinoGet::GotDefault() will return true. Calling SetDefaultColor will clear
any previous calls to SetDefaultString or SetDefaultPoint.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.SetDefaultString(System.String)">
            <summary>
Set a string as default value that will be returned if the user presses ENTER key during the get.
</summary>
            <param name="default_string">[in] value for default string</param>
            <remarks>
Calling SetDefaultString will automatically handle setting the command
prompt default and reacting to the user pressing ENTER. If the user presses
ENTER to accept the default string, CRhinoGet::string is returned and
CRhinoGet::GotDefault() will return true. Calling SetDefaultString will
clear any previous calls to SetDefaultNumber or SetDefaultPoint.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.SetDefaultInteger(System.Int32)">
            <summary>
Set a number as default value that will be returned if the user presses ENTER key during the get.
</summary>
            <param name="default_integer">[in] value for default number</param>
            <remarks>
Calling SetDefaultInteger will automatically handle setting the command
prompt default and reacting to the user pressing ENTER. If the user presses
ENTER to accept the default integer, CRhinoGet::number is returned and
CRhinoGet::GotDefault() will return true. Calling SetDefaultNumber will
clear any previous calls to SetDefaultString or SetDefaultPoint.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.SetDefaultNumber(System.Double)">
            <summary>
Set a number as default value that will be returned if the user presses ENTER key during the get.
</summary>
            <param name="default_number">[in] value for default number</param>
            <remarks>
Calling SetDefaultNumber will automatically handle setting the command
prompt default and reacting to the user pressing ENTER. If the user presses
ENTER to accept the default number, CRhinoGet::number is returned and
CRhinoGet::GotDefault() will return true. Calling SetDefaultNumber will clear
any previous calls to SetDefaultString or SetDefaultPoint.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.SetDefaultNumber(System.Double,System.String)">
            <summary>
Set a number as default value that will be returned if the user presses ENTER key during the get.
</summary>
            <param name="default_number">[in] value for default number</param>
            <param name="format">
[in] If null, RhinoFormatNumber() is used to format the number.
If not null, format is used to format the number.
For example, if you want the default to always have "%g" format,
then you would pass L"%g" as the format string. A non-null format
string must have EXACTLY one %...e, %...f, or %...g in it.
</param>
            <remarks>
Calling SetDefaultNumber will automatically handle setting the command
prompt default and reacting to the user pressing ENTER. If the user presses
ENTER to accept the default number, CRhinoGet::number is returned and
CRhinoGet::GotDefault() will return true. Calling SetDefaultNumber will clear
any previous calls to SetDefaultString or SetDefaultPoint.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.SetDefaultPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Set a point as default value that will be returned if the user presses the ENTER key during the get.
</summary>
            <param name="default_point">[in] value for default point</param>
            <remarks>
Calling SetDefaultPoint will automatically handle setting the command prompt
default and reacting to the user pressing ENTER. If the user presses enter
to accept the default point, CRhinoGet::point is returned and
CRhinoGet::GotDefault() will return true. Calling SetDefaultPoint will clear
any previous calls to SetDefaultString or SetDefaultNumber.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.SetCommandPromptDefault(System.String)">
            <summary>
Set message that describes what default value will be used if the user presses enter.
This description appears in angle brackets &lt;&gt; in the command prompt window.
You do not need to provide a default value description unless you explicity enable AcceptNothing.
</summary>
            <param name="default_value">[in] description of default value.</param>
            <remarks>
If you have a simple default point, number, or string, it is easier to use
SetDefaultPoint, SetDefaultNumber, or SetDefaultString. SetCommandPromptDefault
and AcceptNothing can be used for providing more advanced UI behavior.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.SetCommandPrompt(System.String)">
            <summary>Set prompt message that appears in the command prompt window.</summary>
            <param name="prompt">[in] command prompt message.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.IsGetColor">
            <returns>true if the get is or will be a CRhinoGetString::GetColor()</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.IsGetOption">
            <returns>true if the get is or will be a CRhinoGetString::GetOption()</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.IsGetNumber">
            <returns>true if the get is or will be a CRhinoGetString::GetNumber()</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.IsGetMeshes">
            <returns>true if the get is or will be getting meshes.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.IsGetString">
            <returns>true if the get is or will be a CRhinoGetString::GetString()</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.IsGetObject">
            <returns>true if the get is or will be a CRhinoGetObject::GetObject()</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.IsGetPoint">
            <returns>true if the get is or will be a CRhinoGetPoint::GetPoint()</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.IsValidOptionValueName(System.String)">
            <summary>
Test a string to see if it can be used as an option value in
CRhinoGet::AddCommandOption, CRhinoGet::AddCommandOptionToggle,
or CRhinoGet::AddCommandOptionList.
</summary>
            <returns>true if string can be used as an option value.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGet.IsValidOptionName(System.String)">
            <summary>
Test a string to see if it can be used as an option name in any of the
CRhinoGet::AddCommandOption...() functions.
</summary>
            <returns>true if string can be used as an option name.</returns>
        </member>
        <member name="T:RMA.Rhino.MRhinoGet">
            <summary>
Base class for CRhinoGetObject, CRhinoGetPoint, CRhinoGetSphere, etc.

You will never directly create a CRhinoGet but you will use its member
functions after calling CRhinoGetObject::GetObject(), 
CRhinoGetPoint::GetPoint(), and so on.

Provides tools to set command prompt, set command options, and specify
if the "get" can optionally accept numbers, nothing (pressing enter),
and undo.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGet.SerialNumber">
            <summary>
Description: Used to get Windows message if Get*() returns CRhinoGet::winmsg. Returns: Windows message.
</summary>
            <summary>
low level tool used to identify the get
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGet.Line2d(System.Drawing.Point@,System.Drawing.Point@)">
            <summary>
Location in view window of 2d line selected in CRhinoGetPoint::Get2dLine().
(0,0) = upper left corner of window
</summary>
            <remarks>Call CRhinoGet::View() to get the view window.</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoGet.Rectangle2d">
            <summary>
Location in view of 2d rectangle selected in CRhinoGetPoint::Get2dRectangle().
rect.left &lt; rect.right and rect.top &lt; rect.bottom
(0,0) = upper left corner of window
</summary>
            <remarks>Call CRhinoGet::View() to get the view window.</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoGet.Point2d">
            <summary>
Location in view of point in selected in CRhinoGetPoint::GetPoint() or
CRhinoGetPoint::Get2dPoint(). (0,0) = upper left corner of window
</summary>
            <remarks>Call CRhinoGet::View() to get the view window.</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoGet.PickRect">
            <summary>
If the get was a GetObjects() and the mouse was used to select the objects,
then the returned rect has left &lt; right and top &lt; bottom. This rect
is the Windows GDI screen coordinates of the picking rectangle.
View()-&gt;Viewport().GetPickXform( m_pick_rect, pick_xform ) will calculate
the picking transformation that was used. In all other cases, left=right=top=bottom=0;
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGet.View">
            <summary>
Used to get view user clicked in during CRhinoGetPoint::GetPoint(),
CRhinoGetObject::GetObject(), etc.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGet.Color">
            <summary>Used to get color if Get*() returns CRhinoGet::color.</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGet.Vector">
            <summary>
Used to get direction if Get*() returns CRhinoGet::point.
(Set by some digitizers, but in general it's (0,0,0);
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGet.Point">
            <summary>Used to get point if Get*() returns CRhinoGet::point.</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGet.String">
            <summary>
Used to get string if CRhinoGetPoint::GetPoint(),
RhinoGetObject::GetObject(), etc., returns CRhinoGet::string.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGet.Option">
            <summary>
Used to get option if CRhinoGetPoint::GetPoint(),
CRhinoGetObject::GetObject(), etc., returns CRhinoGet::option.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGet.CommandResult">
            <summary>Handy tool for getting command result value from getter results.</summary>
            <returns>
CRhinoCommand::cancel if CRhinoGet::Result() == CRhinoGet::cancel
CRhinoCommand::exit_rhino if CRhinoGet::Result() == CRhinoGet::exit_rhino
CRhinoCommand::success otherwise
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoGet.GetResult">
            <summary>
Used to get result code returned by CRhinoGetPoint::GetPoint(),
CRhinoGetObject::GetObject(), etc.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGet.GotDefault">
            <returns>
true if user pressed ENTER to accept a default point, number, or string set
using SetDefaultPoint, SetDefaultNumber, or SetDefaultString.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoGet.IsGetColor">
            <returns>true if the get is or will be a CRhinoGetString::GetColor()</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoGet.IsGetOption">
            <returns>true if the get is or will be a CRhinoGetString::GetOption()</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoGet.IsGetNumber">
            <returns>true if the get is or will be a CRhinoGetString::GetNumber()</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoGet.IsGetMeshes">
            <returns>true if the get is or will be getting meshes.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoGet.IsGetString">
            <returns>true if the get is or will be a CRhinoGetString::GetString()</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoGet.IsGetObject">
            <returns>true if the get is or will be a CRhinoGetObject::GetObject()</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoGet.IsGetPoint">
            <returns>true if the get is or will be a CRhinoGetPoint::GetPoint()</returns>
        </member>
        <member name="T:RMA.Rhino.IRhinoGet.result">
            <summary>
Possible results from CRhinoGetObject::GetObject(),
CRhinoGetPoint::GetPoint(), etc.
</summary>
        </member>
        <member name="T:RMA.Rhino.IRhinoGet">
            <summary>
Base class for CRhinoGetObject, CRhinoGetPoint, CRhinoGetSphere, etc.

You will never directly create a CRhinoGet but you will use its member
functions after calling CRhinoGetObject::GetObject(), 
CRhinoGetPoint::GetPoint(), and so on.

Provides tools to set command prompt, set command options, and specify
if the "get" can optionally accept numbers, nothing (pressing enter),
and undo.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayerTable.GetUnusedLayerName(System.String@)">
            <summary>Gets unused layer name used as default when creating new layers.</summary>
            <param name="layer_name">[out] new layer name</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayerTable.GetUnusedLayerName(System.String@,System.Boolean)">
            <summary>Gets unused layer name used as default when creating new layers.</summary>
            <param name="layer_name">[out] new layer name</param>
            <param name="bIgnoreDeleted">[in] if this is true then may use a name used by a deleted layer.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayerTable.GetSortedList(RMA.Rhino.IRhinoLayer[]@)">
            <summary>
Gets an array of pointers to layers that is sorted by
the values of CRhinoLayer::m_sort_index.
</summary>
            <param name="sorted_list">
[out] this array is returned with length LayerCount() and is sorted by the values of CRhinoLayer::m_sort_index.
</param>
            <remarks>Use Sort() to set the values of m_sort_index.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayerTable.GetSortedList(RMA.Rhino.IRhinoLayer[]@,System.Boolean)">
            <summary>
Gets an array of pointers to layers that is sorted by
the values of CRhinoLayer::m_sort_index.
</summary>
            <param name="sorted_list">
[out] this array is returned with length LayerCount() and is sorted by the values of CRhinoLayer::m_sort_index.
</param>
            <param name="bIgnoreDeleted">[in] true means don't include deleted layers.</param>
            <remarks>Use Sort() to set the values of m_sort_index.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayerTable.UndeleteLayer(System.Int32)">
            <summary>Undeletes a layer that has been deleted by DeleteLayer().</summary>
            <param name="layer_index">
[in] zero based index of layer to undelete.
This must be in the range 0 &lt;= layer_index &lt; LayerCount().
</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayerTable.DeleteLayers(System.Int32[],System.Boolean)">
            <summary>Deletes multiple layers</summary>
            <param name="layer_index_list">
[in] array zero based indices of layers to delete.
The indices must be in the range 0 &lt;= layer_index &lt; LayerCount().
</param>
            <param name="bQuiet">
[in] If true, no warning message box appears if a layer
cannot be deleted because it is the current layer,
contains active geometry, and so on.
</param>
            <returns>
Number of layers that were deleted.  If this is &lt; layer_index_count,
you can dig through the layer table and check which ones were not deleted.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayerTable.DeleteLayer(System.Int32,System.Boolean)">
            <summary>Deletes layer</summary>
            <param name="layer_index">
[in] zero based index of layer to delete.
This must be in the range 0 &lt;= layer_index &lt; LayerCount().
</param>
            <param name="bQuiet">
[in] If true, no warning message box appears if a layer
the layer cannot be deleted because it is the current layer
or it contains active geometry.
</param>
            <returns>
true if successful. false if layer_index is out of range or the
the layer cannot be deleted because it is the current layer or
because it layer contains active geometry.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayerTable.UndoModifyLayer(System.Int32)">
            <summary>
If the layer has been modified and the modifcation can be undone,
then UndoModify() will restore the layer to its previous state.
</summary>
            <returns>
true if this layer had been modified and the modifications were undone.
See Also: IsModified.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayerTable.UndoModifyLayer(System.Int32,System.UInt32)">
            <summary>
If the layer has been modified and the modifcation can be undone,
then UndoModify() will restore the layer to its previous state.
</summary>
            <returns>
true if this layer had been modified and the modifications were undone.
See Also: IsModified.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayerTable.ModifyLayer(RMA.OpenNURBS.IOnLayer,System.Int32)">
            <summary>Modify layer settings</summary>
            <param name="layer">[in] new settings.  This information is copied.</param>
            <param name="layer_index">
[in] zero based index of layer to set. This must be in the range 0 &lt;= layer_index &lt; LayerCount().
</param>
            <returns>
true if successful. false if layer_index is out of range
or the settings attempt to lock or hide the current layer.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayerTable.ModifyLayer(RMA.OpenNURBS.IOnLayer,System.Int32,System.Boolean)">
            <summary>Modify layer settings</summary>
            <param name="layer">[in] new settings.  This information is copied.</param>
            <param name="layer_index">
[in] zero based index of layer to set. This must be in the range 0 &lt;= layer_index &lt; LayerCount().
</param>
            <param name="bQuiet">
[in] if true, information message boxes pop up when illegal changes are attempted.
</param>
            <returns>
true if successful. false if layer_index is out of range
or the settings attempt to lock or hide the current layer.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayerTable.AddLayer">
            <summary>Adds a new layer with default definition to the layer table.</summary>
            <returns>index of new layer</returns>
            <remarks>
In some cases, calling AddLayer() can cause the memory 
references previously returned by operator[] and 
CurrentLayer() to become invalid.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayerTable.AddLayer(System.Boolean)">
            <summary>Adds a new layer with default definition to the layer table.</summary>
            <param name="bReference">
[in] true if this layer is a reference layer. Reference layers are not saved in files.
</param>
            <returns>index of new layer</returns>
            <remarks>
In some cases, calling AddLayer() can cause the memory 
references previously returned by operator[] and 
CurrentLayer() to become invalid.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayerTable.AddLayer(RMA.OpenNURBS.IOnLayer)">
            <summary>Adds a new layer with specified definition to the layer table.</summary>
            <param name="layer">
[in] definition of new layer. The information in layer is copied.
If layer.LayerName() is empty then a unique name of the form
"Layer 01" will be automatically created.
</param>
            <returns>
&gt;=0     index of new layer
-1      layer not added because a layer with that name already exists.
</returns>
            <remarks>
In some cases, calling AddLayer() can cause the memory 
references previously returned by operator[] and 
CurrentLayer() to become invalid.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayerTable.AddLayer(RMA.OpenNURBS.IOnLayer,System.Boolean)">
            <summary>Adds a new layer with specified definition to the layer table.</summary>
            <param name="layer">
[in] definition of new layer. The information in layer is copied.
If layer.LayerName() is empty then a unique name of the form
"Layer 01" will be automatically created.
</param>
            <param name="bReference">
[in] true if this layer is a reference layer. Reference layers are not saved in files.
</param>
            <returns>
&gt;=0     index of new layer
-1      layer not added because a layer with that name already exists.
</returns>
            <remarks>
In some cases, calling AddLayer() can cause the memory 
references previously returned by operator[] and 
CurrentLayer() to become invalid.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayerTable.FindLayer(System.Guid)">
            <summary>Find a layer with a matching id</summary>
            <param name="layer_id">[in]</param>
            <returns>
-1 if no matching layer is found
&gt;=0 index of matching layer
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayerTable.FindLayer(System.Guid,System.Boolean)">
            <summary>Find a layer with a matching id</summary>
            <param name="layer_id">[in]</param>
            <param name="bIgnoreDeletedLayers">[in] If true, deleted layers are not checked</param>
            <returns>
-1 if no matching layer is found
&gt;=0 index of matching layer
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayerTable.FindLayer(System.String)">
            <summary>Finds the layer with a given name.</summary>
            <param name="layer_name">
[in] name of layer to search for. The search ignores case.
</param>
            <returns>
&gt;=0     index of the layer with the given name
-1      no layer has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayerTable.FindLayer(System.String,System.Boolean)">
            <summary>Finds the layer with a given name.</summary>
            <param name="layer_name">
[in] name of layer to search for. The search ignores case.
</param>
            <param name="bIgnoreDeletedLayers">
[in] true means don't search deleted layers.
</param>
            <returns>
&gt;=0     index of the layer with the given name
-1      no layer has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayerTable.CurrentLayer">
            <summary>
At all times, there is a "current" layer.  Unless otherwise
specified, new objects are assigned to the current layer.
The current layer is never locked, hidden, or deleted.
</summary>
            <returns>
Reference to the current layer.  Note that this reference
may become invalid after a call to AddLayer().
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayerTable.SetCurrentLayerIndex(System.Int32)">
            <summary>
At all times, there is a "current" layer.  Unless otherwise
specified, new objects are assigned to the current layer.
The current layer is never locked, hidden, or deleted.
</summary>
            <param name="layer_index">
[in] value for new current layer. 0 &lt;= layer_index &lt; LayerCount().
The layer's mode is automatically set to ON::normal_mode.
</param>
            <returns>true if current layer index successfully set.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayerTable.SetCurrentLayerIndex(System.Int32,System.Boolean)">
            <summary>
At all times, there is a "current" layer.  Unless otherwise
specified, new objects are assigned to the current layer.
The current layer is never locked, hidden, or deleted.
</summary>
            <param name="layer_index">
[in] value for new current layer. 0 &lt;= layer_index &lt; LayerCount().
The layer's mode is automatically set to ON::normal_mode.
</param>
            <param name="bQuiet">
[in] if true, then no warning message box pops up if the
current layer request can't be satisfied.
</param>
            <returns>true if current layer index successfully set.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayerTable.CurrentLayerIndex">
            <summary>
At all times, there is a "current" layer.  Unless otherwise
specified, new objects are assigned to the current layer.
The current layer is never locked, hidden, or deleted.
</summary>
            <returns>Zero based layer table index of the current layer.</returns>
        </member>
        <member name="P:RMA.Rhino.MRhinoLayerTable.Item(System.Int32)">
            <summary>
Conceptually, the layer table is an array of LayerCount()
layers.  The operator[] can be used to get individual
layers.  A layer is either active or deleted and this
state is reported by CRhinoLayer::IsDeleted().
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayerTable.LayerCount">
            <returns>
Number of layers in the layer table, including deleted layers.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayerTable.GetDefaultLayerProperties(RMA.OpenNURBS.OnLayer@)">
            <summary>Initializes an ON_Layer with the current default layer properties.</summary>
            <param name="layer">[out] properties returned here</param>
            <remarks>
The default layer properties are:
color              RhinoApp().AppSettings().AppearanceSettings.m_default_layer_color
line style         RhinoApp().AppSettings().AppearanceSettings.m_default_layer_line_style
material index     -1
iges level         -1
mode               ON::normal_layer
name               empty
layer index        0 (ignored by AddLayer)
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayerTable.Document">
            <summary>Layer tables store the list of layers in a Rhino document.</summary>
            <returns>CRhinoDocument that owns this layer table.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoLayerTable.GetUnusedLayerName(System.String@)">
            <summary>Gets unused layer name used as default when creating new layers.</summary>
            <param name="layer_name">[out] new layer name</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoLayerTable.GetUnusedLayerName(System.String@,System.Boolean)">
            <summary>Gets unused layer name used as default when creating new layers.</summary>
            <param name="layer_name">[out] new layer name</param>
            <param name="bIgnoreDeleted">[in] if this is true then may use a name used by a deleted layer.</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoLayerTable.GetSortedList(RMA.Rhino.IRhinoLayer[]@)">
            <summary>
Gets an array of pointers to layers that is sorted by
the values of CRhinoLayer::m_sort_index.
</summary>
            <param name="sorted_list">
[out] this array is returned with length LayerCount() and is sorted by the values of CRhinoLayer::m_sort_index.
</param>
            <remarks>Use Sort() to set the values of m_sort_index.</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoLayerTable.GetSortedList(RMA.Rhino.IRhinoLayer[]@,System.Boolean)">
            <summary>
Gets an array of pointers to layers that is sorted by
the values of CRhinoLayer::m_sort_index.
</summary>
            <param name="sorted_list">
[out] this array is returned with length LayerCount() and is sorted by the values of CRhinoLayer::m_sort_index.
</param>
            <param name="bIgnoreDeleted">[in] true means don't include deleted layers.</param>
            <remarks>Use Sort() to set the values of m_sort_index.</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoLayerTable.FindLayer(System.Guid)">
            <summary>Find a layer with a matching id</summary>
            <param name="layer_id">[in]</param>
            <returns>
-1 if no matching layer is found
&gt;=0 index of matching layer
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoLayerTable.FindLayer(System.Guid,System.Boolean)">
            <summary>Find a layer with a matching id</summary>
            <param name="layer_id">[in]</param>
            <param name="bIgnoreDeletedLayers">[in] If true, deleted layers are not checked</param>
            <returns>
-1 if no matching layer is found
&gt;=0 index of matching layer
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoLayerTable.FindLayer(System.String)">
            <summary>Finds the layer with a given name.</summary>
            <param name="layer_name">
[in] name of layer to search for. The search ignores case.
</param>
            <returns>
&gt;=0     index of the layer with the given name
-1      no layer has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoLayerTable.FindLayer(System.String,System.Boolean)">
            <summary>Finds the layer with a given name.</summary>
            <param name="layer_name">
[in] name of layer to search for. The search ignores case.
</param>
            <param name="bIgnoreDeletedLayers">
[in] true means don't search deleted layers.
</param>
            <returns>
&gt;=0     index of the layer with the given name
-1      no layer has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoLayerTable.CurrentLayer">
            <summary>
At all times, there is a "current" layer.  Unless otherwise
specified, new objects are assigned to the current layer.
The current layer is never locked, hidden, or deleted.
</summary>
            <returns>
Reference to the current layer.  Note that this reference
may become invalid after a call to AddLayer().
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoLayerTable.CurrentLayerIndex">
            <summary>
At all times, there is a "current" layer.  Unless otherwise
specified, new objects are assigned to the current layer.
The current layer is never locked, hidden, or deleted.
</summary>
            <returns>Zero based layer table index of the current layer.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoLayerTable.LayerCount">
            <returns>
Number of layers in the layer table, including deleted layers.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoLayerTable.GetDefaultLayerProperties(RMA.OpenNURBS.OnLayer@)">
            <summary>Initializes an ON_Layer with the current default layer properties.</summary>
            <param name="layer">[out] properties returned here</param>
            <remarks>
The default layer properties are:
color              RhinoApp().AppSettings().AppearanceSettings.m_default_layer_color
line style         RhinoApp().AppSettings().AppearanceSettings.m_default_layer_line_style
material index     -1
iges level         -1
mode               ON::normal_layer
name               empty
layer index        0 (ignored by AddLayer)
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoLayerTable.Document">
            <summary>Layer tables store the list of layers in a Rhino document.</summary>
            <returns>CRhinoDocument that owns this layer table.</returns>
        </member>
        <member name="P:RMA.Rhino.IRhinoLayerTable.Item(System.Int32)">
            <summary>
Conceptually, the layer table is an array of LayerCount()
layers.  The operator[] can be used to get individual
layers.  A layer is either active or deleted and this
state is reported by CRhinoLayer::IsDeleted().
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayer.ParentLayer(System.Boolean)">
            <summary>Returns parent of a layer.</summary>
            <param name="bRootLevelParent">
[in] If true, the root level parent is returned. The root level parent never has a parent.
If false, the immediate parent is returned. The immediate parent may have a parent.
</param>
            <returns>
A pointer to the parent or NULL if this layer does not have a parent.
Calls to CRhinoLayerTable::AddLayer() may make this pointer invalid.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayer.LayerLinetype">
            <summary>Gets the linetype for this layer.</summary>
            <returns>The linetype associated with this layer.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayer.LayerMaterial">
            <summary>
Gets the rendering material for this layer.  The
default layer material is 
RhinoApp().AppSettings().DefaultMaterial()
</summary>
            <returns>The rendering material associated with this layer.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayer.IsModified">
            <summary>Rhino provides the ability to undo layer modifications.</summary>
            <returns>
true if this layer has been modified by 
CRhinoLayerTable::ModifyLayer()and the modifications can be undone.
See Also: UndoModify.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayer.IsReference">
            <summary>
Rhino allows multiple files to be viewed simultaneously.
Layers in the document are "normal" or "reference".
Reference layers are not saved.
</summary>
            <returns>
true if layer is in a reference file and will not be
saved as part of this document.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayer.IsDeleted">
            <summary>
Deleted layers are kept in the runtime layer table
so that undo will work with layers.  Call IsDeleted()
to determine if a layer is deleted.
</summary>
            <returns>true if layer is deleted.</returns>
        </member>
        <member name="P:RMA.Rhino.MRhinoLayer.m_sublayer_bVisible">
            <value>
Chached layer state settings that are used when the
parent layer is visible or unlocked.
Example:
 When parent layer is visible, this layer's 
 m_bVisible = m_sublayer_bVisible.
 When the parent layer is not visible, this layer's
 m_bVisible = false and m_sublayer_bVisible
 stores the state to use when the parent becomes visible.
 When the parent layer is NOT locked, this layer's
 m_bLocked = m_sublayer_bLocked.  When a parent layer
 is locked, this layer's m_bLocked = false and the
 m_sublayer_bLocked saves the state to use when
 the parent becomes unlocked.
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoLayer.m_remap_index">
            <value>
Runtime index used when remapping layers for import/export
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoLayer.m_sort_index">
            <value>
Runtime index used to sort layers in layer dialog
</value>
        </member>
        <member name="M:RMA.Rhino.IRhinoLayer.ParentLayer(System.Boolean)">
            <summary>Returns parent of a layer.</summary>
            <param name="bRootLevelParent">
[in] If true, the root level parent is returned. The root level parent never has a parent.
If false, the immediate parent is returned. The immediate parent may have a parent.
</param>
            <returns>
A pointer to the parent or NULL if this layer does not have a parent.
Calls to CRhinoLayerTable::AddLayer() may make this pointer invalid.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoLayer.LayerLinetype">
            <summary>Gets the linetype for this layer.</summary>
            <returns>The linetype associated with this layer.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoLayer.LayerMaterial">
            <summary>
Gets the rendering material for this layer.  The
default layer material is 
RhinoApp().AppSettings().DefaultMaterial()
</summary>
            <returns>The rendering material associated with this layer.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoLayer.IsModified">
            <summary>Rhino provides the ability to undo layer modifications.</summary>
            <returns>
true if this layer has been modified by 
CRhinoLayerTable::ModifyLayer()and the modifications can be undone.
See Also: UndoModify.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoLayer.IsReference">
            <summary>
Rhino allows multiple files to be viewed simultaneously.
Layers in the document are "normal" or "reference".
Reference layers are not saved.
</summary>
            <returns>
true if layer is in a reference file and will not be
saved as part of this document.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoLayer.IsDeleted">
            <summary>
Deleted layers are kept in the runtime layer table
so that undo will work with layers.  Call IsDeleted()
to determine if a layer is deleted.
</summary>
            <returns>true if layer is deleted.</returns>
        </member>
        <member name="P:RMA.Rhino.IRhinoLayer.m_sublayer_bVisible">
            <value>
Chached layer state settings that are used when the
parent layer is visible or unlocked.
Example:
 When parent layer is visible, this layer's 
 m_bVisible = m_sublayer_bVisible.
 When the parent layer is not visible, this layer's
 m_bVisible = false and m_sublayer_bVisible
 stores the state to use when the parent becomes visible.
 When the parent layer is NOT locked, this layer's
 m_bLocked = m_sublayer_bLocked.  When a parent layer
 is locked, this layer's m_bLocked = false and the
 m_sublayer_bLocked saves the state to use when
 the parent becomes unlocked.
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoLayer.m_remap_index">
            <value>
Runtime index used when remapping layers for import/export
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoLayer.m_sort_index">
            <value>
Runtime index used to sort layers in layer dialog
</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayerNode.IsParentLayer(System.Int32)">
            <summary>
After Create() has been called, IsParentLayer can be used to quickly see
if parent_layer_index is the index of a parent of "this" layer.
</summary>
            <param name="parent_layer_index">[in]</param>
            <returns>
True if parent_layer_index is the index of a parent layer.
See Also: CRhinoLayerNode::Create CRhinoLayerNode::IsChildLayer
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayerNode.IsChildLayer(System.Int32)">
            <summary>
After Create() has been called, IsChildLayer can be used to quickly see
if child_layer_index is the index of a child of "this" layer.
</summary>
            <param name="child_layer_index">[in]</param>
            <returns>
True if child_layer_index is the index of a child layer.
See Also: CRhinoLayerNode::Create CRhinoLayerNode::IsParentLayer
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayerNode.Create(System.Int32,System.Int32,System.Int32)">
            <summary>
Puts the layer tree information in the m_layer_index, m_parent_layer_index,
and m_child_layer_index[] array fields.
</summary>
            <param name="layer_index">[in] index of "this" layer</param>
            <param name="list_parents">
0 = no
1 = immediate parent
   If this layer has a parent, then m_parent_count=1 and
   the returned m_parent_list[] array has one element.
2 = immediate parent their parent, and so on.
   If this layer has a parent, then m_parent_count&gt;=1 and
   the returned m_parent_list[] is sorted by generation.
   m_parent_list[0] = immediate parent,
   m_parent_list[1] = grandparent,
   m_parent_list[2] = great grandparent, and so on.
</param>
            <param name="list_children">
0 = no
1 = immediate children
   If the layer has children, then m_child_count is the number
   of immediate children the returned m_child_list[] array list
   is sorted by layer index.
2 = immediate children, their children, and so on.
   If the layer has children, then m_child_count is the number of
   children, grandchildren, and so on, and the returned m_child_list[]
   array list is sorted by layer index.
</param>
            <returns>
True if input and layer table are valid and false if an index is
out of range or an error was detected in the layer tree information.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLayerNode.Create(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
Puts the layer tree information in the m_layer_index, m_parent_layer_index,
and m_child_layer_index[] array fields.
</summary>
            <param name="layer_index">[in] index of "this" layer</param>
            <param name="list_parents">
0 = no
1 = immediate parent
   If this layer has a parent, then m_parent_count=1 and
   the returned m_parent_list[] array has one element.
2 = immediate parent their parent, and so on.
   If this layer has a parent, then m_parent_count&gt;=1 and
   the returned m_parent_list[] is sorted by generation.
   m_parent_list[0] = immediate parent,
   m_parent_list[1] = grandparent,
   m_parent_list[2] = great grandparent, and so on.
</param>
            <param name="list_children">
0 = no
1 = immediate children
   If the layer has children, then m_child_count is the number
   of immediate children the returned m_child_list[] array list
   is sorted by layer index.
2 = immediate children, their children, and so on.
   If the layer has children, then m_child_count is the number of
   children, grandchildren, and so on, and the returned m_child_list[]
   array list is sorted by layer index.
</param>
            <param name="bIgnoreDeletedLayers">
If true (the default), deleted layers are not added to the lists.
If false, deleted layers are included.
</param>
            <returns>
True if input and layer table are valid and false if an index is
out of range or an error was detected in the layer tree information.
</returns>
        </member>
        <member name="P:RMA.Rhino.MRhinoLayerNode.m_parent_count">
            <value>
number of parent layers
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoLayerNode.m_child_count">
            <value>
number of child layers
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoLayerNode.m_layer_index">
            <value>
index of "this" layer
</value>
        </member>
        <member name="M:RMA.Rhino.IRhinoLayerNode.IsParentLayer(System.Int32)">
            <summary>
After Create() has been called, IsParentLayer can be used to quickly see
if parent_layer_index is the index of a parent of "this" layer.
</summary>
            <param name="parent_layer_index">[in]</param>
            <returns>
True if parent_layer_index is the index of a parent layer.
See Also: CRhinoLayerNode::Create CRhinoLayerNode::IsChildLayer
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoLayerNode.IsChildLayer(System.Int32)">
            <summary>
After Create() has been called, IsChildLayer can be used to quickly see
if child_layer_index is the index of a child of "this" layer.
</summary>
            <param name="child_layer_index">[in]</param>
            <returns>
True if child_layer_index is the index of a child layer.
See Also: CRhinoLayerNode::Create CRhinoLayerNode::IsParentLayer
</returns>
        </member>
        <member name="P:RMA.Rhino.IRhinoLayerNode.m_parent_count">
            <value>
number of parent layers
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoLayerNode.m_child_count">
            <value>
number of child layers
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoLayerNode.m_layer_index">
            <value>
index of "this" layer
</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoKeepKinkySurfaces.#ctor">
            <summary>
The constructor saves the current value of
 RhinoApp().AppSettings().GeneralSettings().m_bSplitCreasedSurfaces
in m_bSavedSetting and then sets  the app setting to false.
</summary>
        </member>
        <member name="P:RMA.Rhino.MRhinoCopyGripsHelper.m_cv_grip_index">
            <value>
If the old and new object are NURBS curves/surface/cages with
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoCopyGripsHelper.m_cv_count(System.Int32)">
            <value>
number of cvs
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoCopyGripsHelper.m_cv_grip_index">
            <value>
If the old and new object are NURBS curves/surface/cages with
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoCopyGripsHelper.m_cv_count(System.Int32)">
            <value>
number of cvs
</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectGrips.Dragging">
            <summary>
Description: Appends the status of the grips to the grip_status[] array. Parameters: grip_status - [out] Returns: Number of visible grips.
</summary>
            <summary>
Description: Set grip status. This is useful in commands that replace and copy objects. Parameters: grip_status - [in] Returns: True if status was restored.
</summary>
            <summary>
Description: Uses the m_captive_object_id[] list to get pointers to captive objects that are in the document. Paramters: captives -[out] Captives are appened to this array. bWithGripsOn - [in] If true, only captives with grips on are appended Returns: Number of objects appended to captives[].
</summary>
            <summary>
Description: Uses the m_captive_object_id[] list to get pointers to captive objects that are in the document. Paramters: captives -[out] Captives are appened to this array. bWithGripsOn - [in] If true, only captives with grips on are appended Returns: Number of objects appended to captives[].
</summary>
            <summary>
Returns: True if grips are currently begin dragged.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectGrips.MorphControl">
            <summary>
Description: If the grips control a morph control, this returns a pointer to that morph controle. You can look at but you must NEVER change this cage. Returns: A pointer to a morph control or NULL.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectGrips.NurbsCage">
            <summary>
Description: If the grips control a NURBS cage, this returns a pointer to that cage. You can look at but you must NEVER change this cage. Returns: A pointer to a NURBS cage or NULL.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectGrips.NurbsCageGrip(System.Int32,System.Int32,System.Int32)">
            <summary>
Description: If the grips are control points of a NURBS cage, then this gets the index of the grip that controls the (i,j,k)-th cv. Parameters: cv_i - [in] cv_j - [in] cv_k - [in] Returns: A grip controling a NURBS cage CV or NULL.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectGrips.NurbsSurface">
            <summary>
Description: If the grips control a NURBS surface, this returns a pointer to that surface. You can look at but you must NEVER change this surface. Returns: A pointer to a NURBS surface or NULL.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectGrips.NurbsSurfaceGrip(System.Int32,System.Int32)">
            <summary>
Description: If the grips are control points of a NURBS surface, then this gets the index of the grip that controls the (i,j)-th cv. Parameters: cv_i - [in] cv_j - [in] Returns: A grip controling a NURBS surface CV or NULL.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectGrips.NurbsCurve">
            <summary>
Description: If the grips control a NURBS curve, this returns a pointer to that curve. You can look at but you must NEVER change this curve. Returns: A pointer to a NURBS curve or NULL.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectGrips.NurbsCurveGrip(System.Int32)">
            <summary>
Description: Get all adjacent grips. Parameters: grip_index - [in] index of grip where the search begins neighbor_grips - [out] neighbors are appended to this array bWrap - [in] If true and object is "closed", the search will wrap. Returns: number of grips appended to neighbor_grips[] array.
</summary>
            <summary>
Description: If the grips are control points of a NURBS curve, then this gets the index of the grip that controls the i-th cv. Parameters: cv_i - [in] Returns: A grip controling a NURBS curve CV or NULL.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectGrips.NeighborGrip(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
Description: Get neighbors. Parameters: grip_index - [in] index of grip where the search begins dr - [in 1 = next grip in the first parameter direction -1 = prev grip in the first parameter direction ds - [in] 1 = next grip in the second parameter direction -1 = prev grip in the second parameter direction dt - [in] 1 = next grip in the third parameter direction -1 = prev grip in the third parameter direction bWrap - [in] If true and object is "closed", the search will wrap. Returns: Pointer to the desired neighbor or NULL if there is no neighbor
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectGrips.HasGripsSelected">
            <summary>
Description: Query the selection state of an object's grips. Parameters: bCheckAllGrips - [in] If false, HasGripsSelected() will return true if any grips are selected. If true, HasGripsSelected() will return true if all grips are selected. Returns: True if all grips are selected or at least one grip is selected and bCheckAllGrips is false.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectGrips.HasGripsSelected(System.Boolean)">
            <summary>
Description: Query the selection state of an object's grips. Parameters: bCheckAllGrips - [in] If false, HasGripsSelected() will return true if any grips are selected. If true, HasGripsSelected() will return true if all grips are selected. Returns: True if all grips are selected or at least one grip is selected and bCheckAllGrips is false.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectGrips.SelectGrips">
            <summary>
Description: If an object has grips turned on, SelectGrips() can be used to change the selection state of the object's grips. Parameters: bSelect - [in] true to select, false to unselect bSynchHighlight - [in] if true, highlight state is syncronized with selection state. bPersistentSelect - [in] if true, grips are persitently selected. See Also: CRhinoObject::HasGripsSelected
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectGrips.SelectGrips(System.Boolean)">
            <summary>
Description: If an object has grips turned on, SelectGrips() can be used to change the selection state of the object's grips. Parameters: bSelect - [in] true to select, false to unselect bSynchHighlight - [in] if true, highlight state is syncronized with selection state. bPersistentSelect - [in] if true, grips are persitently selected. See Also: CRhinoObject::HasGripsSelected
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectGrips.SelectGrips(System.Boolean,System.Boolean)">
            <summary>
Description: If an object has grips turned on, SelectGrips() can be used to change the selection state of the object's grips. Parameters: bSelect - [in] true to select, false to unselect bSynchHighlight - [in] if true, highlight state is syncronized with selection state. bPersistentSelect - [in] if true, grips are persitently selected. See Also: CRhinoObject::HasGripsSelected
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectGrips.SelectGrips(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
Description: If an object has grips turned on, SelectGrips() can be used to change the selection state of the object's grips. Parameters: bSelect - [in] true to select, false to unselect bSynchHighlight - [in] if true, highlight state is syncronized with selection state. bPersistentSelect - [in] if true, grips are persitently selected. See Also: CRhinoObject::HasGripsSelected
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectGrips.Draw(RMA.Rhino.MRhinoDrawGripsSettings@)">
            <summary>
Description: The default draws the grips. Override if you need to draw dynamic stuff and then call CRhinoObjectGrips::Draw() to draw the grips themselves. Parameters: dgs - [in]
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectGrips.NewLightObject(System.Boolean)">
            <summary>
Description: Rhino calls NewLightObject() when it wants a new light that is calculated from the current grip locations. This happens once at the end of a grip drag. Parameters: bCopy - [in] If true, the light object the grips are on is left in place and a new light is added to the light table. If false, the light object is replaced. Returns: Pointer to the new light if successful. The new light is in the light table.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectGrips.DeleteGrips(RMA.OpenNURBS.Arrayint@)">
            <summary>
Description: Rhino calls DeleteGrips() when some of the object's grips are deleted. If the object supports grip deletion, like meshes, then DeleteGrips() should create a new object by deleting the indicated grips. Returns: Pointer to the new object if successful. Rhino will take care of adding this object to the document.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectGrips.NewObject">
            <summary>
Description: If the grips control just one object, then override NewObject(). When NewObject() is called, return an new object calculated from the current grip locations. This happens once at the end of a grip drag. Returns: NULL or a new object whose shape is calculated from the current grip locations. This object should not be added to the document. Remarks: This function is not used for lights.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectGrips.UpdateMesh(RMA.OpenNURBS.IOn.mesh_type)">
            <summary>
Description: Just before Rhino shades an object with grips on, it calls UpdateMesh() to update the display meshes. Grips that modify surface or mesh objects must override this fuction and modify the display meshes here.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectGrips.ResetMeshes">
            <summary>
Description: Just before Rhino turns of objec grips, it calls this function. If grips have modified any display meshes, they must override this function and restore the meshes to their original states.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectGrips.Reset">
            <summary>
Description: Resets location of all grips to original spots and cleans up stuff that was created by dynamic dragging. This is required when dragging is canceled or in the Copy command when grips are "copied". This function should not destroy the current grips and make new ones because the grips may be in a list someplace (like in the copy command). The default CRhinoObjectGrips::Reset() takes care of the grip location issues. The override should clean up dynamic workspace stuff and can call CRhinoObjectGrips::Reset() to handle resetting grip locations.
</summary>
        </member>
        <member name="P:RMA.Rhino.MRhinoObjectGrips.m_grips_id">
            <value>
This id is for distinguishing between different types
of custom grips.
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoObjectGrips.m__grips_type">
            <value>
Type of grips
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoObjectGrips.m_bGripsMoved">
            <value>
If m_bGripsMoved is true if some of the grips have 
ever been moved CRhinoGripObject::NewLocation() sets 
m_bGripsMoved=true  Nothting else should ever change
the value of m_bGripsMoved.
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoObjectGrips.m_bNewLocation">
            <value>
true if some of the grips have been moved.
CRhinoGripObject::NewLocation() sets m_bNewLocation=true 
Derived classes can set m_bNewLocation to false after 
updating temporary display information.
</value>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjectGrips.MorphControl">
            <summary>
Description: If the grips control a morph control, this returns a pointer to that morph controle. You can look at but you must NEVER change this cage. Returns: A pointer to a morph control or NULL.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjectGrips.NurbsCage">
            <summary>
Description: If the grips control a NURBS cage, this returns a pointer to that cage. You can look at but you must NEVER change this cage. Returns: A pointer to a NURBS cage or NULL.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjectGrips.NurbsCageGrip(System.Int32,System.Int32,System.Int32)">
            <summary>
Description: If the grips are control points of a NURBS cage, then this gets the index of the grip that controls the (i,j,k)-th cv. Parameters: cv_i - [in] cv_j - [in] cv_k - [in] Returns: A grip controling a NURBS cage CV or NULL.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjectGrips.NurbsSurface">
            <summary>
Description: If the grips control a NURBS surface, this returns a pointer to that surface. You can look at but you must NEVER change this surface. Returns: A pointer to a NURBS surface or NULL.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjectGrips.NurbsSurfaceGrip(System.Int32,System.Int32)">
            <summary>
Description: If the grips are control points of a NURBS surface, then this gets the index of the grip that controls the (i,j)-th cv. Parameters: cv_i - [in] cv_j - [in] Returns: A grip controling a NURBS surface CV or NULL.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjectGrips.NurbsCurve">
            <summary>
Description: If the grips control a NURBS curve, this returns a pointer to that curve. You can look at but you must NEVER change this curve. Returns: A pointer to a NURBS curve or NULL.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjectGrips.NurbsCurveGrip(System.Int32)">
            <summary>
Description: Get all adjacent grips. Parameters: grip_index - [in] index of grip where the search begins neighbor_grips - [out] neighbors are appended to this array bWrap - [in] If true and object is "closed", the search will wrap. Returns: number of grips appended to neighbor_grips[] array.
</summary>
            <summary>
Description: If the grips are control points of a NURBS curve, then this gets the index of the grip that controls the i-th cv. Parameters: cv_i - [in] Returns: A grip controling a NURBS curve CV or NULL.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjectGrips.NeighborGrip(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
Description: Get neighbors. Parameters: grip_index - [in] index of grip where the search begins dr - [in 1 = next grip in the first parameter direction -1 = prev grip in the first parameter direction ds - [in] 1 = next grip in the second parameter direction -1 = prev grip in the second parameter direction dt - [in] 1 = next grip in the third parameter direction -1 = prev grip in the third parameter direction bWrap - [in] If true and object is "closed", the search will wrap. Returns: Pointer to the desired neighbor or NULL if there is no neighbor
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjectGrips.HasGripsSelected">
            <summary>
Description: Query the selection state of an object's grips. Parameters: bCheckAllGrips - [in] If false, HasGripsSelected() will return true if any grips are selected. If true, HasGripsSelected() will return true if all grips are selected. Returns: True if all grips are selected or at least one grip is selected and bCheckAllGrips is false.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjectGrips.HasGripsSelected(System.Boolean)">
            <summary>
Description: Query the selection state of an object's grips. Parameters: bCheckAllGrips - [in] If false, HasGripsSelected() will return true if any grips are selected. If true, HasGripsSelected() will return true if all grips are selected. Returns: True if all grips are selected or at least one grip is selected and bCheckAllGrips is false.
</summary>
        </member>
        <member name="P:RMA.Rhino.IRhinoObjectGrips.m_grips_id">
            <value>
This id is for distinguishing between different types
of custom grips.
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoObjectGrips.m__grips_type">
            <value>
Type of grips
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoObjectGrips.m_bGripsMoved">
            <value>
If m_bGripsMoved is true if some of the grips have 
ever been moved CRhinoGripObject::NewLocation() sets 
m_bGripsMoved=true  Nothting else should ever change
the value of m_bGripsMoved.
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoObjectGrips.m_bNewLocation">
            <value>
Optional list of grip directions
</value>
            <value>
Optional list of captive object ids.
Use when these object grips deform more than
just the owner of these gripss.
</value>
            <value>
true if some of the grips have been moved.
CRhinoGripObject::NewLocation() sets m_bNewLocation=true 
Derived classes can set m_bNewLocation to false after 
updating temporary display information.
</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoDrawGripsSettings.RestoreViewportSettings">
            <summary>
Description: Restores viewport settings to the values in the m_saved_vp fields.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDrawGripsSettings.DrawControlPolygonLine(RMA.OpenNURBS.IOnLine,RMA.Rhino.IRhinoGripStatus,RMA.Rhino.IRhinoGripStatus)">
            <summary>
Description: A helper function for drawing lines in control polygons. Parameters: L - [in] Line between two grips gs0 - [in] Grip status at start of line. gs1 - [in] Grip status at start of line.
</summary>
        </member>
        <member name="P:RMA.Rhino.MRhinoDrawGripsSettings.m_saved_vp_color">
            <value>
vp settings when CRhinoDrawGripsSettings was created.
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoDrawGripsSettings.m_saved_vp_color">
            <value>
vp settings when CRhinoDrawGripsSettings was created.
</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoGroupObject.Create(RMA.Rhino.IRhinoDoc,System.Int32)">
            <returns>number of members in group</returns>
        </member>
        <member name="T:RMA.Rhino.MRhinoGroupGeometry">
            <summary>
CRhinoGroupObject is a transient runtime proxy CRhinoObject that is 
used during selection when a developer prefers to get a single group
reference instead of a list of the members in a group.  

A CRhinoGroupObject NEVER appears in the CRhinoDoc tables.
</summary>
        </member>
        <member name="T:RMA.Rhino.IRhinoGroupGeometry">
            <summary>
CRhinoGroupObject is a transient runtime proxy CRhinoObject that is 
used during selection when a developer prefers to get a single group
reference instead of a list of the members in a group.  

A CRhinoGroupObject NEVER appears in the CRhinoDoc tables.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatch.Hatch">
            <summary>Get a pointer to the hatch geometry</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatch.SetHatch(RMA.OpenNURBS.IOnHatch)">
            <summary>Specify the ON_Hatch geometry to be used by the Rhino Object</summary>
            <param name="hatch">[in] hatch geometry copied to object</param>
            <returns>Pointer to hatch geometry on CRhinoHatchObject.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatch.FillType">
            <summary>Returns the fill type of the hatch's pattern</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatch.SetPatternScale(System.Double)">
            <summary>
Description: Sets the scale applied to the hatch pattern when it is mapped to the hatch's plane Parameters: scale (I) - The scale Remarks: The pattern is scaled around the hatch's plane origin by this value
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatch.PatternScale">
            <summary>
Gets the scale applied to the hatch pattern when it is mapped to the hatch's plane
</summary>
            <returns>The scale</returns>
            <remarks>The pattern is scaled around the hatch's plane origin by this value</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatch.SetPatternRotation(System.Double)">
            <summary>
Sets the rotation applied to the hatch pattern when it is mapped to the hatch's plane
</summary>
            <param name="rotation">The rotation in radians</param>
            <remarks>The pattern is rotated counter-clockwise around the hatch's plane origin by this value</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatch.PatternRotation">
            <summary>
Gets the rotation applied to the hatch pattern when it is mapped to the hatch's plane
</summary>
            <returns>
The rotation in radians Remarks: The pattern is rotated counter-clockwise
around the hatch's plane origin by this value
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatch.PatternIndex">
            <summary>
copies source object UUID
</summary>
            <summary>
Returns the index of the hatch's fill pattern in the HatchPatternTable
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatch.#ctor(RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <summary>
assigns a new object UUID
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatch.#ctor">
            <summary>
assigns a new object UUID
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoHatch.Hatch">
            <summary>Get a pointer to the hatch geometry</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoHatch.FillType">
            <summary>Returns the fill type of the hatch's pattern</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoHatch.PatternScale">
            <summary>
Gets the scale applied to the hatch pattern when it is mapped to the hatch's plane
</summary>
            <returns>The scale</returns>
            <remarks>The pattern is scaled around the hatch's plane origin by this value</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoHatch.PatternRotation">
            <summary>
Gets the rotation applied to the hatch pattern when it is mapped to the hatch's plane
</summary>
            <returns>
The rotation in radians Remarks: The pattern is rotated counter-clockwise
around the hatch's plane origin by this value
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoHatch.PatternIndex">
            <summary>
Returns the index of the hatch's fill pattern in the HatchPatternTable
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoTextDot.GetScreenRectangleSize(RMA.OpenNURBS.On2dPoint@)">
            <summary>Get the size of the bounding rectangle of the text in pixels</summary>
            <param name="rect">[out] the bounding rectangle</param>
            <returns>
TRUE - success
FALSE - failure
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoTextDot.TextHeight">
            <summary>The height of the text in pixels</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoTextDot.SetTextHeight(System.Int32)">
            <summary>The height of the text in pixels</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoTextDot.FontFace">
            <summary>Get the text string for the object</summary>
            <returns>the object's user text</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoTextDot.SetFontFace(System.String)">
            <summary>Set the text string for the object</summary>
            <param name="text">[in] the text to assign to the object</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoTextDot.TextString">
            <summary>Get the text string for the object</summary>
            <returns>the object's user text</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoTextDot.SetTextString(System.String)">
            <summary>Set the text string for the object</summary>
            <param name="text">the text to assign to the object</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoTextDot.Point">
            <summary>Get a 3d definition point for the annotation object</summary>
            <returns>the point</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoTextDot.SetPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Set a 3d definition point for the annotation object</summary>
            <param name="point"> [in] the point to set</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoTextDot.SetDot(RMA.OpenNURBS.OnTextDot)">
            <summary>
Connect an ON_TextDot
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoTextDot.Create(System.String,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Create a RhinoTextDot from a text string and a point
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoTextDot.#ctor(RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <summary>
assigns a new object UUID
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoTextDot.#ctor">
            <summary>
assigns a new object UUID
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoTextDot.GetScreenRectangleSize(RMA.OpenNURBS.On2dPoint@)">
            <summary>Get the size of the bounding rectangle of the text in pixels</summary>
            <param name="rect">[out] the bounding rectangle</param>
            <returns>
TRUE - success
FALSE - failure
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoTextDot.TextHeight">
            <summary>The height of the text in pixels</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoTextDot.FontFace">
            <summary>Get the text string for the object</summary>
            <returns>the object's user text</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoTextDot.TextString">
            <summary>Get the text string for the object</summary>
            <returns>the object's user text</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoTextDot.Point">
            <summary>Get a 3d definition point for the annotation object</summary>
            <returns>the point</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoOrdinateDimension.Duplicate">
            <summary>
Description: Calculates the line segments to draw Returns: Number of arcs used in the arcs[4] array.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoOrdinateDimension.Explode(RMA.OpenNURBS.OnTextEntity2[]@,RMA.OpenNURBS.OnCurve[]@)">
            <summary>Convert the dimension to curves and text</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoOrdinateDimension.EnableGrips(System.Boolean)">
            <summary>
virtual CRhinoObject::EnableGrips override
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoOrdinateDimension.CalcDistance">
            <summary>Calculate the distance that the dimension is measuring</summary>
            <returns>the calculated distance</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoOrdinateDimension.FormatString(System.Double)">
            <summary>Format the string to display and set the m_text</summary>
            <param name="distance">Distance to display</param>
        </member>
        <member name="P:RMA.Rhino.MRhinoOrdinateDimension.m_ordinate_dimension">
            <value>
The ordinate dimension's definition is on m_ordinate_dimension.
The runtime text info is on CRhinoAnnotationObject::m_text.
</value>
        </member>
        <member name="T:RMA.Rhino.MRhinoOrdinateDimension">
            <summary>dimensions in one direction from a base point</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoOrdinateDimension.Explode(RMA.OpenNURBS.OnTextEntity2[]@,RMA.OpenNURBS.OnCurve[]@)">
            <summary>Convert the dimension to curves and text</summary>
        </member>
        <member name="P:RMA.Rhino.IRhinoOrdinateDimension.m_ordinate_dimension">
            <value>
The ordinate dimension's definition is on m_ordinate_dimension.
The runtime text info is on CRhinoAnnotationObject::m_text.
</value>
        </member>
        <member name="T:RMA.Rhino.IRhinoOrdinateDimension">
            <summary>dimensions in one direction from a base point</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAngularDimension.Duplicate">
            <summary>
Returns: Number of arcs used in the arcs[4] array.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAngularDimension.Explode(RMA.OpenNURBS.OnTextEntity2[]@,RMA.OpenNURBS.OnCurve[]@)">
            <summary>Convert the dimension to curves and text</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAngularDimension.EnableGrips(System.Boolean)">
            <summary>
virtual CRhinoObject::EnableGrips override
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAngularDimension.UpdateDimPoints(RMA.OpenNURBS.On2dPoint@)">
            <param name="arcpoint">
[in] A point on the arc in the annotation plane coordinates (ECS) that determines the radius of the arc
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoAngularDimension.CreateFromPoints(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Set the plane and definition points from WCS 3d input</summary>
            <param name="apex">[in] 3d apex of the dimension (center of the arc)</param>
            <param name="p0">[in] 3d point on first line</param>
            <param name="p1">[in] 3d point on second line</param>
            <param name="arcpt">[in] 3d point on dimension arc</param>
            <returns>True if input is valid and m_angular dimension is created.</returns>
        </member>
        <member name="P:RMA.Rhino.MRhinoAngularDimension.m_angular_dimension">
            <value>
The angular dimension's definition is on m_angular_dimension.
The runtime text info is on CRhinoAnnotationObject::m_text.
</value>
        </member>
        <member name="T:RMA.Rhino.MRhinoAngularDimension">
            <summary>dimensions angles between lines</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAngularDimension.Explode(RMA.OpenNURBS.OnTextEntity2[]@,RMA.OpenNURBS.OnCurve[]@)">
            <summary>Convert the dimension to curves and text</summary>
        </member>
        <member name="P:RMA.Rhino.IRhinoAngularDimension.m_angular_dimension">
            <value>
The angular dimension's definition is on m_angular_dimension.
The runtime text info is on CRhinoAnnotationObject::m_text.
</value>
        </member>
        <member name="T:RMA.Rhino.IRhinoAngularDimension">
            <summary>dimensions angles between lines</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoRadialDimension.Duplicate">
            <summary>
Returns: Number of lines used in the lines[4] array.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoRadialDimension.Explode(RMA.OpenNURBS.OnTextEntity2[]@,RMA.OpenNURBS.OnCurve[]@)">
            <summary>Convert the dimension to curves and text</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoRadialDimension.EnableGrips(System.Boolean)">
            <summary>
virtual CRhinoObject::EnableGrips override
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoRadialDimension.UpdateDimPoints(RMA.OpenNURBS.On2dPoint@,RMA.OpenNURBS.On2dPoint@)">
            <summary>
Uses the input points to set the arrow and knee points and then automatically sets the tail point.
</summary>
            <param name="arrow_point">[in] 2d annotation plane coordinates (ECS)</param>
            <param name="knee_point">[in] 2d annotation plane coordinates (ECS)</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoRadialDimension.FormatString(System.Double)">
            <summary>Format the string displayed when the dimension is drawn</summary>
            <param name="distance">[in] the numeric value to format</param>
            <remarks>
The string is formatted according to the precision and display format
settings in the object's DImStyle
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoRadialDimension.CalcDistance">
            <summary>Calculate the distance that the dimension is measuring</summary>
            <returns>the calculated distance</returns>
        </member>
        <member name="P:RMA.Rhino.MRhinoRadialDimension.m_radial_dimension">
            <value>
The radial dimension's definition is on m_radial_dimension.
The runtime text info is on CRhinoAnnotationObject::m_text.
</value>
        </member>
        <member name="T:RMA.Rhino.MRhinoRadialDimension">
            <summary>dimensions diameter and radius</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoRadialDimension.Explode(RMA.OpenNURBS.OnTextEntity2[]@,RMA.OpenNURBS.OnCurve[]@)">
            <summary>Convert the dimension to curves and text</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoRadialDimension.CalcDistance">
            <summary>Calculate the distance that the dimension is measuring</summary>
            <returns>the calculated distance</returns>
        </member>
        <member name="P:RMA.Rhino.IRhinoRadialDimension.m_radial_dimension">
            <value>
The radial dimension's definition is on m_radial_dimension.
The runtime text info is on CRhinoAnnotationObject::m_text.
</value>
        </member>
        <member name="T:RMA.Rhino.IRhinoRadialDimension">
            <summary>dimensions diameter and radius</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinearDimension.UserPositionedTextPoint">
            <summary>
Returns: Number of lines used in the lines[4] array.
</summary>
            <summary>
Returns the user defined text point. The point is valid only if UserPositionedText() returns true
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinearDimension.Explode(RMA.OpenNURBS.OnTextEntity2[]@,RMA.OpenNURBS.OnCurve[]@)">
            <summary>Convert the dimension to curves and text</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinearDimension.EnableGrips(System.Boolean)">
            <summary>
virtual CRhinoObject::EnableGrips override
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinearDimension.UpdateDimPoints(RMA.OpenNURBS.On2dPoint@)">
            <summary>
Set the remaining dimension points from the first two and a dimension line offset
</summary>
            <param name="dimlinepoint">[in] - an ECS point for the dimension line to go through</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinearDimension.FormatString(System.Double)">
            <summary>Format the string displayed when the dimension is drawn</summary>
            <param name="distance">[in] the numeric value to format</param>
            <remarks>
The string is formatted according to the precision and display
format settings in the object's DImStyle
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinearDimension.CalcDistance">
            <summary>Calculate the distance that the dimension is measuring</summary>
            <returns>the calculated distance</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinearDimension.Aligned">
            <summary>Get a flag that indicates whether the dimension is Aligned or not</summary>
            <returns>
TRUE Dimension is aligned
False Dimension is not aligned
</returns>
            <remarks>
Aligned means that the dimension line orientation is parallel to the
line through the two base definition points. For most dimensions,
the direction of the dimension line is set when the dimension is made
or edited and is independant of the line through the base definition
points, as in Horizontal or Vertical dimensions.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinearDimension.SetAligned(System.Boolean)">
            <summary>Set a flag that indicates whether the dimension is Aligned or not</summary>
            <param name="bAligned">[in] TRUE to indicate Aligned</param>
            <remarks>
Aligned means that the dimension line orientation is parallel to the
line through the two base definition points. For most dimensions,
the direction of the dimension line is set when the dimension is made
or edited and is independant of the line through the base definition
points, as in Horizontal or Vertical dimensions.
</remarks>
        </member>
        <member name="P:RMA.Rhino.MRhinoLinearDimension.m_linear_dimension">
            <value>
The linear dimension's definition is on m_linear_dimension.
The runtime text info is on CRhinoAnnotationObject::m_text.
</value>
        </member>
        <member name="M:RMA.Rhino.IRhinoLinearDimension.UserPositionedTextPoint">
            <summary>
Returns: Number of lines used in the lines[4] array.
</summary>
            <summary>
Returns the user defined text point. The point is valid only if UserPositionedText() returns true
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoLinearDimension.Explode(RMA.OpenNURBS.OnTextEntity2[]@,RMA.OpenNURBS.OnCurve[]@)">
            <summary>Convert the dimension to curves and text</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoLinearDimension.Aligned">
            <summary>Get a flag that indicates whether the dimension is Aligned or not</summary>
            <returns>
TRUE Dimension is aligned
False Dimension is not aligned
</returns>
            <remarks>
Aligned means that the dimension line orientation is parallel to the
line through the two base definition points. For most dimensions,
the direction of the dimension line is set when the dimension is made
or edited and is independant of the line through the base definition
points, as in Horizontal or Vertical dimensions.
</remarks>
        </member>
        <member name="P:RMA.Rhino.IRhinoLinearDimension.m_linear_dimension">
            <value>
The linear dimension's definition is on m_linear_dimension.
The runtime text info is on CRhinoAnnotationObject::m_text.
</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationLeader.Explode(RMA.OpenNURBS.OnTextEntity2[]@,RMA.OpenNURBS.OnCurve[]@)">
            <summary>Convert the dimension to curves and text</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationLeader.EnableGrips(System.Boolean)">
            <summary>
virtual CRhinoObject::EnableGrips override
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationLeader.SetTextString(System.String)">
            <summary>Set the text string used by the leader's m_text member</summary>
            <param name="text">[in] the text for the leader to display</param>
            <returns>TRUE: success FALSE: failure</returns>
        </member>
        <member name="P:RMA.Rhino.MRhinoAnnotationLeader.m_leader">
            <value>
The leader's definition is on m_leader.
The runtime text info is on CRhinoAnnotationObject::m_text.
</value>
        </member>
        <member name="M:RMA.Rhino.IRhinoAnnotationLeader.Explode(RMA.OpenNURBS.OnTextEntity2[]@,RMA.OpenNURBS.OnCurve[]@)">
            <summary>Convert the dimension to curves and text</summary>
        </member>
        <member name="P:RMA.Rhino.IRhinoAnnotationLeader.m_leader">
            <value>
The leader's definition is on m_leader.
The runtime text info is on CRhinoAnnotationObject::m_text.
</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationText.Explode(RMA.OpenNURBS.OnCurve[]@)">
            <summary>Convert to outline curves</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationText.Corner3dPoint(System.Int32)">
            <summary>Get the world coordinates of the corner of the text block.</summary>
            <param name="point_index">
[in] 0: lower left 1: lower right 2: upper left 3: upper right
</param>
            <returns>3d point</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationText.Corner2dPoint(System.Int32)">
            <summary>Get the m_text_block.m_plane coordinates (ECS) of the corner of the text block.</summary>
            <param name="point_index">
[in] 0: lower left 1: lower right 2: upper right 3: upper left
</param>
            <returns>2d point</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationText.EnableGrips(System.Boolean)">
            <summary>
virtual CRhinoObject::EnableGrips override
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationText.SetTextHeight(System.Double)">
            <summary>Set the text height for this text block</summary>
            <param name="height">[in] the new height in model units</param>
            <remarks>
This sets the basic text height, which is usually multiplied by the Dimension Style before being used
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationText.SetFontIndex(System.Int32)">
            <summary>Set the index of the object's Font in the Font Table</summary>
            <param name="index">[in] the index in the font table to assign to this text</param>
        </member>
        <member name="P:RMA.Rhino.MRhinoAnnotationText.m_text_block">
            <value>
The text block's definition is on m_text_block.
The runtime text info is on CRhinoAnnotationObject::m_text.
</value>
        </member>
        <member name="T:RMA.Rhino.MRhinoAnnotationText">
            <summary>Provides user level text block annotation objects</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAnnotationText.Explode(RMA.OpenNURBS.OnCurve[]@)">
            <summary>Convert to outline curves</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAnnotationText.Corner3dPoint(System.Int32)">
            <summary>Get the world coordinates of the corner of the text block.</summary>
            <param name="point_index">
[in] 0: lower left 1: lower right 2: upper left 3: upper right
</param>
            <returns>3d point</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoAnnotationText.Corner2dPoint(System.Int32)">
            <summary>Get the m_text_block.m_plane coordinates (ECS) of the corner of the text block.</summary>
            <param name="point_index">
[in] 0: lower left 1: lower right 2: upper right 3: upper left
</param>
            <returns>2d point</returns>
        </member>
        <member name="P:RMA.Rhino.IRhinoAnnotationText.m_text_block">
            <value>
The text block's definition is on m_text_block.
The runtime text info is on CRhinoAnnotationObject::m_text.
</value>
        </member>
        <member name="T:RMA.Rhino.IRhinoAnnotationText">
            <summary>Provides user level text block annotation objects</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationObject.TextEntity(RMA.OpenNURBS.IOnViewport)">
            <summary>Copy an ON_TextEntity from the annotation object</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationObject.ExplodeArrow(RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOn2dVector,RMA.OpenNURBS.OnCurve[]@)">
            <summary>
Convert arrowhead to outline curves
Caller should delete output curves
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationObject.FormatDimensionAngleString(System.Double,System.String@)">
            <summary>
Formats an angle string according to the composit dimstyle+overrides
for the object and a model unit angle
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationObject.FormatDimensionDistanceString(System.Double,System.String@)">
            <summary>
Formats a distance string according to the composit dimstyle+overrides
for the object and a model unit distance
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationObject.UpdateText">
            <summary>
Calculate text location, reformat the string pre precision specs Store
string size and offset in the dimension
</summary>
            <remarks>Called by Text()-&gt;Regen() whenever the text or font or dimstyle is changed</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationObject.InvalidateRegen">
            <summary>Clear the valid regen flag so that the text will get regenerated</summary>
            <remarks>Call whenever the text or font or dimstyle is changed</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationObject.TextHeight">
            <summary>Get the text height from the dimension's style</summary>
            <returns>The height from the dimstyle referenced by this dimension</returns>
            <remarks>
This does not deal with individual dimensions, but with their dimstyles,
so changing the height may change the height of several dimensions
The height should usually be multiplied by the Dimension Scale -
DimScale() - before being used.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationObject.TextDisplayMode">
            <summary>The way the text is oriented</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationObject.SetTextDisplayMode(RMA.OpenNURBS.IOn.eTextDisplayMode)">
            <summary>The way the text is oriented</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationObject.Text">
            <summary>
Returns: A pointer to this class's m_text memeber. This pointer is never NULL.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationObject.Annotation">
            <summary>
Returns: A pointer to a class derived from ON_Annotation2. This pointer is never NULL.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationObject.SetAnnotation(RMA.OpenNURBS.IOnAnnotation,RMA.OpenNURBS.IOn3dmAnnotationSettings)">
            <summary>Initiialize the object from a Rhino 1/2 style ON_Annotation definition</summary>
            <param name="pAnnotation">[in] This information is copied</param>
            <param name="settings">[in]</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationObject.UserText">
            <summary>Get the user text string for the object</summary>
            <returns>the object's user text</returns>
            <remarks>
UserText is the string that gets printed when the dimensoin is drawn.
If it contains the token "&lt;&gt;", that token is replaced
with the measured value for the dimension, formatted according to the
DimStyle settings. "&lt;&gt;" is the default for linear
dimensions. Other dimensions include "&lt;&gt;" in their
default string
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationObject.SetUserText(System.String)">
            <summary>Set the user text string for the object</summary>
            <param name="text">the text to assign to the object</param>
            <remarks>
UserText is the string that gets printed when the dimensoin is drawn.
If it contains the token "&lt;&gt;", that token is replaced
with the measured value for the dimension, formatted according to the
DimStyle settings. "&lt;&gt;" is the default for linear
dimensions. Other dimensions include "&lt;&gt;" in their
default string
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationObject.UserPositionedText">
            <summary>
Returns: True if the text location is a fixed point by the user.
False if the text location is automatically calculated by Rhino.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationObject.SetPointCount(System.Int32)">
            <summary>Allocate space in the point array for the specified number of points</summary>
            <param name="count">[in] Count of points to allocate</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationObject.FontIndex">
            <summary>Get the index of the object's Font in the Font Table</summary>
            <returns>the object's Font index</returns>
            <remarks>
If this is a dimension, it will get its font index from its dimstyle
If its text, which doesn't use a style, it will have its own font index
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationObject.StyleIndex">
            <summary>Get the index of the object's DimStyle in the DimStyle Table</summary>
            <returns>the object's DimStyle index</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationObject.SetStyleIndex(System.Int32)">
            <summary>Set the index of the object's DimStyle in the DimStyle Table</summary>
            <param name="index">[in] the index to assign to the object</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationObject.GetDimStyle(RMA.OpenNURBS.OnDimStyle@)">
            <summary>
CRhinoAnnotationObjects reference an ON_DimStyle via a CRhinoDimStyle that is
in the DimStyleTable, and also have a local ON_DimStyle for per-object overrides
of the DimStyle in the table. This returns an ON_Dimstyle that is made of the one
in the dimstyle table with the overrides from the local dimstyle. This is the
effective dimstyle that is to be used to display the object. 
</summary>
            <param name="style">[out] an ON_Dimstyle where the results are copied to return</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationObject.Font">
            <summary>
Return the object's font.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationObject.Style">
            <summary>
Return the object's dimension style.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationObject.Point(System.Int32)">
            <summary>Get a 2d ECS definition point for the annotation object</summary>
            <returns>ON_2dPoint the ith point in the object's description</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationObject.SetPoint(System.Int32,RMA.OpenNURBS.IOn2dPoint)">
            <summary>Set a 2d ECS definition point for the annotation object</summary>
            <param name="index">[in] the index of the definition</param>
            <param name="point">[in] point the 2d point to set</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationObject.SetPlane(RMA.OpenNURBS.IOnPlane)">
            <summary>Get the objects Entity Coordinate System plane</summary>
            <param name="plane">new ECS plane to set</param>
            <remarks>
Annotation objects are defined in 2d coordinates on a plane which is described in 3d WCS coordinates.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationObject.Plane">
            <summary>Get the objects Entity Coordinate System plane</summary>
            <returns>the ECS plane</returns>
            <remarks>
Annotation objects are defined in 2d coordinates on a plane which is described in 3d WCS coordinates.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationObject.GetArrowHeadMesh(RMA.OpenNURBS.ArrayOn3dPoint@,RMA.OpenNURBS.OnMesh@)">
            <summary>
Makes a mesh by triangulating the arrowhead corners for the particular arrowhead type
</summary>
            <param name="corners">[in] corners of a polygon representing the arrowhead</param>
            <param name="mesh">[out] triangulation of the polygon</param>
            <remarks>This is used for picking the arrowhead</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationObject.GetArrowHeadCorners(RMA.OpenNURBS.IOn2dVector,RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.ArrayOn2dPoint@)">
            <summary>
2d (ECS) version
Get the corners of a polygon that contains the arrowhead.
</summary>
            <param name="dir">[in] direction of arrow head in annotation plane coordinates (ECS)</param>
            <param name="tip">[in] location of arrowhead tip in annotation plane coordinates (ECS)</param>
            <param name="corners">[out] The arrowhead polygon corners</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationObject.GetArrowHeadCorners(RMA.OpenNURBS.IOn2dVector,RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.ArrayOn3dPoint@)">
            <summary>Get the corners of a polygon that contains the arrowhead.</summary>
            <param name="dir">[in] direction of arrow head in annotation plane coordinates (ECS)</param>
            <param name="tip">[in] location of arrowhead tip in annotation plane coordinates (ECS)</param>
            <param name="corners">[out] The arrowhead polygon corners</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationObject.DrawArrowHead(RMA.OpenNURBS.IOn2dVector,RMA.OpenNURBS.IOn2dPoint,RMA.Rhino.MRhinoDisplayPipeline)">
            <summary>
This helper function is for drawing arrow heads of annotation objects.
This is the fastest way to display arrow heads
</summary>
            <param name="dir">[in] direction of arrow head</param>
            <param name="tip">[in] location of arrowhead tip</param>
            <param name="dp">[in]</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationObject.IsVisibleInViewport(RMA.OpenNURBS.IOnViewport)">
            <summary>
Returns: True if annotation is visible in this projection (and not "edge on");
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationObject.DimStyleIndex(RMA.OpenNURBS.IOn3dmAnnotationSettings)">
            <summary>
5/8/03 LW added so properties from v2 annotation can be brought into v3 files
find an appropriate dimstyle to match  the settings if there is one in the table
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationObject.DimScale">
            <summary>Gets the dimension scale of the document that owns this annotation object.</summary>
            <returns>the dimscale</returns>
            <remarks>
The dimscale is a global multiplier for text height and other sizes of 
parts of annotation objects
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationObject.GetTextXform(RMA.OpenNURBS.IOnViewport,RMA.OpenNURBS.OnXform@)">
            <summary>
Get the transformation that maps the Windows GDI RECT returned
by m_text.NormalizedRect() to world coordinates.  This transformation
is used to position every line of text in m_text.
</summary>
            <param name="vp">
[in] NULL or the view projection used to display the annotation.
The position of the text in some types of annotation depends on the view projection.
If vp is NULL, then cameraX = world X and cameraY (up) = world Y is used.
</param>
            <param name="gdi_to_world">[out]</param>
            <returns>
True if gdi_to_world is set.  False if there is not
enough information to calculate the transformation.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationObject.GetTextBoundingBox(RMA.OpenNURBS.IOnViewport,RMA.OpenNURBS.OnBoundingBox@,System.Boolean)">
            <summary>
Get a world bounding box
</summary>
            <param name="vp">
[in] NULL or the view projection used to display the annotation.
If vp is NULL, a box that contains the text in all views is returned.
</param>
            <returns>True if text_bbox is set.</returns>
        </member>
        <member name="P:RMA.Rhino.MRhinoAnnotationObject.m_text">
            <value>
The runtime text information for all annotation entities 
is stored in m_text.
</value>
        </member>
        <member name="T:RMA.Rhino.MRhinoAnnotationObject">
            <summary>
A virtual base class for annotation objects in Rhino.
Rhino annotation objects are planar entities defined in 
2d coordinates on a plane which is described in 3d WCS coordinates.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAnnotationObject.TextEntity(RMA.OpenNURBS.IOnViewport)">
            <summary>Copy an ON_TextEntity from the annotation object</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAnnotationObject.ExplodeArrow(RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOn2dVector,RMA.OpenNURBS.OnCurve[]@)">
            <summary>
Convert arrowhead to outline curves
Caller should delete output curves
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAnnotationObject.FormatDimensionAngleString(System.Double,System.String@)">
            <summary>
Formats an angle string according to the composit dimstyle+overrides
for the object and a model unit angle
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAnnotationObject.FormatDimensionDistanceString(System.Double,System.String@)">
            <summary>
Formats a distance string according to the composit dimstyle+overrides
for the object and a model unit distance
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAnnotationObject.TextHeight">
            <summary>Get the text height from the dimension's style</summary>
            <returns>The height from the dimstyle referenced by this dimension</returns>
            <remarks>
This does not deal with individual dimensions, but with their dimstyles,
so changing the height may change the height of several dimensions
The height should usually be multiplied by the Dimension Scale -
DimScale() - before being used.
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoAnnotationObject.TextDisplayMode">
            <summary>The way the text is oriented</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAnnotationObject.Text">
            <summary>
Returns: A pointer to this class's m_text memeber. This pointer is never NULL.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAnnotationObject.Annotation">
            <summary>
Returns: A pointer to a class derived from ON_Annotation2. This pointer is never NULL.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAnnotationObject.UserText">
            <summary>Get the user text string for the object</summary>
            <returns>the object's user text</returns>
            <remarks>
UserText is the string that gets printed when the dimensoin is drawn.
If it contains the token "&lt;&gt;", that token is replaced
with the measured value for the dimension, formatted according to the
DimStyle settings. "&lt;&gt;" is the default for linear
dimensions. Other dimensions include "&lt;&gt;" in their
default string
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoAnnotationObject.UserPositionedText">
            <summary>
Returns: True if the text location is a fixed point by the user.
False if the text location is automatically calculated by Rhino.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAnnotationObject.FontIndex">
            <summary>Get the index of the object's Font in the Font Table</summary>
            <returns>the object's Font index</returns>
            <remarks>
If this is a dimension, it will get its font index from its dimstyle
If its text, which doesn't use a style, it will have its own font index
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoAnnotationObject.StyleIndex">
            <summary>Get the index of the object's DimStyle in the DimStyle Table</summary>
            <returns>the object's DimStyle index</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoAnnotationObject.GetDimStyle(RMA.OpenNURBS.OnDimStyle@)">
            <summary>
CRhinoAnnotationObjects reference an ON_DimStyle via a CRhinoDimStyle that is
in the DimStyleTable, and also have a local ON_DimStyle for per-object overrides
of the DimStyle in the table. This returns an ON_Dimstyle that is made of the one
in the dimstyle table with the overrides from the local dimstyle. This is the
effective dimstyle that is to be used to display the object. 
</summary>
            <param name="style">[out] an ON_Dimstyle where the results are copied to return</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoAnnotationObject.Font">
            <summary>
Return the object's font.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAnnotationObject.Style">
            <summary>
Return the object's dimension style.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAnnotationObject.Point(System.Int32)">
            <summary>Get a 2d ECS definition point for the annotation object</summary>
            <returns>ON_2dPoint the ith point in the object's description</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoAnnotationObject.Plane">
            <summary>Get the objects Entity Coordinate System plane</summary>
            <returns>the ECS plane</returns>
            <remarks>
Annotation objects are defined in 2d coordinates on a plane which is described in 3d WCS coordinates.
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoAnnotationObject.GetArrowHeadMesh(RMA.OpenNURBS.ArrayOn3dPoint@,RMA.OpenNURBS.OnMesh@)">
            <summary>
Makes a mesh by triangulating the arrowhead corners for the particular arrowhead type
</summary>
            <param name="corners">[in] corners of a polygon representing the arrowhead</param>
            <param name="mesh">[out] triangulation of the polygon</param>
            <remarks>This is used for picking the arrowhead</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoAnnotationObject.GetArrowHeadCorners(RMA.OpenNURBS.IOn2dVector,RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.ArrayOn2dPoint@)">
            <summary>
2d (ECS) version
Get the corners of a polygon that contains the arrowhead.
</summary>
            <param name="dir">[in] direction of arrow head in annotation plane coordinates (ECS)</param>
            <param name="tip">[in] location of arrowhead tip in annotation plane coordinates (ECS)</param>
            <param name="corners">[out] The arrowhead polygon corners</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoAnnotationObject.GetArrowHeadCorners(RMA.OpenNURBS.IOn2dVector,RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.ArrayOn3dPoint@)">
            <summary>Get the corners of a polygon that contains the arrowhead.</summary>
            <param name="dir">[in] direction of arrow head in annotation plane coordinates (ECS)</param>
            <param name="tip">[in] location of arrowhead tip in annotation plane coordinates (ECS)</param>
            <param name="corners">[out] The arrowhead polygon corners</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoAnnotationObject.DrawArrowHead(RMA.OpenNURBS.IOn2dVector,RMA.OpenNURBS.IOn2dPoint,RMA.Rhino.MRhinoDisplayPipeline)">
            <summary>
This helper function is for drawing arrow heads of annotation objects.
This is the fastest way to display arrow heads
</summary>
            <param name="dir">[in] direction of arrow head</param>
            <param name="tip">[in] location of arrowhead tip</param>
            <param name="dp">[in]</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoAnnotationObject.IsVisibleInViewport(RMA.OpenNURBS.IOnViewport)">
            <summary>
Returns: True if annotation is visible in this projection (and not "edge on");
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAnnotationObject.DimScale">
            <summary>Gets the dimension scale of the document that owns this annotation object.</summary>
            <returns>the dimscale</returns>
            <remarks>
The dimscale is a global multiplier for text height and other sizes of 
parts of annotation objects
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoAnnotationObject.GetTextXform(RMA.OpenNURBS.IOnViewport,RMA.OpenNURBS.OnXform@)">
            <summary>
Get the transformation that maps the Windows GDI RECT returned
by m_text.NormalizedRect() to world coordinates.  This transformation
is used to position every line of text in m_text.
</summary>
            <param name="vp">
[in] NULL or the view projection used to display the annotation.
The position of the text in some types of annotation depends on the view projection.
If vp is NULL, then cameraX = world X and cameraY (up) = world Y is used.
</param>
            <param name="gdi_to_world">[out]</param>
            <returns>
True if gdi_to_world is set.  False if there is not
enough information to calculate the transformation.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoAnnotationObject.GetTextBoundingBox(RMA.OpenNURBS.IOnViewport,RMA.OpenNURBS.OnBoundingBox@,System.Boolean)">
            <summary>
Get a world bounding box.
</summary>
            <param name="vp">
[in] NULL or the view projection used to display the annotation.
If vp is NULL, a box that contains the text in all views is returned.
</param>
            <returns>True if text_bbox is set.</returns>
        </member>
        <member name="P:RMA.Rhino.IRhinoAnnotationObject.m_text">
            <value>
The runtime text information for all annotation entities 
is stored in m_text.
</value>
        </member>
        <member name="T:RMA.Rhino.IRhinoAnnotationObject">
            <summary>
A virtual base class for annotation objects in Rhino.
Rhino annotation objects are planar entities defined in 
2d coordinates on a plane which is described in 3d WCS coordinates.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoArrowhead.DisplayPointsECS(RMA.OpenNURBS.On2dPointArray@)">
            <summary>Get an array of 2d ECS points defining the arrowhead</summary>
            <param name="p2array">An array to return the points Returns: number of points in the array</param>
            <remarks>The points are in the Arrowhead's parent entity's ECS plane</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoArrowhead.DisplayPointsWCS(RMA.OpenNURBS.On3dPointArray@)">
            <summary>Get an array of 3d WCS points defining the arrowhead</summary>
            <param name="p3array">An array to return the points</param>
            <returns>number of points in the array</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoArrowhead.Plane">
            <summary>Return the plane associated with the arrowhead</summary>
            <returns>
The plane in which the arrow's points are mapped
May be NULL if the arrowhead is not associated with a parent
</returns>
            <remarks>The plane is the plane of the Arrowhead's parent entity</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoArrowhead.SetParent(RMA.Rhino.MRhinoAnnotationObject)">
            <summary>Set a pointer to the arrow's parent entity</summary>
            <param name="pParent">the pointer to assign</param>
            <remarks>
The points and directions of CRhinoArrowheads are in 2d coordinates with
respect to the parent entity's coordinate plane.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoArrowhead.Parent">
            <summary>Get a pointer to the arrow's parent entity</summary>
            <returns>
the pointer to the parent entity. May be NULL if the arrow isn't yet associated with a parent
</returns>
            <remarks>
The points and directions of CRhinoArrowheads are in 2d coordinates with
respect to the parent entity's coordinate plane.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoArrowhead.Direction">
            <summary>Set the 2d direction vector of the arrow</summary>
            <returns>The arrow's direction</returns>
            <remarks>The points are in 2d coordinates with respect to the parent entity's plane.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoArrowhead.SetDirection(RMA.OpenNURBS.IOn2dVector)">
            <summary>Set the 2d direction vector of the arrow</summary>
            <param name="dir">[in] direction to assign to the arrow</param>
            <remarks>The points are in 2d coordinates with respect to the parent entity's plane.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoArrowhead.Point">
            <summary>Get the 2d coordinate point at the tip of the arrow</summary>
            <returns>the point at the definition point of the arrow</returns>
            <remarks>The points are in 2d coordinates with respect to hte parent entity's plane.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoArrowhead.SetPoint(RMA.OpenNURBS.IOn2dPoint)">
            <summary>
does not change this-&gt;m_pParent
</summary>
            <summary>Set the 2d coordinate point at the tip of the arrow</summary>
            <param name="pt">[in] the point to assign to the Arrowhead</param>
            <remarks>The points are in 2d coordinates with respect to hte parent entity's plane.</remarks>
        </member>
        <member name="P:RMA.Rhino.MRhinoArrowhead.m_direction">
            <value>
Direction of arrowhead points in annotation plane coordinates (ECS).
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoArrowhead.m_point">
            <value>
Location of arrowhead tip in annotation plane coordinates (ECS).
</value>
        </member>
        <member name="T:RMA.Rhino.MRhinoArrowhead">
            <summary>A symbol to be used by annotation objects</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoArrowhead.DisplayPointsECS(RMA.OpenNURBS.On2dPointArray@)">
            <summary>Get an array of 2d ECS points defining the arrowhead</summary>
            <param name="p2array">An array to return the points Returns: number of points in the array</param>
            <remarks>The points are in the Arrowhead's parent entity's ECS plane</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoArrowhead.DisplayPointsWCS(RMA.OpenNURBS.On3dPointArray@)">
            <summary>Get an array of 3d WCS points defining the arrowhead</summary>
            <param name="p3array">An array to return the points</param>
            <returns>number of points in the array</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoArrowhead.Plane">
            <summary>Return the plane associated with the arrowhead</summary>
            <returns>
The plane in which the arrow's points are mapped
May be NULL if the arrowhead is not associated with a parent
</returns>
            <remarks>The plane is the plane of the Arrowhead's parent entity</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoArrowhead.Parent">
            <summary>Get a pointer to the arrow's parent entity</summary>
            <returns>
the pointer to the parent entity. May be NULL if the arrow isn't yet associated with a parent
</returns>
            <remarks>
The points and directions of CRhinoArrowheads are in 2d coordinates with
respect to the parent entity's coordinate plane.
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoArrowhead.Direction">
            <summary>Set the 2d direction vector of the arrow</summary>
            <returns>The arrow's direction</returns>
            <remarks>The points are in 2d coordinates with respect to the parent entity's plane.</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoArrowhead.Point">
            <summary>Get the 2d coordinate point at the tip of the arrow</summary>
            <returns>the point at the definition point of the arrow</returns>
            <remarks>The points are in 2d coordinates with respect to hte parent entity's plane.</remarks>
        </member>
        <member name="P:RMA.Rhino.IRhinoArrowhead.m_direction">
            <value>
Direction of arrowhead points in annotation plane coordinates (ECS).
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoArrowhead.m_point">
            <value>
Location of arrowhead tip in annotation plane coordinates (ECS).
</value>
        </member>
        <member name="T:RMA.Rhino.IRhinoArrowhead">
            <summary>A symbol to be used by annotation objects</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoText.Explode(RMA.OpenNURBS.OnCurve[]@)">
            <summary>
Convert to outline curves
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoText.GetTextBoundingBox(RMA.OpenNURBS.IOnViewport,RMA.OpenNURBS.OnBoundingBox@)">
            <summary>Get tight bounding box of this Rhino object.</summary>
            <param name="vp">[in] (can be NULL)</param>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoText.GetTextBoundingBox(RMA.OpenNURBS.IOnViewport,RMA.OpenNURBS.OnBoundingBox@,System.Boolean)">
            <summary>Get tight bounding box of this Rhino object.</summary>
            <param name="vp">[in] (can be NULL)</param>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in](default=false) If true and the input tight_bbox is valid, then returned
tight_bbox is the union of the input tight_bbox and the tight bounding box of this Rhino object.
</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoText.GetTextBoundingBox(RMA.OpenNURBS.IOnViewport,RMA.OpenNURBS.OnBoundingBox@,System.Boolean,RMA.OpenNURBS.IOnXform)">
            <summary>Get tight bounding box of this Rhino object.</summary>
            <param name="vp">[in] (can be NULL)</param>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in](default=false) If true and the input tight_bbox is valid, then returned
tight_bbox is the union of the input tight_bbox and the tight bounding box of this Rhino object.
</param>
            <param name="xform">
[in] (default=NULL) If not NULL, the tight bounding box of the transformed
Rhino object is calculated.  The Rhino object is not modified.
</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoText.GetTextXform(RMA.OpenNURBS.IOnViewport,RMA.OpenNURBS.OnXform@)">
            <summary>
Gets the transformation that text with a base point at (0,0) and a base line
along the x-axis to it's location in world coordinates.
</summary>
            <param name="vp">[in] (can be NULL)</param>
            <param name="gdi_to_world">[out]</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoText.GetText3dCorners(RMA.OpenNURBS.IOnXform,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@)">
            <summary>Get world 3d coordinates of the corners of the entire text block.</summary>
            <param name="gdi_to_world">[in] The tranform returned by Parent()-&gt;GetTextXform(gdi_to_world);</param>
            <param name="lower_left">[out]</param>
            <param name="lower_right">[out]</param>
            <param name="upper_right">[out]</param>
            <param name="upper_left">[out]</param>
            <returns>
True if the 3d points are set. False if there is not
enough information to calculate the points' location, i.e.,
the parent annotation object is missing.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoText.GetText2dCorners(RMA.OpenNURBS.On2dPoint@,RMA.OpenNURBS.On2dPoint@,RMA.OpenNURBS.On2dPoint@,RMA.OpenNURBS.On2dPoint@)">
            <summary>Get annotation plane coordinates of the corners of the entire text block.</summary>
            <param name="lower_left">[out]</param>
            <param name="lower_right">[out]</param>
            <param name="upper_right">[out]</param>
            <param name="upper_left">[out]</param>
            <returns>
True if the 2d points are set. False if there is not enough
information to calculate the points' location, i.e., the parent annotation object is missing.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoText.NormalizedRect">
            <returns>
The 2d bounding rectangle of the text block. The rectangle is aligned horizontally
and is in Windows GDI coordinates. The rectangle is set when the paths are calculated
in CRhinoText::MakePath(). The coordinates are for normalized text
(LOGFONT lfHeight = ON_Font::normal_font_height). The rectangle origin is at the
baseline point of the parent CRhinoText block (not this text line).
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoText.DefaultHeight">
            <summary>
Default height for new text
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoText.Regen">
            <summary>
Calculate the character cell sizes for each character
and store them on each textline
Make and store a path for the outline of the text
Both the path and the cell sizes are in normalized size.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoText.ParseTextLines">
            <summary>
separate the text strings at line breaks and save the 
start indices and counts of each line
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoText.TextLines">
            <summary>
Return an array of lines of text in the text object
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoText.CharCount">
            <summary>
Return the number of characters in the string
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoText.SetFaceName(System.String)">
            <summary>
Set the font Facename used by the text object
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoText.FaceName">
            <summary>
Return the font Facename used by the text object
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoText.SetItalic">
            <summary>
Set the text object to italic or not italic
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoText.SetItalic(System.Int32)">
            <summary>
Set the text object to italic or not italic
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoText.IsItalic">
            <summary>
Return TRUE if the text object is italic
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoText.SetBold">
            <summary>
Set the text object to bold or not bold
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoText.SetBold(System.Int32)">
            <summary>
Set the text object to bold or not bold
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoText.IsBold">
            <summary>
Return TRUE if the text object is bold
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoText.LinefeedHeight">
            <returns>
The height of linefeed in model units. The global dimension scale is not applied to
the returned value.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoText.Width">
            <returns>
The width of the string in model units. The global dimension scale is not applied to
the returned value.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoText.Height">
            <returns>
The height of an I in model units. If the text is in a CRhinoAnnotationText object,
this is the value of CRhinoAnnotationText.m_text_block.m_textheight. For all other
annotation objects, this is the value is dimstyle.m_textheight, where dimstyle is
the dimension style of the annotation. The global dimension scale is not applied to
the returned value.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoText.FontIndex">
            <summary>
Get the font table index of the font used by this text object
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoText.Font">
            <summary>
Return a reference to the CRhinoFont used by this text object
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoText.SetString(System.String)">
            <summary>
Set the textstring
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoText.String">
            <summary>
does not copy m_pParent
</summary>
            <summary>
Get the text as Unicode string
</summary>
        </member>
        <member name="T:RMA.Rhino.MRhinoText">
            <summary>
CRhinoText - a unit of text to be used by Rhino entities such as Text and Annotation.
Uses entity coordinates and rotation in the plane of its parent object.
Justification is always lower-left.  If another justification is used by
the parent object, the text positioning must be managed by the parent
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoText.Explode(RMA.OpenNURBS.OnCurve[]@)">
            <summary>
Convert to outline curves
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoText.GetTextBoundingBox(RMA.OpenNURBS.IOnViewport,RMA.OpenNURBS.OnBoundingBox@)">
            <summary>Get tight bounding box of this Rhino object.</summary>
            <param name="vp">[in] (can be NULL)</param>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoText.GetTextBoundingBox(RMA.OpenNURBS.IOnViewport,RMA.OpenNURBS.OnBoundingBox@,System.Boolean)">
            <summary>Get tight bounding box of this Rhino object.</summary>
            <param name="vp">[in] (can be NULL)</param>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in](default=false) If true and the input tight_bbox is valid, then returned
tight_bbox is the union of the input tight_bbox and the tight bounding box of this Rhino object.
</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoText.GetTextBoundingBox(RMA.OpenNURBS.IOnViewport,RMA.OpenNURBS.OnBoundingBox@,System.Boolean,RMA.OpenNURBS.IOnXform)">
            <summary>Get tight bounding box of this Rhino object.</summary>
            <param name="vp">[in] (can be NULL)</param>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in](default=false) If true and the input tight_bbox is valid, then returned
tight_bbox is the union of the input tight_bbox and the tight bounding box of this Rhino object.
</param>
            <param name="xform">
[in] (default=NULL) If not NULL, the tight bounding box of the transformed
Rhino object is calculated.  The Rhino object is not modified.
</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoText.GetTextXform(RMA.OpenNURBS.IOnViewport,RMA.OpenNURBS.OnXform@)">
            <summary>
Gets the transformation that text with a base point at (0,0) and a base line
along the x-axis to it's location in world coordinates.
</summary>
            <param name="vp">[in] (can be NULL)</param>
            <param name="gdi_to_world">[out]</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoText.GetText3dCorners(RMA.OpenNURBS.IOnXform,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@)">
            <summary>Get world 3d coordinates of the corners of the entire text block.</summary>
            <param name="gdi_to_world">[in] The tranform returned by Parent()-&gt;GetTextXform(gdi_to_world);</param>
            <param name="lower_left">[out]</param>
            <param name="lower_right">[out]</param>
            <param name="upper_right">[out]</param>
            <param name="upper_left">[out]</param>
            <returns>
True if the 3d points are set. False if there is not
enough information to calculate the points' location, i.e.,
the parent annotation object is missing.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoText.GetText2dCorners(RMA.OpenNURBS.On2dPoint@,RMA.OpenNURBS.On2dPoint@,RMA.OpenNURBS.On2dPoint@,RMA.OpenNURBS.On2dPoint@)">
            <summary>Get annotation plane coordinates of the corners of the entire text block.</summary>
            <param name="lower_left">[out]</param>
            <param name="lower_right">[out]</param>
            <param name="upper_right">[out]</param>
            <param name="upper_left">[out]</param>
            <returns>
True if the 2d points are set. False if there is not enough
information to calculate the points' location, i.e., the parent annotation object is missing.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoText.NormalizedRect">
            <returns>
The 2d bounding rectangle of the text block. The rectangle is aligned horizontally
and is in Windows GDI coordinates. The rectangle is set when the paths are calculated
in CRhinoText::MakePath(). The coordinates are for normalized text
(LOGFONT lfHeight = ON_Font::normal_font_height). The rectangle origin is at the
baseline point of the parent CRhinoText block (not this text line).
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoText.TextLines">
            <summary>
Return an array of lines of text in the text object
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoText.CharCount">
            <summary>
Return the number of characters in the string
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoText.FaceName">
            <summary>
Return the font Facename used by the text object
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoText.IsItalic">
            <summary>
Return TRUE if the text object is italic
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoText.IsBold">
            <summary>
Return TRUE if the text object is bold
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoText.LinefeedHeight">
            <returns>
The height of linefeed in model units. The global dimension scale is not applied to
the returned value.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoText.Width">
            <returns>
The width of the string in model units. The global dimension scale is not applied to
the returned value.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoText.Height">
            <returns>
The height of an I in model units. If the text is in a CRhinoAnnotationText object,
this is the value of CRhinoAnnotationText.m_text_block.m_textheight. For all other
annotation objects, this is the value is dimstyle.m_textheight, where dimstyle is
the dimension style of the annotation. The global dimension scale is not applied to
the returned value.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoText.FontIndex">
            <summary>
Get the font table index of the font used by this text object
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoText.Font">
            <summary>
Return a reference to the CRhinoFont used by this text object
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoText.String">
            <summary>
Get the text as Unicode string
</summary>
        </member>
        <member name="T:RMA.Rhino.IRhinoText">
            <summary>
CRhinoText - a unit of text to be used by Rhino entities such as Text and Annotation.
Uses entity coordinates and rotation in the plane of its parent object.
Justification is always lower-left.  If another justification is used by
the parent object, the text positioning must be managed by the parent
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoTextLine.GetTextCorners(RMA.OpenNURBS.IOnXform,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@)">
            <summary>Get world 3d coordinates of the corners of the line of text.</summary>
            <param name="gdi_to_world">[in] The tranform returned by Parent()-&gt;GetTextXform(gdi_to_world);</param>
            <param name="lower_left">[out]</param>
            <param name="lower_right">[out]</param>
            <param name="upper_right">[out]</param>
            <param name="upper_left">[out]</param>
            <returns>
True if the 3d points are set. False if there is not enough
information to calculate the points' location, i.e., the
parent text annotation object is missing.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoTextLine.NormalizedRect">
            <returns>
The 2d bounding rectangle of the TextLine. The rectangle is aligned horizontally and
is in Windows GDI coordinates. The rectangle is set when the paths are calculated in
CRhinoText::MakePath(). The coordinates are for normalized text
(LOGFONT lfHeight = ON_Font::normal_font_height). The rectangle origin is at the baseline
point of the parent CRhinoText block (not this text line).
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoTextLine.Count">
            <returns>
Number of characters in this line. This value is set in CRhinoText::ParseTextLines.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoTextLine.Start">
            <returns>
The index into CRhinoText m_String where this line of text begins. This value is set in CRhinoText::ParseTextLines.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoTextLine.Parent">
            <returns>
A pointer to the parent CRhinoText object. This value is set in CRhinoText::ParseTextLines.
</returns>
        </member>
        <member name="T:RMA.Rhino.MRhinoTextLine">
            <summary>One line of text in a CRhinoText object</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoTextLine.GetTextCorners(RMA.OpenNURBS.IOnXform,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@)">
            <summary>Get world 3d coordinates of the corners of the line of text.</summary>
            <param name="gdi_to_world">[in] The tranform returned by Parent()-&gt;GetTextXform(gdi_to_world);</param>
            <param name="lower_left">[out]</param>
            <param name="lower_right">[out]</param>
            <param name="upper_right">[out]</param>
            <param name="upper_left">[out]</param>
            <returns>
True if the 3d points are set. False if there is not enough
information to calculate the points' location, i.e., the
parent text annotation object is missing.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoTextLine.NormalizedRect">
            <returns>
The 2d bounding rectangle of the TextLine. The rectangle is aligned horizontally and
is in Windows GDI coordinates. The rectangle is set when the paths are calculated in
CRhinoText::MakePath(). The coordinates are for normalized text
(LOGFONT lfHeight = ON_Font::normal_font_height). The rectangle origin is at the baseline
point of the parent CRhinoText block (not this text line).
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoTextLine.Count">
            <returns>
Number of characters in this line. This value is set in CRhinoText::ParseTextLines.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoTextLine.Start">
            <returns>
The index into CRhinoText m_String where this line of text begins. This value is set in CRhinoText::ParseTextLines.
</returns>
        </member>
        <member name="T:RMA.Rhino.IRhinoTextLine">
            <summary>One line of text in a CRhinoText object</summary>
        </member>
        <member name="P:RMA.Rhino.MRhinoGDIPath.m_types">
            <value>
m_points[] stores the text path in Windows coordinates
(y increases downwards) with (0,0) = text base point.
For multiple lines, the entire text block is stored
and the linefeed is included in the y values.
m_types[] values are PT_MOVETO, PT_LINETO, and PT_BEZIERTO.
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoGDIPath.m_points">
            <value>
m_points[] stores the text path in Windows coordinates
(y increases downwards) with (0,0) = text base point.
For multiple lines, the entire text block is stored
and the linefeed is included in the y values.
m_types[] values are PT_MOVETO, PT_LINETO, and PT_BEZIERTO.
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoGDIPath.m_types">
            <value>
m_points[] stores the text path in Windows coordinates
(y increases downwards) with (0,0) = text base point.
For multiple lines, the entire text block is stored
and the linefeed is included in the y values.
m_types[] values are PT_MOVETO, PT_LINETO, and PT_BEZIERTO.
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoGDIPath.m_points">
            <value>
m_points[] stores the text path in Windows coordinates
(y increases downwards) with (0,0) = text base point.
For multiple lines, the entire text block is stored
and the linefeed is included in the y values.
m_types[] values are PT_MOVETO, PT_LINETO, and PT_BEZIERTO.
</value>
        </member>
        <member name="T:RMA.Rhino.IRhinoGDIPath">
            <summary>
An array of points and corresponding array of types
Types are PT_MOVETO, PT_LINETO, or PT_BEZIERTO
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoSurfaceObject.op_Implicit(RMA.Rhino.IRhinoSurfaceObject)~RMA.Rhino.MRhinoSurfaceObject">
            <summary>
copies source object UUID
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoSurfaceObject.#ctor(RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <summary>
assigns a new object UUID
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoSurfaceObject.#ctor">
            <summary>
assigns a new object UUID
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoBrepObject.op_Implicit(RMA.Rhino.IRhinoBrepObject)~RMA.Rhino.MRhinoBrepObject">
            <summary>
copies source object UUID
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoBrepObject.#ctor(RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <summary>
assigns a new object UUID
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoBrepObject.#ctor">
            <summary>
assigns a new object UUID
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoMeshStlUI.MeshTolerance(RMA.OpenNURBS.IOnMeshParameters)">
            <summary>Get tolerance setting from mesh parameters.</summary>
            <param name="mp">[in]</param>
            <returns>Tolerance</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoMeshStlUI.MeshQuality(RMA.OpenNURBS.IOnMeshParameters)">
            <summary>Get quality setting from mesh parameters.</summary>
            <param name="mp">[in]</param>
            <returns>
Quality setting:
0 = course, 1 = medium, 2 = fine
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoMeshStlUI.SetMeshParameters(System.Int32,System.Double,RMA.OpenNURBS.OnMeshParameters@)">
            <summary>Sets meshing parameters from simple quality and tolerance settings.</summary>
            <param name="quality">[in] 0 = course, 1 = medium, 2 = fine</param>
            <param name="tolerance">[in] mesh tolerance (ignored if &lt;= 0.0)</param>
            <param name="mp">[out]</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoMeshStlUI.SaveProfile(System.String,RMA.Rhino.MRhinoProfileContext@)">
            <summary>Save settings to the Rhino profile.</summary>
            <param name="lpszSection">[in] profile section to use for this command</param>
            <param name="pc">
[in] profile context to use to get at value saved in the Rhino profile.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoMeshStlUI.LoadProfile(System.String,RMA.Rhino.MRhinoProfileContext@)">
            <summary>Loads settings from the Rhino profile.</summary>
            <param name="lpszSection">[in] profile section to use for this command</param>
            <param name="pc">
[in] profile context to use to get at value saved in the Rhino profile.
</param>
        </member>
        <member name="P:RMA.Rhino.MRhinoMeshStlUI.m_title_str">
            <value>
dialog title
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoMeshStlUI.m_tolerance_str">
            <value>
tolerance description string
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoMeshStlUI.m_detailed_dlg">
            <value>
0 = stl dialog, 1 = detailed dialog
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoMeshStlUI.m_relative_tolerance">
            <value>
The new Rhino 4 mesh Density setting.  Initially set to 0
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoMeshStlUI.m_refine_angle">
            <value>
20.0*ON_PI/180.0;
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoMeshStlUI.m_grid_min_count">
            <value>
16;
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoMeshStlUI.m_grid_aspect_ratio">
            <value>
default = 6.0
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoMeshStlUI.m_max_edge_length">
            <value>
default = 0.0
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoMeshStlUI.m_mesh_tolerance">
            <value>
mesh tolerance is ignored if &lt;= 0.0 (default=0.0)
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoMeshStlUI.m_mesh_quality">
            <value>
0 = course, 1 = medium, 2 = fine (default=1)
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoMeshStlUI.m_command_style">
            <value>
Specifies style of command using this UI CRhinoCommandContext::interactive_ui CRhinoCommandContext::script_ui CRhinoCommandContext::batch_ui (default=interactive_ui)
</value>
        </member>
        <member name="T:RMA.Rhino.MRhinoMeshStlUI">
            <summary>Creates the course/medium/fine + optional tolerance dialog used for STL export.</summary>
        </member>
        <member name="P:RMA.Rhino.IRhinoMeshStlUI.m_title_str">
            <value>
dialog title
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoMeshStlUI.m_tolerance_str">
            <value>
tolerance description string
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoMeshStlUI.m_detailed_dlg">
            <value>
0 = stl dialog, 1 = detailed dialog
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoMeshStlUI.m_relative_tolerance">
            <value>
The new Rhino 4 mesh Density setting.  Initially set to 0
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoMeshStlUI.m_refine_angle">
            <value>
20.0*ON_PI/180.0;
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoMeshStlUI.m_grid_min_count">
            <value>
16;
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoMeshStlUI.m_grid_aspect_ratio">
            <value>
default = 6.0
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoMeshStlUI.m_max_edge_length">
            <value>
default = 0.0
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoMeshStlUI.m_mesh_tolerance">
            <value>
mesh tolerance is ignored if &lt;= 0.0 (default=0.0)
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoMeshStlUI.m_mesh_quality">
            <value>
0 = course, 1 = medium, 2 = fine (default=1)
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoMeshStlUI.m_command_style">
            <value>
Specifies style of command using this UI CRhinoCommandContext::interactive_ui CRhinoCommandContext::script_ui CRhinoCommandContext::batch_ui (default=interactive_ui)
</value>
        </member>
        <member name="T:RMA.Rhino.IRhinoMeshStlUI">
            <summary>Creates the course/medium/fine + optional tolerance dialog used for STL export.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoMeshObjectsUI.OnCancelPreview">
            <summary>Call to cancel mesh calculations happening during a call to OnPreview().</summary>
            <returns>True if preview meshes were begin cacluated and the calculation was canceled.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoMeshObjectsUI.OnPreview(RMA.OpenNURBS.IOnMeshParameters)">
            <summary>
Call this function if you want a visual preview of the meshes created from the settings in mp.
</summary>
            <returns>
0: OnCancelPreview() canceled the mesh caclulation.
1: successful preview mesh creation.
2: User pressed ESC key. Return CRhinoCommand::cancel immediately.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoMeshObjectsUI.GetMeshParameters(RMA.Rhino.IRhinoObject[],RMA.OpenNURBS.OnMeshParameters@)">
            <summary>Provides the user interface that gets meshing parameters.</summary>
            <param name="objects">[in] objects being meshed</param>
            <param name="mp">[out] meshing parameters.</param>
            <returns>
CRhinoCommand::success if the mesh parameters returned in mp should be used to create meshes.
CRhinoCommand::cancel if the user canceled.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjectMesh.GetMesh">
            <summary>Mesh is returned here</summary>
        </member>
        <member name="P:RMA.Rhino.MRhinoObjectMesh.m_brep">
            <value>
If m_brep_object is not NULL, then m_brep is the object that was meshed
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoObjectMesh.m_brep_object">
            <value>
Exactly one of m_mesh_object or m_brep_object is not NULL.
If m_iref_object is NULL, then m_brep_object or m_mesh_object
is an object in the doc's geometry  or reference geometry tables.
If m_iref_object is not NULL, then m_brep_object or m_mesh_object
is in the doc's instance definition geometry list.
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoObjectMesh.m_mesh_object">
            <value>
Exactly one of m_mesh_object or m_brep_object is not NULL.
If m_iref_object is NULL, then m_brep_object or m_mesh_object
is an object in the doc's geometry  or reference geometry tables.
If m_iref_object is not NULL, then m_brep_object or m_mesh_object
is in the doc's instance definition geometry list.
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoObjectMesh.m_iref_object">
            <value>
If m_iref_object is not NULL when the top level object
was an instance reference.  Otherwise, m_iref_object
is NULL and the m_brep_object or m_mesh_object is the
top level object.
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoObjectMesh.m_parent_object">
            <value>object that was meshed to create m_mesh</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoObjectMesh.m_mesh_attributes">
            <value>
object attributes associated with this mesh
</value>
        </member>
        <member name="T:RMA.Rhino.MRhinoObjectMesh">
            <summary>Used to return meshes created by RhinoMeshObjects.</summary>
        </member>
        <member name="P:RMA.Rhino.IRhinoObjectMesh.m_mesh_attributes">
            <value>
object attributes associated with this mesh
</value>
        </member>
        <member name="T:RMA.Rhino.IRhinoObjectMesh">
            <summary>Used to return meshes created by RhinoMeshObjects.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoMeshDensity.IsValid">
            <summary>
Returns: true if settings are valid
</summary>
        </member>
        <member name="P:RMA.Rhino.MRhinoMeshDensity.m_vertical">
            <value>
(&gt;=2) number of quads in longitude direction
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoMeshDensity.m_around">
            <value>
(&gt;=3) number of quads in latitude direction
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoMeshDensity.m_z">
            <value>
(&gt;=1) number of quads in "z" direction
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoMeshDensity.m_y">
            <value>
(&gt;=1) number of quads in "y" direction
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoMeshDensity.m_x">
            <value>
(&gt;=1) number of quads in "x" direction
</value>
        </member>
        <member name="T:RMA.Rhino.MRhinoMeshDensity">
            <summary>
CRhinoMeshDensity determines the number of quads created by the RhinoMeshPlane,
RhinoMeshBox, and RhinoMeshSphere commands.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoMeshDensity.IsValid">
            <summary>
Returns: true if settings are valid
</summary>
        </member>
        <member name="P:RMA.Rhino.IRhinoMeshDensity.m_vertical">
            <value>
(&gt;=2) number of quads in longitude direction
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoMeshDensity.m_around">
            <value>
(&gt;=3) number of quads in latitude direction
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoMeshDensity.m_z">
            <value>
(&gt;=1) number of quads in "z" direction
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoMeshDensity.m_y">
            <value>
(&gt;=1) number of quads in "y" direction
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoMeshDensity.m_x">
            <value>
(&gt;=1) number of quads in "x" direction
</value>
        </member>
        <member name="T:RMA.Rhino.IRhinoMeshDensity">
            <summary>
CRhinoMeshDensity determines the number of quads created by the RhinoMeshPlane,
RhinoMeshBox, and RhinoMeshSphere commands.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoMeshObject.SetMesh(RMA.OpenNURBS.OnMesh)">
            <summary>
copies source object UUID
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoMeshObject.#ctor(RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <summary>
assigns a new object UUID
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoMeshObject.#ctor">
            <summary>
assigns a new object UUID
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoCurveObject.DeleteCurveDisplay">
            <summary>
If you change a setting that requires the curve segments to be updated, then call this function.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoCurveObject.SetCurve(RMA.OpenNURBS.OnCurve)">
            <summary>Specify the curve geometry.</summary>
            <param name="pCurve">[in] ~CRhinoCurveObject() will delete this curve</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoCurveObject.SetCurve(RMA.OpenNURBS.IOnBezierCurve)">
            <summary>Specify the curve geometry.</summary>
            <param name="curve">[in] curve geometry copied to object</param>
            <returns>Pointer to curve geometry on CRhinoCurveObject.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoCurveObject.SetCurve(RMA.OpenNURBS.IOnCurve)">
            <summary>
copies source object UUID
</summary>
            <summary>Specify the curve geometry.</summary>
            <param name="curve">[in] curve geometry copied to object</param>
            <returns>Pointer to curve geometry on CRhinoCurveObject.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoCurveObject.#ctor(RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <summary>
assigns a new object UUID
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoCurveObject.#ctor">
            <summary>
assigns a new object UUID
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoCurveObject.DeleteCurveDisplay">
            <summary>
If you change a setting that requires the curve segments to be updated, then call this function.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGripObject.Prev">
            <summary>
prev in CRhinoDoc::m_grip_list list
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGripObject.Next">
            <summary>
Description: If a grip has "directions" (like a surface control point), this function evaluates those directions. Parameters: gd - [out] Returns: True if evaluation sets gd.
</summary>
            <summary>
Description: Unconditionally sets grip directions to values in gd. Parameters: gd - [in]
</summary>
            <summary>
next in CRhinoDoc::m_grip_list list
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGripObject.GripsId">
            <summary>
Description: This id is used to differentiate between different types of custom grips. The default object grips (curve cvs, etc.) allways have an id of ON_nil_uuid. Returns: The value of m_grips_owner-&gt;m_grips_id.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGripObject.GripType">
            <summary>
Parameters: cvindex - [out] Control point indices are appended to this array. Returns: Number of NURBS surface control points managed by this grip. If the grip is not a surface control point, zero is returned.
</summary>
            <summary>
Parameters: cvindex - [out] Control point indices are appended to this array. Returns: Number of NURBS cage control points managed by this grip. If the grip is not a cage control point, zero is returned.
</summary>
            <summary>
Returns: The value of m_grips_owner-&gt;m__grips_type
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGripObject.GetCurveCVIndices(RMA.OpenNURBS.Arrayint@)">
            <summary>
Parameters: cvindex - [out] Control point indices are appended to this array. Returns: Number of NURBS curve control points managed by this grip. If the grip is not a curve control point, zero is returned.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGripObject.NeighborGrip(System.Int32,System.Int32,System.Int32)">
            <summary>
Description: Used to get a grip's logical neighbors, like NURBS curve, suface, and cage control point grips. Parameters: dr - [in] -1 to go back one grip, +1 to move forward one grip For curves, surfaces and cages, this is the first parameter direction. ds - [in] -1 to go back one grip, +1 to move forward one grip For surfaces and cages this is the second parameter direction. dt - [in] For cages this is the third parameter direction. Returns: Pointer to the logical neighbor or NULL if there is no logical neighbor.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGripObject.NeighborGrip(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
Description: Used to get a grip's logical neighbors, like NURBS curve, suface, and cage control point grips. Parameters: dr - [in] -1 to go back one grip, +1 to move forward one grip For curves, surfaces and cages, this is the first parameter direction. ds - [in] -1 to go back one grip, +1 to move forward one grip For surfaces and cages this is the second parameter direction. dt - [in] For cages this is the third parameter direction. Returns: Pointer to the logical neighbor or NULL if there is no logical neighbor.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGripObject.SetWeight(System.Double)">
            <summary>
Description: Set the weight of a NURBS control point grip. double weight - [in] NURBS control point weight (&gt;= 0 ) Returns: True if weight was changed.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGripObject.Weight">
            <summary>
Returns: The weight of a NURBS control point grip or ON_UNSET_VALUE if the grip is not a NURBS control point.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGripObject.HideGrip(System.Boolean)">
            <summary>
Description: Called when a grip is being dynamically dragged. Parameters: world_line - [in] 3d world mouse line delta - [in] default translation Remarks: Default calls MoveGrip(delta)
</summary>
            <summary>
Description: CRhinoDoc::ShowObject and CRhinoDoc::HideObject call this function when a grip visibility is changed. If needed, override HideGrip to do any extra work that is required. For example, when mesh grips are hidden, the ON_Mesh::m_H[] array needs to be updated. Parameters: bHide - [in] true mean grips is being hidden, false means grip is being shown.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGripObject.UndoMoveGrip">
            <summary>
Description: Undoes any grip moves made by calling MoveGrip.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGripObject.MoveGrip(RMA.OpenNURBS.IOnXform)">
            <summary>
Description: Move the grip to a new location. Paramters: xform - [in] transformation applied to base point. morph - [in] transformation applied to base point. delta - [in] translation applied to base point. new_location - [in] new location for grip point See Also: CRhinoGripObject::operator=
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGripObject.Owner">
            <summary>
Returns: Object that owns this grip
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGripObject.GripMoved">
            <summary>
Returns: True if grip has moved.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGripObject.GetGripDirections(RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>
Description: Sometimes grips have directions. These directions can have any length and do not have to be orthoganal. Parameters: X - [out] Y - [out] Z - [out] Returns: True if the grip has directions.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGripObject.GripBasePoint">
            <summary>
Returns: Original grip location. See Also: CRhinoGripObject::GripLocation
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGripObject.GripLocation">
            <summary>
Returns: Current grip location. See Also: CRhinoGripObject::GripBasePoint
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGripObject.Attributes">
            <summary>
Description: virtual CRhinoObject::Attributes override returns parent object's display and layer attributes. Returns: attributes
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGripObject.ModifyAttributes(RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <summary>
Description: virtual CRhinoObject::ModifyAttributes override to prevent changing grip attributes. Returns: false
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGripObject.ModifyAttributes(RMA.OpenNURBS.IOn3dmObjectAttributes,System.Boolean)">
            <summary>
Description: virtual CRhinoObject::ModifyAttributes override to prevent changing grip attributes. Returns: false
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGripObject.ModifyAttributes(RMA.OpenNURBS.IOn3dmObjectAttributes,System.Boolean,System.Boolean)">
            <summary>
Description: virtual CRhinoObject::ModifyAttributes override to prevent changing grip attributes. Returns: false
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGripObject.IsDeletable">
            <summary>
Description: Sets location of grip point. Parameter: new_location - [in] See Also: CRhinoGripObject::MoveGrip
</summary>
            <summary>
virtual CRhinoObject::PickFilter override
</summary>
        </member>
        <member name="P:RMA.Rhino.MRhinoGripObject.m_base_point">
            <value>
starting location of grip point
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoGripObject.m_grip_index">
            <value>
index of grip in CRhinoObjectGrips m_grip_list array
</value>
        </member>
        <member name="M:RMA.Rhino.IRhinoGripObject.Prev">
            <summary>
prev in CRhinoDoc::m_grip_list list
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGripObject.Next">
            <summary>
Description: If a grip has "directions" (like a surface control point), this function evaluates those directions. Parameters: gd - [out] Returns: True if evaluation sets gd.
</summary>
            <summary>
next in CRhinoDoc::m_grip_list list
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGripObject.GripsId">
            <summary>
Description: This id is used to differentiate between different types of custom grips. The default object grips (curve cvs, etc.) allways have an id of ON_nil_uuid. Returns: The value of m_grips_owner-&gt;m_grips_id.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGripObject.GripType">
            <summary>
Parameters: cvindex - [out] Control point indices are appended to this array. Returns: Number of NURBS surface control points managed by this grip. If the grip is not a surface control point, zero is returned.
</summary>
            <summary>
Parameters: cvindex - [out] Control point indices are appended to this array. Returns: Number of NURBS cage control points managed by this grip. If the grip is not a cage control point, zero is returned.
</summary>
            <summary>
Returns: The value of m_grips_owner-&gt;m__grips_type
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGripObject.GetCurveCVIndices(RMA.OpenNURBS.Arrayint@)">
            <summary>
Parameters: cvindex - [out] Control point indices are appended to this array. Returns: Number of NURBS curve control points managed by this grip. If the grip is not a curve control point, zero is returned.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGripObject.NeighborGrip(System.Int32,System.Int32,System.Int32)">
            <summary>
Description: Used to get a grip's logical neighbors, like NURBS curve, suface, and cage control point grips. Parameters: dr - [in] -1 to go back one grip, +1 to move forward one grip For curves, surfaces and cages, this is the first parameter direction. ds - [in] -1 to go back one grip, +1 to move forward one grip For surfaces and cages this is the second parameter direction. dt - [in] For cages this is the third parameter direction. Returns: Pointer to the logical neighbor or NULL if there is no logical neighbor.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGripObject.NeighborGrip(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
Description: Used to get a grip's logical neighbors, like NURBS curve, suface, and cage control point grips. Parameters: dr - [in] -1 to go back one grip, +1 to move forward one grip For curves, surfaces and cages, this is the first parameter direction. ds - [in] -1 to go back one grip, +1 to move forward one grip For surfaces and cages this is the second parameter direction. dt - [in] For cages this is the third parameter direction. Returns: Pointer to the logical neighbor or NULL if there is no logical neighbor.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGripObject.Weight">
            <summary>
Returns: The weight of a NURBS control point grip or ON_UNSET_VALUE if the grip is not a NURBS control point.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGripObject.HideGrip(System.Boolean)">
            <summary>
Description: CRhinoDoc::ShowObject and CRhinoDoc::HideObject call this function when a grip visibility is changed. If needed, override HideGrip to do any extra work that is required. For example, when mesh grips are hidden, the ON_Mesh::m_H[] array needs to be updated. Parameters: bHide - [in] true mean grips is being hidden, false means grip is being shown.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGripObject.Owner">
            <summary>
Returns: Object that owns this grip
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGripObject.GripMoved">
            <summary>
Returns: True if grip has moved.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGripObject.GetGripDirections(RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>
Description: Sometimes grips have directions. These directions can have any length and do not have to be orthoganal. Parameters: X - [out] Y - [out] Z - [out] Returns: True if the grip has directions.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGripObject.GripBasePoint">
            <summary>
Returns: Original grip location. See Also: CRhinoGripObject::GripLocation
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGripObject.GripLocation">
            <summary>
Returns: Current grip location. See Also: CRhinoGripObject::GripBasePoint
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGripObject.Attributes">
            <summary>
Description: virtual CRhinoObject::Attributes override returns parent object's display and layer attributes. Returns: attributes
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGripObject.IsDeletable">
            <summary>
virtual CRhinoObject::PickFilter override
</summary>
        </member>
        <member name="P:RMA.Rhino.IRhinoGripObject.m_base_point">
            <value>
starting location of grip point
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoGripObject.m_grip_index">
            <value>
index of grip in CRhinoObjectGrips m_grip_list array
</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoPointCloudObject.SetPointCloud(RMA.OpenNURBS.OnPointCloud@)">
            <summary>
leave attributes unchanged.
</summary>
            <summary>
leave attributes unchanged.
</summary>
            <summary>
Description: Copies copies point cloud and moves user data from point_cloud to m_point_cloud. Paramters: point_cloud - [in] information in point_cloud is copied. Any attached ON_UserData is moved from point_cloud to m_point_cloud.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPointCloudObject.#ctor(RMA.OpenNURBS.IArrayOn3dPoint)">
            <summary>
copies source object UUID
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPointCloudObject.#ctor(RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <summary>
assigns a new object UUID
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPointCloudObject.#ctor">
            <summary>
assigns a new object UUID
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPointObject.Duplicate">
            <summary>
virtual CRhinoObject::Draw override
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPointObject.SetPoint(RMA.OpenNURBS.OnPoint@)">
            <summary>
copies source object UUID
</summary>
            <summary>
leave attributes unchanged.
</summary>
            <summary>
copies point and moves user data from argument to m_point.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPointObject.#ctor(RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <summary>
assigns a new object UUID
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPointObject.#ctor">
            <summary>
assigns a new object UUID
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoLightTable.GetLightingModel(RMA.OpenNURBS.ArrayOnLight@,RMA.OpenNURBS.IOn.display_mode)">
            <summary>Gets lighting model defined by the light table.</summary>
            <param name="lights">[out] world coordinate lighting model returned here.</param>
            <param name="display_mode">
[in] mode for the lighting model
ON::wireframe_display - lighting model for wireframe display mode is returned
ON::shaded_display - lighting model for shaded display mode is returned
ON::renderpreview_display - lighting model for render display display mode is returned
</param>
            <returns>
number of lights.
See Also: CRhinoView::GetLightingModel
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLightTable.WireframeIconsBoundingBox(RMA.Rhino.IRhinoView)">
            <summary>Get bounding box of wireframe icons for lights that are visible and not deleted.</summary>
            <returns>Bounding box of wireframe icons for lights that are visible and not deleted.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLightTable.DrawWireframeIcons(RMA.Rhino.MRhinoViewport@)">
            <summary>Draw wireframe icons for lights that are visible and not deleted.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoLightTable.GetUnusedLightName(System.String@)">
            <summary>Gets unsed light name used as default when creating new lights</summary>
            <param name="result">[out] this is the wString which receives new name</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoLightTable.GetUnusedLightName(System.String@,System.String)">
            <summary>Gets unsed light name used as default when creating new lights</summary>
            <param name="result">[out] this is the wString which receives new name</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoLightTable.GetSortedList(RMA.Rhino.IRhinoLight[]@)">
            <summary>
Gets an array of pointers to lights that is sorted by
the values of CRhinoLight::m_sort_index.
</summary>
            <param name="sorted_list">
[out] this array is returned with length LightCount() and is sorted by the
values of CRhinoLight::m_sort_index.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoLightTable.GetSortedList(RMA.Rhino.IRhinoLight[]@,System.Boolean)">
            <summary>
Gets an array of pointers to lights that is sorted by
the values of CRhinoLight::m_sort_index.
</summary>
            <param name="sorted_list">
[out] this array is returned with length LightCount() and is sorted by the
values of CRhinoLight::m_sort_index.
</param>
            <param name="bIgnoreDeleted">[in] TRUE means don't include deleted lights.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoLightTable.UndeleteLight(System.Int32)">
            <summary>Undeletes a light that has been deleted by DeleteLight().</summary>
            <param name="light_index">
[in] zero based index of light to undelete.
This must be in the range 0 &lt;= light_index &lt; LightCount().
</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLightTable.DeleteLights(System.Int32[],System.Boolean)">
            <summary>Deletes multiple lights</summary>
            <param name="light_index">
[in] array zero based indices of lights to delete.
The indices must be in the range 0 &lt;= light_index &lt; LightCount().
</param>
            <param name="bQuiet">
[in] If TRUE, no warning message box appears if a light
the light cannot be deleted because it is the current light
or it contains active geometry.
</param>
            <returns>
TRUE if successful. FALSE if light_index is out of range or the
the light cannot be deleted because it is the current light or
because it light contains active geometry.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLightTable.DeleteLight(System.Int32,System.Boolean)">
            <summary>Deletes light</summary>
            <param name="light_index">
[in] zero based index of light to delete.
This must be in the range 0 &lt;= light_index &lt; LightCount().
</param>
            <param name="bQuiet">
[in] If TRUE, no warning message box appears if a light
the light cannot be deleted because it is the current light
or it contains active geometry.
</param>
            <returns>
TRUE if successful. FALSE if light_index is out of range or the
the light cannot be deleted because it is the current light or
because it light contains active geometry.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLightTable.UndoModifyLight(System.Int32)">
            <summary>
If the light has been modified and the modifcation can be undone,
then UndoModify() will restore the light to its previous state.
</summary>
            <returns>
TRUE if this light had been modified and the modifications were undone.
See Also: IsModified.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLightTable.UndoModifyLight(System.Int32,System.UInt32)">
            <summary>
If the light has been modified and the modifcation can be undone,
then UndoModify() will restore the light to its previous state.
</summary>
            <returns>
TRUE if this light had been modified and the modifications were undone.
See Also: IsModified.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLightTable.ModifyLight(RMA.OpenNURBS.IOnLight,System.Int32)">
            <summary>Modify light settings</summary>
            <param name="light">[in] new settings. This information is copied.</param>
            <param name="light_index">
[in] zero based index of light to set.
This must be in the range 0 &lt;= light_index &lt; LightCount().
</param>
            <returns>TRUE if successful. FALSE if light_index is out of range.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLightTable.ModifyLight(RMA.OpenNURBS.IOnLight,System.Int32,System.Boolean)">
            <summary>Modify light settings</summary>
            <param name="light">[in] new settings. This information is copied.</param>
            <param name="light_index">
[in] zero based index of light to set.
This must be in the range 0 &lt;= light_index &lt; LightCount().
</param>
            <param name="bEnableUndo">[in] if TRUE, previous settings are saved for possible undo.</param>
            <returns>TRUE if successful. FALSE if light_index is out of range.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLightTable.ModifyLight(RMA.OpenNURBS.IOnLight,System.Int32,System.Boolean,System.Boolean)">
            <summary>Modify light settings</summary>
            <param name="light">[in] new settings. This information is copied.</param>
            <param name="light_index">
[in] zero based index of light to set.
This must be in the range 0 &lt;= light_index &lt; LightCount().
</param>
            <param name="bEnableUndo">[in] if TRUE, previous settings are saved for possible undo.</param>
            <param name="bQuiet">
[in] if TRUE, information message boxes pop up when illegal changes are attempted.
</param>
            <returns>TRUE if successful. FALSE if light_index is out of range.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLightTable.AddLight(RMA.OpenNURBS.IOnLight)">
            <summary>Adds a new light with specified definition to the light table.</summary>
            <param name="light">
[in] definition of new light. The information in light is copied. If light.LightName() is empty
then a unique name of the form "Light 01" will be automatically created.
</param>
            <returns>
&gt;=0     index of new light
-1      light not added because a light with that name already exists.
</returns>
            <remarks>
If attributes is not NULL, attributes-&gt;m_name is ignored. 
light.LightName() specifies the light's name.

In some cases, calling AddLight() can cause the memory 
references previously returned by operator[] and 
CurrentLight() to become invalid.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoLightTable.AddLight(RMA.OpenNURBS.IOnLight,RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <summary>Adds a new light with specified definition to the light table.</summary>
            <param name="light">
[in] definition of new light. The information in light is copied. If light.LightName() is empty
then a unique name of the form "Light 01" will be automatically created.
</param>
            <param name="attributes">
[in] NULL or attributes (layer, etc.) for light
See remarks for details about name.
</param>
            <returns>
&gt;=0     index of new light
-1      light not added because a light with that name already exists.
</returns>
            <remarks>
If attributes is not NULL, attributes-&gt;m_name is ignored. 
light.LightName() specifies the light's name.

In some cases, calling AddLight() can cause the memory 
references previously returned by operator[] and 
CurrentLight() to become invalid.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoLightTable.FindLight(System.String)">
            <summary>
Finds a light with the given name. (There may be more than one light with the same name)
</summary>
            <param name="light_name">[in] name of light to search for. The search ignores case.</param>
            <returns>
&gt;=0 index of the light with the given name
-1 no light has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLightTable.FindLight(System.String,System.Boolean)">
            <summary>
Finds a light with the given name. (There may be more than one light with the same name)
</summary>
            <param name="light_name">[in] name of light to search for. The search ignores case.</param>
            <param name="bIgnoreDeletedLights">[in] TRUE means don't search deleted lights.</param>
            <returns>
&gt;=0 index of the light with the given name
-1 no light has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLightTable.FindLight(System.String,System.Boolean,System.Int32)">
            <summary>
Finds a light with the given name. (There may be more than one light with the same name)
</summary>
            <param name="light_name">[in] name of light to search for. The search ignores case.</param>
            <param name="bIgnoreDeletedLights">[in] TRUE means don't search deleted lights.</param>
            <param name="first_light_index">[in] searching begins at this index.</param>
            <returns>
&gt;=0 index of the light with the given name
-1 no light has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLightTable.LightCount">
            <summary>
Returns: Number of lights in the light table, including deleted lights.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoLightTable.Document">
            <summary>Light tables store the list of lights in a Rhino document.</summary>
            <returns>CRhinoDocument that owns this light table.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoLightTable.GetLightingModel(RMA.OpenNURBS.ArrayOnLight@,RMA.OpenNURBS.IOn.display_mode)">
            <summary>Gets lighting model defined by the light table.</summary>
            <param name="lights">[out] world coordinate lighting model returned here.</param>
            <param name="display_mode">
[in] mode for the lighting model
ON::wireframe_display - lighting model for wireframe display mode is returned
ON::shaded_display - lighting model for shaded display mode is returned
ON::renderpreview_display - lighting model for render display display mode is returned
</param>
            <returns>
number of lights.
See Also: CRhinoView::GetLightingModel
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoLightTable.WireframeIconsBoundingBox(RMA.Rhino.IRhinoView)">
            <summary>Get bounding box of wireframe icons for lights that are visible and not deleted.</summary>
            <returns>Bounding box of wireframe icons for lights that are visible and not deleted.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoLightTable.DrawWireframeIcons(RMA.Rhino.MRhinoViewport@)">
            <summary>Draw wireframe icons for lights that are visible and not deleted.</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoLightTable.GetUnusedLightName(System.String@)">
            <summary>Gets unsed light name used as default when creating new lights</summary>
            <param name="result">[out] this is the wString which receives new name</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoLightTable.GetUnusedLightName(System.String@,System.String)">
            <summary>Gets unsed light name used as default when creating new lights</summary>
            <param name="result">[out] this is the wString which receives new name</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoLightTable.GetSortedList(RMA.Rhino.IRhinoLight[]@)">
            <summary>
Gets an array of pointers to lights that is sorted by
the values of CRhinoLight::m_sort_index.
</summary>
            <param name="sorted_list">
[out] this array is returned with length LightCount() and is sorted by the
values of CRhinoLight::m_sort_index.
</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoLightTable.GetSortedList(RMA.Rhino.IRhinoLight[]@,System.Boolean)">
            <summary>
Gets an array of pointers to lights that is sorted by
the values of CRhinoLight::m_sort_index.
</summary>
            <param name="sorted_list">
[out] this array is returned with length LightCount() and is sorted by the
values of CRhinoLight::m_sort_index.
</param>
            <param name="bIgnoreDeleted">[in] TRUE means don't include deleted lights.</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoLightTable.FindLight(System.String)">
            <summary>
Finds a light with the given name. (There may be more than one light with the same name)
</summary>
            <param name="light_name">[in] name of light to search for. The search ignores case.</param>
            <returns>
&gt;=0 index of the light with the given name
-1 no light has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoLightTable.FindLight(System.String,System.Boolean)">
            <summary>
Finds a light with the given name. (There may be more than one light with the same name)
</summary>
            <param name="light_name">[in] name of light to search for. The search ignores case.</param>
            <param name="bIgnoreDeletedLights">[in] TRUE means don't search deleted lights.</param>
            <returns>
&gt;=0 index of the light with the given name
-1 no light has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoLightTable.FindLight(System.String,System.Boolean,System.Int32)">
            <summary>
Finds a light with the given name. (There may be more than one light with the same name)
</summary>
            <param name="light_name">[in] name of light to search for. The search ignores case.</param>
            <param name="bIgnoreDeletedLights">[in] TRUE means don't search deleted lights.</param>
            <param name="first_light_index">[in] searching begins at this index.</param>
            <returns>
&gt;=0 index of the light with the given name
-1 no light has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoLightTable.LightCount">
            <summary>
Returns: Number of lights in the light table, including deleted lights.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoLightTable.Document">
            <summary>Light tables store the list of lights in a Rhino document.</summary>
            <returns>CRhinoDocument that owns this light table.</returns>
        </member>
        <member name="P:RMA.Rhino.MRhinoLight.m_remap_index">
            <value>
runtime index used when remapping lights for import/export
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoLight.m_sort_index">
            <value>
runtime index used to determine how lights are sorted in light dialig
</value>
        </member>
        <member name="T:RMA.Rhino.MRhinoLight">
            <summary>
All CRhinoLights are in CRhinoDoc::m_light_table[].
Use CRhinoLightTable::AddLight() to add new lights to
the document and CRhinoLightTable::ModifyLight() to
change light settings.  Use CRhinoObject::ModifyAttributes
to change CRhinoLight attributes like layer, etc.
</summary>
        </member>
        <member name="P:RMA.Rhino.IRhinoLight.m_remap_index">
            <value>
runtime index used when remapping lights for import/export
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoLight.m_sort_index">
            <value>
runtime index used to determine how lights are sorted in light dialig
</value>
        </member>
        <member name="T:RMA.Rhino.IRhinoLight">
            <summary>
All CRhinoLights are in CRhinoDoc::m_light_table[].
Use CRhinoLightTable::AddLight() to add new lights to
the document and CRhinoLightTable::ModifyLight() to
change light settings.  Use CRhinoObject::ModifyAttributes
to change CRhinoLight attributes like layer, etc.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.BindToRuntimeObject">
            <summary>
Expert user tool to use the object uuid and component index to set m_pHeader
and m_pGeometry when they are NULL. Use DecrementReferenceCount() to unbind.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.DecrementReferenceCount">
            <summary>
Expert user tool to decrement reference counts. Most users will never need to call
this tool. It is called by ~CRhinoObjRef and used in rare cases when a CRhinoObjRef
needs to reference an object only by uuid and component index.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.GetInstanceTransformation(RMA.OpenNURBS.OnXform@,RMA.Rhino.IRhinoInstanceObject[]@,RMA.OpenNURBS.OnXform[]@)">
            <summary>
If the CRhinoObjRef geometry is in the list returned by RhinoGetRenderMeshes or RhinoGetAnalysisMeshes and a 
transformed version of a piece of geometry that is ultimately part of an instance  definition, then this 
function returns that top level instance reference and the complete transformation that was applied to the 
piece of geometry.
</summary>
            <param name="xform">[out] transformation is returned here.</param>
            <param name="nested_iref_objects">
[out] a list of nested instance references is returned here.
If there are no nested references the list is empty.
The first item in the list is the non-nested instance.
The last item in a multi-item list will be the penultimate instance reference.
</param>
            <param name="nested_iref_xforms">
[out] a list of nested instance reference xforms is returned here.
If there are no nested references the list is empty.
The first item in the list is the non-nested instance.
The last item in a multi-item list will be the penultimate instance reference.
</param>
            <returns>
NULL if this geometry did not come from an instance definition.
Pointer to the top level instance reference if the geometry did come from an instance definition.
</returns>
            <example>
Assume a CRhinoMeshObject M2 is the geometry for instance defintion D1.
CRhinoInstanceObject R1 is a reference to D1 and the geometry for instance definition D2.
R2 is a reference to D2 and the geometry for instance definion D3.  R3 is a reference to D3.
Then CRhinoObjRef::Object() CRhinoObjRef::Object() would return a pointer to M2 and
CRhinoObjRef::Geometry() would return a pointer to a mesh that is already transformed
to be in the correct location.
CRhinoObjRef::GetInstanceTransformation() would return a pointer to R3, xform would be
the transformation that was used to move M2-&gt;Mesh() to the location of the returned
mesh, and the and the nested_iref[] array would be (R2,R1).
</example>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.GetInstanceTransformation(RMA.OpenNURBS.OnXform@)">
            <summary>
If the CRhinoObjRef geometry is in the list returned by RhinoGetRenderMeshes or RhinoGetAnalysisMeshes and a 
transformed version of a piece of geometry that is ultimately part of an instance  definition, then this 
function returns that top level instance reference and the complete transformation that was applied to the 
piece of geometry.
</summary>
            <param name="xform">[out] transformation is returned here.</param>
            <returns>
NULL if this geometry did not come from an instance definition.
Pointer to the top level instance reference if the geometry did come from an instance definition.
</returns>
            <example>
Assume a CRhinoMeshObject M2 is the geometry for instance defintion D1.
CRhinoInstanceObject R1 is a reference to D1 and the geometry for instance definition D2.
R2 is a reference to D2 and the geometry for instance definion D3.  R3 is a reference to D3.
Then CRhinoObjRef::Object() CRhinoObjRef::Object() would return a pointer to M2 and
CRhinoObjRef::Geometry() would return a pointer to a mesh that is already transformed
to be in the correct location.
CRhinoObjRef::GetInstanceTransformation() would return a pointer to R3, xform would be
the transformation that was used to move M2-&gt;Mesh() to the location of the returned
mesh, and the and the nested_iref[] array would be (R2,R1).
</example>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.TrimParameter(System.Double@)">
            <summary>
If the reference geometry is an edge of a surface,
then this gets the trim paramter of the selection point.
</summary>
            <param name="trim_parameter">
[out] If nonnull pointer is returned, this is then *trim_parameter is the parameter of the selection point.
</param>
            <returns>
If the selection point was on the edge of a surface, a pointer
to the associated trim is returned.
See Also: CRhinoObjRef::CurveParameter
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.SurfaceParameter(System.Double@,System.Double@)">
            <summary>
If the reference geometry is a surface, brep with one face,
or surface edge with a selection point, then this gets the 
surface paramters of the selection point.
</summary>
            <param name="u">
[out] If the selection point was on surface, then (*u,*v)
are the parameters of the selection point.
</param>
            <returns>
If the selection point was on a surfce, the
the surface is returned.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.CurveParameter(System.Double@)">
            <summary>
If the reference geometry is a curve or edge with a selection
point, then this gets the paramter of the selection point.
</summary>
            <param name="curve_parameter">
[out] If the selection point is on a curve or edge,
then *curve_parametert is the parameter of the selection point.
</param>
            <returns>
If the selection point was on a curve or edge, a pointer
to the curve/edge is returned.
See Also:
CRhinoObjRef::Curve
CRhinoObjRef::TrimParameter
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.SelectionView">
            <summary>
If the object was interactively selected in a particular viewport, then
SelectionView() returns the view where the object was selected.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.SelectionPoint(RMA.OpenNURBS.On3dPoint@)">
            <summary>
If the object was selected by picking a point on it, then
SelectionPoint() returns true and the point where the selection occured.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.SelectionDistance">
            <returns>
Relative visual distance from pick point to the object.
0 (spot on) to 2 (outer corner of pick box)
0 is returned for objects that were not picked using a point pick.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.SelectionDepth">
            <summary>
Returns: Depth of selection point. -1 (far away) to 1 (near) or ON_UNSET_VALUE if not available.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.SelectionStyle">
            <summary>
Returns: 0: not a shaded mode point pick 1: shaded mode point pick
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.SelectionMethod">
            <summary>Get the method used to select this object.</summary>
            <returns>
0: selected by non-mouse method (SelAll, etc.)
1: selected by mouse click on the object
2: selected by being inside of a mouse window
3: selected by intersecting a mouse crossing window
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.IsSubGeometry">
            <returns>
true if the selected piece of geometry is a proper sub-part of the parent object.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.Light">
            <summary>
If the referenced geometry is some type of render light, this returns the render light.
</summary>
            <returns>
light or NULL.
See Also: CRhinoObjectRef::Geometry CRhinoObjectRef::GeometryType
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.Annotation">
            <summary>If the referenced geometry is some type of annotation, this returns the annotation.</summary>
            <returns>
annotation or NULL.
See Also: CRhinoObjectRef::Geometry CRhinoObjectRef::GeometryType
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.MeshFace">
            <summary>If the referenced geometry is a mesh, this returns the mesh.</summary>
            <returns>
mesh or NULL.
See Also: CRhinoObjectRef::Geometry CRhinoObjectRef::GeometryType
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.MeshEdge">
            <summary>If the referenced geometry is a mesh, this returns the mesh.</summary>
            <returns>
mesh or NULL.
See Also: CRhinoObjectRef::Geometry CRhinoObjectRef::GeometryType
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.MeshVertex">
            <summary>If the referenced geometry is a mesh vertex, this returns the mesh vertex.</summary>
            <returns>
mesh or NULL.
See Also: CRhinoObjectRef::Geometry CRhinoObjectRef::GeometryType
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.Mesh">
            <summary>
If the referenced geometry is a mesh, mesh vertex, mesh edge, or mesh face, this returns the mesh.
</summary>
            <returns>
mesh or NULL.
See Also: CRhinoObjectRef::Geometry CRhinoObjectRef::GeometryType
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.Brep">
            <summary>
If the referenced geometry is a brep, a surface, or an edge, this returns the brep.
</summary>
            <returns>
brep or NULL.
See Also: CRhinoObjectRef::Geometry CRhinoObjectRef::GeometryType
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.Face">
            <summary>
If the referenced geometry is a brep face, a brep with one face, or an edge of a
surface, this returns the brep face.
</summary>
            <returns>
surface or NULL.
See Also: CRhinoObjectRef::Geometry CRhinoObjectRef::GeometryType
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.Loop">
            <summary>If the referenced geometry is an edge of a surface, this returns the associated brep trim.</summary>
            <returns>trim or NULL.</returns>
            <remarks>
The associated object is a CRhinoBrepObject.
See Also: CRhinoObjectRef::Curve CRhinoObjectRef::Trim CRhinoObjectRef::Brep CRhinoObjectRef::Geometry CRhinoObjectRef::GeometryType
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.Trim">
            <summary>If the referenced geometry is an edge of a surface, this returns the associated brep trim.</summary>
            <returns>trim or NULL.</returns>
            <remarks>
The associated object is a CRhinoBrepObject.
See Also: CRhinoObjectRef::Curve CRhinoObjectRef::Trim CRhinoObjectRef::Brep CRhinoObjectRef::Geometry CRhinoObjectRef::GeometryType
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.Edge">
            <summary>If the referenced geometry is an edge, this returns the edge.</summary>
            <returns>
edge or NULL.
See Also: CRhinoObjectRef::Curve CRhinoObjectRef::Trim CRhinoObjectRef::Brep CRhinoObjectRef::Geometry CRhinoObjectRef::GeometryType
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.Surface">
            <summary>
If the referenced geometry is a surface, a brep with one face, or an edge
of a surface, this returns the surface.
</summary>
            <returns>
surface or NULL.
See Also: CRhinoObjectRef::Geometry CRhinoObjectRef::GeometryType
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.Curve">
            <summary>If the referenced geometry is a curve or edge, this returns the curve.</summary>
            <returns>
curve or NULL.
See Also: CRhinoObjectRef::Edge CRhinoObjectRef::Geometry CRhinoObjectRef::GeometryType
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.PointCloud">
            <summary>If the referenced geometry is a point cloud, this returns the point cloud.</summary>
            <returns>
point or NULL.
See Also: CRhinoObjectRef::Geometry CRhinoObjectRef::GeometryType
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.Point">
            <summary>If the referenced geometry is a point, this returns the point.</summary>
            <returns>
point or NULL.
See Also: CRhinoObjectRef::Geometry CRhinoObjectRef::GeometryType
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.Geometry">
            <summary>
Returns the referenced piece of geometry. This piece of geometry may be a
sub-part of the parent object geometry.
</summary>
            <returns>Pointer to the referenced piece of geometry.</returns>
            <remarks>
CRhinoObjRef::Geometry is a low level utility function and, in general, it is
more convienient to use GeometryType to determine the type of referenced geometry
and the Point, Curve, ..., functions to get at the actual geometry.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.GeometryComponentIndex">
            <summary>Get the component index of the referenced (sub) geometry.</summary>
            <returns>
-1 Top level object is referenced.
&gt;0 component index of the referenced subgeometry.
</returns>
            <remarks>
Some objects have subobjects that are valid pieces of geometry.
For example, breps have edges and faces that are valid curves and surfaces.
Each subobject has a component index that is &gt; 0. The parent geometry has a component index = -1.
See Also: CRhinoObjRef::Geometry
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.GeometryType">
            <returns>the type of referenced geometry.</returns>
            <remarks>
The reference geometry may be a component of the parent object's geometry.
So, the type returned by this function may be different than the type parent object's geometry.
See Also: CRhinoObjRef::Geometry
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.Object">
            <returns>the referenced Rhino object</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.ObjectUuid">
            <returns>the id of the referenced Rhino object. See Also: CRhinoObjRef::Object</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.SetEdgeSelectionPoint(System.Double,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOnBrepEdge,RMA.OpenNURBS.IOnBrepTrim)">
            <summary>
When an edge is selected by picking a point on the edge of a surface,
SetEdgeSelectionPoint is used to save the edge parameter, trim parameter,
and the location of the point.
</summary>
            <param name="edge_parameter">[in]</param>
            <param name="point">[in]</param>
            <param name="edge">[in]</param>
            <param name="trim">[in]</param>
            <remarks>
Use CRhinoObjRef::TrimParameter, CRhinoObjRef::CurveParameter, and CRhinoObjRef::SurfaceParameter
to get the location of the pick.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.SetSurfaceSelectionPoint(System.Double,System.Double,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
When an surface is selected by picking a point on the surface, SetSurfaceSelectionPoint is used to save the surface parameters and location of the point. Parameters: u - [in] first surface parameter v - [in] second surface parameter point - [in] Remarks: Use CRhinoObjRef::SurfaceParameter to get the location of the pick.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.SetCurveSelectionPoint(System.Double,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
When an curve is selected by picking a point on the curve, SetCurveSelectionPoint
is used to save the curve parameter and location of the point.
</summary>
            <param name="curve_parameter">[in] curve parameter</param>
            <param name="point">[in]</param>
            <remarks>Use CRhinoObjRef::CurveParameter to get the location of the pick.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.SetSelectionPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
When an object is selected by picking a point on the object, SetSelectionPoint
is used to save the location of the point.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.op_Inequality(RMA.Rhino.MRhinoObjRef,RMA.Rhino.IRhinoObjRef)">
            <summary>Determine if two CRhinoObjRefs refer to the same object.</summary>
            <returns>true if the object or geometry pointers are not equal.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.op_Equality(RMA.Rhino.MRhinoObjRef,RMA.Rhino.IRhinoObjRef)">
            <summary>Determine if two CRhinoObjRefs refer to the same object.</summary>
            <returns>true if the object and object and geometry pointers are equal.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.#ctor(RMA.Rhino.IRhinoObject)">
            <summary>object in doc</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObjRef.#ctor(System.Guid)">
            <summary>object uuid</summary>
        </member>
        <member name="T:RMA.Rhino.MRhinoObjRef">
            <summary>
CRhinoObjRef is used to store references to objects returned by CRhinoGetPoint and CRhinoGetObject
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjRef.GetInstanceTransformation(RMA.OpenNURBS.OnXform@,RMA.Rhino.IRhinoInstanceObject[]@,RMA.OpenNURBS.OnXform[]@)">
            <summary>
If the CRhinoObjRef geometry is in the list returned by RhinoGetRenderMeshes or RhinoGetAnalysisMeshes and a 
transformed version of a piece of geometry that is ultimately part of an instance  definition, then this 
function returns that top level instance reference and the complete transformation that was applied to the 
piece of geometry.
</summary>
            <param name="xform">[out] transformation is returned here.</param>
            <param name="nested_iref_objects">
[out] a list of nested instance references is returned here.
If there are no nested references the list is empty.
The first item in the list is the non-nested instance.
The last item in a multi-item list will be the penultimate instance reference.
</param>
            <param name="nested_iref_xforms">
[out] a list of nested instance reference xforms is returned here.
If there are no nested references the list is empty.
The first item in the list is the non-nested instance.
The last item in a multi-item list will be the penultimate instance reference.
</param>
            <returns>
NULL if this geometry did not come from an instance definition.
Pointer to the top level instance reference if the geometry did come from an instance definition.
</returns>
            <example>
Assume a CRhinoMeshObject M2 is the geometry for instance defintion D1.
CRhinoInstanceObject R1 is a reference to D1 and the geometry for instance definition D2.
R2 is a reference to D2 and the geometry for instance definion D3.  R3 is a reference to D3.
Then CRhinoObjRef::Object() CRhinoObjRef::Object() would return a pointer to M2 and
CRhinoObjRef::Geometry() would return a pointer to a mesh that is already transformed
to be in the correct location.
CRhinoObjRef::GetInstanceTransformation() would return a pointer to R3, xform would be
the transformation that was used to move M2-&gt;Mesh() to the location of the returned
mesh, and the and the nested_iref[] array would be (R2,R1).
</example>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjRef.GetInstanceTransformation(RMA.OpenNURBS.OnXform@)">
            <summary>
If the CRhinoObjRef geometry is in the list returned by RhinoGetRenderMeshes or RhinoGetAnalysisMeshes and a 
transformed version of a piece of geometry that is ultimately part of an instance  definition, then this 
function returns that top level instance reference and the complete transformation that was applied to the 
piece of geometry.
</summary>
            <param name="xform">[out] transformation is returned here.</param>
            <returns>
NULL if this geometry did not come from an instance definition.
Pointer to the top level instance reference if the geometry did come from an instance definition.
</returns>
            <example>
Assume a CRhinoMeshObject M2 is the geometry for instance defintion D1.
CRhinoInstanceObject R1 is a reference to D1 and the geometry for instance definition D2.
R2 is a reference to D2 and the geometry for instance definion D3.  R3 is a reference to D3.
Then CRhinoObjRef::Object() CRhinoObjRef::Object() would return a pointer to M2 and
CRhinoObjRef::Geometry() would return a pointer to a mesh that is already transformed
to be in the correct location.
CRhinoObjRef::GetInstanceTransformation() would return a pointer to R3, xform would be
the transformation that was used to move M2-&gt;Mesh() to the location of the returned
mesh, and the and the nested_iref[] array would be (R2,R1).
</example>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjRef.TrimParameter(System.Double@)">
            <summary>
If the reference geometry is an edge of a surface,
then this gets the trim paramter of the selection point.
</summary>
            <param name="trim_parameter">
[out] If nonnull pointer is returned, this is then *trim_parameter is the parameter of the selection point.
</param>
            <returns>
If the selection point was on the edge of a surface, a pointer
to the associated trim is returned.
See Also: CRhinoObjRef::CurveParameter
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjRef.SurfaceParameter(System.Double@,System.Double@)">
            <summary>
If the reference geometry is a surface, brep with one face,
or surface edge with a selection point, then this gets the 
surface paramters of the selection point.
</summary>
            <param name="u">
[out] If the selection point was on surface, then (*u,*v)
are the parameters of the selection point.
</param>
            <returns>
If the selection point was on a surfce, the
the surface is returned.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjRef.CurveParameter(System.Double@)">
            <summary>
If the reference geometry is a curve or edge with a selection
point, then this gets the paramter of the selection point.
</summary>
            <param name="curve_parameter">
[out] If the selection point is on a curve or edge,
then *curve_parametert is the parameter of the selection point.
</param>
            <returns>
If the selection point was on a curve or edge, a pointer
to the curve/edge is returned.
See Also:
CRhinoObjRef::Curve
CRhinoObjRef::TrimParameter
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjRef.SelectionView">
            <summary>
If the object was interactively selected in a particular viewport, then
SelectionView() returns the view where the object was selected.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjRef.SelectionPoint(RMA.OpenNURBS.On3dPoint@)">
            <summary>
If the object was selected by picking a point on it, then
SelectionPoint() returns true and the point where the selection occured.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjRef.SelectionDistance">
            <returns>
Relative visual distance from pick point to the object.
0 (spot on) to 2 (outer corner of pick box)
0 is returned for objects that were not picked using a point pick.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjRef.SelectionDepth">
            <summary>
Returns: Depth of selection point. -1 (far away) to 1 (near) or ON_UNSET_VALUE if not available.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjRef.SelectionStyle">
            <summary>
Returns: 0: not a shaded mode point pick 1: shaded mode point pick
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjRef.SelectionMethod">
            <summary>Get the method used to select this object.</summary>
            <returns>
0: selected by non-mouse method (SelAll, etc.)
1: selected by mouse click on the object
2: selected by being inside of a mouse window
3: selected by intersecting a mouse crossing window
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjRef.IsSubGeometry">
            <returns>
true if the selected piece of geometry is a proper sub-part of the parent object.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjRef.Light">
            <summary>
If the referenced geometry is some type of render light, this returns the render light.
</summary>
            <returns>
light or NULL.
See Also: CRhinoObjectRef::Geometry CRhinoObjectRef::GeometryType
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjRef.Annotation">
            <summary>If the referenced geometry is some type of annotation, this returns the annotation.</summary>
            <returns>
mesh or NULL.
See Also: CRhinoObjectRef::Geometry CRhinoObjectRef::GeometryType
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjRef.MeshFace">
            <summary>If the referenced geometry is a mesh, this returns the mesh.</summary>
            <returns>
mesh or NULL.
See Also: CRhinoObjectRef::Geometry CRhinoObjectRef::GeometryType
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjRef.MeshEdge">
            <summary>If the referenced geometry is a mesh, this returns the mesh.</summary>
            <returns>
mesh or NULL.
See Also: CRhinoObjectRef::Geometry CRhinoObjectRef::GeometryType
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjRef.MeshVertex">
            <summary>If the referenced geometry is a mesh vertex, this returns the mesh vertex.</summary>
            <returns>
mesh or NULL.
See Also: CRhinoObjectRef::Geometry CRhinoObjectRef::GeometryType
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjRef.Mesh">
            <summary>
If the referenced geometry is a mesh, mesh vertex, mesh edge, or mesh face, this returns the mesh.
</summary>
            <returns>
mesh or NULL.
See Also: CRhinoObjectRef::Geometry CRhinoObjectRef::GeometryType
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjRef.Brep">
            <summary>
If the referenced geometry is a brep, a surface, or an edge, this returns the brep.
</summary>
            <returns>
brep or NULL.
See Also: CRhinoObjectRef::Geometry CRhinoObjectRef::GeometryType
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjRef.Face">
            <summary>
If the referenced geometry is a brep face, a brep with one face, or an edge of a
surface, this returns the brep face.
</summary>
            <returns>
surface or NULL.
See Also: CRhinoObjectRef::Geometry CRhinoObjectRef::GeometryType
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjRef.Loop">
            <summary>If the referenced geometry is an edge of a surface, this returns the associated brep trim.</summary>
            <returns>trim or NULL.</returns>
            <remarks>
The associated object is a CRhinoBrepObject.
See Also: CRhinoObjectRef::Curve CRhinoObjectRef::Trim CRhinoObjectRef::Brep CRhinoObjectRef::Geometry CRhinoObjectRef::GeometryType
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjRef.Trim">
            <summary>If the referenced geometry is an edge of a surface, this returns the associated brep trim.</summary>
            <returns>trim or NULL.</returns>
            <remarks>
The associated object is a CRhinoBrepObject.
See Also: CRhinoObjectRef::Curve CRhinoObjectRef::Trim CRhinoObjectRef::Brep CRhinoObjectRef::Geometry CRhinoObjectRef::GeometryType
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjRef.Edge">
            <summary>If the referenced geometry is an edge, this returns the edge.</summary>
            <returns>
edge or NULL.
See Also: CRhinoObjectRef::Curve CRhinoObjectRef::Trim CRhinoObjectRef::Brep CRhinoObjectRef::Geometry CRhinoObjectRef::GeometryType
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjRef.Surface">
            <summary>
If the referenced geometry is a surface, a brep with one face, or an edge
of a surface, this returns the surface.
</summary>
            <returns>
surface or NULL.
See Also: CRhinoObjectRef::Geometry CRhinoObjectRef::GeometryType
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjRef.Curve">
            <summary>If the referenced geometry is a curve or edge, this returns the curve.</summary>
            <returns>
curve or NULL.
See Also: CRhinoObjectRef::Edge CRhinoObjectRef::Geometry CRhinoObjectRef::GeometryType
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjRef.PointCloud">
            <summary>If the referenced geometry is a point cloud, this returns the point cloud.</summary>
            <returns>
point or NULL.
See Also: CRhinoObjectRef::Geometry CRhinoObjectRef::GeometryType
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjRef.Point">
            <summary>If the referenced geometry is a point, this returns the point.</summary>
            <returns>
point or NULL.
See Also: CRhinoObjectRef::Geometry CRhinoObjectRef::GeometryType
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjRef.Geometry">
            <summary>
Returns the referenced piece of geometry. This piece of geometry may be a
sub-part of the parent object geometry.
</summary>
            <returns>Pointer to the referenced piece of geometry.</returns>
            <remarks>
CRhinoObjRef::Geometry is a low level utility function and, in general, it is
more convienient to use GeometryType to determine the type of referenced geometry
and the Point, Curve, ..., functions to get at the actual geometry.
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjRef.GeometryComponentIndex">
            <summary>Get the component index of the referenced (sub) geometry.</summary>
            <returns>
-1 Top level object is referenced.
&gt;0 component index of the referenced subgeometry.
</returns>
            <remarks>
Some objects have subobjects that are valid pieces of geometry.
For example, breps have edges and faces that are valid curves and surfaces.
Each subobject has a component index that is &gt; 0. The parent geometry has a component index = -1.
See Also: CRhinoObjRef::Geometry
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjRef.GeometryType">
            <returns>the type of referenced geometry.</returns>
            <remarks>
The reference geometry may be a component of the parent object's geometry.
So, the type returned by this function may be different than the type parent object's geometry.
See Also: CRhinoObjRef::Geometry
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjRef.Object">
            <returns>the referenced Rhino object</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObjRef.ObjectUuid">
            <returns>the id of the referenced Rhino object.</returns>
        </member>
        <member name="T:RMA.Rhino.IRhinoObjRef">
            <summary>
CRhinoObjRef is used to store references to objects returned by CRhinoGetPoint and CRhinoGetObject
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoProxyObject.DeleteGeometry">
            <summary>
Returns: The value of m_bDeleteGeometry. If this is true,
then ~CRhinoProxyObject() will delete the geometry.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoProxyObject.SetGeometry(RMA.OpenNURBS.OnGeometry)">
            <summary>Use this to hang a piece of geometry off the rhino proxy object.</summary>
            <param name="geometry">
[in] geometry. Pass a NULL to clear existing geometry. If geometry is NULL, any existing
m_geometry will not be deleted
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoProxyObject.#ctor(RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <summary>assigns a new object UUID</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoProxyObject.#ctor">
            <summary>assigns a new object UUID</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoProxyObject.DeleteGeometry">
            <returns>
The value of m_bDeleteGeometry. If this is true, then ~CRhinoProxyObject() will delete the geometry.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPhantomObject.Duplicate">
            <summary>
copies source object UUID
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPhantomObject.#ctor(RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <summary>
assigns a new object UUID
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPhantomObject.#ctor">
            <summary>
assigns a new object UUID
</summary>
        </member>
        <member name="P:RMA.Rhino.MRhinoPhantomObject.m_CRhinoPhantomObject_class_id">
            <value>
CRhinoPhantomObject acts like an ordinary CRhinoObject
but is NEVER saved in file.
</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.PrepareToWrite(System.Int32)">
            <summary>
Called before the object is saved to a 3dm archive so that the object pointed
to by m_geometry can prepared for writing.
</summary>
            <param name="archive_3dm_version">
[in] Version of the 3dm archive 2 = Rhino2, 3 = Rhino3, 4 = Rhino4.
</param>
            <returns>True if m_geometry should be saved. False otherwise.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.GetSubObjects(RMA.Rhino.MRhinoObject[]@)">
            <summary>Explode this object into subobjects.</summary>
            <param name="subObjects">
[out] subobjects are appended to this list. The returned objects have not
been added to the document and it is the caller's responsibility to manage them.
</param>
            <returns>
Number of subobjects ( &gt;= 2 ) or 0 if this
object cannot be exploded.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.GetSubObjects(RMA.Rhino.MRhinoObject[]@,RMA.Rhino.IRhinoViewport)">
            <summary>Explode this object into subobjects.</summary>
            <param name="subObjects">
[out] subobjects are appended to this list. The returned objects have not
been added to the document and it is the caller's responsibility to manage them.
</param>
            <param name="pViewport">
[in] Some objects' appearance is viewport dependent. If not NULL, the object should
be exploded with respect to its appearance in this viewport.
</param>
            <returns>
Number of subobjects ( &gt;= 2 ) or 0 if this
object cannot be exploded.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.UpdateBoundingBox">
            <summary>
updates CRhinoObject.m_bbox member.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.IsSolid">
            <summary>
Returns true if object is a closed solid otherwise false.  GetMeshes may
return more than one mesh to represent a solid object.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.GetWireframeCurves(RMA.OpenNURBS.OnCurve[]@)">
            <summary>Get curves that are used to display the object's wireframe.</summary>
            <param name="curve_list">
[in] 3d world space wireframe curves are appended to this list. The caller is
responsible for deleting the curves.
</param>
            <returns>Number of curves appended to the list.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.GetMeshes(RMA.OpenNURBS.IOn.mesh_type,RMA.OpenNURBS.IOnMesh[]@)">
            <summary>Get existing meshes used to render and analyze surface and polysrf objects.</summary>
            <param name="mesh_type">[in] type of mesh to get</param>
            <param name="meshes">
[out] meshes are appended to this array. The CRhinoObject owns these meshes so the cannot be modified.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.DestroyMeshes(RMA.OpenNURBS.IOn.mesh_type)">
            <summary>Destroy meshes used to render and analyze surface and polysrf objects.</summary>
            <param name="mesh_type">[in] type of mesh to destroy</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.DestroyMeshes(RMA.OpenNURBS.IOn.mesh_type,System.Boolean)">
            <summary>Destroy meshes used to render and analyze surface and polysrf objects.</summary>
            <param name="mesh_type">[in] type of mesh to destroy</param>
            <param name="bDeleteMeshes">
[in] if true, cached meshes are deleted. If false, pointers to cached meshes are just set to NULL.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.CreateMeshes(RMA.OpenNURBS.IOn.mesh_type,RMA.OpenNURBS.IOnMeshParameters)">
            <summary>Create meshes used to render and analyze surface and polysrf objects.</summary>
            <param name="mesh_type">[in] type of meshes to</param>
            <param name="mp">[in] in parameters that control the quality of the meshes that are created.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.MeshCount(RMA.OpenNURBS.IOn.mesh_type)">
            <summary>
CRhinoHeaders can have several different types of meshes and different numbers of meshes.
A b-rep can have a render and an analysis mesh on each face. A mesh object has a single 
render mesh and no analysis mesh.  Curve, point, and annotation objects have no meshes.
</summary>
            <param name="mesh_type">[in] type of mesh to count</param>
            <returns>number of meshes.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.MeshCount(RMA.OpenNURBS.IOn.mesh_type,RMA.OpenNURBS.IOnMeshParameters)">
            <summary>
CRhinoHeaders can have several different types of meshes and different numbers of meshes.
A b-rep can have a render and an analysis mesh on each face. A mesh object has a single 
render mesh and no analysis mesh.  Curve, point, and annotation objects have no meshes.
</summary>
            <param name="mesh_type">[in] type of mesh to count</param>
            <param name="mp">
[in] if not NULL and if the object can change its mesh (like a brep),
then only meshes that were created with these mesh parameters are counted.
</param>
            <returns>number of meshes.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.IsMeshable(RMA.OpenNURBS.IOn.mesh_type)">
            <summary>
Gets the history record that describes how this object was created. This information is used to update this object when Rhino history is enabled and an input object changes. Returns: NULL or a pointer to the history record for this object.
</summary>
            <returns>true if the object is capable of having a mesh of the specified type.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.ShortDescription(System.Boolean)">
            <summary>
Localized short description of object like "curve", "surface",
"mesh", etc.).
</summary>
            <param name="bPlural">
[in] If true, then a plural, like "curves", "surfaces", etc., is returned.
</param>
            <returns>NULL terminated string.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.InAnalysisMode">
            <summary>
Returns: True if any visual analysis mode is active
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.InAnalysisMode(System.Guid)">
            <summary>Reports if an analysis mode is currently enabled for an object</summary>
            <param name="am_id">[in]</param>
            <returns>True if the analysis display mode is currently enabled.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.EnableAnalysisMode(System.Guid)">
            <summary>Used to turn analysis modes on and off.</summary>
            <param name="am_id">[in] specifies analysis mode</param>
            <remarks>
The zebra, emap, curvature, and draftangle surface analysis modes are mutually exclusive.
Turning one on will automatically turn off the other three. The edge and curvature_graph
modes are independent of all other modes.
</remarks>
            <returns>True if this object supports the analysis mode.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.EnableAnalysisMode(System.Guid,System.Boolean)">
            <summary>Used to turn analysis modes on and off.</summary>
            <param name="am_id">[in] specifies analysis mode</param>
            <param name="bEnable">[in] true to turn mode on.</param>
            <remarks>
The zebra, emap, curvature, and draftangle surface analysis modes are mutually exclusive.
Turning one on will automatically turn off the other three. The edge and curvature_graph
modes are independent of all other modes.
</remarks>
            <returns>True if this object supports the analysis mode.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.ObjectDrawColor(RMA.Rhino.IRhinoObjectAttributes)">
            <summary>
Examines the attributes and gets the color that should be used to draw this object.
</summary>
            <param name="attributes">
[in] Source for color information...normally color information is taken from the
object's attributes, however, in this case all color info will be determined
base on the passed in attributes object.
</param>
            <returns>
drawing color Remarks: Objects and layers can have colors assigned to them The
value of attributes.ColorSource() determines if the object's color or the
object's layer color should be used to draw the object in a normal state.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.ObjectDrawColor(RMA.Rhino.IRhinoObjectAttributes,System.Boolean)">
            <summary>
Examines the attributes and gets the color that should be used to draw this object.
</summary>
            <param name="attributes">
[in] Source for color information...normally color information is taken from the
object's attributes, however, in this case all color info will be determined
base on the passed in attributes object.
</param>
            <param name="bIgnoreObjectState">
[in] Objects can be in one of 4 states: selected, normal, locked, and hidden. locked objects.
By default, selected objects are drawn in RhinoApp().AppSettings().SelectedObjectColor(),
locked objects are drawn in RhinoApp().AppSettings().LockedObjectColor(), and normal objects
are drawn in the color determined by the attributes settings. If you want to ignore the
object state and get the color determined by the attributes, the pass true.
</param>
            <returns>
drawing color Remarks: Objects and layers can have colors assigned to them The
value of attributes.ColorSource() determines if the object's color or the
object's layer color should be used to draw the object in a normal state.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.ObjectDrawColor">
            <summary>
Examines the attributes and gets the color that should be used to draw a wireframe image of this object.
</summary>
            <returns>wireframe image drawing color</returns>
            <remarks>
Objects and layers can have colors assigned to them The value of
CRhinoObject::Attributes().ColorSource() determines if the object's color or
the object's layer color should be used to draw the object in a normal state.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.ObjectDrawColor(System.Boolean)">
            <summary>
Examines the attributes and gets the color that should be used to draw a wireframe image of this object.
</summary>
            <param name="bIgnoreObjectState">
[in] Objects can be in one of 4 states: selected, normal, locked, and hidden. locked objects.
By default, selected objects are drawn in RhinoApp().AppSettings().SelectedObjectColor(),
locked objects are drawn in RhinoApp().AppSettings().LockedObjectColor(), and normal objects
are drawn in the color determined by the attributes settings. If you want to ignore the
object state and get the color determined by the attributes, the pass true.
</param>
            <returns>wireframe image drawing color</returns>
            <remarks>
Objects and layers can have colors assigned to them The value of
CRhinoObject::Attributes().ColorSource() determines if the object's color or
the object's layer color should be used to draw the object in a normal state.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.SetTextureCoordinates(RMA.OpenNURBS.IOnTextureMapping,RMA.OpenNURBS.IOnXform)">
            <summary>
If the object is a mesh or has existing render meshes, then this call
uses mapping to set the texture coordinates.
</summary>
            <param name="mapping">
[in] Texture mapping function used to calculate the mesh's texture coordinates.
</param>
            <param name="object_xform">
[in] (optional) Pass if the object has been transformed after the mapping was set.
For example, if a mapping M was used to calculate the objects's texture
coordinates, the object was subsequently transformed by T, and for some reason
you needed to use M to recalculate the original texture coordinates, then you
would pass the T as object_xform.
</param>
            <returns>
True if the object's texture coordinates are set.
False if the the coordinates cannot be set (the object may not have texture
coordinates, like a point, or it may not have render mesh, like a new
CRhinoBrepObject, or the mapping calculation may fail.

The CRinoObject::Attributes()::m_rendering_attributes and CRhinoDoc::m_texture_mapping_table
has tools to get texture mappings.  
See Also: ON_TextureMapping::GetTextureCoordinates  ON_Mesh::SetTextureCoordinates 
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.SetTextureCoordinates(RMA.OpenNURBS.IOnTextureMapping,RMA.OpenNURBS.IOnXform,System.Boolean)">
            <summary>
If the object is a mesh or has existing render meshes, then this call
uses mapping to set the texture coordinates.
</summary>
            <param name="mapping">
[in] Texture mapping function used to calculate the mesh's texture coordinates.
</param>
            <param name="object_xform">
[in] (optional) Pass if the object has been transformed after the mapping was set.
For example, if a mapping M was used to calculate the objects's texture
coordinates, the object was subsequently transformed by T, and for some reason
you needed to use M to recalculate the original texture coordinates, then you
would pass the T as object_xform.
</param>
            <param name="bLazy">
[in] If true, then the calculation is performed only if the current mesh texture
coordinates were calculated with a different mapping.
</param>
            <returns>
True if the object's texture coordinates are set.
False if the the coordinates cannot be set (the object may not have texture
coordinates, like a point, or it may not have render mesh, like a new
CRhinoBrepObject, or the mapping calculation may fail.

The CRinoObject::Attributes()::m_rendering_attributes and CRhinoDoc::m_texture_mapping_table
has tools to get texture mappings.  
See Also: ON_TextureMapping::GetTextureCoordinates  ON_Mesh::SetTextureCoordinates  CRhinoObject::GetTextureMapping
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.ObjectMaterial(System.Guid@)">
            <summary>Gets the material used to render the object's front side.</summary>
            <param name="plugin_id">
[in] (optional) If not present, the plugin_id returned by RhinoApp().GetDefaultRenderApp() is used.
</param>
            <returns>
A reference to a rendering material. When no material is explicitly specified, this is
the default material RhinoApp().AppSettings().DefaultMaterial().
NOTE WELL: If the material table is modified, this pointer will become invalid.
Do not use this pointer for saving long term reference to the material. Use the
material index or id instead.
See Also CRhinoObjectAttributes::ObjectMaterialRef CRhinoMaterialTable::GetMaterials CRhinoObject::ObjectMaterialRef
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.ObjectMaterial">
            <summary>Gets the material used to render the object's front side.</summary>
            <returns>
A reference to a rendering material. When no material is explicitly specified, this is
the default material RhinoApp().AppSettings().DefaultMaterial().
NOTE WELL: If the material table is modified, this pointer will become invalid.
Do not use this pointer for saving long term reference to the material. Use the
material index or id instead.
See Also CRhinoObjectAttributes::ObjectMaterialRef CRhinoMaterialTable::GetMaterials CRhinoObject::ObjectMaterialRef
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.ObjectLinetype">
            <summary>All objects reference a linetype.</summary>
            <returns>
Linetype this object is references to. ( -1 == solid/continuous)
NOTE WELL: This linetype reference may become invalid if the linetype table is
modified in any way. Do not use this pointer as a long term reference to a linetype.
See Also: CRhinoObject::Attributes
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.ObjectLayer">
            <summary>All objects are assigned to a layer.</summary>
            <returns>
Layer this object is assigned to. NOTE WELL: This layer reference may become invalid if
the layer table is modified in any way. Do not use this pointer as a long term reference
to a layer.
See Also: CRhinoObject::Attributes
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.Attributes">
            <summary>
Object attributes include normal/locked/hidden status, name, layer, rendering attributes,
display attributes, group membership, and so on.
</summary>
            <returns>Attributes</returns>
            <remarks>
Some attributes like drawing color and rendering material can be specified per object or per layer.
The values of the attributes ColorSource() and MaterialSource() determine which definition should
be used.
See Also: CRhinoObject::ObjectLayer, CRhinoObject::ObjectMaterial, CRhinoObject::ObjectColor
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.ModifyAttributes(RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <summary>Used to change object attrributes like name, layer, color, rendering material, etc.</summary>
            <param name="new_attributes">[in] new object attributes. Values are copied.</param>
            <returns>
true if successful. false if the layer index, material index, or any of the group indices are invalid.
</returns>
            <remarks>
ModifyAttributes() will not change the object's uuid. If
doc.m_layer_table[new_attributes.LayerIndex()].IsDeleted() is true, the layer is
automatically undeleted. If doc.m_material_table[new_attributes.RenderMaterialIndex()].IsDeleted()
is true, the material is automatically undeleted.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.ModifyAttributes(RMA.OpenNURBS.IOn3dmObjectAttributes,System.Boolean)">
            <summary>Used to change object attrributes like name, layer, color, rendering material, etc.</summary>
            <param name="new_attributes">[in] new object attributes. Values are copied.</param>
            <param name="bEnableUndo">
[in] if true, the attribute change can be undone by calling UndoModifyAttributes().
</param>
            <returns>
true if successful. false if the layer index, material index, or any of the group indices are invalid.
</returns>
            <remarks>
ModifyAttributes() will not change the object's uuid. If
doc.m_layer_table[new_attributes.LayerIndex()].IsDeleted() is true, the layer is
automatically undeleted. If doc.m_material_table[new_attributes.RenderMaterialIndex()].IsDeleted()
is true, the material is automatically undeleted.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.ModifyAttributes(RMA.OpenNURBS.IOn3dmObjectAttributes,System.Boolean,System.Boolean)">
            <summary>Used to change object attrributes like name, layer, color, rendering material, etc.</summary>
            <param name="new_attributes">[in] new object attributes. Values are copied.</param>
            <param name="bEnableUndo">
[in] if true, the attribute change can be undone by calling UndoModifyAttributes().
</param>
            <param name="bQuiet">[in] true to run quietly.</param>
            <returns>
true if successful. false if the layer index, material index, or any of the group indices are invalid.
</returns>
            <remarks>
ModifyAttributes() will not change the object's uuid. If
doc.m_layer_table[new_attributes.LayerIndex()].IsDeleted() is true, the layer is
automatically undeleted. If doc.m_material_table[new_attributes.RenderMaterialIndex()].IsDeleted()
is true, the material is automatically undeleted.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.GetFrame(RMA.OpenNURBS.OnPlane@)">
            <summary>Gets 3d frame for object.</summary>
            <param name="plane">[out] 3d frame</param>
            <returns>true if successful</returns>
            <remarks>
The default implementation uses m_geometry-&gt;BoundingBox(), lazy evaluation, and
caches the result in m_bbox. If you override this function, then you must set m_bbox.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>Get tight bounding box of this Rhino object.</summary>
            <param name="tight_box">[in/out] tight bounding box</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Boolean)">
            <summary>Get tight bounding box of this Rhino object.</summary>
            <param name="tight_box">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in](default=false) If true and the input tight_bbox is valid, then returned
tight_bbox is the union of the input tight_bbox and the tight bounding box of
this Rhino object.
</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Boolean,RMA.OpenNURBS.IOnXform)">
            <summary>Get tight bounding box of this Rhino object.</summary>
            <param name="tight_box">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in](default=false) If true and the input tight_bbox is valid, then returned
tight_bbox is the union of the input tight_bbox and the tight bounding box of
this Rhino object.
</param>
            <param name="xform">
[in] (default=NULL) If not NULL, the tight bounding box of the transformed
Rhino object is calculated.  The Rhino object is not modified.
</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.BoundingBox(RMA.Rhino.IRhinoView)">
            <summary>
Gets 3d axis aligned world coordinate bounding box that 
contains the geometry used to display the object.  
For most objects, this is the same as BoundingBox().
For objects like lights that use an icon, the world 
coordinate bounding box depends on the view.
</summary>
            <returns>3d bounding box</returns>
            <remarks>The default implementation calls BoundingBox().</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.BoundingBox">
            <summary>Gets 3d axis aligned bounding box that contains the object.</summary>
            <returns>3d bounding box</returns>
            <remarks>
The default implementation uses m_geometry-&gt;BoundingBox(), lazy evaluation,
and caches the result in m_bbox. If you override this function, then you must set m_bbox.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.Geometry">
            <summary>returns a pointer to the object's geometry</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.DrawHighlightedSubObjects(RMA.Rhino.MRhinoViewport@)">
            <summary>
Draws wireframe representation of highlighed sub objects.
objects that support subobject highlighting must override this function
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.DrawSubObject(RMA.Rhino.MRhinoViewport@,RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Draws wireframe representation of a sub object.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.DrawHighlightedSubObjects(RMA.Rhino.MRhinoDisplayPipeline)">
            <summary>
Draws wireframe representation of highlighed sub objects.
objects that support subobject highlighting must override this function
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.DrawSubObject(RMA.Rhino.MRhinoDisplayPipeline,RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Draws wireframe representation of a sub object.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.Draw(RMA.Rhino.MRhinoDisplayPipeline)">
            <summary>Draws object based on pipeline display attributes...</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.DrawGrips(RMA.Rhino.MRhinoDisplayPipeline)">
            <summary>
Draws the object's grips, control polygon, and dynamic wireframe object.
Dynamic shaded objects are drawn in the Draw
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.GetGrips(RMA.Rhino.MRhinoGripObject[]@)">
            <summary>
If grips are enabled, then GetGrips appends the object's grips to the grip_list[] array.
</summary>
            <returns>
Number of grips appended to the array.
See Also: CRhinoObject::GripsOn CRhinoObject::EnableGrips
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.EnableGrips(System.Boolean)">
            <summary>Turns on the object's default editing grips</summary>
            <param name="bDefaultGripsOn">
[in] True to turn on the object's default grips.
False to turn off any grips.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.GripsSelected">
            <summary>
Returns: If the object has grips on, this returns the enabler to turn on that type of grips. If the object does not have grips on, this returns NULL.
</summary>
            <returns>
True if grips are turned on and at least one is selected.
See Also: CRhinoObject::GripsOn
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.GripsOn">
            <returns>
CRhinoGripObject::GRIP_TYPE value
0 = off
See Also: CRhinoObject::EnableGrips CRhinoObject::GripsSelected
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.IsMarked">
            <summary>
marking - no impact on display - not saved or copied
Use CRhinoDoc::ClearMarks() to set all marks to zero.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.HighlightRequiresRedraw">
            <returns>
true if pixels used by hightlighted object differ from pixels used by unhighlighted object.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.UnhighlightAllSubObjects">
            <returns>number of changed subobjects</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.GetHighlightedSubObjects(RMA.OpenNURBS.OnCOMPONENT_INDEX[]@)">
            <summary>Get a list of all highlighted sub-objects</summary>
            <param name="component_indices">[out] component indices of highlighted sub-objects.</param>
            <returns>number of highlighted subobjects</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.IsSubObjectHighlighted(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <returns>true if specified component is highlighted</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.IsHighlighted">
            <summary>
Check highlight state.
highlighted state (almost always = IsSelected() except in one or two commands)
</summary>
            <returns>
0 object is not highlighted 
1 entire object is highlighted
3 one or more proper sub-objects are highlighted
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.IsHighlighted(System.Boolean)">
            <summary>
Check highlight state.
highlighted state (almost always = IsSelected() except in one or two commands)
</summary>
            <param name="bCheckSubObjects">
[in] If true and the entire object is not highlighted, and some subset of the
object is highlighted, like some edges of a surface, then 3 is returned.
If false and the entire object is not highlighted, then zero is returned.
</param>
            <returns>
0 object is not highlighted 
1 entire object is highlighted
3 one or more proper sub-objects are highlighted
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.UnselectAllSubObjects">
            <returns>number of unselected subobjects</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.SelectSubObject(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Reports if an object can be selected.</summary>
            <param name="component_index">[in] index of subobject to check</param>
            <returns>
0: object is not selected
1: object is selected
2: object is selected persistently
</returns>
            <remarks>
Objects that are locked, hidden, or on locked or hidden layers cannot be selected.
If IsSelectableWithGripsOn() returns false, then an that object is not selectable
if it has grips turned on.
See Also: CRhinoDoc::UnselectAll CRhinoView::UnselectAllSubObjects
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.SelectSubObject(RMA.OpenNURBS.IOnCOMPONENT_INDEX,System.Boolean)">
            <summary>Reports if an object can be selected.</summary>
            <param name="component_index">[in] index of subobject to check</param>
            <param name="bSelect">[in] (default=true)</param>
            <returns>
0: object is not selected
1: object is selected
2: object is selected persistently
</returns>
            <remarks>
Objects that are locked, hidden, or on locked or hidden layers cannot be selected.
If IsSelectableWithGripsOn() returns false, then an that object is not selectable
if it has grips turned on.
See Also: CRhinoDoc::UnselectAll CRhinoView::UnselectAllSubObjects
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.SelectSubObject(RMA.OpenNURBS.IOnCOMPONENT_INDEX,System.Boolean,System.Boolean)">
            <summary>Reports if an object can be selected.</summary>
            <param name="component_index">[in] index of subobject to check</param>
            <param name="bSelect">[in] (default=true)</param>
            <param name="bSynchHighlight">
[in] (default=true) If true, then the object is hightlighted if it is selected and not
hightlighted if is is not selected.
</param>
            <returns>
0: object is not selected
1: object is selected
2: object is selected persistently
</returns>
            <remarks>
Objects that are locked, hidden, or on locked or hidden layers cannot be selected.
If IsSelectableWithGripsOn() returns false, then an that object is not selectable
if it has grips turned on.
See Also: CRhinoDoc::UnselectAll CRhinoView::UnselectAllSubObjects
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.Select(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Reports if an object can be selected.</summary>
            <param name="bSelect">[in] (default=true)</param>
            <param name="bSynchHighlight">
[in] (default=true) If true, then the object is hightlighted if it is selected and
not hightlighted if is is not selected.
</param>
            <param name="bPersistentSelect">
[in] (default=true) Objects that are persistently selected stay selected when a command terminates.
</param>
            <param name="bIgnoreGripsState">
[in] If true, then objects with grips on can be selected. If false,
then the value returned by the object's virtual IsSelectableWithGripsOn()
function decides if the object can be selected when it has grips turned on.
</param>
            <param name="bIgnoreLayerLocking">
[in] (default=false) If true, then objects on locked layers can be selected.
If false, the objects on locked layers cannot be selected.
</param>
            <param name="bIgnoreLayerVisibility">
[in] (default=false) If true, then objects on hidden layers can be selectable.
If false, the objects on hidden layers cannot be selected.
</param>
            <returns>
0: object is not selected
1: object is selected
2: object is selected persistently
</returns>
            <remarks>
Objects that are locked, hidden, or on locked or hidden layers cannot be selected.
If IsSelectableWithGripsOn() returns false, then an that object is not selectable
if it has grips turned on.
See Also: CRhinoDoc::UnselectAll
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.Select">
            <summary>Reports if an object can be selected.</summary>
            <returns>
0: object is not selected
1: object is selected
2: object is selected persistently
</returns>
            <remarks>
Objects that are locked, hidden, or on locked or hidden layers cannot be selected.
If IsSelectableWithGripsOn() returns false, then an that object is not selectable
if it has grips turned on.
See Also: CRhinoDoc::UnselectAll
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.Select(System.Boolean)">
            <summary>Reports if an object can be selected.</summary>
            <param name="bSelect">[in] (default=true)</param>
            <returns>
0: object is not selected
1: object is selected
2: object is selected persistently
</returns>
            <remarks>
Objects that are locked, hidden, or on locked or hidden layers cannot be selected.
If IsSelectableWithGripsOn() returns false, then an that object is not selectable
if it has grips turned on.
See Also: CRhinoDoc::UnselectAll
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.Select(System.Boolean,System.Boolean)">
            <summary>Reports if an object can be selected.</summary>
            <param name="bSelect">[in] (default=true)</param>
            <param name="bSynchHighlight">
[in] (default=true) If true, then the object is hightlighted if it is selected and
not hightlighted if is is not selected.
</param>
            <returns>
0: object is not selected
1: object is selected
2: object is selected persistently
</returns>
            <remarks>
Objects that are locked, hidden, or on locked or hidden layers cannot be selected.
If IsSelectableWithGripsOn() returns false, then an that object is not selectable
if it has grips turned on.
See Also: CRhinoDoc::UnselectAll
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.Select(System.Boolean,System.Boolean,System.Boolean)">
            <summary>Reports if an object can be selected.</summary>
            <param name="bSelect">[in] (default=true)</param>
            <param name="bSynchHighlight">
[in] (default=true) If true, then the object is hightlighted if it is selected and
not hightlighted if is is not selected.
</param>
            <param name="bPersistentSelect">
[in] (default=true) Objects that are persistently selected stay selected when a command terminates.
</param>
            <returns>
0: object is not selected
1: object is selected
2: object is selected persistently
</returns>
            <remarks>
Objects that are locked, hidden, or on locked or hidden layers cannot be selected.
If IsSelectableWithGripsOn() returns false, then an that object is not selectable
if it has grips turned on.
See Also: CRhinoDoc::UnselectAll
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.Select(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Reports if an object can be selected.</summary>
            <param name="bSelect">[in] (default=true)</param>
            <param name="bSynchHighlight">
[in] (default=true) If true, then the object is hightlighted if it is selected and
not hightlighted if is is not selected.
</param>
            <param name="bPersistentSelect">
[in] (default=true) Objects that are persistently selected stay selected when a command terminates.
</param>
            <param name="bIgnoreGripsState">
[in] If true, then objects with grips on can be selected.
If false, then the value returned by the object's virtual IsSelectableWithGripsOn()
function decides if the object can be selected when it has grips turned on.
</param>
            <returns>
0: object is not selected
1: object is selected
2: object is selected persistently
</returns>
            <remarks>
Objects that are locked, hidden, or on locked or hidden layers cannot be selected.
If IsSelectableWithGripsOn() returns false, then an that object is not selectable
if it has grips turned on.
See Also: CRhinoDoc::UnselectAll
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.IsSubObjectSelectable(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Reports if a subobject can be selected.</summary>
            <param name="component_index">[in] index of subobject to check</param>
            <remarks>
Objects that are locked, hidden, or on locked or hidden layers cannot be selected.
If IsSelectableWithGripsOn() returns false, then an that object is not selectable if it has grips turned on.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.IsSubObjectSelectable(RMA.OpenNURBS.IOnCOMPONENT_INDEX,System.Boolean)">
            <summary>Reports if a subobject can be selected.</summary>
            <param name="component_index">[in] index of subobject to check</param>
            <param name="bIgnoreSelectionState">
[in] (default=false) If true, then selected objects are selectable.
If false, the selected objects are not selectable.
</param>
            <remarks>
Objects that are locked, hidden, or on locked or hidden layers cannot be selected.
If IsSelectableWithGripsOn() returns false, then an that object is not selectable if it has grips turned on.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.IsSelectable(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Reports if an object can be selected.</summary>
            <param name="bIgnoreSelectionState">
[in] (default=false) If true, then selected objects are selectable.
If false, the selected objects are not selectable.
</param>
            <param name="bIgnoreGripsState">
[in] If true, then objects with grips on can be selected. If false,
then the value returned by the object's virtual IsSelectableWithGripsOn()
function decides if the object can be selected.
</param>
            <param name="bIgnoreLayerLocking">
[in] (default=false) If true, then objects on locked layers are selectable.
If false, the objects on locked layers are not selectable.
</param>
            <param name="bIgnoreLayerVisibility">
[in] (default=false) If true, then objects on hidden layers are selectable. If false,
the objects on hidden layers are not selectable.
</param>
            <returns>True if object is capable of being selected</returns>
            <remarks>
Objects that are locked or hidden cannot be selected.
If IsSelectableWithGripsOn() returns false, then an that object is not selectable
if it has grips turned on.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.IsSelectable">
            <summary>Reports if an object can be selected.</summary>
            <remarks>
Objects that are locked, hidden, or on locked or hidden layers cannot be selected.
If IsSelectableWithGripsOn() returns false, then an that object is not selectable
if it has grips turned on.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.IsSelectable(System.Boolean)">
            <summary>Reports if an object can be selected.</summary>
            <param name="bIgnoreSelectionState">
[in] (default=false) If true, then selected objects are selectable.
If false, the selected objects are not selectable.
</param>
            <remarks>
Objects that are locked, hidden, or on locked or hidden layers cannot be selected.
If IsSelectableWithGripsOn() returns false, then an that object is not selectable
if it has grips turned on.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.IsSelectable(System.Boolean,System.Boolean)">
            <summary>Reports if an object can be selected.</summary>
            <param name="bIgnoreSelectionState">
[in] (default=false) If true, then selected objects are selectable.
If false, the selected objects are not selectable.
</param>
            <param name="bIgnoreGripsState">
[in] If true, then objects with grips on can be selected.
If false, then the value returned by the object's virtual IsSelectableWithGripsOn()
function decides if the object can be selected.
</param>
            <remarks>
Objects that are locked, hidden, or on locked or hidden layers cannot be selected.
If IsSelectableWithGripsOn() returns false, then an that object is not selectable
if it has grips turned on.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.GetSelectedSubObjects(RMA.OpenNURBS.OnCOMPONENT_INDEX[]@)">
            <summary>Get a list of all selected sub-objects</summary>
            <param name="component_indices">[out] component indices of selected sub-objects.</param>
            <returns>number of selected subobjects</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.IsSubObjectSelected(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Check sub-object selection state.</summary>
            <param name="component_index">[in] index of subobject to check</param>
            <remarks>subobject cannot be persistently selected</remarks>
            <returns>
false sub-object is not selected
true sub-object is selected
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.IsSelected">
            <summary>Check selection state.</summary>
            <returns>
0 object is not selected
1 object is selected
2 entire object is selected persistently
3 one or more proper sub-objects are selected
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.IsSelected(System.Boolean)">
            <summary>Check selection state.</summary>
            <param name="bCheckSubObjects">
[in] If true and the entire object is not selected, and some subset of the
object is selected, like some edges of a surface, then 3 is returned. If
false and the entire object is not selected, then zero is returned.
</param>
            <returns>
0 object is not selected
1 object is selected
2 entire object is selected persistently
3 one or more proper sub-objects are selected
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.IsActiveInViewport(RMA.Rhino.IRhinoViewport)">
            <summary>Query to determine if this object is active in a particular viewport.</summary>
            <param name="viewport">[in]</param>
            <returns>True if the object is active in viewport.</returns>
            <remarks>
The default implementation tests for space and viewport id.
This handles things like testing if a page space object is visible in a modeling view.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.IsVisible">
            <returns>true if an object is visible and is on a layer that is visible.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.IsPageObject">
            <returns>True if the object is in page layout space.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.IsModelObject">
            <returns>True if the object is in model space.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.IsReference">
            <summary>Determine if an object is a reference object.</summary>
            <returns>True if the object is a reference object.</returns>
            <remarks>
An object from a work session reference model is reference
a reference object and cannot be modified. An object is a
reference object if, and only if, it is on a reference layer.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.IsHidden">
            <summary>
(depending on the circumstance, you may need to assign
a new UUID after using the copy constructor or operator=)
there are 3 mutually exclusive object states 
- normal (visible, can be snapped to, independent of selection state)
- locked (visible, can be snapped to, cannot be selected)
- hidden (not visible, cannot be snapped to, cannot be selected)
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.IsLocked">
            <summary>
(depending on the circumstance, you may need to assign
a new UUID after using the copy constructor or operator=)
there are 3 mutually exclusive object states 
- normal (visible, can be snapped to, independent of selection state)
- locked (visible, can be snapped to, cannot be selected)
- hidden (not visible, cannot be snapped to, cannot be selected)
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.IsNormal">
            <summary>
(depending on the circumstance, you may need to assign
a new UUID after using the copy constructor or operator=)
there are 3 mutually exclusive object states 
- normal (visible, can be snapped to, independent of selection state)
- locked (visible, can be snapped to, cannot be selected)
- hidden (not visible, cannot be snapped to, cannot be selected)
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.IsGroupObject">
            <summary>Test object to see if it is a proxy CRhinoGroupObject.</summary>
            <returns>true if this is a CRhinoGroupObject.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.IsInstanceDefinitionGeometry">
            <returns>true if object is is used as part of an instance definition.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.AddToDocNotification">
            <summary>
This call informs an object it is about to be added to the list of active objects in the document.
Some objects, like clipping planes, need to do a little extra cleanup before they are deleted.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.DeleteFromDocNotification">
            <summary>
This call informs an object it is about to be deleted. Some objects, like clipping planes,
need to do a little extra cleanup before they are deleted.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.IsDeleted">
            <returns>true if object is deleted.</returns>
            <remarks>Use CRhinoDoc::UndeleteObject() to undelete an object.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.IsDeletable">
            <summary>Some objects cannot be deleted, like grips on lights and annotation objects.</summary>
            <returns>True if object can be deleted.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.Document">
            <summary>Gets document that owns the object.</summary>
            <returns>Document that manages object.</returns>
            <remarks>
When an object is created, it does not belong to a document.
CRhinoDoc::AddObject() or CRhinoDoc::ReplaceObject() are used
to add new objects to a document.  After the object is added
to a document, it it managed by that document.  If the
CRhinoObject::Document() returns NULL, then the object is
not part of a document.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.NextRuntimeObjectSerialNumber">
            <summary>
Get the runtime serial number that will be assigned to the next CRhinoObject that is created.
</summary>
            <returns>
Returns: The runtime serial number that will be assigned to the next CRhinoObject that is created.
Example: unsigned int s0 = CRhinoObject::NextRuntimeSerialNumber();
... do a bunch of stuff
unsigned int s1 = CRhinoObject::NextRuntimeSerialNumber();
... 
const CRhinoObject* pObject = ...;
if ( s0 &lt;= pObject-&gt;m_runtime_object_serial_number &amp;&amp;
pObject-&gt;m_runtime_object_serial_number &lt; s1 )
{ // pObject was created during "... do a bunch of stuff" }
See Also: CRhinoObject::m_runtime_object_serial_number
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoObject.DuplicateRhinoObject">
            <summary>
copies source object UUID
</summary>
            <summary>
Duplicates the Rhino object. If "this" is a CRhinoProxyObject, the duplicate
is a "real" Rhino object. If "this" is an ordinary Rhino object like
a CRhinoCurveObject, CRhinoPointObject, and so on, then the dupicate is another rhino object
of the same type.
</summary>
            <returns>
NULL or a pointer to the duplicate. The new object is not added to the Rhino document.
</returns>
        </member>
        <member name="P:RMA.Rhino.MRhinoObject.m_no_show_mark">
            <value>
if m_no_show_mark!= 0 and m_no_show_mark == m_mark,
then the IsVisible() returns false.  This is used
when inserting files.
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoObject.m_use_preview_mesh">
            <value>
When an object like a CRhinoBrepObject is being meshed and
the display code should use the preview mesh instead of
the render or analysis mesh, then this flag is set to 1.
Otherwise it is set to zero.
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoObject.m_runtime_object_serial_number">
            <value>
The CRhinoObject constructors set m_runtime_object_serial_number and the serial number
is unique for each instance of the rhino.exe application. The first object created has
serial number 1, and so on. If a CRhinoObject is copied, the copy will have a different
serial number. The serial number can be used to identify objects created between two events.
The value of m_runtime_object_serial_number does NOT persist in 3DM archives and is not
unique between instances of rhino3.exe. Use the object's uuid when you need a persistent
and unique way to identify the object.
See Also: CRhinoObject::NextRuntimeObjectSerialNumber
</value>
        </member>
        <member name="T:RMA.Rhino.MRhinoObject">
            <summary>CRhinoObject is the base class for all runtime Rhino objects.</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.GetSubObjects(RMA.Rhino.MRhinoObject[]@)">
            <summary>Explode this object into subobjects.</summary>
            <param name="subObjects">
[out] subobjects are appended to this list. The returned objects have not
been added to the document and it is the caller's responsibility to manage them.
</param>
            <returns>
Number of subobjects ( &gt;= 2 ) or 0 if this
object cannot be exploded.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.GetSubObjects(RMA.Rhino.MRhinoObject[]@,RMA.Rhino.IRhinoViewport)">
            <summary>
Get a pointer to user data on a Rhino object's geometry. Parameters: userdata_uuid - [in] value of the user data's m_userdata_uuid field. Remarks: The returned user data is still attached to the object. Deleting the returned user data will automatically remove the user data from the object.
</summary>
            <summary>
Get a pointer to user data on a Rhino object's attributes. Parameters: userdata_uuid - [in] value of the user data's m_userdata_uuid field. Remarks: The returned user data is still attached to the object. Deleting the returned user data will automatically remove the user data from the object.
</summary>
            <summary>Explode this object into subobjects.</summary>
            <param name="subObjects">
[out] subobjects are appended to this list. The returned objects have not
been added to the document and it is the caller's responsibility to manage them.
</param>
            <param name="pViewport">
[in] Some objects' appearance is viewport dependent. If not NULL, the object should
be exploded with respect to its appearance in this viewport.
</param>
            <returns>
Number of subobjects ( &gt;= 2 ) or 0 if this
object cannot be exploded.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.IsSolid">
            <summary>
Returns true if object is a closed solid otherwise false.  GetMeshes may
return more than one mesh to represent a solid object.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.GetWireframeCurves(RMA.OpenNURBS.OnCurve[]@)">
            <summary>Get curves that are used to display the object's wireframe.</summary>
            <param name="curve_list">
[in] 3d world space wireframe curves are appended to this list. The caller is
responsible for deleting the curves.
</param>
            <returns>Number of curves appended to the list.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.GetMeshes(RMA.OpenNURBS.IOn.mesh_type,RMA.OpenNURBS.IOnMesh[]@)">
            <summary>Get existing meshes used to render and analyze surface and polysrf objects.</summary>
            <param name="mesh_type">[in] type of mesh to get</param>
            <param name="meshes">
[out] meshes are appended to this array. The CRhinoObject owns these meshes so the cannot be modified.
</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.MeshCount(RMA.OpenNURBS.IOn.mesh_type)">
            <summary>
CRhinoHeaders can have several different types of meshes and different numbers of meshes.
A b-rep can have a render and an analysis mesh on each face. A mesh object has a single 
render mesh and no analysis mesh.  Curve, point, and annotation objects have no meshes.
</summary>
            <param name="mesh_type">[in] type of mesh to count</param>
            <returns>number of meshes.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.MeshCount(RMA.OpenNURBS.IOn.mesh_type,RMA.OpenNURBS.IOnMeshParameters)">
            <summary>
CRhinoHeaders can have several different types of meshes and different numbers of meshes.
A b-rep can have a render and an analysis mesh on each face. A mesh object has a single 
render mesh and no analysis mesh.  Curve, point, and annotation objects have no meshes.
</summary>
            <param name="mesh_type">[in] type of mesh to count</param>
            <param name="mp">
[in] if not NULL and if the object can change its mesh (like a brep),
then only meshes that were created with these mesh parameters are counted.
</param>
            <returns>number of meshes.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.IsMeshable(RMA.OpenNURBS.IOn.mesh_type)">
            <summary>
Gets the history record that describes how this object was created. This information is used to update this object when Rhino history is enabled and an input object changes. Returns: NULL or a pointer to the history record for this object.
</summary>
            <returns>true if the object is capable of having a mesh of the specified type.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.ShortDescription(System.Boolean)">
            <summary>
Localized short description of object like "curve", "surface",
"mesh", etc.).
</summary>
            <param name="bPlural">
[in] If true, then a plural, like "curves", "surfaces", etc., is returned.
</param>
            <returns>NULL terminated string.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.InAnalysisMode">
            <summary>
Returns: True if any visual analysis mode is active
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.InAnalysisMode(System.Guid)">
            <summary>Reports if an analysis mode is currently enabled for an object</summary>
            <param name="am_id">[in]</param>
            <returns>True if the analysis display mode is currently enabled.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.EnableAnalysisMode(System.Guid)">
            <summary>Used to turn analysis modes on and off.</summary>
            <param name="am_id">[in] specifies analysis mode</param>
            <remarks>
The zebra, emap, curvature, and draftangle surface analysis modes are mutually exclusive.
Turning one on will automatically turn off the other three. The edge and curvature_graph
modes are independent of all other modes.
</remarks>
            <returns>True if this object supports the analysis mode.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.EnableAnalysisMode(System.Guid,System.Boolean)">
            <summary>Used to turn analysis modes on and off.</summary>
            <param name="am_id">[in] specifies analysis mode</param>
            <param name="bEnable">[in] true to turn mode on.</param>
            <remarks>
The zebra, emap, curvature, and draftangle surface analysis modes are mutually exclusive.
Turning one on will automatically turn off the other three. The edge and curvature_graph
modes are independent of all other modes.
</remarks>
            <returns>True if this object supports the analysis mode.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.ObjectDrawColor(RMA.Rhino.IRhinoObjectAttributes)">
            <summary>
Examines the attributes and gets the color that should be used to draw this object.
</summary>
            <param name="attributes">
[in] Source for color information...normally color information is taken from the
object's attributes, however, in this case all color info will be determined
base on the passed in attributes object.
</param>
            <returns>
drawing color Remarks: Objects and layers can have colors assigned to them The
value of attributes.ColorSource() determines if the object's color or the
object's layer color should be used to draw the object in a normal state.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.ObjectDrawColor(RMA.Rhino.IRhinoObjectAttributes,System.Boolean)">
            <summary>
Examines the attributes and gets the color that should be used to draw this object.
</summary>
            <param name="attributes">
[in] Source for color information...normally color information is taken from the
object's attributes, however, in this case all color info will be determined
base on the passed in attributes object.
</param>
            <param name="bIgnoreObjectState">
[in] Objects can be in one of 4 states: selected, normal, locked, and hidden. locked objects.
By default, selected objects are drawn in RhinoApp().AppSettings().SelectedObjectColor(),
locked objects are drawn in RhinoApp().AppSettings().LockedObjectColor(), and normal objects
are drawn in the color determined by the attributes settings. If you want to ignore the
object state and get the color determined by the attributes, the pass true.
</param>
            <returns>
drawing color Remarks: Objects and layers can have colors assigned to them The
value of attributes.ColorSource() determines if the object's color or the
object's layer color should be used to draw the object in a normal state.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.ObjectDrawColor">
            <summary>
Examines the attributes and gets the color that should be used to draw a wireframe image of this object.
</summary>
            <returns>wireframe image drawing color</returns>
            <remarks>
Objects and layers can have colors assigned to them The value of
CRhinoObject::Attributes().ColorSource() determines if the object's color or
the object's layer color should be used to draw the object in a normal state.
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.ObjectDrawColor(System.Boolean)">
            <summary>
Examines the attributes and gets the color that should be used to draw a wireframe image of this object.
</summary>
            <param name="bIgnoreObjectState">
[in] Objects can be in one of 4 states: selected, normal, locked, and hidden. locked objects.
By default, selected objects are drawn in RhinoApp().AppSettings().SelectedObjectColor(),
locked objects are drawn in RhinoApp().AppSettings().LockedObjectColor(), and normal objects
are drawn in the color determined by the attributes settings. If you want to ignore the
object state and get the color determined by the attributes, the pass true.
</param>
            <returns>wireframe image drawing color</returns>
            <remarks>
Objects and layers can have colors assigned to them The value of
CRhinoObject::Attributes().ColorSource() determines if the object's color or
the object's layer color should be used to draw the object in a normal state.
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.SetTextureCoordinates(RMA.OpenNURBS.IOnTextureMapping,RMA.OpenNURBS.IOnXform)">
            <summary>
If the object is a mesh or has existing render meshes, then this call
uses mapping to set the texture coordinates.
</summary>
            <param name="mapping">
[in] Texture mapping function used to calculate the mesh's texture coordinates.
</param>
            <param name="object_xform">
[in] (optional) Pass if the object has been transformed after the mapping was set.
For example, if a mapping M was used to calculate the objects's texture
coordinates, the object was subsequently transformed by T, and for some reason
you needed to use M to recalculate the original texture coordinates, then you
would pass the T as object_xform.
</param>
            <returns>
True if the object's texture coordinates are set.
False if the the coordinates cannot be set (the object may not have texture
coordinates, like a point, or it may not have render mesh, like a new
CRhinoBrepObject, or the mapping calculation may fail.

The CRinoObject::Attributes()::m_rendering_attributes and CRhinoDoc::m_texture_mapping_table
has tools to get texture mappings.  
See Also: ON_TextureMapping::GetTextureCoordinates  ON_Mesh::SetTextureCoordinates  CRhinoObject::GetTextureMapping
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.SetTextureCoordinates(RMA.OpenNURBS.IOnTextureMapping,RMA.OpenNURBS.IOnXform,System.Boolean)">
            <summary>
If the object is a mesh or has existing render meshes, then this call
uses mapping to set the texture coordinates.
</summary>
            <param name="mapping">
[in] Texture mapping function used to calculate the mesh's texture coordinates.
</param>
            <param name="object_xform">
[in] (optional) Pass if the object has been transformed after the mapping was set.
For example, if a mapping M was used to calculate the objects's texture
coordinates, the object was subsequently transformed by T, and for some reason
you needed to use M to recalculate the original texture coordinates, then you
would pass the T as object_xform.
</param>
            <param name="bLazy">
[in] If true, then the calculation is performed only if the current mesh texture
coordinates were calculated with a different mapping.
</param>
            <returns>
True if the object's texture coordinates are set.
False if the the coordinates cannot be set (the object may not have texture
coordinates, like a point, or it may not have render mesh, like a new
CRhinoBrepObject, or the mapping calculation may fail.

The CRinoObject::Attributes()::m_rendering_attributes and CRhinoDoc::m_texture_mapping_table
has tools to get texture mappings.  
See Also: ON_TextureMapping::GetTextureCoordinates  ON_Mesh::SetTextureCoordinates  CRhinoObject::GetTextureMapping
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.ObjectMaterial(System.Guid@)">
            <summary>Gets the material used to render the object's front side.</summary>
            <param name="plugin_id">
[in] (optional) If not present, the plugin_id returned by RhinoApp().GetDefaultRenderApp() is used.
</param>
            <returns>
A reference to a rendering material. When no material is explicitly specified, this is
the default material RhinoApp().AppSettings().DefaultMaterial().
NOTE WELL: If the material table is modified, this pointer will become invalid.
Do not use this pointer for saving long term reference to the material. Use the
material index or id instead.
See Also CRhinoObjectAttributes::ObjectMaterialRef CRhinoMaterialTable::GetMaterials CRhinoObject::ObjectMaterialRef
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.ObjectMaterial">
            <summary>Gets the material used to render the object's front side.</summary>
            <returns>
A reference to a rendering material. When no material is explicitly specified, this is
the default material RhinoApp().AppSettings().DefaultMaterial().
NOTE WELL: If the material table is modified, this pointer will become invalid.
Do not use this pointer for saving long term reference to the material. Use the
material index or id instead.
See Also CRhinoObjectAttributes::ObjectMaterialRef CRhinoMaterialTable::GetMaterials CRhinoObject::ObjectMaterialRef
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.ObjectLinetype">
            <summary>All objects reference a linetype.</summary>
            <returns>
Linetype this object is references to. ( -1 == solid/continuous)
NOTE WELL: This linetype reference may become invalid if the linetype table is
modified in any way. Do not use this pointer as a long term reference to a linetype.
See Also: CRhinoObject::Attributes
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.ObjectLayer">
            <summary>All objects are assigned to a layer.</summary>
            <returns>
Layer this object is assigned to. NOTE WELL: This layer reference may become invalid if
the layer table is modified in any way. Do not use this pointer as a long term reference
to a layer.
See Also: CRhinoObject::Attributes
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.Attributes">
            <summary>
Object attributes include normal/locked/hidden status, name, layer, rendering attributes,
display attributes, group membership, and so on.
</summary>
            <returns>Attributes</returns>
            <remarks>
Some attributes like drawing color and rendering material can be specified per object or per layer.
The values of the attributes ColorSource() and MaterialSource() determine which definition should
be used.
See Also: CRhinoObject::ObjectLayer, CRhinoObject::ObjectMaterial, CRhinoObject::ObjectColor
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.GetFrame(RMA.OpenNURBS.OnPlane@)">
            <summary>Gets 3d frame for object.</summary>
            <param name="plane">[out] 3d frame</param>
            <returns>true if successful</returns>
            <remarks>
The default implementation uses m_geometry-&gt;BoundingBox(), lazy evaluation, and
caches the result in m_bbox. If you override this function, then you must set m_bbox.
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>Get tight bounding box of this Rhino object.</summary>
            <param name="tight_box">[in/out] tight bounding box</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Boolean)">
            <summary>Get tight bounding box of this Rhino object.</summary>
            <param name="tight_box">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in](default=false) If true and the input tight_bbox is valid, then returned
tight_bbox is the union of the input tight_bbox and the tight bounding box of
this Rhino object.
</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Boolean,RMA.OpenNURBS.IOnXform)">
            <summary>Get tight bounding box of this Rhino object.</summary>
            <param name="tight_box">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in](default=false) If true and the input tight_bbox is valid, then returned
tight_bbox is the union of the input tight_bbox and the tight bounding box of
this Rhino object.
</param>
            <param name="xform">
[in] (default=NULL) If not NULL, the tight bounding box of the transformed
Rhino object is calculated.  The Rhino object is not modified.
</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.BoundingBox(RMA.Rhino.IRhinoView)">
            <summary>
Gets 3d axis aligned world coordinate bounding box that 
contains the geometry used to display the object.  
For most objects, this is the same as BoundingBox().
For objects like lights that use an icon, the world 
coordinate bounding box depends on the view.
</summary>
            <returns>3d bounding box</returns>
            <remarks>The default implementation calls BoundingBox().</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.BoundingBox">
            <summary>Gets 3d axis aligned bounding box that contains the object.</summary>
            <returns>3d bounding box</returns>
            <remarks>
The default implementation uses m_geometry-&gt;BoundingBox(), lazy evaluation,
and caches the result in m_bbox. If you override this function, then you must set m_bbox.
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.Geometry">
            <summary>returns a pointer to the object's geometry</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.DrawHighlightedSubObjects(RMA.Rhino.MRhinoViewport@)">
            <summary>
Draws wireframe representation of highlighed sub objects.
objects that support subobject highlighting must override this function
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.DrawSubObject(RMA.Rhino.MRhinoViewport@,RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Draws wireframe representation of a sub object.</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.DrawHighlightedSubObjects(RMA.Rhino.MRhinoDisplayPipeline)">
            <summary>
Draws wireframe representation of highlighed sub objects.
objects that support subobject highlighting must override this function
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.DrawSubObject(RMA.Rhino.MRhinoDisplayPipeline,RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Draws wireframe representation of a sub object.</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.Draw(RMA.Rhino.MRhinoDisplayPipeline)">
            <summary>Draws object based on pipeline display attributes...</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.DrawGrips(RMA.Rhino.MRhinoDisplayPipeline)">
            <summary>
Draws the object's grips, control polygon, and dynamic wireframe object.
Dynamic shaded objects are drawn in the Draw
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.GetGrips(RMA.Rhino.MRhinoGripObject[]@)">
            <summary>
If grips are enabled, then GetGrips appends the object's grips to the grip_list[] array.
</summary>
            <returns>
Number of grips appended to the array.
See Also: CRhinoObject::GripsOn CRhinoObject::EnableGrips
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.GripsSelected">
            <summary>
Returns: If the object has grips on, this returns the enabler to turn on that type of grips. If the object does not have grips on, this returns NULL.
</summary>
            <returns>
True if grips are turned on and at least one is selected.
See Also: CRhinoObject::GripsOn
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.GripsOn">
            <returns>
CRhinoGripObject::GRIP_TYPE value
0 = off
See Also: CRhinoObject::EnableGrips CRhinoObject::GripsSelected
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.IsMarked">
            <summary>
marking - no impact on display - not saved or copied
Use CRhinoDoc::ClearMarks() to set all marks to zero.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.HighlightRequiresRedraw">
            <returns>
true if pixels used by hightlighted object differ from pixels used by unhighlighted object.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.GetHighlightedSubObjects(RMA.OpenNURBS.OnCOMPONENT_INDEX[]@)">
            <summary>Get a list of all highlighted sub-objects</summary>
            <param name="component_indices">[out] component indices of highlighted sub-objects.</param>
            <returns>number of highlighted subobjects</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.IsSubObjectHighlighted(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <returns>true if specified component is highlighted</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.IsHighlighted">
            <summary>
Check highlight state.
highlighted state (almost always = IsSelected() except in one or two commands)
</summary>
            <returns>
0 object is not highlighted 
1 entire object is highlighted
3 one or more proper sub-objects are highlighted
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.IsHighlighted(System.Boolean)">
            <summary>
Check highlight state.
highlighted state (almost always = IsSelected() except in one or two commands)
</summary>
            <param name="bCheckSubObjects">
[in] If true and the entire object is not highlighted, and some subset of the
object is highlighted, like some edges of a surface, then 3 is returned.
If false and the entire object is not highlighted, then zero is returned.
</param>
            <returns>
0 object is not highlighted 
1 entire object is highlighted
3 one or more proper sub-objects are highlighted
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.SelectSubObject(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Reports if an object can be selected.</summary>
            <param name="component_index">[in] index of subobject to check</param>
            <returns>
0: object is not selected
1: object is selected
2: object is selected persistently
</returns>
            <remarks>
Objects that are locked, hidden, or on locked or hidden layers cannot be selected.
If IsSelectableWithGripsOn() returns false, then an that object is not selectable
if it has grips turned on.
See Also: CRhinoDoc::UnselectAll CRhinoView::UnselectAllSubObjects
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.SelectSubObject(RMA.OpenNURBS.IOnCOMPONENT_INDEX,System.Boolean)">
            <summary>Reports if an object can be selected.</summary>
            <param name="component_index">[in] index of subobject to check</param>
            <param name="bSelect">[in] (default=true)</param>
            <returns>
0: object is not selected
1: object is selected
2: object is selected persistently
</returns>
            <remarks>
Objects that are locked, hidden, or on locked or hidden layers cannot be selected.
If IsSelectableWithGripsOn() returns false, then an that object is not selectable
if it has grips turned on.
See Also: CRhinoDoc::UnselectAll CRhinoView::UnselectAllSubObjects
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.SelectSubObject(RMA.OpenNURBS.IOnCOMPONENT_INDEX,System.Boolean,System.Boolean)">
            <summary>Reports if an object can be selected.</summary>
            <param name="component_index">[in] index of subobject to check</param>
            <param name="bSelect">[in] (default=true)</param>
            <param name="bSynchHighlight">
[in] (default=true) If true, then the object is hightlighted if it is selected and not
hightlighted if is is not selected.
</param>
            <returns>
0: object is not selected
1: object is selected
2: object is selected persistently
</returns>
            <remarks>
Objects that are locked, hidden, or on locked or hidden layers cannot be selected.
If IsSelectableWithGripsOn() returns false, then an that object is not selectable
if it has grips turned on.
See Also: CRhinoDoc::UnselectAll CRhinoView::UnselectAllSubObjects
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.Select(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Reports if an object can be selected.</summary>
            <param name="bSelect">[in] (default=true)</param>
            <param name="bSynchHighlight">
[in] (default=true) If true, then the object is hightlighted if it is selected and
not hightlighted if is is not selected.
</param>
            <param name="bPersistentSelect">
[in] (default=true) Objects that are persistently selected stay selected when a command terminates.
</param>
            <param name="bIgnoreGripsState">
[in] If true, then objects with grips on can be selected. If false,
then the value returned by the object's virtual IsSelectableWithGripsOn()
function decides if the object can be selected when it has grips turned on.
</param>
            <param name="bIgnoreLayerLocking">
[in] (default=false) If true, then objects on locked layers can be selected.
If false, the objects on locked layers cannot be selected.
</param>
            <param name="bIgnoreLayerVisibility">
[in] (default=false) If true, then objects on hidden layers can be selectable.
If false, the objects on hidden layers cannot be selected.
</param>
            <returns>
0: object is not selected
1: object is selected
2: object is selected persistently
</returns>
            <remarks>
Objects that are locked, hidden, or on locked or hidden layers cannot be selected.
If IsSelectableWithGripsOn() returns false, then an that object is not selectable
if it has grips turned on.
See Also: CRhinoDoc::UnselectAll
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.Select">
            <summary>Reports if an object can be selected.</summary>
            <returns>
0: object is not selected
1: object is selected
2: object is selected persistently
</returns>
            <remarks>
Objects that are locked, hidden, or on locked or hidden layers cannot be selected.
If IsSelectableWithGripsOn() returns false, then an that object is not selectable
if it has grips turned on.
See Also: CRhinoDoc::UnselectAll
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.Select(System.Boolean)">
            <summary>Reports if an object can be selected.</summary>
            <param name="bSelect">[in] (default=true)</param>
            <returns>
0: object is not selected
1: object is selected
2: object is selected persistently
</returns>
            <remarks>
Objects that are locked, hidden, or on locked or hidden layers cannot be selected.
If IsSelectableWithGripsOn() returns false, then an that object is not selectable
if it has grips turned on.
See Also: CRhinoDoc::UnselectAll
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.Select(System.Boolean,System.Boolean)">
            <summary>Reports if an object can be selected.</summary>
            <param name="bSelect">[in] (default=true)</param>
            <param name="bSynchHighlight">
[in] (default=true) If true, then the object is hightlighted if it is selected and
not hightlighted if is is not selected.
</param>
            <returns>
0: object is not selected
1: object is selected
2: object is selected persistently
</returns>
            <remarks>
Objects that are locked, hidden, or on locked or hidden layers cannot be selected.
If IsSelectableWithGripsOn() returns false, then an that object is not selectable
if it has grips turned on.
See Also: CRhinoDoc::UnselectAll
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.Select(System.Boolean,System.Boolean,System.Boolean)">
            <summary>Reports if an object can be selected.</summary>
            <param name="bSelect">[in] (default=true)</param>
            <param name="bSynchHighlight">
[in] (default=true) If true, then the object is hightlighted if it is selected and
not hightlighted if is is not selected.
</param>
            <param name="bPersistentSelect">
[in] (default=true) Objects that are persistently selected stay selected when a command terminates.
</param>
            <returns>
0: object is not selected
1: object is selected
2: object is selected persistently
</returns>
            <remarks>
Objects that are locked, hidden, or on locked or hidden layers cannot be selected.
If IsSelectableWithGripsOn() returns false, then an that object is not selectable
if it has grips turned on.
See Also: CRhinoDoc::UnselectAll
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.Select(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Reports if an object can be selected.</summary>
            <param name="bSelect">[in] (default=true)</param>
            <param name="bSynchHighlight">
[in] (default=true) If true, then the object is hightlighted if it is selected and
not hightlighted if is is not selected.
</param>
            <param name="bPersistentSelect">
[in] (default=true) Objects that are persistently selected stay selected when a command terminates.
</param>
            <param name="bIgnoreGripsState">
[in] If true, then objects with grips on can be selected.
If false, then the value returned by the object's virtual IsSelectableWithGripsOn()
function decides if the object can be selected when it has grips turned on.
</param>
            <returns>
0: object is not selected
1: object is selected
2: object is selected persistently
</returns>
            <remarks>
Objects that are locked, hidden, or on locked or hidden layers cannot be selected.
If IsSelectableWithGripsOn() returns false, then an that object is not selectable
if it has grips turned on.
See Also: CRhinoDoc::UnselectAll
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.IsSubObjectSelectable(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Reports if a subobject can be selected.</summary>
            <param name="component_index">[in] index of subobject to check</param>
            <remarks>
Objects that are locked, hidden, or on locked or hidden layers cannot be selected.
If IsSelectableWithGripsOn() returns false, then an that object is not selectable if it has grips turned on.
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.IsSubObjectSelectable(RMA.OpenNURBS.IOnCOMPONENT_INDEX,System.Boolean)">
            <summary>Reports if a subobject can be selected.</summary>
            <param name="component_index">[in] index of subobject to check</param>
            <param name="bIgnoreSelectionState">
[in] (default=false) If true, then selected objects are selectable.
If false, the selected objects are not selectable.
</param>
            <remarks>
Objects that are locked, hidden, or on locked or hidden layers cannot be selected.
If IsSelectableWithGripsOn() returns false, then an that object is not selectable if it has grips turned on.
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.IsSelectable(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Reports if an object can be selected.</summary>
            <param name="bIgnoreSelectionState">
[in] (default=false) If true, then selected objects are selectable.
If false, the selected objects are not selectable.
</param>
            <param name="bIgnoreGripsState">
[in] If true, then objects with grips on can be selected. If false,
then the value returned by the object's virtual IsSelectableWithGripsOn()
function decides if the object can be selected.
</param>
            <param name="bIgnoreLayerLocking">
[in] (default=false) If true, then objects on locked layers are selectable.
If false, the objects on locked layers are not selectable.
</param>
            <param name="bIgnoreLayerVisibility">
[in] (default=false) If true, then objects on hidden layers are selectable. If false,
the objects on hidden layers are not selectable.
</param>
            <returns>True if object is capable of being selected</returns>
            <remarks>
Objects that are locked or hidden cannot be selected.
If IsSelectableWithGripsOn() returns false, then an that object is not selectable
if it has grips turned on.
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.IsSelectable">
            <summary>Reports if an object can be selected.</summary>
            <remarks>
Objects that are locked, hidden, or on locked or hidden layers cannot be selected.
If IsSelectableWithGripsOn() returns false, then an that object is not selectable
if it has grips turned on.
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.IsSelectable(System.Boolean)">
            <summary>Reports if an object can be selected.</summary>
            <param name="bIgnoreSelectionState">
[in] (default=false) If true, then selected objects are selectable.
If false, the selected objects are not selectable.
</param>
            <remarks>
Objects that are locked, hidden, or on locked or hidden layers cannot be selected.
If IsSelectableWithGripsOn() returns false, then an that object is not selectable
if it has grips turned on.
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.IsSelectable(System.Boolean,System.Boolean)">
            <summary>Reports if an object can be selected.</summary>
            <param name="bIgnoreSelectionState">
[in] (default=false) If true, then selected objects are selectable.
If false, the selected objects are not selectable.
</param>
            <param name="bIgnoreGripsState">
[in] If true, then objects with grips on can be selected.
If false, then the value returned by the object's virtual IsSelectableWithGripsOn()
function decides if the object can be selected.
</param>
            <remarks>
Objects that are locked, hidden, or on locked or hidden layers cannot be selected.
If IsSelectableWithGripsOn() returns false, then an that object is not selectable
if it has grips turned on.
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.GetSelectedSubObjects(RMA.OpenNURBS.OnCOMPONENT_INDEX[]@)">
            <summary>Get a list of all selected sub-objects</summary>
            <param name="component_indices">[out] component indices of selected sub-objects.</param>
            <returns>number of selected subobjects</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.IsSubObjectSelected(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Check sub-object selection state.</summary>
            <param name="component_index">[in] index of subobject to check</param>
            <remarks>subobject cannot be persistently selected</remarks>
            <returns>
false sub-object is not selected
true sub-object is selected
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.IsSelected">
            <summary>Check selection state.</summary>
            <returns>
0 object is not selected
1 object is selected
2 entire object is selected persistently
3 one or more proper sub-objects are selected
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.IsSelected(System.Boolean)">
            <summary>Check selection state.</summary>
            <param name="bCheckSubObjects">
[in] If true and the entire object is not selected, and some subset of the
object is selected, like some edges of a surface, then 3 is returned. If
false and the entire object is not selected, then zero is returned.
</param>
            <returns>
0 object is not selected
1 object is selected
2 entire object is selected persistently
3 one or more proper sub-objects are selected
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.IsActiveInViewport(RMA.Rhino.IRhinoViewport)">
            <summary>Query to determine if this object is active in a particular viewport.</summary>
            <param name="viewport">[in]</param>
            <returns>True if the object is active in viewport.</returns>
            <remarks>
The default implementation tests for space and viewport id.
This handles things like testing if a page space object is visible in a modeling view.
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.IsVisible">
            <returns>true if an object is visible and is on a layer that is visible.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.IsPageObject">
            <returns>True if the object is in page layout space.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.IsModelObject">
            <returns>True if the object is in model space.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.IsReference">
            <summary>Determine if an object is a reference object.</summary>
            <returns>True if the object is a reference object.</returns>
            <remarks>
An object from a work session reference model is reference
a reference object and cannot be modified. An object is a
reference object if, and only if, it is on a reference layer.
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.IsHidden">
            <summary>
(depending on the circumstance, you may need to assign
a new UUID after using the copy constructor or operator=)
there are 3 mutually exclusive object states 
- normal (visible, can be snapped to, independent of selection state)
- locked (visible, can be snapped to, cannot be selected)
- hidden (not visible, cannot be snapped to, cannot be selected)
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.IsLocked">
            <summary>
(depending on the circumstance, you may need to assign
a new UUID after using the copy constructor or operator=)
there are 3 mutually exclusive object states 
- normal (visible, can be snapped to, independent of selection state)
- locked (visible, can be snapped to, cannot be selected)
- hidden (not visible, cannot be snapped to, cannot be selected)
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.IsNormal">
            <summary>
(depending on the circumstance, you may need to assign
a new UUID after using the copy constructor or operator=)
there are 3 mutually exclusive object states 
- normal (visible, can be snapped to, independent of selection state)
- locked (visible, can be snapped to, cannot be selected)
- hidden (not visible, cannot be snapped to, cannot be selected)
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.IsGroupObject">
            <summary>Test object to see if it is a proxy CRhinoGroupObject.</summary>
            <returns>true if this is a CRhinoGroupObject.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.IsInstanceDefinitionGeometry">
            <returns>true if object is is used as part of an instance definition.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.IsDeleted">
            <returns>true if object is deleted.</returns>
            <remarks>Use CRhinoDoc::UndeleteObject() to undelete an object.</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.IsDeletable">
            <summary>Some objects cannot be deleted, like grips on lights and annotation objects.</summary>
            <returns>True if object can be deleted.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.Document">
            <summary>Gets document that owns the object.</summary>
            <returns>Document that manages object.</returns>
            <remarks>
When an object is created, it does not belong to a document.
CRhinoDoc::AddObject() or CRhinoDoc::ReplaceObject() are used
to add new objects to a document.  After the object is added
to a document, it it managed by that document.  If the
CRhinoObject::Document() returns NULL, then the object is
not part of a document.
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoObject.DuplicateRhinoObject">
            <summary>
Duplicates the Rhino object. If "this" is a CRhinoProxyObject, the duplicate
is a "real" Rhino object. If "this" is an ordinary Rhino object like
a CRhinoCurveObject, CRhinoPointObject, and so on, then the dupicate is another rhino object
of the same type.
</summary>
            <returns>
NULL or a pointer to the duplicate. The new object is not added to the Rhino document.
</returns>
        </member>
        <member name="P:RMA.Rhino.IRhinoObject.m_use_preview_mesh">
            <value>
When an object like a CRhinoBrepObject is being meshed and
the display code should use the preview mesh instead of
the render or analysis mesh, then this flag is set to 1.
Otherwise it is set to zero.
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoObject.m_runtime_object_serial_number">
            <value>
The CRhinoObject constructors set m_runtime_object_serial_number and the serial number
is unique for each instance of the rhino.exe application. The first object created has
serial number 1, and so on. If a CRhinoObject is copied, the copy will have a different
serial number. The serial number can be used to identify objects created between two events.
The value of m_runtime_object_serial_number does NOT persist in 3DM archives and is not
unique between instances of rhino3.exe. Use the object's uuid when you need a persistent
and unique way to identify the object.
See Also: CRhinoObject::NextRuntimeObjectSerialNumber
</value>
        </member>
        <member name="T:RMA.Rhino.IRhinoObject.GEOMETRY_TYPE">
            <summary>
Geometry types for CRhinoObjRef.
values &lt;= 0x000FFFFF are the same as the ON::object_type enum value
</summary>
        </member>
        <member name="T:RMA.Rhino.IRhinoObject">
            <summary>CRhinoObject is the base class for all runtime Rhino objects.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinetypeTable.ByLayerLinetypeName">
            <summary>
Returns the text name of the bylayer linetype
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinetypeTable.ContinuousLinetypeName">
            <summary>
Returns the text name of the continuous linetype
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinetypeTable.GetUnusedLinetypeName(System.String@)">
            <summary>Gets unused linetype name used as default when creating new linetypes.</summary>
            <param name="linetype_name">[out] new linetype name</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinetypeTable.GetUnusedLinetypeName(System.String@,System.Boolean)">
            <summary>Gets unused linetype name used as default when creating new linetypes.</summary>
            <param name="linetype_name">[out] new linetype name</param>
            <param name="bIgnoreDeleted">[in] if this is true then may use a name used by a deleted linetype.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinetypeTable.GetSortedList(RMA.Rhino.IRhinoLinetype[]@)">
            <summary>
Gets an array of pointers to linetypes that is sorted by
the values of CRhinoLinetype::m_sort_index.
</summary>
            <param name="sorted_list">
[out] this array is returned with length LinetypeCount() and is sorted by the values of
CRhinoLinetype::m_sort_index.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinetypeTable.GetSortedList(RMA.Rhino.IRhinoLinetype[]@,System.Boolean)">
            <summary>
Gets an array of pointers to linetypes that is sorted by
the values of CRhinoLinetype::m_sort_index.
</summary>
            <param name="sorted_list">
[out] this array is returned with length LinetypeCount() and is sorted by the values of
CRhinoLinetype::m_sort_index.
</param>
            <param name="bIgnoreDeleted">[in] true means don't include deleted linetypes.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinetypeTable.UndeleteLinetype(System.Int32)">
            <summary>Undeletes a linetype that has been deleted by DeleteLinetype().</summary>
            <param name="linetype_index">
[in] zero based index of linetype to undelete.
This must be in the range 0 &lt;= linetype_index &lt; LinetypeCount().
</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinetypeTable.DeleteLinetypes(System.Int32[],System.Boolean)">
            <summary>Deletes multiple linetypes</summary>
            <param name="linetype_index">
[in] array zero based indices of linetypes to delete.
The indices must be in the range 0 &lt;= linetype_index &lt; LinetypeCount().
</param>
            <param name="bQuiet">
[in] If true, no warning message box appears if a linetype the linetype cannot
be deleted because it is the current linetype or it contains active geometry.
</param>
            <returns>
true if successful. false if linetype_index is out of range or the
the linetype cannot be deleted because it is the current linetype or
because it linetype contains active geometry.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinetypeTable.DeleteLinetype(System.Int32,System.Boolean)">
            <summary>Deletes linetype</summary>
            <param name="linetype_index">
[in] zero based index of linetype to delete.
This must be in the range 0 &lt;= linetype_index &lt; LinetypeCount().
</param>
            <param name="bQuiet">
[in] If true, no warning message box appears if a linetype
the linetype cannot be deleted because it is the current linetype
or it contains active geometry.
</param>
            <returns>
true if successful. false if linetype_index is out of range or the
the linetype cannot be deleted because it is the current linetype or
because it linetype is referenced by active geometry.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinetypeTable.UndoModifyLinetype(System.Int32)">
            <summary>
If the linetype has been modified and the modifcation can be undone,
then UndoModify() will restore the linetype to its previous state.
</summary>
            <returns>
true if this linetype had been modified and the modifications were
undone.
See Also: IsModified.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinetypeTable.UndoModifyLinetype(System.Int32,System.UInt32)">
            <summary>
If the linetype has been modified and the modifcation can be undone,
then UndoModify() will restore the linetype to its previous state.
</summary>
            <returns>
true if this linetype had been modified and the modifications were
undone.
See Also: IsModified.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinetypeTable.ModifyLinetype(RMA.OpenNURBS.IOnLinetype,System.Int32)">
            <summary>Modify linetype settings</summary>
            <param name="linetype">[in] new settings.  This information is copied.</param>
            <param name="linetype_index">
[in] zero based index of linetype to set.
This must be in the range 0 &lt;= linetype_index &lt; LinetypeCount().
</param>
            <returns>
true if successful. false if linetype_index is out of range
or the settings attempt to lock or hide the current linetype.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinetypeTable.ModifyLinetype(RMA.OpenNURBS.IOnLinetype,System.Int32,System.Boolean)">
            <summary>Modify linetype settings</summary>
            <param name="linetype">[in] new settings.  This information is copied.</param>
            <param name="linetype_index">
[in] zero based index of linetype to set.
This must be in the range 0 &lt;= linetype_index &lt; LinetypeCount().
</param>
            <param name="bQuiet">
[in] if true, information message boxes pop up when illegal changes are attempted.
</param>
            <returns>
true if successful. false if linetype_index is out of range
or the settings attempt to lock or hide the current linetype.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinetypeTable.AddLinetype(System.String,RMA.OpenNURBS.Arraydouble@)">
            <summary>Adds a new linetype to the linetype table.</summary>
            <param name="linetype_name">[in] name for the new linetype</param>
            <param name="segments">
[in] array of segment lengths. Positive values are dashes, negative values are gaps
</param>
            <returns>
&gt;=0 index of new linetype
-1 linetype not added because a linetype with that name already exists or input is not valid.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinetypeTable.AddLinetype(RMA.OpenNURBS.IOnLinetype)">
            <summary>Adds a new linetype with specified definition to the linetype table.</summary>
            <param name="linetype">
[in] definition of new linetype. The information in linetype is copied.
If linetype.LinetypeName() is empty then a unique name of the form
"Linetype 01" will be automatically created.
</param>
            <returns>
&gt;=0     index of new linetype
-1      linetype not added because a linetype with that name already exists.
</returns>
            <remarks>
In some cases, calling AddLinetype() can cause the memory 
references previously returned by operator[] and 
CurrentLinetype() to become invalid.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinetypeTable.AddLinetype(RMA.OpenNURBS.IOnLinetype,System.Boolean)">
            <summary>Adds a new linetype with specified definition to the linetype table.</summary>
            <param name="linetype">
[in] definition of new linetype. The information in linetype is copied.
If linetype.LinetypeName() is empty then a unique name of the form
"Linetype 01" will be automatically created.
</param>
            <param name="bReference">
[in] true if this linetype is a reference linetype. Reference linetypes are not saved in files.
</param>
            <returns>
&gt;=0     index of new linetype
-1      linetype not added because a linetype with that name already exists.
</returns>
            <remarks>
In some cases, calling AddLinetype() can cause the memory 
references previously returned by operator[] and 
CurrentLinetype() to become invalid.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinetypeTable.SetLinetypeScale(System.Double)">
            <param name="scale">New scale factor for linetype display</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinetypeTable.LinetypeScale">
            <summary>
For display in Rhino viewports, the linetypes are scaled by a
 single scale factor for all viewports.
This is not used for printing, where all linetype patterns are
 scaled to print in their defined size 1:1 on the paper.
</summary>
            <returns>The scale factor for linetype display</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinetypeTable.FindLinetype(System.String)">
            <summary>Finds the linetype with a given name.</summary>
            <param name="linetype_name">
[in] name of linetype to search for. The search ignores case.
</param>
            <returns>
&gt;=0     index of the linetype with the given name
-1      no linetype has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinetypeTable.FindLinetype(System.String,System.Boolean)">
            <summary>Finds the linetype with a given name.</summary>
            <param name="linetype_name">
[in] name of linetype to search for. The search ignores case.
</param>
            <param name="bIgnoreDeletedLinetypes">
[in] true means don't search deleted linetypes.
</param>
            <returns>
&gt;=0     index of the linetype with the given name
-1      no linetype has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinetypeTable.CurrentLinetype">
            <summary>
At all times, there is a "current" linetype.  Unless otherwise
specified, new objects are assigned to the current linetype.
If the current linetype source is ON::linetype_from_layer, 
 the object's layer's linetype is used instead
</summary>
            <returns>
Reference to the current linetype.  Note that this reference
may become invalid after a call to AddLinetype().
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinetypeTable.EffectiveLinetypeIndex(RMA.Rhino.IRhinoObject)">
            <summary>
Returns the effective linetype index to be used to find the 
linetype definition to draw an object
If an object's linetype source is ON::linetype_from_object,
the linetype index in the object's attributes is used.
If an object's linetype source is ON::linetyper_from_layer,
the linetype index from the object's layer is used.
</summary>
            <returns>Zero based linetype table index of the effective linetype.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinetypeTable.SetCurrentLinetypeIndex(System.Int32)">
            <summary>
At all times, there is a "current" linetype.  Unless otherwise
specified, new objects are assigned to the current linetype.
If the current linetype source is ON::linetype_from_layer, 
 the object's layer's linetype is used instead
The current linetype is never deleted.
</summary>
            <param name="linetype_index">
[in] value for new current linetype. 0 &lt;= linetype_index &lt; LinetypeCount().
</param>
            <returns>true if current linetype index successfully set.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinetypeTable.SetCurrentLinetypeIndex(System.Int32,System.Boolean)">
            <summary>
At all times, there is a "current" linetype.  Unless otherwise
specified, new objects are assigned to the current linetype.
If the current linetype source is ON::linetype_from_layer, 
 the object's layer's linetype is used instead
The current linetype is never deleted.
</summary>
            <param name="linetype_index">
[in] value for new current linetype. 0 &lt;= linetype_index &lt; LinetypeCount().
</param>
            <param name="bQuiet">
[in] if true, then no warning message box pops up if the current
linetype request can't be satisfied.
</param>
            <returns>true if current linetype index successfully set.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinetypeTable.CurrentLinetypeIndex">
            <summary>
At all times, there is a "current" linetype.  Unless otherwise
specified, new objects are assigned to the current linetype.
If the current linetype source is ON::linetype_from_layer, 
the object's layer's linetype is used instead
</summary>
            <returns>Zero based linetype table index of the current linetype.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinetypeTable.SetCurrentLinetypeSource(RMA.OpenNURBS.IOn.object_linetype_source)">
            <summary>
Set the source to be used by new objects to determine their current linetype
</summary>
            <param name="source">the new current linetype source</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinetypeTable.CurrentLinetypeSource">
            <summary>
Returns the source used by an object to determine its current linetype
to be used by new objects.
Default is ON::linetype_from_layer.
</summary>
            <returns>The linetype source for new objects.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinetypeTable.LinetypeCount">
            <summary>
Returns: Number of linetypes in the linetype table, including deleted linetypes.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinetypeTable.Document">
            <summary>Linetype tables store the list of linetypes in a Rhino document.</summary>
            <returns>CRhinoDocument that owns this linetype table.</returns>
        </member>
        <member name="P:RMA.Rhino.MRhinoLinetypeTable.Item(System.Int32)">
            <summary>
Conceptually, the linetype table is an array of LinetypeCount()
linetypes.  The operator[] can be used to get individual
linetypes.  A linetype is either active or deleted and this
state is reported by CRhinoLinetype::IsDeleted().
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoLinetypeTable.ByLayerLinetypeName">
            <summary>
Returns the text name of the bylayer linetype
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoLinetypeTable.ContinuousLinetypeName">
            <summary>
Returns the text name of the continuous linetype
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoLinetypeTable.GetUnusedLinetypeName(System.String@)">
            <summary>Gets unused linetype name used as default when creating new linetypes.</summary>
            <param name="linetype_name">[out] new linetype name</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoLinetypeTable.GetUnusedLinetypeName(System.String@,System.Boolean)">
            <summary>Gets unused linetype name used as default when creating new linetypes.</summary>
            <param name="linetype_name">[out] new linetype name</param>
            <param name="bIgnoreDeleted">[in] if this is true then may use a name used by a deleted linetype.</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoLinetypeTable.GetSortedList(RMA.Rhino.IRhinoLinetype[]@)">
            <summary>
Gets an array of pointers to linetypes that is sorted by
the values of CRhinoLinetype::m_sort_index.
</summary>
            <param name="sorted_list">
[out] this array is returned with length LinetypeCount() and is sorted by the values of
CRhinoLinetype::m_sort_index.
</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoLinetypeTable.GetSortedList(RMA.Rhino.IRhinoLinetype[]@,System.Boolean)">
            <summary>
Gets an array of pointers to linetypes that is sorted by
the values of CRhinoLinetype::m_sort_index.
</summary>
            <param name="sorted_list">
[out] this array is returned with length LinetypeCount() and is sorted by the values of
CRhinoLinetype::m_sort_index.
</param>
            <param name="bIgnoreDeleted">[in] true means don't include deleted linetypes.</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoLinetypeTable.FindLinetype(System.String)">
            <summary>Finds the linetype with a given name.</summary>
            <param name="linetype_name">
[in] name of linetype to search for. The search ignores case.
</param>
            <returns>
&gt;=0     index of the linetype with the given name
-1      no linetype has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoLinetypeTable.FindLinetype(System.String,System.Boolean)">
            <summary>Finds the linetype with a given name.</summary>
            <param name="linetype_name">
[in] name of linetype to search for. The search ignores case.
</param>
            <param name="bIgnoreDeletedLinetypes">
[in] true means don't search deleted linetypes.
</param>
            <returns>
&gt;=0     index of the linetype with the given name
-1      no linetype has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoLinetypeTable.CurrentLinetype">
            <summary>
At all times, there is a "current" linetype.  Unless otherwise
specified, new objects are assigned to the current linetype.
If the current linetype source is ON::linetype_from_layer, 
 the object's layer's linetype is used instead
</summary>
            <returns>
Reference to the current linetype.  Note that this reference
may become invalid after a call to AddLinetype().
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoLinetypeTable.EffectiveLinetypeIndex(RMA.Rhino.IRhinoObject)">
            <summary>
Returns the effective linetype index to be used to find the 
linetype definition to draw an object
If an object's linetype source is ON::linetype_from_object,
the linetype index in the object's attributes is used.
If an object's linetype source is ON::linetyper_from_layer,
the linetype index from the object's layer is used.
</summary>
            <returns>Zero based linetype table index of the effective linetype.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoLinetypeTable.CurrentLinetypeIndex">
            <summary>
At all times, there is a "current" linetype.  Unless otherwise
specified, new objects are assigned to the current linetype.
If the current linetype source is ON::linetype_from_layer, 
the object's layer's linetype is used instead
</summary>
            <returns>Zero based linetype table index of the current linetype.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoLinetypeTable.CurrentLinetypeSource">
            <summary>
Returns the source used by an object to determine its current linetype
to be used by new objects.
Default is ON::linetype_from_layer.
</summary>
            <returns>The linetype source for new objects.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoLinetypeTable.LinetypeCount">
            <summary>
Returns: Number of linetypes in the linetype table, including deleted linetypes.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoLinetypeTable.Document">
            <summary>Linetype tables store the list of linetypes in a Rhino document.</summary>
            <returns>CRhinoDocument that owns this linetype table.</returns>
        </member>
        <member name="P:RMA.Rhino.IRhinoLinetypeTable.Item(System.Int32)">
            <summary>
Conceptually, the linetype table is an array of LinetypeCount()
linetypes.  The operator[] can be used to get individual
linetypes.  A linetype is either active or deleted and this
state is reported by CRhinoLinetype::IsDeleted().
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinetype.IsModified">
            <summary>Rhino provides the ability to undo linetype modifications.</summary>
            <returns>
true if this linetype has been modified by 
CRhinoLinetypeTable::ModifyLinetype()and the modifications can
be undone.
See Also: UndoModify.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinetype.IsReference">
            <summary>
Rhino allows multiple files to be viewed simultaneously.
Linetypes in the document are "normal" or "reference".
Reference linetypes are not saved.
</summary>
            <returns>
true if linetype is in a reference file and will not be
saved as part of this document.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoLinetype.IsDeleted">
            <summary>
Deleted linetypes are kept in the runtime linetype table
so that undo will work with linetypes.  Call IsDeleted()
to determine if a linetype is deleted.
</summary>
            <returns>true if linetype is deleted.</returns>
        </member>
        <member name="P:RMA.Rhino.MRhinoLinetype.m_linetype_sn">
            <value>
Serial number of this linetype
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoLinetype.m_remap_index">
            <value>
Runtime index used when remapping linetypes for import/export
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoLinetype.m_sort_index">
            <value>
Runtime index used to sort linetypes in linetype dialog
</value>
        </member>
        <member name="M:RMA.Rhino.IRhinoLinetype.IsModified">
            <summary>Rhino provides the ability to undo linetype modifications.</summary>
            <returns>
true if this linetype has been modified by 
CRhinoLinetypeTable::ModifyLinetype()and the modifications can
be undone.
See Also: UndoModify.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoLinetype.IsReference">
            <summary>
Rhino allows multiple files to be viewed simultaneously.
Linetypes in the document are "normal" or "reference".
Reference linetypes are not saved.
</summary>
            <returns>
true if linetype is in a reference file and will not be
saved as part of this document.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoLinetype.IsDeleted">
            <summary>
Deleted linetypes are kept in the runtime linetype table
so that undo will work with linetypes.  Call IsDeleted()
to determine if a linetype is deleted.
</summary>
            <returns>true if linetype is deleted.</returns>
        </member>
        <member name="P:RMA.Rhino.IRhinoLinetype.m_linetype_sn">
            <value>
Serial number of this linetype
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoLinetype.m_remap_index">
            <value>
Runtime index used when remapping linetypes for import/export
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoLinetype.m_sort_index">
            <value>
Runtime index used to sort linetypes in linetype dialog
</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.Wait(System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Pause for specified time but keep Windows message pump alive so views will update
and windows will repaint
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.RhinoRenderPlugInUUID">
            <summary>
Description: Rhino skin.
</summary>
            <returns>the one and only Rhino system render plug-in</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.RestoreFullscreen">
            <summary>
Resets Rhino's main window from fullscreen mode, which got set previously
by a call to SetFullscreen()...
</summary>
            <returns>
true - if successfully restored from fullscreen mode.
false - if failed to come out of fullscreen mode...
       or if fullscreen wasn't active in the first place...
See Also:
 CRhinoApp::SetFullscreen()
 CRhinoApp::RestoreToolBars()
 CRhinoApp::RestoreeControlBars()
 CRhinoApp::RestoreWindowBars()
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.SetFullscreen(System.UInt32,System.UInt32,System.Int32)">
            <summary>Sets Rhino's main window fullscreen mode.</summary>
            <param name="nCBMask">
[in]: Control bar bit mask indicating which control bars to hide. If the
corresponding bit is ON, then that control bar will be hidden (see
description above for control bar bit values).
</param>
            <param name="nWBMask">
[in]: Window bar bit mask indicating which window bars to hide. If the
corresponding bit is ON, then that window bar will be hidden (see
description above for window bar bit values).
</param>
            <param name="nDockState">
0 = hide control bars regardless of dock state
1 = hide only DOCKED control bars
2 = hide only FLOATING control bars
</param>
            <returns>
true - if fullscreen mode was successfully set.
false - if fullscreen mode failed to get set.
See Also:
 CRhinoApp::RestoreFullscreen()
 CRhinoApp::HideToolBars()
 CRhinoApp::HideControlBars()
 CRhinoApp::HideWindowBars()
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.RestoreWindowBars">
            <summary>
Restores the window bars to their previous state prior to calling "HideWindowBars"
</summary>
            <returns>
true - if any window bars were restored.
false - if nothing was done.
See Also: CRhinoApp::HideWindowBars()
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.RestoreWindowBars(System.Boolean)">
            <summary>
Restores the window bars to their previous state prior to calling "HideWindowBars"
</summary>
            <param name="bRedraw">
true = redraw and recalc the main window and layout
false = don't do anything after the window bars have been hidden.
</param>
            <returns>
true - if any window bars were restored.
false - if nothing was done.
See Also: CRhinoApp::HideWindowBars()
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.HideWindowBars">
            <summary>
Hides the main window's window bars based on the passed in bit mask.
See above list that describes the different types of window bars that are
currently supported and their corresponding mask value.
</summary>
            <returns>
true - if any bars specified were hidden.
false - if nothing was hidden.
See Also: CRhinoApp::RestoreWindowBars()
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.HideWindowBars(System.UInt32)">
            <summary>
Hides the main window's window bars based on the passed in bit mask.
See above list that describes the different types of window bars that are
currently supported and their corresponding mask value.
</summary>
            <param name="nWBMask">
[in]: Window bar bit mask indicating which window bars to hide. If the
corresponding bit is ON, then that window bar will be hidden (see
description above for window bar bit values).
</param>
            <returns>
true - if any bars specified were hidden.
false - if nothing was hidden.
See Also: CRhinoApp::RestoreWindowBars()
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.HideWindowBars(System.UInt32,System.Boolean)">
            <summary>
Hides the main window's window bars based on the passed in bit mask.
See above list that describes the different types of window bars that are
currently supported and their corresponding mask value.
</summary>
            <param name="nWBMask">
[in]: Window bar bit mask indicating which window bars to hide. If the
corresponding bit is ON, then that window bar will be hidden (see
description above for window bar bit values).
</param>
            <param name="bRedraw">
true = redraw and recalc the main window and layout
false = don't do anything after the bars have been hidden.
</param>
            <returns>
true - if any bars specified were hidden.
false - if nothing was hidden.
See Also: CRhinoApp::RestoreWindowBars()
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.RestoreControlBars">
            <summary>
Restores the control bars to their previous state prior to calling "HideControlBars"
</summary>
            <returns>
true - if any control bars were restored.
false - if nothing was done.
See Also: CRhinoApp::HideControlBars()
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.RestoreControlBars(System.Boolean)">
            <summary>
Restores the control bars to their previous state prior to calling "HideControlBars"
</summary>
            <param name="bRedraw">
true = redraw and recalc the main window and layout
false = don't do anything after the control bars have been hidden.
</param>
            <returns>
true - if any control bars were restored.
false - if nothing was done.
See Also: CRhinoApp::HideControlBars()
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.HideControlBars">
            <summary>
Hides the control bars based on the passed in bit mask and dock state...
See above list that describes the control bars that are currently supported
and their corresponding mask value:
</summary>
            <returns>
true - if any toolbars with specified state were hidden.
false - if nothing was hidden.
See Also: CRhinoApp::RestoreControlBars()
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.HideControlBars(System.UInt32)">
            <summary>
Hides the control bars based on the passed in bit mask and dock state...
See above list that describes the control bars that are currently supported
and their corresponding mask value:
</summary>
            <param name="nCBMask">
[in]: Control bar bit mask indicating which control bars to hide. If the
corresponding bit is ON, then that control bar will be hidden (see description
above for control bar bit values).
</param>
            <returns>
true - if any toolbars with specified state were hidden.
false - if nothing was hidden.
See Also: CRhinoApp::RestoreControlBars()
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.HideControlBars(System.UInt32,System.Int32)">
            <summary>
Hides the control bars based on the passed in bit mask and dock state...
See above list that describes the control bars that are currently supported
and their corresponding mask value:
</summary>
            <param name="nCBMask">
[in]: Control bar bit mask indicating which control bars to hide. If the
corresponding bit is ON, then that control bar will be hidden (see description
above for control bar bit values).
</param>
            <param name="nDockState">
0 = hide control bars regardless of dock state
1 = hide only DOCKED control bars
2 = hide only FLOATING control bars
</param>
            <returns>
true - if any toolbars with specified state were hidden.
false - if nothing was hidden.
See Also: CRhinoApp::RestoreControlBars()
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.HideControlBars(System.UInt32,System.Int32,System.Boolean)">
            <summary>
Hides the control bars based on the passed in bit mask and dock state...
See above list that describes the control bars that are currently supported
and their corresponding mask value:
</summary>
            <param name="nCBMask">
[in]: Control bar bit mask indicating which control bars to hide. If the
corresponding bit is ON, then that control bar will be hidden (see description
above for control bar bit values).
</param>
            <param name="nDockState">
0 = hide control bars regardless of dock state
1 = hide only DOCKED control bars
2 = hide only FLOATING control bars
</param>
            <param name="bRedraw">
true = redraw and recalc the main window and layout
false = don't do anything after the toolbars have been hidden.
</param>
            <returns>
true - if any toolbars with specified state were hidden.
false - if nothing was hidden.
See Also: CRhinoApp::RestoreControlBars()
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.RestoreToolBars">
            <summary>Restores the toolbars to their previous state prior to calling "HideToolBars"</summary>
            <returns>
true - if any toolbars were restored.
false - if nothing was done.
See Also: CRhinoApp::HideToolBars()
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.RestoreToolBars(System.Boolean)">
            <summary>Restores the toolbars to their previous state prior to calling "HideToolBars"</summary>
            <param name="bRedraw">
true = redraw and recalc the main window and layout
false = don't do anything after the toolbars have been hidden.
</param>
            <returns>
true - if any toolbars were restored.
false - if nothing was done.
See Also: CRhinoApp::HideToolBars()
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.HideToolBars">
            <summary>Hides the toolbars based on the passed in flag...</summary>
            <returns>
true - if any toolbars with specified state were hidden.
false - if nothing was hidden.
See Also: CRhinoApp::RestoreToolBars()
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.HideToolBars(System.Int32)">
            <summary>Hides the toolbars based on the passed in flag...</summary>
            <param name="nDockState">
0 = hide ALL toolbars regardless of dock state
1 = hide only DOCKED toolbars
2 = hide only FLOATING toolbars
</param>
            <returns>
true - if any toolbars with specified state were hidden.
false - if nothing was hidden.
See Also: CRhinoApp::RestoreToolBars()
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.HideToolBars(System.Int32,System.Boolean)">
            <summary>
Description: Use a command's uuid to find a command. Parameters: command_uuid - [in] command uuid. Returns: Pointer to the command or NULL if no command was found.
</summary>
            <summary>
Description: Use a command's name to find a command. Parameters: command_name - [in] command name. Use the "_" prefix if you want to lookup the english command name. If no "_" prefix is present, then this will search for the local command name.. Returns: Pointer to the command or NULL if no command was found.
</summary>
            <summary>Hides the toolbars based on the passed in flag...</summary>
            <param name="nDockState">
0 = hide ALL toolbars regardless of dock state
1 = hide only DOCKED toolbars
2 = hide only FLOATING toolbars
</param>
            <param name="bRedraw">
true = redraw and recalc the main window and layout
false = don't do anything after the toolbars have been hidden.
</param>
            <returns>
true - if any toolbars with specified state were hidden.
false - if nothing was hidden.
See Also: CRhinoApp::RestoreToolBars()
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.RunningCommand(System.Int32)">
            <summary>
When script running or nestable commands are running, there can be more than one
command running at a given time. The private array m_running_commands_stack[] keeps
track of all the commands that are running. The one on the end of the array is the
"active" command. You really should not be using this function, except
when you are forced to hack around a sticky situation that requires you to know
when a certain command (like a base level script running command) may be active.
</summary>
            <param name="i">[in] 0 based index.</param>
            <returns>Pointer to command.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.ActiveCommand">
            <summary>
Returns: Pointer to currently running command.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.GetPlugInObjectInterface(System.Guid@,System.Guid@)">
            <summary>Returns the pointer to an interface object in a plug-in.</summary>
            <param name="plugin_uuid">[in] - The plug-in to query.</param>
            <param name="interface_uuid">[in] - The requested interface.</param>
            <returns>
The IUnknown pointer of the requested interface, if successful.
NULL on error or if the interface is not supported.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.GetRhinoScriptInterface">
            <summary>
Returns the COM IUnknown pointer to RhinoScript.
Cast the returned object to a RhinoScript4.IRhinoScript interface
that is created automatically if your project references the RhinoScript.TLB
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.RegistrySchemeName">
            <returns>String that gets appended to end of build name when opening registry keys.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.ClearCursorToolTip">
            <summary>
Clears cursor tooltip, including all tooltip panes.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.ClearCursorToolTipPane(RMA.Rhino.IRhinoApp.cursor_tooltip_pane)">
            <summary>
Clears one tooltip pane.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.SetCursorToolTipPane(RMA.Rhino.IRhinoApp.cursor_tooltip_pane,System.String)">
            <summary>
Sets tooltip pane. Can be used as an override to set any pane to any string.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.SetCursorToolTipPointPane(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Sets tooltip point pane.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.SetCursorToolTipPointPane(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOnPlane)">
            <summary>
Sets tooltip point pane.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.SetCursorToolTipNumberPane(System.Double)">
            <summary>
Sets tooltip number pane.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.SetCursorToolTipNumberPane(System.Double,System.Boolean)">
            <summary>
Sets tooltip number pane.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.SetCursorToolTipOsnapPane(RMA.Rhino.IRhinoAppSettings.osnap_mode)">
            <summary>
Sets tooltip osnap pane.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.SetCursorToolTip(System.String)">
            <summary>
Sets a cursor tooltip string shown next to the mouse cursor. Overrides all cursor tooltip panes.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.MonitorRects">
            <summary>
Call this method to get a sorted list of monitor display rectangles associated
with the currently installed monitors. The array will be sorted by the left edge.
</summary>
            <returns>Reference to the monitor rectangles.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.RhinoCommandManager">
            <summary>
Description: Gets the module state of the Rhino core executable. Using this information is for advanced, skilled, and very careful developers. You are probably best off pretending this does not exist. It is exported just in case somebody needs this low level information in a plug-in situation that we have yet to discover. Returns: Rhino core executable module state.
</summary>
            <summary>
Description: Gets the module state of the Rhino core executable. Using this information is for advanced, skilled, and very careful developers. You are probably best off pretending this does not exist. It is exported just in case somebody needs this low level information in a plug-in situation that we have yet to discover. Returns: Rhino core executable module state.
</summary>
            <summary>The command manager lets you find commands from names and uuids.</summary>
            <returns>Reference to the command manager tool.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.RhinoAbout">
            <summary>Call this method to display the Rhino or RhinoSkin about box.</summary>
            <returns>See Also: CRhinoSkin class</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.RhinoAbout(System.Boolean)">
            <summary>Call this method to display the Rhino or RhinoSkin about box.</summary>
            <param name="bForceRhinoAbout">
[in] This parameter is only used if Rhino is running in skin mode, see CRhinoSkin for deatils.
If Rhino is in skin mode and this is true then the Rhino about box will display otherwise the
skin splash screen will display.
</param>
            <returns>See Also: CRhinoSkin class</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.DoHelp">
            <summary>Show help topic.</summary>
            <returns>
TRUE - help topic found
FALSE - help topic not found
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.DoHelp(System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>Show help topic.</summary>
            <param name="help_topic_id">
[in] if zero, the help topic for the active command is displayed.
If not zero, help_topic_id specifies a help topic id in the Rhino3 help file.
</param>
            <returns>
TRUE - help topic found
FALSE - help topic not found
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.GetDefaultRenderApp">
            <summary>
Get the application ID for the default render plug-in
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.SetDefaultRenderApp(System.Guid@)">
            <summary>Set default render application</summary>
            <param name="uuid">[in] ID of render plug-in.</param>
            <returns>
TRUE - If plug-in found and loaded successfully
FALSE - If ID is invalid or was unable to load plug-in
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.AutoSave">
            <summary>Auto save if necessary</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.AutoSave(System.String)">
            <summary>Auto save if necessary</summary>
            <param name="lpsCommandName">
[in] If command name is in the CRhinoAppFileSettings::m_always_autosave_before_commands
list then force auto save.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.AutoSave(System.String,System.Boolean)">
            <summary>Auto save if necessary</summary>
            <param name="lpsCommandName">
[in] If command name is in the CRhinoAppFileSettings::m_always_autosave_before_commands
list then force auto save.
</param>
            <param name="bForceAutoSave">
[in] If non zero then ignore lpsCommandName paramater and force auto save. If zero and
lpsCommandName is NULL or not in alwas sve list then save it save time has ellapsed.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.GetBuildDate(System.String@)">
            <summary>Get build date formatted for use in registry</summary>
            <param name="wBuildDate">[out] L"YYYY-MM-DD"</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.GetBuildDate(System.Int32@,System.Int32@,System.Int32@)">
            <summary>Get build date information from VERSIONINFO block of the EXE</summary>
            <param name="nYear">[out] Gets filled in with four digit year</param>
            <param name="nMonth">[out] Gets filled in with month</param>
            <param name="nDate">[out] Gets filled in with the day of the month</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.GetBuildDate(System.String@,System.String@,System.String@)">
            <summary>Get build date information from VERSIONINFO block of the EXE</summary>
            <param name="wYear">[out] Gets filled in with four digit year</param>
            <param name="wMonth">[out] Gets filled in with first 3 chars of the month</param>
            <param name="wDate">[out] Gets filled in with the day of the month</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.GetRhinoProfileContext(RMA.Rhino.IRhinoProfileContext.context_location)">
            <summary>
For expert use only. Use profile contexts for reading and writing 
information that should persist between Rhino sessions. The profile
contexts are platform and location independent.

Appropriate profile contexts are:
   RhinoApp().m_PC
   RhinoApp().m_PC_GlobalOptions
   RhinoApp().m_PC_BuildDate_HKLM
   RhinoApp().m_PC_BuildDate_HKCU
</summary>
            <param name="location">[in] see CRhinoProfileContext::context_location for options</param>
            <returns>CRhinoProfileContext reference to requested profile context.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.RunAsServer">
            <summary>
Determines if Rhino is running as a server. If rhino3.exe is started with the command
line switch "/server" then Rhino will run in server mode. This means that no
UI or command Windows task bar icon are displayed. It is assumed that the caller is
running a script or plug-in that will close Rhino when finished. Rhino will not close itself.
</summary>
            <returns>Returns true if Rhino is running invisibly as a server. Otherwise false.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.GetCommandLineScript(System.String@)">
            <summary>Parse command line arguments passed to rhino3.exe on startup.</summary>
            <param name="wScript">
[out] A string containing a space-delimited series of commands and command arguments
that are run when Rhino starts. These commands are executed immediately after the
commands specified by the user as "Startup" commands in the General tab
of the Options dialog box.
</param>
            <returns>
true if wScript is not empty, indicating that there are commands to run.
false if wScript is empty, indicating that there are not commands to run.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.GetCommandPrompt(System.String@)">
            <summary>
Description: Set Rhino command prompt. Paramters: prompt - [in] prompt prompt_default - [in] text that appears in angle brackets and indicates what will happen if the user pressed ENTER. options - [in] command options
</summary>
            <summary>Get Rhino command prompt string.</summary>
            <param name="prompt">[out] Prompt display string.</param>
            <returns>Returns TRUE on success.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.SetCommandPrompt(System.String)">
            <summary>Set Rhino command prompt.</summary>
            <param name="prompt">[in] prompt</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.SetCommandPrompt(System.String,System.String)">
            <summary>Set Rhino command prompt.</summary>
            <param name="prompt">[in] prompt</param>
            <param name="prompt_default">
[in] text that appears in angle brackets and indicates what will happen if the user pressed ENTER.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.SetCommandPromptMessage(System.String)">
            <summary>Set the text that appears in the Rhino command prompt.</summary>
            <param name="sMessage">[in] literal text for the command prompt window.</param>
            <remarks>
In general, you should use the CRhinoApp::SetCommandPrompt functions. The create
a prompt that is correctly formated. In rare cases, like worker thread messages,
the message that appears in the prompt has non-standard formatting. In these rare
cases, SetCommandPromptMessage can be used to literally specify the text that
appears in the command prompt window.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.ClearCommandHistoryWindowText">
            <summary>Clear the text from Rhino's command history window</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.GetCommandHistoryWindowText(System.String@)">
            <summary>Returns the text from Rhino's command history window</summary>
            <param name="wstr">[out] The command history window text.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.Print(System.String)">
            <summary>Print text in the command window</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.ExecutableFolder(System.String@)">
            <summary>Get Rhino's executable folder</summary>
            <param name="result">[out] Folder name placed in this object</param>
            <returns>TRUE if result updated otherwise FALSE.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.InstallFolder(System.String@)">
            <summary>Get Rhino's installation folder</summary>
            <param name="result">[out] Folder name placed in this object</param>
            <returns>TRUE if result updated otherwise FALSE.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.RhinoInstanceHandle">
            <summary>Get Rhino HINSTANCE</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.MainWnd">
            <summary>Get Rhino main window.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.ActiveSpace">
            <summary>Returns the current working space.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.LookupView(System.Guid)">
            <summary>Find a viewport from a viewport_id.</summary>
            <param name="viewport_id">[in]</param>
            <returns>A pointer to a view or NULL if no viewport is has viewport_id.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.SetActiveViewport(System.Guid)">
            <summary>
Set the active viewport by id
(may be the viewport id of a detail object on a page)
</summary>
            <remarks>
This can be much slower than the SetActiveView() command. If
you can get away with just calling SetActiveView(), do that.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.SetActiveView(RMA.Rhino.MRhinoView)">
            <summary>
Active view (can be NULL if a file is being read and no views have 
been created)
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.ActiveView">
            <summary>Returns the active view.</summary>
            <returns>Pointer to active view or NULL if no views have been created.</returns>
            <remarks>
While a document is being read, there is a brief time when
there is no active view.  Code that may be run during file
reading needs to test for a NULL pointer.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.ActiveDoc">
            <summary>
Returns the active document.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.CommandCanceled">
            <returns>
True if a command is running and the user has pressed the escape key to cancel a command.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.Echo">
            <returns>
True if echo is enabled. Scripts that begin with "noecho" or "_noecho"
turn off echo. There is NO other way to control echo in V 3.0. This will not be
enhanced until V 3.1.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.RunMenuScript(System.String)">
            <summary>
Run a Rhino menu item script.  Will add the selected menu string to the MRU command menu.
</summary>
            <param name="script">[in] script to run</param>
            <remarks>
Rhino acts as if each character in the script string had
been typed in the command prompt.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.RunScript(System.String)">
            <summary>Run a Rhino command script.</summary>
            <param name="script">[in] script to run</param>
            <remarks>
Rhino acts as if each character in the script string had been typed in the command prompt.
When RunScript is called from a "script runner" command, it completely runs the
script before returning. When RunScript is called outside of a command, it returns and the
script is run. This way menus and buttons can use RunScript to execute complicated functions.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.RunScript(System.String,System.Int32)">
            <summary>Run a Rhino command script.</summary>
            <param name="script">[in] script to run</param>
            <param name="echo_mode">
[in] Controls how the script is echoed in the command output window.
0 = silent - nothing is echoed
1 = verbatim - the script is echoed literally
</param>
            <remarks>
Rhino acts as if each character in the script string had been typed in the command prompt.
When RunScript is called from a "script runner" command, it completely runs the
script before returning. When RunScript is called outside of a command, it returns and the
script is run. This way menus and buttons can use RunScript to execute complicated functions.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.InScriptRunnerCommand">
            <summary>
This is a low level tool to determine if Rhino is currently running a script
running command like "ReadCommandFile" or the RhinoScript plug-in's
"RunScript".
</summary>
            <returns>True if a script running command is active.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.InCommand">
            <summary>This is a low level tool to determine if Rhino is currently running a command.</summary>
            <returns>Number of active commands.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.InCommand(System.Boolean)">
            <summary>This is a low level tool to determine if Rhino is currently running a command.</summary>
            <param name="bIgnoreScriptRunnerCommands">
[in] if true, script running commands like "ReadCommandFile" and the RhinoScript
plug-ins "RunScript" are not counted.
</param>
            <returns>Number of active commands.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.RepeatCommand">
            <summary>repeats previous command</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.ExecuteCommand(System.String)">
            <summary>
In general, you should use CRhinoApp::RunScript to run commands
unless you are trying to modify the Rhino model from a modeless
dialog.  See the example below for how to handle the modeless
dialog situation.

This is a low level tool that searches for a command (a instance
of a class  derived from CRhinoCommand) with a matching command
name, if it finds a command, runs that command by calling the 
virtual CRhinoCommand::RunCommand() member function.

The command name can be prefaced with a combination of 
underbar (_), hyphen (-), or right single quote (').  If an
underbar is present, then the command name search looks for
a matching english command name.  If the underbar is not present,
the command name search looks for a matching localized command
name.  If the hypen is present, then the command is run in script
mode; otherwise the command is run in interactive mode.  The right
single quote is ignored by ExecuteCommand.  It is used in scripts
to indicate that the text token must be treated as a command name
and is important to upstream text token parsing.  
</summary>
            <example>
CMyCommand : pubic CRhinoCommand
{
public:
 RunCommand(...);
 type1 m_my_info1;
 type2 m_my_info2;
 bool m_bOkToRunCommand;
};

CMyCommand::CMyCommand(){ m_bOkToRunCommand = false; }

CMyCommand theMyCommand;

CMyCommand::RunCommand(...)
{
 if (!m_bOkToRunCommand)
 {
   RhinoMessageBox(L"Use the MyDialog button to run this command");
   return CRhinoCommand::failure;
 }
 the dialog has filled in m_my_info1 and m_my_info2.
 Use this as the "input" to the command and then
 do whatever you need to as if the command were
 an ordinary command.
 return CRhinoCommand::success;
}

CMyDialog::OnButtonDown(...)
{
 fill in the parameters
 theMyCommand.m_my_info1 = ...;
 theMyCommand.m_my_info2 = ...;
 theMyCommand.m_bOkToRunCommand = true;
 RhinoApp().ExectueCommand(theMyCommand.LocalCommandName());       
 theMyCommand.m_bOkToRunCommand = false;
}
</example>
            <returns>
Command return code indicating if the command worked, failed,
or was canceled by the user.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.AppSettings">
            <summary>
All appliction settings are kept in CRhinoAppSettings.
The settings are loaded in CRhinoApp::InitInstance() and saved
in CRhinoApp::ExitInstance().
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.SdkServiceRelease">
            <summary>
Service service release of the Rhino SDK supported by this executable. Rhino will only
load plug-ins that require a service release of &lt;= this release number.
For example, SR1 will load all plug-ins made with any SDK released up through and including
the SR1 SDK. But, SR1 will not load a plug-in built using the SR2 SDK. If an "old" Rhino
tries to load a "new" plug-in, the user is told that they have to get a free Rhino.exe
update in order for the plug-in to load. Rhino.exe updates are available from http://www.rhino3d.com.
</summary>
            <returns>
Rhino SDK 9 digit SDK service release number in the form YYYYMMDDn
See Also: CRhinoApp::SdkVersion
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoApp.SdkVersion">
            <summary>
Base version of the Rhino SDK supported by this Rhino executable.
Rhino will only load plug-ins that were build with exactly the same version of the SDK.
</summary>
            <returns>
Rhino SDK 9 digit SDK version number in the form YYYYMMDDn
See Also: CRhinoApp::SdkServiceRelease
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoApp.RhinoRenderPlugInUUID">
            <summary>
Description: Rhino skin.
</summary>
            <returns>the one and only Rhino system render plug-in</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoApp.RunningCommand(System.Int32)">
            <summary>
When script running or nestable commands are running, there can be more than one
command running at a given time. The private array m_running_commands_stack[] keeps
track of all the commands that are running. The one on the end of the array is the
"active" command. You really should not be using this function, except
when you are forced to hack around a sticky situation that requires you to know
when a certain command (like a base level script running command) may be active.
</summary>
            <param name="i">[in] 0 based index.</param>
            <returns>Pointer to command.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoApp.ActiveCommand">
            <summary>
Returns: Pointer to currently running command.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoApp.RegistrySchemeName">
            <returns>String that gets appended to end of build name when opening registry keys.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoApp.MonitorRects">
            <summary>
Description: Gets the module state of the Rhino core executable. Using this information is for advanced, skilled, and very careful developers. You are probably best off pretending this does not exist. It is exported just in case somebody needs this low level information in a plug-in situation that we have yet to discover. Returns: Rhino core executable module state.
</summary>
            <summary>
Call this method to get a sorted list of monitor display rectangles associated
with the currently installed monitors. The array will be sorted by the left edge.
</summary>
            <returns>Reference to the monitor rectangles.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoApp.RhinoAbout">
            <summary>Call this method to display the Rhino or RhinoSkin about box.</summary>
            <returns>See Also: CRhinoSkin class</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoApp.RhinoAbout(System.Boolean)">
            <summary>Call this method to display the Rhino or RhinoSkin about box.</summary>
            <param name="bForceRhinoAbout">
[in] This parameter is only used if Rhino is running in skin mode, see CRhinoSkin for deatils.
If Rhino is in skin mode and this is true then the Rhino about box will display otherwise the
skin splash screen will display.
</param>
            <returns>See Also: CRhinoSkin class</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoApp.DoHelp">
            <summary>Show help topic.</summary>
            <returns>
TRUE - help topic found
FALSE - help topic not found
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoApp.DoHelp(System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>Show help topic.</summary>
            <param name="help_topic_id">
[in] if zero, the help topic for the active command is displayed.
If not zero, help_topic_id specifies a help topic id in the Rhino3 help file.
</param>
            <returns>
TRUE - help topic found
FALSE - help topic not found
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoApp.GetDefaultRenderApp">
            <summary>
Get the application ID for the default render plug-in
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoApp.GetBuildDate(System.String@)">
            <summary>Get build date formatted for use in registry</summary>
            <param name="wBuildDate">[out] L"YYYY-MM-DD"</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoApp.GetBuildDate(System.Int32@,System.Int32@,System.Int32@)">
            <summary>Get build date information from VERSIONINFO block of the EXE</summary>
            <param name="nYear">[out] Gets filled in with four digit year</param>
            <param name="nMonth">[out] Gets filled in with month</param>
            <param name="nDate">[out] Gets filled in with the day of the month</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoApp.GetBuildDate(System.String@,System.String@,System.String@)">
            <summary>Get build date information from VERSIONINFO block of the EXE</summary>
            <param name="wYear">[out] Gets filled in with four digit year</param>
            <param name="wMonth">[out] Gets filled in with first 3 chars of the month</param>
            <param name="wDate">[out] Gets filled in with the day of the month</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoApp.GetCommandHistoryWindowText(System.String@)">
            <summary>Returns the text from Rhino's command history window</summary>
            <param name="wstr">[out] The command history window text.</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoApp.Print(System.String)">
            <summary>Print text in the command window</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoApp.ExecutableFolder(System.String@)">
            <summary>Get Rhino's executable folder</summary>
            <param name="result">[out] Folder name placed in this object</param>
            <returns>TRUE if result updated otherwise FALSE.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoApp.RhinoInstanceHandle">
            <summary>Get Rhino HINSTANCE</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoApp.MainWnd">
            <summary>Get Rhino main window.</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoApp.ActiveSpace">
            <summary>Returns the current working space.</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoApp.LookupView(System.Guid)">
            <summary>Find a viewport from a viewport_id.</summary>
            <param name="viewport_id">[in]</param>
            <returns>A pointer to a view or NULL if no viewport is has viewport_id.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoApp.SetActiveView(RMA.Rhino.MRhinoView)">
            <summary>
Active view (can be NULL if a file is being read and no views have 
been created)
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoApp.ActiveView">
            <summary>Returns the active view.</summary>
            <returns>Pointer to active view or NULL if no views have been created.</returns>
            <remarks>
While a document is being read, there is a brief time when
there is no active view.  Code that may be run during file
reading needs to test for a NULL pointer.
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoApp.ActiveDoc">
            <summary>
Returns the active document.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoApp.CommandCanceled">
            <returns>
True if a command is running and the user has pressed the escape key to cancel a command.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoApp.Echo">
            <returns>
True if echo is enabled. Scripts that begin with "noecho" or "_noecho"
turn off echo. There is NO other way to control echo in V 3.0. This will not be
enhanced until V 3.1.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoApp.InScriptRunnerCommand">
            <summary>
This is a low level tool to determine if Rhino is currently running a script
running command like "ReadCommandFile" or the RhinoScript plug-in's
"RunScript".
</summary>
            <returns>True if a script running command is active.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoApp.InCommand">
            <summary>This is a low level tool to determine if Rhino is currently running a command.</summary>
            <returns>Number of active commands.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoApp.InCommand(System.Boolean)">
            <summary>This is a low level tool to determine if Rhino is currently running a command.</summary>
            <param name="bIgnoreScriptRunnerCommands">
[in] if true, script running commands like "ReadCommandFile" and the RhinoScript
plug-ins "RunScript" are not counted.
</param>
            <returns>Number of active commands.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoApp.SdkServiceRelease">
            <summary>
Service service release of the Rhino SDK supported by this executable. Rhino will only
load plug-ins that require a service release of &lt;= this release number.
For example, SR1 will load all plug-ins made with any SDK released up through and including
the SR1 SDK. But, SR1 will not load a plug-in built using the SR2 SDK. If an "old" Rhino
tries to load a "new" plug-in, the user is told that they have to get a free Rhino.exe
update in order for the plug-in to load. Rhino.exe updates are available from http://www.rhino3d.com.
</summary>
            <returns>
Rhino SDK 9 digit SDK service release number in the form YYYYMMDDn
See Also: CRhinoApp::SdkVersion
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoApp.SdkVersion">
            <summary>
Base version of the Rhino SDK supported by this Rhino executable.
Rhino will only load plug-ins that were build with exactly the same version of the SDK.
</summary>
            <returns>
Rhino SDK 9 digit SDK version number in the form YYYYMMDDn
See Also: CRhinoApp::SdkServiceRelease
</returns>
        </member>
        <member name="P:RMA.Rhino.MRhinoGripsEnabler.m_grips_id">
            <value>
This is the id is used to distinguish between different types of
custom grips.  Rhino default grips (the ones you get with the
PointsOn command) have the id = nil.  Custom grips must
have a non-nil id.
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoGripsEnabler.m_grips_id">
            <value>
This is the id is used to distinguish between different types of
custom grips.  Rhino default grips (the ones you get with the
PointsOn command) have the id = nil.  Custom grips must
have a non-nil id.
</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoRenderPlugIn.RenderDialogPage(RMA.Rhino.MRhinoDoc)">
            <summary>
Called prior to adding the Rhino render tab to the FileProperites dialog.
This is only called when your render plug-in is the current render plug-in.
This function should return a pointer to a MRhinoOptionsDialogPage derived 
object or NULL if you do not wish to replace the render tab.
</summary>
            <param name="doc">[in] - Document to display properties for</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoRenderPlugIn.OnSetCurrentRenderPlugIn(System.Boolean)">
            <summary>
This plug-in (has become)/(is no longer) the current renerer.
If bCurrent then this plug-in has become the current renderer otherwise it
was, but is no longer, the current renderer.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoRenderPlugIn.CloseRenderWindow">
            <summary>
Close render window notification, called when rendering is done and render window
is no longer modal. (When RenderCommand returns if you leave the window up)
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoRenderPlugIn.SaveRenderedImage(System.String)">
            <summary>Message sent from script to save file</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoRenderPlugIn.EnableCreateMaterialButton">
            <summary>
Called to enable/disable the "New" button located on the "Material" in the 
Properties and Layer dialog boxes.  The default return value is false 
which will disable the button.  If the button is disabled then the OnEditMaterial
function is never called.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoRenderPlugIn.OnCreateMaterial(System.Windows.Forms.IWin32Window,RMA.OpenNURBS.OnMaterial@)">
            <summary>
This function is called by the Object Properties and Layer Control dialogs
when the "New" button is pressed in the "Material" tab.  This is only called
if AppType returns RhinoApp::Render and EnableCreateMaterialButton return Rhino::rhTrue.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoRenderPlugIn.EnableEditMaterialButton(RMA.OpenNURBS.OnMaterial@)">
            <summary>
Called to enable/disable the "Edit" button located on the "Material" in the 
Properties and Layer dialog boxes.  The default return value is false 
which will disable the button.  If the button is disabled then the OnEditMaterial
function is never called.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoRenderPlugIn.OnEditMaterial(System.Windows.Forms.IWin32Window,RMA.OpenNURBS.OnMaterial@)">
            <summary>
This function is called by the Object Properties and Layer Control dialogs
when the "Edit" button is pressed in the "Material" tab.  This is only called
if AppType returns RhinoApp::Render and EnableEditMaterialButton return Rhino::rhTrue.
A return value of Rhino::rhTrue means the material has been updted.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoRenderPlugIn.EnableAssignMaterialButton">
            <summary>
Called to enable/disable the "Material" button located on the "Material" tab
in the Properties and Layer dialog boxes.  The default return value is false 
which will disable the button.  If the button is disabled then the OnAssignMaterial 
function is never called.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoRenderPlugIn.OnAssignMaterial(System.Windows.Forms.IWin32Window,RMA.OpenNURBS.OnMaterial@)">
            <summary>
This function is called by the Object Properties and Layer Control dialogs
when the "Material" button is pressed in the "Render" tab.  This is only called
if AppType returns RhinoApp::Render and EnableAssignMaterialButton return Rhino::rhTrue.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoRenderPlugIn.RenderWindow(RMA.Rhino.IRhinoCommandContext,System.Boolean,RMA.Rhino.MRhinoView,System.Drawing.Rectangle,System.Boolean)">
            <summary>
Called by RenderWindow and RenderWindowPreview commands if this application is a Render
PlugIn and the set as the default render engine.
</summary>
            <param name="context">[in] Command paramaters passed to the render command.</param>
            <param name="render_preview">[in] If true, lower quality fater render expected.</param>
            <param name="view">[in] View to render</param>
            <param name="rect">[in] Rectangle to render in viewport window coordinates</param>
            <param name="bInWindow">[in] If true the output destination is a standard CRhinoSdkRenderView otherwise output to the current CRhinoView.</param>
            <remarks>
When overriding this function you should call CRhinoRenderPlugIn::IsRenderInWindow
to determine if being called by RenderWindow or RenderInWindow command.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoRenderPlugIn.Render(RMA.Rhino.IRhinoCommandContext,System.Boolean)">
            <summary>
Called by Render and RenderPreview commands if this application is a Render PlugIn and
the set as the default render engine.
</summary>
            <param name="context">[in] Command paramaters passed to the render command.</param>
            <param name="render_preview">[in] If true, lower quality fater render expected.</param>
        </member>
        <member name="T:RMA.Rhino.MRhinoRenderPlugIn">
            <summary>
Control class usesd when creating Render plug-ins.  Render plug-ins have the 
ability to replace the Rhino render command and object properties render property page.
</summary>
        </member>
        <member name="T:RMA.Rhino.MRhinoUtilityPlugIn">
            <summary>Control class for writing plug-in that adds commands to Rhino.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoFileExportPlugIn.WriteFile(System.String,System.Int32,RMA.Rhino.MRhinoDoc@,RMA.Rhino.IRhinoFileWriteOptions@)">
            <summary>Rhino calls WriteFile() to create document geometry</summary>
            <param name="lpsFileName">Name of file to write</param>
            <param name="index"> Index of file extension added to list in AddToFileType() callback.</param>
            <remarks>The plug-in is responsible for opening lpsFile and writing document data to it.</remarks>
            <returns>
&gt; 0 = File was successfully writen
0 = Not able to write file for some reason
&lt; 0 = File writing canceled
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoFileExportPlugIn.AddFileType(RMA.Rhino.ArrayMRhinoFileType@,RMA.Rhino.IRhinoFileWriteOptions@)">
            <summary>
When Rhino gets ready to display the save file dialog, it calls AddFileType()
once for each CRhinoExportPlugIn.
</summary>
            <param name="ext_list">Append your supported file types to this list</param>
            <param name="opts">File write options</param>
        </member>
        <member name="T:RMA.Rhino.MRhinoFileExportPlugIn">
            <summary>
Derive plug-in contol object from this class to create a file export plug-in.
This class provides interfaces for extending the Rhino file save dialog, 
drawing custom preview images and writing files.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoFileImportPlugIn.ReadFile(System.String,System.Int32,RMA.Rhino.MRhinoDoc@,RMA.Rhino.IRhinoFileReadOptions@)">
            <summary>Rhino calls ReadFile() to create document geometry.</summary>
            <param name="lpsFileName">Name of file to read</param>
            <param name="index">Index of file extension added to list in AddToFileType() callback.</param>
            <param name="doc">Empty document containing nothing but a Default layer.</param>
            <param name="options">File read options</param>
            <remarks>
The plug-in is responsible for opening lpsFile, reading it and creating document geometry.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoFileImportPlugIn.AddFileType(RMA.Rhino.ArrayMRhinoFileType@,RMA.Rhino.IRhinoFileReadOptions@)">
            <summary>
When Rhino gets ready to display the open file dialog, it calls AddFileType()
once for each loaded CRhinoFileImportPlugIn.
</summary>
            <param name="ext_list">Append your supported file types to this list</param>
            <param name="opts">File read options,</param>
        </member>
        <member name="T:RMA.Rhino.MRhinoFileImportPlugIn">
            <summary>
Derive plug-in contol object from this class to create a file import plug-in.
This class provides interfaces for extending the Rhino file open dialog, 
drawing custom preview images and reading files.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoFileType.FileTypePlugInID">
            <summary>ID of the plug-in that reads these files (or you can set it in the constructor)</summary>
            <returns>Plug-in ID that reads/writes this file type</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoFileType.FileTypeExtension(System.Int32)">
            <summary>Get file extension (returns NULL if index is out of range)</summary>
            <returns>UNICODE File extension</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoFileType.FileTypeDescription">
            <summary>Get description associated with this file extensions</summary>
            <returns>UNICODE File type description string.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoFileType.FileTypeDescription(System.String)">
            <summary>Set file description (or you can set it in the constructor)</summary>
            <param name="lpsDescription">File type description</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoFileType.AddFileTypeExtension(System.String)">
            <summary>Add file extension or alternate if called more than once.</summary>
            <param name="lpsExt">File extension to add</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoFileType.SetFileTypePlugInID(System.Guid)">
            <summary>Set ID of the plug-in that reads these files (or you can set it in the constructor)</summary>
            <param name="guid">ID of plug-in that reads this file type</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoFileType.#ctor(System.Guid,System.String,System.String,System.String,System.String)">
            <param name="guid">Plug-in ID of the CRhinoFileImportPlugIn/CRhinoFileExportPlugIn</param>
            <param name="lpsDescription">Description of the file displayed in the open file dialog</param>
            <param name="lpsExt1">file extension (without the "*.")</param>
            <param name="lpsExt2">another file extension associated with this file type</param>
            <param name="lpsExt3">another file extension associated with this file type</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoFileType.#ctor(System.Guid,System.String,System.String,System.String)">
            <param name="guid">Plug-in ID of the CRhinoFileImportPlugIn/CRhinoFileExportPlugIn</param>
            <param name="lpsDescription">Description of the file displayed in the open file dialog</param>
            <param name="lpsExt1">file extension (without the "*.")</param>
            <param name="lpsExt2">another file extension associated with this file type</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoFileType.#ctor(System.Guid,System.String,System.String)">
            <param name="guid">Plug-in ID of the CRhinoFileImportPlugIn/CRhinoFileExportPlugIn</param>
            <param name="lpsDescription">Description of the file displayed in the open file dialog</param>
            <param name="lpsExt">file extension (without the "*.")</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoFileType.#ctor(System.Guid,System.String)">
            <param name="guid">Plug-in ID of the CRhinoFileImportPlugIn/CRhinoFileExportPlugIn</param>
            <param name="lpsDescription">Description of the file displayed in the open file dialog</param>
        </member>
        <member name="T:RMA.Rhino.MRhinoFileType">
            <summary>
Used by CRhinoFileImport and CRhinoFileExport file plug-ins to add file
extensions to the standard Rhino file dialog box.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoFileType.FileTypePlugInID">
            <summary>ID of the plug-in that reads these files (or you can set it in the constructor)</summary>
            <returns>Plug-in ID that reads/writes this file type</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoFileType.FileTypeExtension(System.Int32)">
            <summary>Get file extension (returns NULL if index is out of range)</summary>
            <returns>UNICODE File extension</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoFileType.FileTypeDescription">
            <summary>Get description associated with this file extensions</summary>
            <returns>UNICODE File type description string.</returns>
        </member>
        <member name="T:RMA.Rhino.IRhinoFileType">
            <summary>
Used by CRhinoFileImport and CRhinoFileExport file plug-ins to add file
extensions to the standard Rhino file dialog box.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPlugIn.VisualAnalysisModes">
            <returns>array of visual analysis modes defined by this plug-in. may be null</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPlugIn.Commands">
            <returns>array of command instances for this plug-in. may be null</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoPlugIn.AddPagesToOptionsDialog(System.Windows.Forms.IWin32Window,System.Collections.Generic.List`1{RMA.UI.MRhinoOptionsDialogPage^})">
            <summary>Override this funtion if you want to extend the Options dialog</summary>
            <param name="pages">
[out] - Array of page pointers to add to the options dialog.
This array may contain pages added by other plug-ins
so simply append your additions to the end of the list.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoPlugIn.AddPagesToDocumentPropertiesDialog(RMA.Rhino.MRhinoDoc,System.Windows.Forms.IWin32Window,System.Collections.Generic.List`1{RMA.UI.MRhinoOptionsDialogPage^})">
            <summary>Override this funtion if you want to extend the DocumentProperties dialog</summary>
            <param name="doc">[in]  - Document whos properties are to be modified.</param>
            <param name="hwndParent">[in] - HWND of parent dialog.</param>
            <param name="pages">
[out] - Array of pages to add to the options dialog.
This array may contain pages added by other plug-ins
so simply append your additions to the end of the list.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoPlugIn.AddPagesToObjectPropertiesDialog(System.Collections.Generic.List`1{RMA.UI.MRhinoObjectPropertiesDialogPage^})">
            <summary>Override this funtion if you want to extend the object properties dialog.</summary>
            <param name="pages">[out] - Array of page objects to add to the options dialog.</param>
            <remarks>
This method is called once at the completion of loading the plug-in.  The
CRhinoObjectPropertiesDialogPage objects are notified when CRhinoObjects 
are added to the properties control bar. See CRhinoStackedDialogPage for
page notification events.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoPlugIn.RemovePlugInMenuFromRhino(RMA.UI.MRhinoPlugInMenu)">
            <summary>Remove menu added by this plug-in</summary>
            <param name="menu">menu to unload</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoPlugIn.InsertPlugInMenuToRhinoMenu(RMA.UI.MRhinoPlugInMenu)">
            <summary>
A Plug-in can call this function to add its menu to the Rhino Menubar
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPlugIn.GetPlugInObjectInterface(System.Guid@)">
            <summary>
Override this function if you want to return an interface pointer for
a COM object in your plug-in. Note, if you want your plugin to support
scripting with RhinoScript, you must return the interface pointer of an
IDispatch-derived object (IID_IDispatch).
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPlugIn.OnDisplayPlugInHelp(System.Windows.Forms.IWin32Window)">
            <summary>
Called by Rhino if AddToPlugInHelpMenu() returns true and menu item associated
with this plug-in is selected.
</summary>
            <param name="hWnd">Window handle of the active Rhino interface.</param>
            <returns>
true  = Help displayed successfully.
false = Error displaying help
</returns>
            <remarks>
If AddToPlugInHelpMenu() was overridden and returns true then override this 
funtion and call your plug-in's help file.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoPlugIn.AddToPlugInHelpMenu">
            <summary>
Called by Rhino to determine if the plug-in name should be added to the Rhino
Help/Plug-ins menu.
</summary>
            <returns>
true  = Plug-in name is added to menu.
false = Plug-in name is not added to menu.
</returns>
            <remarks>
Default is false, to automaticly add your plug-in to the Rhino help menu override
and return true.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoPlugIn.PlugInLoadTime">
            <summary>Called when plug-in self registration begins and ends.</summary>
            <remarks>
When a plug-in is loaded successfully Rhino registers it so it may be loaded
automaticly in the future.  This method is called at the begining and end of
the registration process.
</remarks>
            <summary>
Called by Rhino when writing plug-in information to the registry.  This
infomation will be read the next time Rhino starts to identify properly
installed plug-ins.
</summary>
            <returns>
load_plugin_when_needed = Plug-in will not be loaded when Rhino starts.  Plug-in
                         will be loaded when a plug-in defined command is
                         run or when a user selects a plug-in defined file
                         import/export type.
load_plugin_at_startup  = Plug-in is loaded when Rhino is loaded and initialized.
</returns>
            <remarks>
Override this function and return load_plugin_at_startup to get your plug-in to
load when Rino does.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoPlugIn.SaveProfile(System.String,RMA.Rhino.MRhinoProfileContext@)">
            <summary>
Save persistent plug-in settings to the Rhino profile.
</summary>
            <param name="lpszSection">[in] profile section to use for this plug-in</param>
            <param name="pc">[in] profile context to use to get at value saved in the Rhino profile.</param>
            <remarks>
Rhino will call SaveProfile before unloading your plug-in
and exiting.  Override SaveProfile to save plug-in settings
that need to persist between Rhino sessions.
The default does nothing.
</remarks>
            <seealso cref="M:RMA.Rhino.MRhinoPlugIn.LoadProfile(System.String,RMA.Rhino.MRhinoProfileContext@)" />
        </member>
        <member name="M:RMA.Rhino.MRhinoPlugIn.LoadProfile(System.String,RMA.Rhino.MRhinoProfileContext@)">
            <summary>
Loads persistent plug-in settings from the Rhino profile.
</summary>
            <param name="lpszSection">[in] profile section to use for this plug-in</param>
            <param name="pc">[in] profile context to use to get at value saved in the Rhino profile.</param>
            <remarks>
Rhino will call LoadProfile after the plug-in is loaded and before
the plug-in is used.  The default does nothing.
</remarks>
            <seealso cref="M:RMA.Rhino.MRhinoPlugIn.SaveProfile(System.String,RMA.Rhino.MRhinoProfileContext@)" />
        </member>
        <member name="M:RMA.Rhino.MRhinoPlugIn.OnUnloadPlugIn">
            <summary>
Called one time when plug-in is about to be unloaded. By this time,
Rhino's mainframe window has been destroyed, and some of the SDK
managers have been deleted. There is also no active document or active 
view at this time. Thus, you should only be manipulating your own objects.
or tools here.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPlugIn.OnSaveAllSettings">
            <summary>
The Rhino plug-in manager will call this method when Rhino is preparing
to close. At this point, the Rhino SDK should still be completely
accessible.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoPlugIn.OnLoadPlugInErrorString(System.String@)">
            <summary>
If OnLoadPlugIn() returns 0 the Rhino plug-in manager will call this method.
If this metod sets message to a valid string and returns true then the
plug-in on load error dialog will disply your custom message.
</summary>
            <param name="msg">[out] Error message to display</param>
            <returns>
true = Display custom message
false = Display system message
</returns>
            <seealso cref="M:RMA.Rhino.MRhinoPlugIn.OnLoadPlugIn" />
        </member>
        <member name="M:RMA.Rhino.MRhinoPlugIn.OnLoadPlugIn">
            <summary>Called one time when a plug-in is loaded.</summary>
            <returns>
1  = Initialization succeded, leave the plug-in loaded.
0  = Unable to initialize, unload the plug-in and display load error dialog.
-1 = Unable to initialize, unload the plug-in and do not display load error dialog.
        Note: OnUnloadPlugIn will not be called.
</returns>
            <remarks>
Plug-ins are not loaded until after Rhino is started and a default document
is created.  Because the default document already exists 
CRhinoEventWatcher::On????Document() functions are not called for the default
document.  If you need to do any document initialization/synchronization then
override this function and do it here.  It is not necessary to call 
CPlugIn::OnLoadPlugIn() from your derived class.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoFileReadOptions.Mode(RMA.Rhino.IRhinoFileReadOptions.ModeFlag)">
            <summary>
Check which modes are enabled for file reading. More than one mode can be enabled for a file read.
</summary>
            <param name="mode_to_check">[in]</param>
            <returns>TRUE if mode_to_check is active.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoFileReadOptions.Mode(RMA.Rhino.IRhinoFileReadOptions.ModeFlag)">
            <summary>
Check which modes are enabled for file reading. More than one mode can be enabled for a file read.
</summary>
            <param name="mode_to_check">[in]</param>
            <returns>TRUE if mode_to_check is active.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoFileWriteOptions.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <param name="bSelectedOnly">Write only selected objects</param>
            <param name="bTransform">GetTransform() returns transform to apply to all exported geometry.</param>
            <param name="bSaveRenderMeshes">Write render meshes</param>
            <param name="bSavePreview">Write preview image</param>
            <param name="bSaveBitmaps">Write render bitmaps</param>
            <param name="bSaveHistory">Write history inforamtion</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoCommandOptionValue.#ctor(System.String)">
            <summary>
Sets m_english_option_value = option_value
and m_local_option_value = option_value.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoCommandOptionValue.#ctor(System.String,System.String)">
            <summary>
Sets m_english_option_value = english_option_value
and m_local_option_value = local_option_value.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoCommandOptionValue.#ctor">
            <summary>
Sets both string pointers to NULL.
</summary>
        </member>
        <member name="T:RMA.Rhino.MRhinoCommandOptionValue">
            <summary>
CRhinoCommandOptionValue classes are used to pass command 
toggle option and list option values to 
CRhinoGet::AddCommandOptionToggle() and 
CRhinoGet::AddCommandOptionList().
</summary>
        </member>
        <member name="T:RMA.Rhino.IRhinoCommandOptionValue">
            <summary>
CRhinoCommandOptionValue classes are used to pass command 
toggle option and list option values to 
CRhinoGet::AddCommandOptionToggle() and 
CRhinoGet::AddCommandOptionList().
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoCommandOptionName.#ctor(System.String)">
            <summary>
Sets m_english_option_name = option_name
and m_local_option_name = option_name.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoCommandOptionName.#ctor(System.String,System.String)">
            <summary>
Sets m_english_option_name = english_option_name
and m_local_option_name = local_option_name.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoCommandOptionName.#ctor">
            <summary>
Sets both string pointers to NULL.
</summary>
        </member>
        <member name="T:RMA.Rhino.MRhinoCommandOptionName">
            <summary>
CRhinoCommandOptionName classes are used to pass command 
option names, list option values, and toggle option values 
to CRhinoGet::AddCommandOption...().
</summary>
        </member>
        <member name="T:RMA.Rhino.IRhinoCommandOptionName">
            <summary>
CRhinoCommandOptionName classes are used to pass command 
option names, list option values, and toggle option values 
to CRhinoGet::AddCommandOption...().
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoCommandOption.SetDisplayString(System.Int32)">
            <summary>
sets m_display_string
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoCommandOption.ValidNumber(System.Double)">
            <summary>
Returns:
 TRUE if this is a number option and the value passes
 the m_bIntegerNumberValue, m_number_lower_limit, and
 m_number_upper_limit tests.
</summary>
        </member>
        <member name="P:RMA.Rhino.MRhinoCommandOption.m_display_rect">
            <value>
(volatile) for hit testing mouse picks
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoCommandOption.m_display_string">
            <value>
(volatile) contains formatting instructions
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoCommandOption.m_list_option_current">
            <value>
0 based index into m_list_option_values[] array
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoCommandOption.m_toggle_option_value">
            <value>
-1 = unset, 1 = true, 0 = false
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoCommandOption.m_number_upper_limit">
            <value>
if != ON_UNSET_VALUE, number value must be &lt;= upper_limit
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoCommandOption.m_number_lower_limit">
            <value>
if != ON_UNSET_VALUE, number value must be &gt;= lower_limit
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoCommandOption.m_bIntegerNumberValue">
            <value>
if TRUE, number must be an integer
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoCommandOption.m_color_option_value">
            <value>
0 = general
1 = distance
2 = angle in degrees
3 = angle in radians
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoCommandOption.m_number_option_format">
            <value>
format used to display the number option
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoCommandOption.m_local_simple_option_value">
            <value>
simple option value
if empty string prompt looks like
 " local_option_name "
if not empty string prompt looks like
 " local_option_name=value "
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoCommandOption.m_option_prompt">
            <value>
&lt;- this one shows up then user types the number/toggle/list option name and presses Enter
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoCommandOption.m_english_option_name">
            <value>
this is for _english script processing
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoCommandOption.m_local_option_name">
            <value>
&lt;- this one shows up on command window prompt
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoCommandOption.m_option_value">
            <value>
Assigned by CRhinoGet::Get*() if an option value specified in script
or by a fancy command window control
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoCommandOption.m_option_index">
            <value>
Index assigned by CRhinoGet::AddOption();
</value>
        </member>
        <member name="M:RMA.Rhino.IRhinoCommandOption.SetDisplayString(System.Int32)">
            <summary>
sets m_display_string
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoCommandOption.ValidNumber(System.Double)">
            <summary>
Returns:
 TRUE if this is a number option and the value passes
 the m_bIntegerNumberValue, m_number_lower_limit, and
 m_number_upper_limit tests.
</summary>
        </member>
        <member name="P:RMA.Rhino.IRhinoCommandOption.m_display_rect">
            <value>
(volatile) for hit testing mouse picks
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoCommandOption.m_display_string">
            <value>
(volatile) contains formatting instructions
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoCommandOption.m_list_option_current">
            <value>
&lt;- this one shows up on command window prompt
</value>
            <value>
this is for _english script processing
</value>
            <value>
&lt;- this one shows up on command window prompt
</value>
            <value>
this is for _english script processing
</value>
            <value>
0 based index into m_list_option_values[] array
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoCommandOption.m_toggle_option_value">
            <value>
-1 = unset, 1 = true, 0 = false
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoCommandOption.m_number_upper_limit">
            <value>
if != ON_UNSET_VALUE, number value must be &lt;= upper_limit
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoCommandOption.m_number_lower_limit">
            <value>
if != ON_UNSET_VALUE, number value must be &gt;= lower_limit
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoCommandOption.m_bIntegerNumberValue">
            <value>
if TRUE, number must be an integer
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoCommandOption.m_color_option_value">
            <value>
0 = general
1 = distance
2 = angle in degrees
3 = angle in radians
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoCommandOption.m_number_option_format">
            <value>
format used to display the number option
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoCommandOption.m_local_simple_option_value">
            <value>
simple option value
if empty string prompt looks like
 " local_option_name "
if not empty string prompt looks like
 " local_option_name=value "
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoCommandOption.m_option_prompt">
            <value>
option aliases (for hidden options)
</value>
            <value>
&lt;- this one shows up then user types the number/toggle/list option name and presses Enter
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoCommandOption.m_english_option_name">
            <value>
this is for _english script processing
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoCommandOption.m_local_option_name">
            <value>
&lt;- this one shows up on command window prompt
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoCommandOption.m_option_value">
            <value>
Assigned by CRhinoGet::Get*() if an option value specified in script
or by a fancy command window control
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoCommandOption.m_option_index">
            <value>
Index assigned by CRhinoGet::AddOption();
</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoCommandManager.GetCommandNames(System.String[]@,System.Boolean,System.Boolean)">
            <summary>Get list of command names in Rhino. This list does not include Test, Alpha, or System commands</summary>
            <param name="names">[out] names for every command are appended to this list</param>
            <param name="english">
[in] if true, retrieve the english name for every command
if false, retrieve the local name for every command
</param>
            <param name="loaded">
[in] if true, only get names of currently loaded commands
if false, get names of all registered (may not be currently loaded) commands
</param>
            <returns>Number of commands appended to the list.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoCommandManager.LookupLocalCommandName(System.String)">
            <summary>Lookup a command from the local command name.</summary>
            <param name="local_command_name">[in] local command name.</param>
            <returns>Pointer to the command or NULL if no command was found</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoCommandManager.LookupEnglishCommandName(System.String)">
            <summary>Lookup a command from the english command name.</summary>
            <param name="english_command_name">[in] english command name.</param>
            <returns>Pointer to the command or NULL if no command was found</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoCommandManager.LookupCommandName(System.String)">
            <summary>
Lookup a command from a command name using the same algorithm that is
used when a user types thae command name.
</summary>
            <param name="command_name">
[in] command name with optional RHINO_SCRIPT_COMMAND_PREFIX 
and/or RHINO_ENGLISH_COMMAND_PREFIX characters in any order.
</param>
            <returns>Pointer to the command or NULL if no command was found</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoCommandManager.LookupCommand(System.Guid)">
            <summary>Lookup a command from it uuid.</summary>
            <param name="command_uuid">[in]</param>
            <returns>Pointer to the command or NULL if no command was found</returns>
        </member>
        <member name="T:RMA.Rhino.MRhinoCommandManager">
            <summary>Public interface to lookup commands by name and uuid</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoCommandManager.GetCommandNames(System.String[]@,System.Boolean,System.Boolean)">
            <summary>Get list of command names in Rhino. This list does not include Test, Alpha, or System commands</summary>
            <param name="names">[out] names for every command are appended to this list</param>
            <param name="english">
[in] if true, retrieve the english name for every command
if false, retrieve the local name for every command
</param>
            <param name="loaded">
[in] if true, only get names of currently loaded commands
if false, get names of all registered (may not be currently loaded) commands
</param>
            <returns>Number of commands appended to the list.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoCommandManager.LookupLocalCommandName(System.String)">
            <summary>Lookup a command from the local command name.</summary>
            <param name="local_command_name">[in] local command name.</param>
            <returns>Pointer to the command or NULL if no command was found</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoCommandManager.LookupEnglishCommandName(System.String)">
            <summary>Lookup a command from the english command name.</summary>
            <param name="english_command_name">[in] english command name.</param>
            <returns>Pointer to the command or NULL if no command was found</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoCommandManager.LookupCommandName(System.String)">
            <summary>
Lookup a command from a command name using the same algorithm that is
used when a user types thae command name.
</summary>
            <param name="command_name">
[in] command name with optional RHINO_SCRIPT_COMMAND_PREFIX 
and/or RHINO_ENGLISH_COMMAND_PREFIX characters in any order.
</param>
            <returns>Pointer to the command or NULL if no command was found</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoCommandManager.LookupCommand(System.Guid)">
            <summary>Lookup a command from it uuid.</summary>
            <param name="command_uuid">[in]</param>
            <returns>Pointer to the command or NULL if no command was found</returns>
        </member>
        <member name="T:RMA.Rhino.IRhinoCommandManager">
            <summary>Public interface to lookup commands by name and uuid</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistory.SetGeometryValues(System.Int32,RMA.OpenNURBS.OnGeometry[])">
            <summary>For setting values when commands are creating history records.</summary>
            <param name="value_id">
[in] If there a value with the same input id exists, the old value is replaced.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistory.SetStringValues(System.Int32,System.String[])">
            <summary>For setting values when commands are creating history records.</summary>
            <param name="value_id">
[in] If there a value with the same input id exists, the old value is replaced.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistory.SetUuidValues(System.Int32,System.Guid[])">
            <summary>For setting values when commands are creating history records.</summary>
            <param name="value_id">
[in] If there a value with the same input id exists, the old value is replaced.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistory.SetObjRefValues(System.Int32,RMA.Rhino.ArrayMRhinoObjRef)">
            <summary>For setting values when commands are creating history records.</summary>
            <param name="value_id">
[in] If there a value with the same input id exists, the old value is replaced.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistory.SetColorValues(System.Int32,RMA.OpenNURBS.ArrayOnColor)">
            <summary>For setting values when commands are creating history records.</summary>
            <param name="value_id">
[in] If there a value with the same input id exists, the old value is replaced.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistory.SetXformValues(System.Int32,RMA.OpenNURBS.ArrayOnXform)">
            <summary>For setting values when commands are creating history records.</summary>
            <param name="value_id">
[in] If there a value with the same input id exists, the old value is replaced.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistory.SetVectorValues(System.Int32,RMA.OpenNURBS.ArrayOn3dVector)">
            <summary>For setting values when commands are creating history records.</summary>
            <param name="value_id">
[in] If there a value with the same input id exists, the old value is replaced.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistory.SetPointValues(System.Int32,RMA.OpenNURBS.ArrayOn3dPoint)">
            <summary>For setting values when commands are creating history records.</summary>
            <param name="value_id">
[in] If there a value with the same input id exists, the old value is replaced.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistory.SetDoubleValues(System.Int32,System.Double[])">
            <summary>For setting values when commands are creating history records.</summary>
            <param name="value_id">
[in] If there a value with the same input id exists, the old value is replaced.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistory.SetIntValues(System.Int32,System.Int32[])">
            <summary>For setting values when commands are creating history records.</summary>
            <param name="value_id">
[in] If there a value with the same input id exists, the old value is replaced.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistory.SetBoolValues(System.Int32,System.Boolean[])">
            <summary>For setting values when commands are creating history records.</summary>
            <param name="value_id">
[in] If there a value with the same input id exists, the old value is replaced.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistory.SetMeshValue(System.Int32,RMA.OpenNURBS.IOnMesh)">
            <summary>For setting values when commands are creating history records.</summary>
            <param name="value_id">
[in] If there a value with the same input id exists, the old value is replaced.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistory.SetBrepValue(System.Int32,RMA.OpenNURBS.IOnBrep)">
            <summary>For setting values when commands are creating history records.</summary>
            <param name="value_id">
[in] If there a value with the same input id exists, the old value is replaced.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistory.SetSurfaceValue(System.Int32,RMA.OpenNURBS.IOnSurface)">
            <summary>For setting values when commands are creating history records.</summary>
            <param name="value_id">
[in] If there a value with the same input id exists, the old value is replaced.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistory.SetCurveValue(System.Int32,RMA.OpenNURBS.IOnCurve)">
            <summary>For setting values when commands are creating history records.</summary>
            <param name="value_id">
[in] If there a value with the same input id exists, the old value is replaced.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistory.SetGeometryValue(System.Int32,RMA.OpenNURBS.OnGeometry)">
            <summary>For setting values when commands are creating history records.</summary>
            <param name="value_id">
[in] If there a value with the same input id exists, the old value is replaced.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistory.SetStringValue(System.Int32,System.String)">
            <summary>For setting values when commands are creating history records.</summary>
            <param name="value_id">
[in] If there a value with the same input id exists, the old value is replaced.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistory.SetUuidValue(System.Int32,System.Guid)">
            <summary>For setting values when commands are creating history records.</summary>
            <param name="value_id">
[in] If there a value with the same input id exists, the old value is replaced.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistory.SetPointOnObjectValue(System.Int32,RMA.Rhino.IRhinoObjRef,RMA.OpenNURBS.IOn3dPoint)">
            <summary>For setting values when commands are creating history records.</summary>
            <param name="value_id">
[in] If there a value with the same input id exists, the old value is replaced.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistory.SetObjRefValue(System.Int32,RMA.Rhino.IRhinoObjRef)">
            <summary>For setting values when commands are creating history records.</summary>
            <param name="value_id">
[in] If there a value with the same input id exists, the old value is replaced.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistory.SetColorValue(System.Int32,RMA.OpenNURBS.IOnColor)">
            <summary>For setting values when commands are creating history records.</summary>
            <param name="value_id">
[in] If there a value with the same input id exists, the old value is replaced.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistory.SetXformValue(System.Int32,RMA.OpenNURBS.IOnXform)">
            <summary>For setting values when commands are creating history records.</summary>
            <param name="value_id">
[in] If there a value with the same input id exists, the old value is replaced.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistory.SetVectorValue(System.Int32,RMA.OpenNURBS.IOn3dVector)">
            <summary>For setting values when commands are creating history records.</summary>
            <param name="value_id">
[in] If there a value with the same input id exists, the old value is replaced.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistory.SetPointValue(System.Int32,RMA.OpenNURBS.IOn3dPoint)">
            <summary>For setting values when commands are creating history records.</summary>
            <param name="value_id">
[in] If there a value with the same input id exists, the old value is replaced.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistory.SetDoubleValue(System.Int32,System.Double)">
            <summary>For setting values when commands are creating history records.</summary>
            <param name="value_id">
[in] If there a value with the same input id exists, the old value is replaced.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistory.SetIntValue(System.Int32,System.Int32)">
            <summary>For setting values when commands are creating history records.</summary>
            <param name="value_id">
[in] If there a value with the same input id exists, the old value is replaced.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistory.SetBoolValue(System.Int32,System.Boolean)">
            <summary>For setting values when commands are creating history records.</summary>
            <param name="value_id">
[in] If there a value with the same input id exists, the old value is replaced.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistory.SetCommand(RMA.Rhino.IRhinoCommand)">
            <summary>
Set the command whos ReplayHistory override will be used to update the
command's ouput objects if an input changes.
</summary>
            <param name="cmd">[in]</param>
            <remarks>
You can either set the command by passing it to the constructor or by using this function.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoHistory.SetHistoryVersion(System.Int32)">
            <summary>
Specify a non-zero integer that identifies the version of this history record.
The virtual ReplayHistory() functions can check this version to avoid replaying
history using information created by earlier versions of the command.
</summary>
            <param name="history_version">
[in] any non-zero integer. It is strongly suggested that something like YYYYMMDD be used.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="T:RMA.Rhino.IRhinoHistory">
            <summary>
MRhinoHistory simply manages a pointer to an ON_HistoryRecord and frees command
developers from having to carefuly create the CRhinoHistoryRecord pointer in a way that 
never leaks memory.
</summary>
        </member>
        <member name="T:RMA.Rhino.MRhinoTestCommand">
            <summary>
Test commands do not auto-complete. This is useful for hidden or test commands
</summary>
        </member>
        <member name="T:RMA.Rhino.IRhinoTestCommand">
            <summary>
Test commands do not auto-complete. This is useful for hidden or test commands
</summary>
        </member>
        <member name="T:RMA.Rhino.MRhinoScriptCommand">
            <summary>
For advanced users only.  Support is not available.
Commands like the RhinoScript plug-in's RunScript() that want
to run scripts as if they were typed at the command line,
should be derived from CRhinoScriptCommand.
</summary>
        </member>
        <member name="T:RMA.Rhino.IRhinoScriptCommand">
            <summary>
For advanced users only.  Support is not available.
Commands like the RhinoScript plug-in's RunScript() that want
to run scripts as if they were typed at the command line,
should be derived from CRhinoScriptCommand.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoCommand.ReplayHistory(RMA.Rhino.IRhinoHistoryRecord)">
            <summary>
Rhino calls uses the virtual ReplayHistory functions to remake an object
when inputs have changed. If a command supports history, it must override
exactly one of the ReplayHistory functions. Simple commands can use the
simple version of replay history that just generates a new object. Complex
commands, like Project and Interesect need to override the complex version
of replay history that uses a results[] array to return multiple objects.
</summary>
            <param name="history_record">
[in] History information the command record when it first created the existing objects.
</param>
            <returns>either NULL or an updated object.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoCommand.ReplayHistory(RMA.Rhino.IRhinoHistoryRecord,RMA.Rhino.MRhinoObjectPairList)">
            <summary>
Rhino calls uses the virtual ReplayHistory functions to remake an object
when inputs have changed. If a command supports history, it must override
exactly one of the ReplayHistory functions. Simple commands can use the
simple version of replay history that just generates a new object. Complex
commands, like Project and Interesect need to override the complex version
of replay history that uses a results[] array to return multiple objects.
</summary>
            <param name="history_record">
[in] History information the command record when it first created the existing objects.
</param>
            <param name="results">
results[i].m_objects[0] - [in]  existing object
results[i].m_objects[1] - [out] updated object

The input array has the objects that were created by the command in results[i].m_objects[0]. 

ReplayHistory is responsible for creating replacements and putting them in
results[i].m_objects[1]. The replacements must NOT be added to the document.
The results[] array can be grown if there are new "updated" objects
that do not replace an existing object. In this case set the m_objects[0] pointer
to NULL. An input results[i].m_objects[0] can be set to NULL if no replacement
can be calculated.

If results[i].m_objects[0] and results[i].m_objects[1] are
both not NULL, then m_objects[1] will replace m_objects[0].
If results[i].m_objects[0] is not NULL and results[i].m_objects[1]
is NULL, then results[i].m_objects[0] is deleted.
If results[i].m_objects[0] is NULL and results[i].m_objects[1]
is not NULL, then results[i].m_objects[1] is added.
</param>
            <returns>
true if Rhino should process the information in results[] and false otherwise.
</returns>
        </member>
        <member name="P:RMA.Rhino.MRhinoCommand.UseExceptionHandling">
            <value>Determines if the RunCommand function should be called in a try...catch block</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoCommand.PlugIn">
            <summary>If command is in a plug-in, this returns the pointer to the plug-in.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoCommand.IsAlphaCommand">
            <summary>Returns true if a command is an "alpha" command.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoCommand.EnableUndo(System.Boolean)">
            <summary>
By default, all commands are undoable.  If you have a command that
should not be undoable, then call EnableUndo(false) in the constructor
for the command's class.
</summary>
            <remarks>
It is a rare command that should call EnableUndo. Enable undo should
only be called in the constructor for the command.  Under no
circustances should enable undo be called while RunCommand is active.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoCommand.IsUndoable">
            <summary>Returns true if this command's actions can be undone by the Rhino "Undo" command.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoCommand.IsTestCommand">
            <summary>
Returns true if a command is a "test" command that is
not available in the commercial release.  All commands
derived from CRhinoTestCommand are "test" commands.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoCommand.IsSystem">
            <summary>
Returns true if a command is a system command.
(Most commands are not and SDK developers can ignore this field.)
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoCommand.IsRepeatable">
            <summary>
Returns true if a command is "repeatable"; i.e., the command
can be repeated by pressing ENTER immediately after the
command finishes.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoCommand.IsTransparent">
            <summary>
Returns true if a command is "transparent"; i.e., the command
does not modify the contents of the model's geometry in any way.
Examples of transparent commands include commands that change
views and toggle snap states.  Any command that adds or deletes,
a view cannot be transparent.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoCommand.ContextHelpURL(System.String@)">
            <summary>
The Command Context window will call this function when it is attempting
to show help for this command. Override this function if you have a help
topic that you can display in the Command Context window.
</summary>
            <param name="url">
[out] URL to your command's help topic. The Command Context window is an
embedded web browser control, so any URL that you can display in a web
browser would be valid. The base class function returns a URL that is
formatted to show a page inside the Rhino CHM help file. For example,
Rhino's line command returns a string like the following:
mk:@MSITStore:C:\Program%20Files\Rhinoceros%204.0\English\Help\rhinov4.chm::/Commands/Lines.htm#Line_command
</param>
            <returns>
true if the Command Context should update to display the url
false if you don't want the Command Context window to change it's current url
</returns>
            <remarks>
The recommended approach is to create a URL that points to an HTML file that
is on the user's computer. This speeds up the display of your help topic and
doesn't make your command look like it is running slow when the Command Context
auto-update is on.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoCommand.DoHelp">
            <summary>Override this function to display help for this command.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoCommand.SaveProfile(System.String,RMA.Rhino.MRhinoProfileContext@)">
            <summary>Save persistent command settings to the Rhino profile.</summary>
            <param name="lpszSection">[in] profile section to use for this command</param>
            <param name="pc">[in] profile context to use to get at value saved in the Rhino profile.</param>
            <remarks>
Most commands do not override SaveProfile.  Use SaveProfile
to save command options that persist between Rhino sessions.
The default does nothing.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoCommand.LoadProfile(System.String,RMA.Rhino.MRhinoProfileContext@)">
            <summary>Loads persistenct command settings from the Rhino profile.</summary>
            <param name="lpszSection">[in] profile section to use for this command</param>
            <param name="pc">[in] profile context to use to get at value saved in the Rhino profile.</param>
            <remarks>
Most commands do not override LoadProfile.  Use LoadProfile
to get command options that persist between Rhino sessions.
The default does nothing.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoCommand.RunCommand(RMA.Rhino.IRhinoCommandContext)">
            <summary>Rhino calls this function to run the command.</summary>
            <returns>
success  command worked
cancel   user canceled command
nothing  command did nothing but cancel was not pressed.
failure  command failed (bad input, computational problem, etc.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoCommand.LocalCommandName">
            <summary>
Localized command name.  The default implementation
uses the command name string table to translate the
string returned by EnglishCommandName().
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoCommand.EnglishCommandName">
            <summary>Rhino default english command name</summary>
        </member>
        <member name="T:RMA.Rhino.MRhinoCommand">
            <summary>Every command is Rhino is defined by a class derived from CRhinoCommand.</summary>
        </member>
        <member name="T:RMA.Rhino.IRhinoCommand">
            <summary>Every command is Rhino is defined by a class derived from CRhinoCommand.</summary>
        </member>
        <member name="P:RMA.Rhino.MRhinoCommandContext.m_doc">
            <summary>Active document for this command.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoCommandContext.IsInteractive">
            <summary>Tests if the command is being run in interactive mode</summary>
            <returns>
true:
Command is running in interactive mode. Commands are allowed
to display dialog boxes for user input when running in interactive mode.

false:
Command is not running in interactive mode. Commands should
get user input using command-line options, and should never
display dialog boxes or other non-scriptable UI elements.
The user indicates non-interactive mode by preceeding the command
name with a "-" (eg. "-Layer") on the command line.
</returns>
        </member>
        <member name="P:RMA.Rhino.MRhinoCommandContext.m_style">
            <value>
m_style determines what kind of user interface (ui) the command
can use and how serious errors should be reported.

interative_ui:
 Can use dialogs for input.  Must use message boxes to report
 serious error conditions.

script_ui:
 All input must come from command line, GetPoint, GetObject,
 GetString, etc.  Must use message boxes to report serious
 error conditions.  Script mode gets used when a command is
 run with a hyphen (-) prefix.

batch_ui:
 All input must come from command line, GetPoint, GetObject,
 GetString, etc.  Must use RhinoApp().Print() to report serious
 error conditions.  NO dialog boxes are permitted.
 Batch mode is enabled by calling the Rhino BatchModeOn 
 command in a command script.
</value>
        </member>
        <member name="M:RMA.Rhino.IRhinoCommandContext.IsInteractive">
            <summary>Tests if the command is being run in interactive mode</summary>
            <returns>
true:
Command is running in interactive mode. Commands are allowed
to display dialog boxes for user input when running in interactive mode.

false:
Command is not running in interactive mode. Commands should
get user input using command-line options, and should never
display dialog boxes or other non-scriptable UI elements.
The user indicates non-interactive mode by preceeding the command
name with a "-" (eg. "-Layer") on the command line.
</returns>
        </member>
        <member name="P:RMA.Rhino.IRhinoCommandContext.m_doc">
            <summary>Active document for this command.</summary>
        </member>
        <member name="P:RMA.Rhino.IRhinoCommandContext.m_style">
            <value>
m_style determines what kind of user interface (ui) the command
can use and how serious errors should be reported.

interative_ui:
 Can use dialogs for input.  Must use message boxes to report
 serious error conditions.

script_ui:
 All input must come from command line, GetPoint, GetObject,
 GetString, etc.  Must use message boxes to report serious
 error conditions.  Script mode gets used when a command is
 run with a hyphen (-) prefix.

batch_ui:
 All input must come from command line, GetPoint, GetObject,
 GetString, etc.  Must use RhinoApp().Print() to report serious
 error conditions.  NO dialog boxes are permitted.
 Batch mode is enabled by calling the Rhino BatchModeOn 
 command in a command script.
</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppSettings.LocalizeColorList">
            <summary>
For internal use only.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppSettings.LockedObjectMaterial">
            <summary>
for RenderPreview
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppSettings.DisplayCurvesAndIsocurvesInRenderedViews(RMA.Rhino.IRhinoDoc)">
            <summary>
If GetRenderedViewSettingsFromDoc() returns true then values for the
following are returned from CRhinoDoc::Properties().RenderSettings()
otherwise they are returned from CRhinoDisplaySettings
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppSettings.DirectionArrowIconHeadSize">
            <summary>
Length of direction arrow icon head in pixels
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppSettings.DirectionArrowIconShaftSize">
            <summary>
Length of direction arrow icon shaft in pixels
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppSettings.WorldCoordIconMoveLabels">
            <summary>
If WorldCoordIconMoveLabels() returns true, the
world axes icon labels position themselves so that
the axes lines are not drawn on top of the
axes labels.  If false, the labels are always drawn
to the right of the ends of the axes.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppSettings.WorldCoordIconLabelSize">
            <summary>
radius of the axes labels in pixels
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppSettings.WorldCoordIconAxisSize">
            <summary>
length of the axes lines in pixels
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppSettings.SaveViewChanges">
            <summary>
true if changing a view should mark a document as modified
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppSettings.OsnapEnabled">
            <summary>
Returns:
 true if any osnaps are enabled.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppSettings.EnablePlanar">
            <summary>
Planar
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppSettings.EnablePlanar(System.Boolean)">
            <summary>
Planar
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppSettings.EnableOrtho">
            <summary>
Ortho
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppSettings.EnableOrtho(System.Boolean)">
            <summary>
Ortho
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppSettings.EnableGridSnap">
            <summary>
GridSnap
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppSettings.EnableGridSnap(System.Boolean)">
            <summary>
GridSnap
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppSettings.OsnapMode">
            <summary>
Returns:
 An unsigned int with CRhinoAppSettings::osnap_mode bits set
 if an osnap is enabled.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppSettings.LoadProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
load from registry
</summary>
        </member>
        <member name="T:RMA.Rhino.MRhinoAppSettings">
            <summary>
this class holds all the "app" settings that are stored
in the INI file/registry.  The interface to get/set these
values is in CRhinoApp;
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppSettings.LockedObjectMaterial">
            <summary>
for RenderPreview
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppSettings.DisplayCurvesAndIsocurvesInRenderedViews(RMA.Rhino.IRhinoDoc)">
            <summary>
If GetRenderedViewSettingsFromDoc() returns true then values for the
following are returned from CRhinoDoc::Properties().RenderSettings()
otherwise they are returned from CRhinoDisplaySettings
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppSettings.DirectionArrowIconHeadSize">
            <summary>
Length of direction arrow icon head in pixels
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppSettings.DirectionArrowIconShaftSize">
            <summary>
Length of direction arrow icon shaft in pixels
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppSettings.WorldCoordIconMoveLabels">
            <summary>
If WorldCoordIconMoveLabels() returns true, the
world axes icon labels position themselves so that
the axes lines are not drawn on top of the
axes labels.  If false, the labels are always drawn
to the right of the ends of the axes.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppSettings.WorldCoordIconLabelSize">
            <summary>
radius of the axes labels in pixels
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppSettings.WorldCoordIconAxisSize">
            <summary>
length of the axes lines in pixels
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppSettings.SaveViewChanges">
            <summary>
true if changing a view should mark a document as modified
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppSettings.OsnapEnabled">
            <returns>true if any osnaps are enabled.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppSettings.OsnapMode">
            <returns>
An unsigned int with CRhinoAppSettings::osnap_mode bits set
if an osnap is enabled.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="T:RMA.Rhino.IRhinoAppSettings">
            <summary>
this class holds all the "app" settings that are stored
in the INI file/registry.  The interface to get/set these
values is in CRhinoApp;
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppCursorToolTipSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppCursorToolTipSettings.LoadProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
load from registry
</summary>
        </member>
        <member name="T:RMA.Rhino.MRhinoAppCursorToolTipSettings">
            <summary>Cursor ToolTip settings</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppCursorToolTipSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="T:RMA.Rhino.IRhinoAppCursorToolTipSettings">
            <summary>Cursor ToolTip settings</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppSmartTrackSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppSmartTrackSettings.LoadProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
load from registry
</summary>
        </member>
        <member name="T:RMA.Rhino.MRhinoAppSmartTrackSettings">
            <summary>SmartTrack settings</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppSmartTrackSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="T:RMA.Rhino.IRhinoAppSmartTrackSettings">
            <summary>SmartTrack settings</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppChooseOneObjectSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppChooseOneObjectSettings.LoadProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
load from registry
</summary>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppChooseOneObjectSettings.m_bFollowCursor">
            <value>
Choose One Object dialog settings
</value>
        </member>
        <member name="T:RMA.Rhino.MRhinoAppChooseOneObjectSettings">
            <summary>Choose One Object dialog settings</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppChooseOneObjectSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="T:RMA.Rhino.IRhinoAppChooseOneObjectSettings">
            <summary>Choose One Object dialog settings</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppMouseSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppMouseSettings.LoadProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
load from registry
</summary>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppMouseSettings.m_bEnableUnselectedGripDrag">
            <value>
true if mouse can drag unselected grips
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppMouseSettings.m_bEnableSelectedGripDrag">
            <value>
true if mouse can drag selected grips
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppMouseSettings.m_bEnableUnselectedObjectDrag">
            <value>
true if mouse can drag unselected objects
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppMouseSettings.m_bEnableSelectedObjectDrag">
            <value>
true if mouse can drag selected objects
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppMouseSettings.m_mouse_move_object_tol">
            <value>
number of pixels the mouse must move to 
trigger an object drag event (&gt;=m_mouse_move_tol)
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppMouseSettings.m_mouse_move_grip_tol">
            <value>
number of pixels the mouse must move to 
trigger a control point drag (&gt;=m_mouse_move_tol)
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppMouseSettings.m_mouse_move_tol">
            <value>
number of pixels the mouse must move to 
trigger any mouse move UI event
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppMouseSettings.m_left_mouse_down_remap">
            <value>
mouse event remap
</value>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppMouseSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppMouseSettings.m_bEnableUnselectedGripDrag">
            <value>
true if mouse can drag unselected grips
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppMouseSettings.m_bEnableSelectedGripDrag">
            <value>
true if mouse can drag selected grips
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppMouseSettings.m_bEnableUnselectedObjectDrag">
            <value>
true if mouse can drag unselected objects
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppMouseSettings.m_bEnableSelectedObjectDrag">
            <value>
true if mouse can drag selected objects
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppMouseSettings.m_mouse_move_object_tol">
            <value>
number of pixels the mouse must move to 
trigger an object drag event (&gt;=m_mouse_move_tol)
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppMouseSettings.m_mouse_move_grip_tol">
            <value>
number of pixels the mouse must move to 
trigger a control point drag (&gt;=m_mouse_move_tol)
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppMouseSettings.m_mouse_move_tol">
            <value>
number of pixels the mouse must move to 
trigger any mouse move UI event
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppMouseSettings.m_left_mouse_down_remap">
            <value>
mouse event remap
</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppRenderMeshSettings.SetFastRenderMeshParameters(RMA.OpenNURBS.IOnMeshParameters)">
            <summary>
The fast render mesh parameters are used to create render meshes when the user
selects the "fast" button on the doc properties render mesh tab.
</summary>
            <param name="mp">[in] meshing parameters used to create "fast" render meshes.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppRenderMeshSettings.FastMeshParameters">
            <summary>
The fast render mesh parameters are used to create render meshes when the user
selects the "fast" button on the doc properties render mesh tab.
</summary>
            <returns>
Meshing parameters used to create "fast" render meshes.
See Also:
 CRhinoAppRenderMeshSettings::SetFastRenderMeshParameters
 CRhinoAppRenderMeshSettings::QualityMeshParameters
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppRenderMeshSettings.SetQualityRenderMeshParameters(RMA.OpenNURBS.IOnMeshParameters)">
            <summary>
The quality render mesh parameters are used to create render meshes when the user
selects the "quality" button on the doc properties render mesh tab.
</summary>
            <param name="mp">[in] meshing parameters used to create "quality" render meshes.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppRenderMeshSettings.QualityMeshParameters">
            <summary>
The quality render mesh parameters are used to create render meshes when the user
selects the "quality" button on the doc properties render mesh tab.
</summary>
            <returns>
Meshing parameters used to create "quality" render meshes.
See Also:
 CRhinoAppRenderMeshSettings::SetQualityRenderMeshParameters
 CRhinoAppRenderMeshSettings::FastMeshParameters
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppRenderMeshSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppRenderMeshSettings.LoadProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
load from registry
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppRenderMeshSettings.FastMeshParameters">
            <summary>
The fast render mesh parameters are used to create render meshes when the user
selects the "fast" button on the doc properties render mesh tab.
</summary>
            <returns>
Meshing parameters used to create "fast" render meshes.
See Also:
 CRhinoAppRenderMeshSettings::SetFastRenderMeshParameters
 CRhinoAppRenderMeshSettings::QualityMeshParameters
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppRenderMeshSettings.QualityMeshParameters">
            <summary>
The quality render mesh parameters are used to create render meshes when the user
selects the "quality" button on the doc properties render mesh tab.
</summary>
            <returns>
Meshing parameters used to create "quality" render meshes.
See Also:
 CRhinoAppRenderMeshSettings::SetQualityRenderMeshParameters
 CRhinoAppRenderMeshSettings::FastMeshParameters
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppRenderMeshSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppAliasList.AliasIndex(System.String)">
            <summary>
returns -1 if not found
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppAliasList.Alias(System.Int32)">
            <summary>
start at 0, return NULL when index is out of range
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppAliasList.ModifyAlias(System.Int32,System.String,System.String)">
            <summary>
already in the list.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppAliasList.AddAlias(System.String,System.String)">
            <summary>
return true if added, false if
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppAliasList.DestroyAliasList">
            <summary>
remove all aliases from the list
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppAliasList.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppAliasList.LoadProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
load from registry
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppAliasList.AliasIndex(System.String)">
            <summary>
returns -1 if not found
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppAliasList.Alias(System.Int32)">
            <summary>
start at 0, return NULL when index is out of range
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppAliasList.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppShortcutKeys.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppShortcutKeys.LoadProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
load from registry
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppShortcutKeys.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppViewSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppViewSettings.LoadProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
load from registry
</summary>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppViewSettings.m_single_click_maximize">
            <value>
viewport
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppViewSettings.m_defined_view_set_cplane">
            <value>
what happens when defined view are loaded
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppViewSettings.m_fast_regen_frames_per_second">
            <value>
must be a number &gt;= 0
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppViewSettings.m_rotate_to_view">
            <value>
false means around world axes
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppViewSettings.m_rotate_circle_increment">
            <value>
rotate
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppViewSettings.m_zoom_scale">
            <value>
zoom
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppViewSettings.m_pan_increment">
            <value>
pan
</value>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppViewSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppViewSettings.m_single_click_maximize">
            <value>
viewport
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppViewSettings.m_defined_view_set_cplane">
            <value>
what happens when defined view are loaded
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppViewSettings.m_fast_regen_frames_per_second">
            <value>
must be a number &gt;= 0
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppViewSettings.m_rotate_to_view">
            <value>
false means around world axes
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppViewSettings.m_rotate_circle_increment">
            <value>
rotate
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppViewSettings.m_zoom_scale">
            <value>
zoom
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppViewSettings.m_pan_increment">
            <value>
pan
</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppSpaceBallSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppSpaceBallSettings.LoadProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
load from registry
</summary>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppSpaceBallSettings.m_rotation_scale">
            <value>
spacemouse/spaceball settings
</value>
        </member>
        <member name="T:RMA.Rhino.MRhinoAppSpaceBallSettings">
            <summary>spacemouse/spaceball settings</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppSpaceBallSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="T:RMA.Rhino.IRhinoAppSpaceBallSettings">
            <summary>spacemouse/spaceball settings</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppModelAidSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppModelAidSettings.LoadProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
load from registry
</summary>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppModelAidSettings.m_uplane_mode">
            <value>
Universal construction plane mode
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppModelAidSettings.m_osnap_mode">
            <value>
bits set using osnap_mode enum
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppModelAidSettings.m_cursor_mode">
            <value>
See enum cursor_mode
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppModelAidSettings.m_suspend_osnap">
            <value>
osnap
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppModelAidSettings.m_display_control_polygon">
            <value>
control polygon display
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppModelAidSettings.m_nudge_mode">
            <value>
0 = world, 1 = cplane, 2 = view, 3 = uvn, -1 = not set
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppModelAidSettings.m_alt_plus_arrows">
            <value>
true mean Alt+arrow is used for nudging.
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppModelAidSettings.m_nudge_key_step">
            <value>
nudge steps in units
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppModelAidSettings.m_extend_trim_lines">
            <value>
trim / extend
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppModelAidSettings.m_osnap_pickbox_radius">
            <value>
object snaps
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppModelAidSettings.m_planar_on">
            <value>
planar mode
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppModelAidSettings.m_ortho_on">
            <value>
ortho
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppModelAidSettings.m_grid_snap_on">
            <value>
Grid snap
</value>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppModelAidSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppModelAidSettings.m_uplane_mode">
            <value>
Universal construction plane mode
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppModelAidSettings.m_osnap_mode">
            <value>
bits set using osnap_mode enum
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppModelAidSettings.m_cursor_mode">
            <value>
See enum cursor_mode
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppModelAidSettings.m_suspend_osnap">
            <value>
osnap
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppModelAidSettings.m_display_control_polygon">
            <value>
control polygon display
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppModelAidSettings.m_nudge_mode">
            <value>
0 = world, 1 = cplane, 2 = view, 3 = uvn, -1 = not set
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppModelAidSettings.m_alt_plus_arrows">
            <value>
true mean Alt+arrow is used for nudging.
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppModelAidSettings.m_nudge_key_step">
            <value>
nudge steps in units
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppModelAidSettings.m_extend_trim_lines">
            <value>
trim / extend
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppModelAidSettings.m_osnap_pickbox_radius">
            <value>
object snaps
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppModelAidSettings.m_planar_on">
            <value>
planar mode
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppModelAidSettings.m_ortho_on">
            <value>
ortho
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppModelAidSettings.m_grid_snap_on">
            <value>
Grid snap
</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppGridSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppGridSettings.LoadProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
load from registry
</summary>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppGridSettings.m_thin_line_color">
            <value>
grid colors
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppGridSettings.m_axis_line_width">
            <value>
1 or 2
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppGridSettings.m_thick_line_width">
            <value>
1 or 2
</value>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppGridSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppGridSettings.m_thin_line_color">
            <value>
grid colors
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppGridSettings.m_axis_line_width">
            <value>
1 or 2
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppGridSettings.m_thick_line_width">
            <value>
1 or 2
</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppGeneralSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppGeneralSettings.LoadProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
load from registry
</summary>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppGeneralSettings.m_bEnableParentLayerControl">
            <value>
If true, then parent layers control the visible
and locked modes of sublayers. Otherwise, layers
operate independently.
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppGeneralSettings.m_bAutoUpdateCommandContext">
            <value>
CommandContext dialog auto-update feature
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppGeneralSettings.m_bSplitCreasedSurfaces">
            <value>
If true, split surfaces are automatically split into
polysurfaces with smooth faces.
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppGeneralSettings.m_bShareMaterials">
            <value>
If true, objects that are copied from other objects
will get the same material index.  Otherwise the new
object gets an identical material with a unique 
material index.
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppGeneralSettings.m_bSaveUnreferencedMaterials">
            <value>
Material persistence
If true, the "Save" command will save every material
including the ones that are not used by any object
or layer.
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppGeneralSettings.m_context_menu_delay">
            <value>
number of milliseconds to wait before 
permitting context menu display
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppGeneralSettings.m_bEnableContextMenu">
            <value>
Right mouse button
True if right mouse down + delay will pop up
context menu on a mouse up if no move happens.
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppGeneralSettings.m_middle_mouse_mode">
            <value>
Middle mouse button
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppGeneralSettings.m_new_object_isoparm_count">
            <value>
Surface isoparm density
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppGeneralSettings.m_max_undo_memory_mb">
            <value>
in MB megabytes
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppGeneralSettings.m_min_undo_steps">
            <value>
Undo
 Undo records will be purged if 
 there are more than m_min_undo_steps 
   AND 
they use more than m_max_undo_memory_kb.
When the records are purged there will
always be at least m_min_undo_steps.
saved.
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppGeneralSettings.m_startup_commands">
            <value>
Commands
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppGeneralSettings.m_max_popup_menu_lines">
            <value>
Popup menu
</value>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppGeneralSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppGeneralSettings.m_bEnableParentLayerControl">
            <value>
If true, then parent layers control the visible
and locked modes of sublayers. Otherwise, layers
operate independently.
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppGeneralSettings.m_bAutoUpdateCommandContext">
            <value>
CommandContext dialog auto-update feature
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppGeneralSettings.m_bSplitCreasedSurfaces">
            <value>
If true, split surfaces are automatically split into
polysurfaces with smooth faces.
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppGeneralSettings.m_bShareMaterials">
            <value>
If true, objects that are copied from other objects
will get the same material index.  Otherwise the new
object gets an identical material with a unique 
material index.
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppGeneralSettings.m_bSaveUnreferencedMaterials">
            <value>
Material persistence
If true, the "Save" command will save every material
including the ones that are not used by any object
or layer.
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppGeneralSettings.m_context_menu_delay">
            <value>
number of milliseconds to wait before 
permitting context menu display
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppGeneralSettings.m_bEnableContextMenu">
            <value>
Right mouse button
True if right mouse down + delay will pop up
context menu on a mouse up if no move happens.
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppGeneralSettings.m_middle_mouse_mode">
            <value>
Middle mouse button
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppGeneralSettings.m_new_object_isoparm_count">
            <value>
Surface isoparm density
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppGeneralSettings.m_max_undo_memory_mb">
            <value>
in MB megabytes
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppGeneralSettings.m_min_undo_steps">
            <value>
Undo
 Undo records will be purged if 
 there are more than m_min_undo_steps 
   AND 
they use more than m_max_undo_memory_kb.
When the records are purged there will
always be at least m_min_undo_steps.
saved.
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppGeneralSettings.m_startup_commands">
            <value>
Commands
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppGeneralSettings.m_max_popup_menu_lines">
            <value>
Popup menu
</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppDontRepeatCommandSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppDontRepeatCommandSettings.LoadProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
load from registry
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppDontRepeatCommandSettings.GetDontRepeatList(System.String@)">
            <summary>Convert m_dont_repeat_list to space delited string</summary>
            <param name="list">[out] Receives delimited string</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppDontRepeatCommandSettings.SetDontRepeatList(System.String)">
            <summary>Parse input string and put command name tokens in m_dont_repeat_list.</summary>
            <param name="lps">
[in] String to parse. Will use " ", "," and ";" as delimiters.
</param>
            <returns>Number of items added to m_dont_repeat_list.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppDontRepeatCommandSettings.UseDontRepeatList">
            <summary>
Only use the m_dont_repeat_list if somebody modifies it via CRhinoAppSettings::SetDontRepeatCommands()
</summary>
            <returns>
A return value of true means CRhinoCommand don't repeat flags will be ignored
and the m_dont_repeat_list will be used instead.
False means the individual CRhinoCommands will determine if they are repeatable.
</returns>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppDontRepeatCommandSettings.m_dont_repeat_list">
            <value>
List of commands that will not repeat
</value>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppDontRepeatCommandSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppDontRepeatCommandSettings.GetDontRepeatList(System.String@)">
            <summary>Convert m_dont_repeat_list to space delited string</summary>
            <param name="list">[out] Receives delimited string</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppDontRepeatCommandSettings.UseDontRepeatList">
            <summary>
Only use the m_dont_repeat_list if somebody modifies it via CRhinoAppSettings::SetDontRepeatCommands()
</summary>
            <returns>
A return value of true means CRhinoCommand don't repeat flags will be ignored
and the m_dont_repeat_list will be used instead.
False means the individual CRhinoCommands will determine if they are repeatable.
</returns>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppDontRepeatCommandSettings.m_dont_repeat_list">
            <value>
List of commands that will not repeat
</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppFileSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppFileSettings.LoadProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
load from registry
</summary>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppFileSettings.m_copy_to_previous_rhino_version">
            <value>
Copy both objects to the clipboard in both the current and previous Rhino clipboard formats.  This
means you will double the size of what is saved in the clipboard but will be able to copy from 
the current to the previous version using the clipboard.
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppFileSettings.m_enable_file_locking_open_warning">
            <value>
Display information dialog which identifies computer file is open on
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppFileSettings.m_enable_file_locking">
            <value>
Ensure that only one person at a time can have a file open for saving
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppFileSettings.m_save_view_changes">
            <value>
true for users who consider view changes a document change
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppFileSettings.m_always_autosave_before_commands">
            <value>
List of commands that force AutoSave prior to running
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppFileSettings.m_autosave_increment">
            <value>
how many minutes between autosaves
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppFileSettings.m_autosave_meshes">
            <value>
save render and display meshes
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppFileSettings.m_autosave">
            <value>
enable autosave feature
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppFileSettings.m_autosave_file">
            <value>
name of the default autosave file (&lt;RhinoInstallFolder&gt;\Autosave.3dm)
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppFileSettings.m_default_template_file">
            <value>
template file loaded when Rhino starts and the default file name for OpenTemplateFile dialog
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppFileSettings.m_template_files">
            <value>
default template file folder (RhinoInstallFolder\Templates)
</value>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppFileSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppFileSettings.m_copy_to_previous_rhino_version">
            <value>
Copy both objects to the clipboard in both the current and previous Rhino clipboard formats.  This
means you will double the size of what is saved in the clipboard but will be able to copy from 
the current to the previous version using the clipboard.
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppFileSettings.m_enable_file_locking_open_warning">
            <value>
Display information dialog which identifies computer file is open on
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppFileSettings.m_enable_file_locking">
            <value>
Ensure that only one person at a time can have a file open for saving
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppFileSettings.m_save_view_changes">
            <value>
true for users who consider view changes a document change
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppFileSettings.m_always_autosave_before_commands">
            <value>
List of commands that force AutoSave prior to running
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppFileSettings.m_autosave_increment">
            <value>
how many minutes between autosaves
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppFileSettings.m_autosave_meshes">
            <value>
save render and display meshes
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppFileSettings.m_autosave">
            <value>
enable autosave feature
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppFileSettings.m_autosave_file">
            <value>
name of the default autosave file (&lt;RhinoInstallFolder&gt;\Autosave.3dm)
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppFileSettings.m_default_template_file">
            <value>
template file loaded when Rhino starts and the default file name for OpenTemplateFile dialog
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppFileSettings.m_template_files">
            <value>
default template file folder (RhinoInstallFolder\Templates)
</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppAppearanceSettings.LockedObjectColor">
            <summary>Get the color used to draw selected objects.</summary>
            <remarks>The default is yellow, but this can be customized by the user.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppAppearanceSettings.LockedObjectColor(System.Boolean)">
            <summary>Get the color used to draw selected objects.</summary>
            <param name="bIsReferenceObject">
[in] if true, the color used for selected reference model objects is returned.
</param>
            <remarks>The default is yellow, but this can be customized by the user.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppAppearanceSettings.ValidateFontSetting">
            <summary>
Makes sure the font is appropriate for the locale that is selected.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppAppearanceSettings.SelectedObjectColor">
            <summary>Get the color used to draw selected objects.</summary>
            <remarks>The default is yellow, but this can be customized by the user.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppAppearanceSettings.SelectedObjectColor(System.Boolean)">
            <summary>Get the color used to draw selected objects.</summary>
            <param name="bIsReferenceObject">
[in] if true, the color used for selected reference model objects is returned.
</param>
            <remarks>The default is yellow, but this can be customized by the user.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppAppearanceSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppAppearanceSettings.LoadProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
load from registry
</summary>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppAppearanceSettings.m_current_layer_bkcolor">
            <value>
This color is used by the layer manager dialog 
as the background color for the current layer.
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppAppearanceSettings.m_pageview_paper_color">
            <value>
CRhinoPageView paper background. A rectangle is drawn into the background
of page views to represent the printed area. The alpha portion of the color
is used to draw the paper blended into the background
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppAppearanceSettings.m_main_window_title">
            <value>
main frame window title
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppAppearanceSettings.m_show_viewport_title">
            <value>
viewport name in top left cornner
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppAppearanceSettings.m_crosshair_color">
            <value>
cross hair line color
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppAppearanceSettings.m_show_crosshairs">
            <value>
lines that extend across the view
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppAppearanceSettings.m_show_osnap_dialog">
            <value>
display persistant Osnaps dialog
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppAppearanceSettings.m_shaded_specular_intensity">
            <value>
Shaded viewport display settings
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppAppearanceSettings.m_cmdprompt_text_color">
            <value>
command prompt window colors
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppAppearanceSettings.m_frame_background_color">
            <value>
frame window color attributes
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppAppearanceSettings.m_viewport_background_color">
            <value>
view colors
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppAppearanceSettings.m_default_color">
            <value>
default object color
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppAppearanceSettings.m_tracking_color">
            <value>
object creation and modification colors
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppAppearanceSettings.m_bFlagTextOnTop">
            <value>
3d "flag" text (like the Dot command) can either be depth 
tested or shown on top. true means on top.
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppAppearanceSettings.m_direction_arrow_icon_head_size">
            <value>
length of direction arrowhead icon in pixels
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppAppearanceSettings.m_direction_arrow_icon_shaft_size">
            <value>
length of direction arrow shaft icon in pixels
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppAppearanceSettings.m_world_coord_icon_bMoveLabels">
            <value>
true to move axis letters as sprite rotates
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppAppearanceSettings.m_world_coord_icon_label_size">
            <value>
"radius" of letter in pixels
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppAppearanceSettings.m_world_coord_icon_axis_size">
            <value>
length of world coordinate sprite axis in pixels
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppAppearanceSettings.m_world_coord_icon_xaxis_color">
            <value>
ON_Color m_selected_grip_color;
world coordinate sprite axes attributes
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoAppAppearanceSettings.m_default_layer_color">
            <value>
default layer color
</value>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppAppearanceSettings.LockedObjectColor">
            <summary>Get the color used to draw selected objects.</summary>
            <remarks>The default is yellow, but this can be customized by the user.</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppAppearanceSettings.LockedObjectColor(System.Boolean)">
            <summary>Get the color used to draw selected objects.</summary>
            <param name="bIsReferenceObject">
[in] if true, the color used for selected reference model objects is returned.
</param>
            <remarks>The default is yellow, but this can be customized by the user.</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppAppearanceSettings.SelectedObjectColor">
            <summary>Get the color used to draw selected objects.</summary>
            <remarks>The default is yellow, but this can be customized by the user.</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppAppearanceSettings.SelectedObjectColor(System.Boolean)">
            <summary>Get the color used to draw selected objects.</summary>
            <param name="bIsReferenceObject">
[in] if true, the color used for selected reference model objects is returned.
</param>
            <remarks>The default is yellow, but this can be customized by the user.</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppAppearanceSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppAppearanceSettings.m_current_layer_bkcolor">
            <value>
This color is used by the layer manager dialog 
as the background color for the current layer.
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppAppearanceSettings.m_pageview_paper_color">
            <value>
CRhinoPageView paper background. A rectangle is drawn into the background
of page views to represent the printed area. The alpha portion of the color
is used to draw the paper blended into the background
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppAppearanceSettings.m_main_window_title">
            <value>
main frame window title
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppAppearanceSettings.m_show_viewport_title">
            <value>
viewport name in top left cornner
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppAppearanceSettings.m_crosshair_color">
            <value>
cross hair line color
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppAppearanceSettings.m_show_crosshairs">
            <value>
lines that extend across the view
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppAppearanceSettings.m_show_osnap_dialog">
            <value>
display persistant Osnaps dialog
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppAppearanceSettings.m_shaded_specular_intensity">
            <value>
Shaded viewport display settings
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppAppearanceSettings.m_cmdprompt_text_color">
            <value>
command prompt window colors
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppAppearanceSettings.m_frame_background_color">
            <value>
frame window color attributes
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppAppearanceSettings.m_viewport_background_color">
            <value>
view colors
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppAppearanceSettings.m_default_color">
            <value>
default object color
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppAppearanceSettings.m_tracking_color">
            <value>
object creation and modification colors
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppAppearanceSettings.m_bFlagTextOnTop">
            <value>
3d "flag" text (like the Dot command) can either be depth 
tested or shown on top. true means on top.
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppAppearanceSettings.m_direction_arrow_icon_head_size">
            <value>
length of direction arrowhead icon in pixels
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppAppearanceSettings.m_direction_arrow_icon_shaft_size">
            <value>
length of direction arrow shaft icon in pixels
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppAppearanceSettings.m_world_coord_icon_bMoveLabels">
            <value>
true to move axis letters as sprite rotates
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppAppearanceSettings.m_world_coord_icon_label_size">
            <value>
"radius" of letter in pixels
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppAppearanceSettings.m_world_coord_icon_axis_size">
            <value>
length of world coordinate sprite axis in pixels
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppAppearanceSettings.m_world_coord_icon_xaxis_color">
            <value>
ON_Color m_selected_grip_color;
world coordinate sprite axes attributes
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoAppAppearanceSettings.m_default_layer_color">
            <value>
default layer color
</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoOpenGLSettings.Validate">
            <summary>
clamp settings to valid values
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoOpenGLSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoOpenGLSettings.LoadProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
load from registry
</summary>
        </member>
        <member name="P:RMA.Rhino.MRhinoOpenGLSettings.m_bRegenBufferOnHardwareSwap">
            <value>
Some cards can't reproduce the backbuffer in certain situations.
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoOpenGLSettings.m_bUseHardwareDriverModes">
            <value>
Try to use non-generic modes...
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoOpenGLSettings.m_nDefaultTexturingMode">
            <value>
Texture filtering modes?? maybe not needed...
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoOpenGLSettings.m_bUseDriverModeEmap">
            <value>
Let the driver do emap, or do it the hard way...
</value>
        </member>
        <member name="M:RMA.Rhino.IRhinoOpenGLSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="P:RMA.Rhino.IRhinoOpenGLSettings.m_bRegenBufferOnHardwareSwap">
            <value>
Some cards can't reproduce the backbuffer in certain situations.
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoOpenGLSettings.m_bUseHardwareDriverModes">
            <value>
Try to use non-generic modes...
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoOpenGLSettings.m_nDefaultTexturingMode">
            <value>
Texture filtering modes?? maybe not needed...
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoOpenGLSettings.m_bUseDriverModeEmap">
            <value>
Let the driver do emap, or do it the hard way...
</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoAdvDisplaySettings.Validate">
            <summary>
clamp settings to valid values
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAdvDisplaySettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAdvDisplaySettings.LoadProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
load from registry
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAdvDisplaySettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplaySettings.Validate">
            <summary>
clamp settings to valid values
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplaySettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDisplaySettings.LoadProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
load from registry
</summary>
        </member>
        <member name="P:RMA.Rhino.MRhinoDisplaySettings.m_nShadedObjectGloss">
            <value>
0..100
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoDisplaySettings.m_nGhostedShadeTransparency">
            <value>
Transparency percentage for GhostedShade mode 0..100
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoDisplaySettings.m_wire_display_engine">
            <value>
Default display engine for new viewports.
</value>
        </member>
        <member name="M:RMA.Rhino.IRhinoDisplaySettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="P:RMA.Rhino.IRhinoDisplaySettings.m_nShadedObjectGloss">
            <value>
0..100
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoDisplaySettings.m_nGhostedShadeTransparency">
            <value>
Transparency percentage for GhostedShade mode 0..100
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoDisplaySettings.m_wire_display_engine">
            <value>
Default display engine for new viewports.
</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoEdgeAnalysisSettings.Validate">
            <summary>
clamp settings to valid values
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoEdgeAnalysisSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoEdgeAnalysisSettings.LoadProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
load from registry
</summary>
        </member>
        <member name="P:RMA.Rhino.MRhinoEdgeAnalysisSettings.m_show_edges">
            <value>
0 = all, 1 = naked
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoEdgeAnalysisSettings.m_show_edge_color">
            <value>
color used to enhance display edges in commands like ShowEdges
and ShowNakedEdges.
</value>
        </member>
        <member name="M:RMA.Rhino.IRhinoEdgeAnalysisSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="P:RMA.Rhino.IRhinoEdgeAnalysisSettings.m_show_edges">
            <value>
0 = all, 1 = naked
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoEdgeAnalysisSettings.m_show_edge_color">
            <value>
color used to enhance display edges in commands like ShowEdges
and ShowNakedEdges.
</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoDraftAngleAnalysisSettings.Validate">
            <summary>
clamp settings to valid values
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDraftAngleAnalysisSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDraftAngleAnalysisSettings.LoadProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
load from registry
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDraftAngleAnalysisSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoCurvatureAnalysisSettings.Validate">
            <summary>
clamp settings to valid values
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoCurvatureAnalysisSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoCurvatureAnalysisSettings.LoadProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
load from registry
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoCurvatureAnalysisSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoEmapAnalysisSettings.MruRemoveFileName(System.Int32)">
            <summary>Remove MRU file name at specified index.</summary>
            <param name="index">[in] Index of name to remove from list.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoEmapAnalysisSettings.MruFileName(System.Int32)">
            <summary>Get MRU file name at specified index.</summary>
            <param name="index">[in] Index of name to return, 0 for oldest, MruFleNameCount()-1 for current.</param>
            <returns>If index is valid then a pointer to the name is returned otherwise NULL.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoEmapAnalysisSettings.MruFileNameCount">
            <summary>
Get number of items in most recently used(MRU) file name list.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoEmapAnalysisSettings.SetFileName(System.String)">
            <summary>Set file name.</summary>
            <param name="name">
[in] Name to make current. The previous name
will get moved down the MRU file name list.
</param>
            <returns>If name added successfully true is returned otherwise false.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoEmapAnalysisSettings.FileName">
            <summary>
Return file name to be maped to objects
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoEmapAnalysisSettings.Validate">
            <summary>
clamp settings to valid values
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoEmapAnalysisSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoEmapAnalysisSettings.LoadProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
load from registry
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoEmapAnalysisSettings.MruFileName(System.Int32)">
            <summary>Get MRU file name at specified index.</summary>
            <param name="index">[in] Index of name to return, 0 for oldest, MruFleNameCount()-1 for current.</param>
            <returns>If index is valid then a pointer to the name is returned otherwise NULL.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoEmapAnalysisSettings.MruFileNameCount">
            <summary>
Get number of items in most recently used(MRU) file name list.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoEmapAnalysisSettings.FileName">
            <summary>
Return file name to be maped to objects
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoEmapAnalysisSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoZebraAnalysisSettings.Validate">
            <summary>
clamp settings to valid values
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoZebraAnalysisSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoZebraAnalysisSettings.LoadProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
load from registry
</summary>
        </member>
        <member name="P:RMA.Rhino.MRhinoZebraAnalysisSettings.m_stripe_thickness">
            <value>
0 = thinnest ... 6 = thickest
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoZebraAnalysisSettings.m_stripe_direction">
            <value>
0 = horizontal, 1 = vertical
</value>
        </member>
        <member name="M:RMA.Rhino.IRhinoZebraAnalysisSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="P:RMA.Rhino.IRhinoZebraAnalysisSettings.m_stripe_thickness">
            <value>
0 = thinnest ... 6 = thickest
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoZebraAnalysisSettings.m_stripe_direction">
            <value>
0 = horizontal, 1 = vertical
</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoCurvatureGraphSettings.Validate">
            <summary>
clamp settings to valid values
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoCurvatureGraphSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoCurvatureGraphSettings.LoadProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
load from registry
</summary>
        </member>
        <member name="P:RMA.Rhino.MRhinoCurvatureGraphSettings.m_sample_density">
            <value>
between 1 and 10.  Higher numbers draw smoother outer curves.
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoCurvatureGraphSettings.m_hair_density">
            <value>
&gt;= 0 larger numbers = more hairs
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoCurvatureGraphSettings.m_hair_scale">
            <value>
100 = true length, &gt; 100 magnified, &lt; 100 shortened
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoCurvatureGraphSettings.m_bSrfvHair">
            <value>
true if surface v isocurve hair is on
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoCurvatureGraphSettings.m_bSrfuHair">
            <value>
true if surface u isocurve hair is on
</value>
        </member>
        <member name="T:RMA.Rhino.MRhinoCurvatureGraphSettings">
            <summary>
When curves, surfaces, and polysurfaces have their
curvature graph turned on, these settings control
the appearance of the curvature graph.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoCurvatureGraphSettings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="P:RMA.Rhino.IRhinoCurvatureGraphSettings.m_sample_density">
            <value>
between 1 and 10.  Higher numbers draw smoother outer curves.
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoCurvatureGraphSettings.m_hair_density">
            <value>
&gt;= 0 larger numbers = more hairs
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoCurvatureGraphSettings.m_hair_scale">
            <value>
100 = true length, &gt; 100 magnified, &lt; 100 shortened
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoCurvatureGraphSettings.m_bSrfvHair">
            <value>
true if surface v isocurve hair is on
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoCurvatureGraphSettings.m_bSrfuHair">
            <value>
true if surface u isocurve hair is on
</value>
        </member>
        <member name="T:RMA.Rhino.IRhinoCurvatureGraphSettings">
            <summary>
When curves, surfaces, and polysurfaces have their
curvature graph turned on, these settings control
the appearance of the curvature graph.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppWarnings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppWarnings.LoadProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
load from registry
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppWarnings.PrintWarning(RMA.Rhino.IRhinoAppWarnings.warning)">
            <summary>Display warning message in dialog and/or command history window (RhinoApp().Print()).</summary>
            <param name="id">[in] Type of warning message to display.</param>
            <returns>true if id is in range otherwise returns false.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppWarnings.WarningDialog(RMA.Rhino.IRhinoAppWarnings.warning)">
            <summary>Display warning message in dialog and/or command history window (RhinoApp().Print()).</summary>
            <param name="id">[in] Type of warning message to display.</param>
            <returns>true if id is in range otherwise returns false.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppWarnings.WarningDialog(RMA.Rhino.IRhinoAppWarnings.warning,System.Windows.Forms.IWin32Window)">
            <summary>Display warning message in dialog and/or command history window (RhinoApp().Print()).</summary>
            <param name="id">[in] Type of warning message to display.</param>
            <param name="hWndParent">
[in] Will be the parent window for the warning message dialog, if NULL
uses main Rhino window handle.
</param>
            <returns>true if id is in range otherwise returns false.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppWarnings.DisplayWarning(RMA.Rhino.IRhinoAppWarnings.warning)">
            <summary>Display warning message in dialog and/or command history window (RhinoApp().Print()).</summary>
            <param name="id">[in] - Type of warning message to display.</param>
            <returns>true if id is in range otherwise returns false.</returns>
            <remarks>Will return true but do nothing if WarningEnabled( id) returns false.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppWarnings.DisplayWarning(RMA.Rhino.IRhinoAppWarnings.warning,System.Boolean)">
            <summary>Display warning message in dialog and/or command history window (RhinoApp().Print()).</summary>
            <param name="id">[in] - Type of warning message to display.</param>
            <param name="bInDialog">
[in] - If true then dialog is displayed with check box that says don't display this message again.
</param>
            <returns>true if id is in range otherwise returns false.</returns>
            <remarks>Will return true but do nothing if WarningEnabled( id) returns false.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppWarnings.DisplayWarning(RMA.Rhino.IRhinoAppWarnings.warning,System.Boolean,System.Windows.Forms.IWin32Window)">
            <summary>Display warning message in dialog and/or command history window (RhinoApp().Print()).</summary>
            <param name="id">[in] - Type of warning message to display.</param>
            <param name="bInDialog">
[in] - If true then dialog is displayed with check box that says don't display this message again.
</param>
            <param name="hWndParent">
[in] Only used if bInDialog is true.  Will be the parent window for the
warning message dialog, if NULL uses main Rhino window handle.
</param>
            <returns>true if id is in range otherwise returns false.</returns>
            <remarks>Will return true but do nothing if WarningEnabled( id) returns false.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppWarnings.DisplayWarning(RMA.Rhino.IRhinoAppWarnings.warning,System.Boolean,System.Windows.Forms.IWin32Window,System.Boolean)">
            <summary>Display warning message in dialog and/or command history window (RhinoApp().Print()).</summary>
            <param name="id">[in] - Type of warning message to display.</param>
            <param name="bInDialog">
[in] - If true then dialog is displayed with check box that says don't display this message again.
</param>
            <param name="hWndParent">
[in] Only used if bInDialog is true.  Will be the parent window for the
warning message dialog, if NULL uses main Rhino window handle.
</param>
            <param name="bPrint">[in] - If true then message is displayed using RhinoApp().Print()</param>
            <returns>true if id is in range otherwise returns false.</returns>
            <remarks>Will return true but do nothing if WarningEnabled( id) returns false.</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppWarnings.EnableWarning(RMA.Rhino.IRhinoAppWarnings.warning,System.Boolean)">
            <summary>Enable or disable specified warning message</summary>
            <param name="id">[in] - Warning type to enable/dissable.</param>
            <param name="enable">[in] - Warning enabled if true, dissabled if false.</param>
            <returns>Previous enable warning state.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppWarnings.WarningEnabled(RMA.Rhino.IRhinoAppWarnings.warning)">
            <summary>Check to see if warning should be displayed.</summary>
            <param name="id">[in] - Warning type.</param>
            <returns>
true if warning should be displayed otherwise false.  Called by
DisplayWarning, WarningDialog and PrintWarning to determine if
message should be displayed.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppWarnings.Warning(RMA.Rhino.IRhinoAppWarnings.warning)">
            <summary>Get display stirng for specified warning</summary>
            <param name="id">[in] - Warning type</param>
            <returns>String to display if id is valid otherwise NULL</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoAppWarnings.Warning(RMA.Rhino.IRhinoAppWarnings.warning,System.Boolean)">
            <summary>Get display stirng for specified warning</summary>
            <param name="id">[in] - Warning type</param>
            <param name="format_for_print">
[in] - If true then returns single line suitable for use with
CRhinoApp().Print() otherwise returns string which may contain
'\n' chars for use in a multi-line text control
</param>
            <returns>String to display if id is valid otherwise NULL</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppWarnings.SaveProfile(RMA.Rhino.MRhinoProfileContext@)">
            <summary>
save in registry
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppWarnings.PrintWarning(RMA.Rhino.IRhinoAppWarnings.warning)">
            <summary>Display warning message in dialog and/or command history window (RhinoApp().Print()).</summary>
            <param name="id">[in] Type of warning message to display.</param>
            <returns>true if id is in range otherwise returns false.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppWarnings.WarningDialog(RMA.Rhino.IRhinoAppWarnings.warning)">
            <summary>Display warning message in dialog and/or command history window (RhinoApp().Print()).</summary>
            <param name="id">[in] Type of warning message to display.</param>
            <returns>true if id is in range otherwise returns false.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppWarnings.WarningDialog(RMA.Rhino.IRhinoAppWarnings.warning,System.Windows.Forms.IWin32Window)">
            <summary>Display warning message in dialog and/or command history window (RhinoApp().Print()).</summary>
            <param name="id">[in] Type of warning message to display.</param>
            <param name="hWndParent">
[in] Will be the parent window for the warning message dialog, if NULL
uses main Rhino window handle.
</param>
            <returns>true if id is in range otherwise returns false.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppWarnings.DisplayWarning(RMA.Rhino.IRhinoAppWarnings.warning)">
            <summary>Display warning message in dialog and/or command history window (RhinoApp().Print()).</summary>
            <param name="id">[in] - Type of warning message to display.</param>
            <returns>true if id is in range otherwise returns false.</returns>
            <remarks>Will return true but do nothing if WarningEnabled( id) returns false.</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppWarnings.DisplayWarning(RMA.Rhino.IRhinoAppWarnings.warning,System.Boolean)">
            <summary>Display warning message in dialog and/or command history window (RhinoApp().Print()).</summary>
            <param name="id">[in] - Type of warning message to display.</param>
            <param name="bInDialog">
[in] - If true then dialog is displayed with check box that says don't display this message again.
</param>
            <returns>true if id is in range otherwise returns false.</returns>
            <remarks>Will return true but do nothing if WarningEnabled( id) returns false.</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppWarnings.DisplayWarning(RMA.Rhino.IRhinoAppWarnings.warning,System.Boolean,System.Windows.Forms.IWin32Window)">
            <summary>Display warning message in dialog and/or command history window (RhinoApp().Print()).</summary>
            <param name="id">[in] - Type of warning message to display.</param>
            <param name="bInDialog">
[in] - If true then dialog is displayed with check box that says don't display this message again.
</param>
            <param name="hWndParent">
[in] Only used if bInDialog is true.  Will be the parent window for the
warning message dialog, if NULL uses main Rhino window handle.
</param>
            <returns>true if id is in range otherwise returns false.</returns>
            <remarks>Will return true but do nothing if WarningEnabled( id) returns false.</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppWarnings.DisplayWarning(RMA.Rhino.IRhinoAppWarnings.warning,System.Boolean,System.Windows.Forms.IWin32Window,System.Boolean)">
            <summary>Display warning message in dialog and/or command history window (RhinoApp().Print()).</summary>
            <param name="id">[in] - Type of warning message to display.</param>
            <param name="bInDialog">
[in] - If true then dialog is displayed with check box that says don't display this message again.
</param>
            <param name="hWndParent">
[in] Only used if bInDialog is true.  Will be the parent window for the
warning message dialog, if NULL uses main Rhino window handle.
</param>
            <param name="bPrint">[in] - If true then message is displayed using RhinoApp().Print()</param>
            <returns>true if id is in range otherwise returns false.</returns>
            <remarks>Will return true but do nothing if WarningEnabled( id) returns false.</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppWarnings.WarningEnabled(RMA.Rhino.IRhinoAppWarnings.warning)">
            <summary>Check to see if warning should be displayed.</summary>
            <param name="id">[in] - Warning type.</param>
            <returns>
true if warning should be displayed otherwise false.  Called by
DisplayWarning, WarningDialog and PrintWarning to determine if
message should be displayed.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppWarnings.Warning(RMA.Rhino.IRhinoAppWarnings.warning)">
            <summary>Get display stirng for specified warning</summary>
            <param name="id">[in] - Warning type</param>
            <returns>String to display if id is valid otherwise NULL</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoAppWarnings.Warning(RMA.Rhino.IRhinoAppWarnings.warning,System.Boolean)">
            <summary>Get display stirng for specified warning</summary>
            <param name="id">[in] - Warning type</param>
            <param name="format_for_print">
[in] - If true then returns single line suitable for use with
CRhinoApp().Print() otherwise returns string which may contain
'\n' chars for use in a multi-line text control
</param>
            <returns>String to display if id is valid otherwise NULL</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoIniProfileContext.IniFileName">
            <summary>
-----------------------------------------------------------------------------------------------
Local public methods
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoIniProfileContext.IniFileName">
            <summary>
-----------------------------------------------------------------------------------------------
Local public methods
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoProfileContext.SaveProfileRGBA(System.String,System.String,RMA.OpenNURBS.IOnColor)">
            <summary>
The LoadProfileColor/SaveProfileColor functions ignore aplha. If you want to save a
color with alpha information, use the following RGBA functions
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoProfileContext.SaveProfileUuid(System.String,System.String,System.Guid)">
            <summary>
The default implimentation does nothing, CRhinoRegProfileContext is the only class that current
implimentes these.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoProfileContext.LoadProfileString(System.String,System.String,System.String@)">
            <summary>
The default implimentation of these do nothing.  CRhinoRegProfileContext is the only class that current
implimentes these as registry multi-strings.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoProfileContext.SaveProfileString(System.String,System.String,System.String)">
            <summary>
This method must be overriden to provide a CRhinoProfileContextIterator which is
responsible for iterating section names and values associated with this profile
context.  The overriden method need to derive a class from CRhinoProfileContextIterator,
and return a new pointer to the derived class.  It is the responsibility of the calling
function to delete the returned pointer.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoProfileContext.SaveProfileRGBA(System.String,System.String,RMA.OpenNURBS.IOnColor)">
            <summary>
The LoadProfileColor/SaveProfileColor functions ignore aplha. If you want to save a
color with alpha information, use the following RGBA functions
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoProfileContext.SaveProfileUuid(System.String,System.String,System.Guid)">
            <summary>
The default implimentation does nothing, CRhinoRegProfileContext is the only class that current
implimentes these.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoProfileContext.LoadProfileString(System.String,System.String,System.String@)">
            <summary>
The default implimentation of these do nothing.  CRhinoRegProfileContext is the only class that current
implimentes these as registry multi-strings.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoFontTable.GetSortedList(RMA.Rhino.IRhinoFont[]@)">
            <summary>
Gets an array of pointers to fonts that is sorted by
the values of CRhinoFont::m_sort_index.
</summary>
            <param name="sorted_list">
[out] this array is returned with length FontCount() and is sorted by the values of CRhinoLayer::m_sort_index.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoFontTable.GetSortedList(RMA.Rhino.IRhinoFont[]@,System.Boolean)">
            <summary>
Gets an array of pointers to fonts that is sorted by
the values of CRhinoFont::m_sort_index.
</summary>
            <param name="sorted_list">
[out] this array is returned with length FontCount() and is sorted by the values of CRhinoLayer::m_sort_index.
</param>
            <param name="bIgnoreDeleted">[in] true means don't include deleted fonts.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoFontTable.UndeleteFont(System.Int32)">
            <summary>Undeletes a font that has been deleted by DeleteFont().</summary>
            <param name="font_index">
[in] zero based index of tyle to undelete.
This must be in the range 0 &lt;= font_index &lt; FontCount().
</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoFontTable.DeleteFonts(RMA.OpenNURBS.Arrayint,System.Boolean)">
            <summary>Deletes multiple fonts</summary>
            <param name="font_index">
[in] array zero based indices of fonts to delete.
The indices must be in the range 0 &lt;= font_index &lt; FontCount().
</param>
            <param name="bQuiet">
[in] If true, no warning message box appears if a font cannot be
deleted because it is the current font or it contains active geometry.
</param>
            <returns>
true if successful. false if font_index is out of range or the
the font cannot be deleted because it is the current font or
because there is geometry referencing this font.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoFontTable.DeleteFont(System.Int32,System.Boolean)">
            <summary>Deletes font</summary>
            <param name="font_index">
[in] zero based index of font to delete.
This must be in the range 0 &lt;= font_index &lt; FontCount().
</param>
            <param name="bQuiet">
[in] If true, no warning message box appears if a layer
the font cannot be deleted because it is the current font
or it contains active geometry.
</param>
            <returns>
true if successful. false if font_index is out of range or the
the font cannot be deleted because it is the current font or
because it font contains active geometry.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoFontTable.UndoModifyFont(System.Int32)">
            <summary>
If the font has been modified and the modification can be undone, then
UndoModifyFont() will restore the font to its previous state.
</summary>
            <returns>
True if this font had been modified and the modifications were undone.
See Also: CRhinoFont::IsModified.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoFontTable.UndoModifyFont(System.Int32,System.UInt32)">
            <summary>
If the font has been modified and the modification can be undone, then
UndoModifyFont() will restore the font to its previous state.
</summary>
            <returns>
True if this font had been modified and the modifications were undone.
See Also: CRhinoFont::IsModified.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoFontTable.ModifyFont(RMA.OpenNURBS.IOnFont,System.Int32)">
            <summary>Modify font settings</summary>
            <param name="font">[in] new settings.  This information is copied.</param>
            <param name="font_index">
[in] zero based index of font to set. This must be in the range 0 &lt;= font_index &lt; FontCount().
</param>
            <returns>true if successful. false if font_index is out of range.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoFontTable.ModifyFont(RMA.OpenNURBS.IOnFont,System.Int32,System.Boolean)">
            <summary>Modify font settings</summary>
            <param name="font">[in] new settings.  This information is copied.</param>
            <param name="font_index">
[in] zero based index of font to set. This must be in the range 0 &lt;= font_index &lt; FontCount().
</param>
            <param name="bQuiet">
[in] if true, information message boxes pop up when illegal changes are attempted.
</param>
            <returns>true if successful. false if font_index is out of range.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoFontTable.AddFont(RMA.OpenNURBS.IOnFont,System.Boolean)">
            <summary>Adds a new font with specified definition to the font table.</summary>
            <param name="font">
[in] definition of new font. The information in font is copied.
If font.Name() is empty the a unique name of the form "Font 01"
will be automatically created.
</param>
            <param name="bReference">
[in] true if this layer is a reference font. Reference fonts are not saved in files.
</param>
            <returns>
&gt;=0     index of new font
-1      font not added because a font with that name already exists.
</returns>
            <remarks>
In some cases, calling AddFont() can cause the memory 
references previously returned by operator[] and 
CurrentFont() to become invalid.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoFontTable.AddFont(System.Boolean)">
            <summary>Adds a new font with default definition to the font table.</summary>
            <param name="bReference">
[in] true if this font is a reference font. Reference fonts are not saved in files.
</param>
            <returns>index of new font</returns>
            <remarks>
In some cases, calling AddFont() can cause the memory 
references previously returned by operator[] and 
CurrentFont() to become invalid.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoFontTable.GetUnusedFontName(System.String@)">
            <summary>Gets unsed font name used as default when creating new fonts</summary>
            <param name="result">[out] this is the wString which receives new name</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoFontTable.FindOrCreateFont(System.String@)">
            <summary>Finds the font with a given face name and bold and/or italic as specified</summary>
            <param name="facename">[in] name of font face to search for.  The search ignores case.</param>
            <returns>
&gt;=0     index of the font with the given characteristics
-1      couldn't find or make the font
</returns>
            <remarks>
If the font is found, its index is returned
If the matching font is deleted, it is undeleted.
If the font isn't found, one is made and added to the table
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoFontTable.FindOrCreateFont(System.String@,System.Boolean)">
            <summary>Finds the font with a given face name and bold and/or italic as specified</summary>
            <param name="facename">[in] name of font face to search for.  The search ignores case.</param>
            <param name="bBold">[in] true if the font is bold</param>
            <returns>
&gt;=0     index of the font with the given characteristics
-1      couldn't find or make the font
</returns>
            <remarks>
If the font is found, its index is returned
If the matching font is deleted, it is undeleted.
If the font isn't found, one is made and added to the table
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoFontTable.FindOrCreateFont(System.String@,System.Boolean,System.Boolean)">
            <summary>
Description:
 Finds the font with a given face name and bold and/or italic as specified
Parameters:
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoFontTable.FindFont(System.String)">
            <summary>Finds the font with a given name.</summary>
            <param name="name">[in] name of font to search for. The search ignores case.</param>
            <returns>
&gt;=0     index of the font with the given name
-1      no font has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoFontTable.FindFont(System.String,System.Boolean)">
            <summary>Finds the font with a given name.</summary>
            <param name="name">[in] name of font to search for. The search ignores case.</param>
            <param name="bIgnoreDeletedFonts">[in] true means don't search deleted fonts.</param>
            <returns>
&gt;=0     index of the font with the given name
-1      no font has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoFontTable.CurrentFontIndex">
            <summary>
At all times, there is a "current" font. Unless otherwise
specified, new dimension objects are assigned to the current font.
The current font is never deleted.
</summary>
            <returns>Zero based font index of the current font.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoFontTable.CurrentFont">
            <summary>
At all times, there is a "current" font.  Unless otherwise
specified, new dimension objects are assigned the current font.
The current font is never deleted.
</summary>
            <returns>
Reference to the current font.  Note that this reference
may become invalid after a call to AddFont().
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoFontTable.SetCurrentFontIndex(System.Int32)">
            <summary>
At all times, there is a "current" font.  Unless otherwise
specified, new dim objects are assigned to the current font.
The current font is never deleted.
</summary>
            <param name="font_index">
[in] value for new current font. 0 &lt;= font_index &lt; FontCount().
</param>
            <returns>true if current font index successfully set.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoFontTable.SetCurrentFontIndex(System.Int32,System.Boolean)">
            <summary>
At all times, there is a "current" font.  Unless otherwise
specified, new dim objects are assigned to the current font.
The current font is never deleted.
</summary>
            <param name="font_index">
[in] value for new current font. 0 &lt;= font_index &lt; FontCount().
</param>
            <param name="bQuiet">
[in] if true, then no warning message box  pops up if the
current font request can't be satisfied.
</param>
            <returns>true if current font index successfully set.</returns>
        </member>
        <member name="P:RMA.Rhino.MRhinoFontTable.Item(System.Int32)">
            <summary>
Conceptually, the font table is an array of StyleCount()
fonts.  The operator[] can be used to get individual
fonts.  A font is either active or deleted and this
state is reported by CRhinoFont::IsDeleted().
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoFontTable.FontCount">
            <returns>Number of styles in the font table, including deleted styles.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoFontTable.GetDefaultFontProperties(RMA.OpenNURBS.OnFont@)">
            <summary>Initializes an CRhinoFont with the current default dimension font properties.</summary>
            <param name="font">[out] properties returned here</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoFontTable.GetSortedList(RMA.Rhino.IRhinoFont[]@)">
            <summary>
Gets an array of pointers to fonts that is sorted by
the values of CRhinoFont::m_sort_index.
</summary>
            <param name="sorted_list">
[out] this array is returned with length FontCount() and is sorted by the values of CRhinoLayer::m_sort_index.
</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoFontTable.GetSortedList(RMA.Rhino.IRhinoFont[]@,System.Boolean)">
            <summary>
Gets an array of pointers to fonts that is sorted by
the values of CRhinoFont::m_sort_index.
</summary>
            <param name="sorted_list">
[out] this array is returned with length FontCount() and is sorted by the values of CRhinoLayer::m_sort_index.
</param>
            <param name="bIgnoreDeleted">[in] true means don't include deleted fonts.</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoFontTable.GetUnusedFontName(System.String@)">
            <summary>Gets unsed font name used as default when creating new fonts</summary>
            <param name="result">[out] this is the wString which receives new name</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoFontTable.FindFont(System.String)">
            <summary>Finds the font with a given name.</summary>
            <param name="name">[in] name of font to search for. The search ignores case.</param>
            <returns>
&gt;=0     index of the font with the given name
-1      no font has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoFontTable.FindFont(System.String,System.Boolean)">
            <summary>Finds the font with a given name.</summary>
            <param name="name">[in] name of font to search for. The search ignores case.</param>
            <param name="bIgnoreDeletedFonts">[in] true means don't search deleted fonts.</param>
            <returns>
&gt;=0     index of the font with the given name
-1      no font has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoFontTable.CurrentFontIndex">
            <summary>
At all times, there is a "current" font. Unless otherwise
specified, new dimension objects are assigned to the current font.
The current font is never deleted.
</summary>
            <returns>Zero based font index of the current font.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoFontTable.CurrentFont">
            <summary>
At all times, there is a "current" font.  Unless otherwise
specified, new dimension objects are assigned the current font.
The current font is never deleted.
</summary>
            <returns>
Reference to the current font.  Note that this reference
may become invalid after a call to AddFont().
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoFontTable.FontCount">
            <returns>Number of styles in the font table, including deleted styles.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoFontTable.GetDefaultFontProperties(RMA.OpenNURBS.OnFont@)">
            <summary>Initializes an CRhinoFont with the current default dimension font properties.</summary>
            <param name="font">[out] properties returned here</param>
        </member>
        <member name="P:RMA.Rhino.IRhinoFontTable.Item(System.Int32)">
            <summary>
Conceptually, the font table is an array of StyleCount()
fonts.  The operator[] can be used to get individual
fonts.  A font is either active or deleted and this
state is reported by CRhinoFont::IsDeleted().
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoFont.HeightAdjustment">
            <summary>
HeightAdjustment includes the scaling from normal height 
to ECS height and the ratio between height of 'H' and 
</summary>
            <returns>1.0/HeightOfI()</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoFont.NormalLinefeed">
            <summary>
Ratio of linefeed to character height
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoFont.NormalFontHeight">
            <summary>
Height to use for the default Rhino system font
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoFont.DefaultFaceName">
            <summary>
Font facename to use for the default Rhino system font
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoFont.DefaultName">
            <summary>
Name to use for the default Rhino system font
</summary>
        </member>
        <member name="P:RMA.Rhino.MRhinoFont.m_remap_index">
            <value>
m_remap_index is used for font index remapping during
I/O operations. It is a runtime variable and should be
ignored by everything except CRhinoDoc::Read3DM() and
CRhinoDoc::Write3DM().
</value>
        </member>
        <member name="T:RMA.Rhino.MRhinoFont">
            <summary>a text style to be stored in a Rhino table</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoFont.HeightAdjustment">
            <summary>
HeightAdjustment includes the scaling from normal height 
to ECS height and the ratio between height of 'H' and 
</summary>
            <returns>1.0/HeightOfI()</returns>
        </member>
        <member name="P:RMA.Rhino.IRhinoFont.m_remap_index">
            <value>
m_remap_index is used for font index remapping during
I/O operations. It is a runtime variable and should be
ignored by everything except CRhinoDoc::Read3DM() and
CRhinoDoc::Write3DM().
</value>
        </member>
        <member name="T:RMA.Rhino.IRhinoFont">
            <summary>a text style to be stored in a Rhino table</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatchPatternTable.DrawPattern(System.Int32,System.Drawing.IDeviceContext,System.Drawing.Rectangle,System.Double)">
            <summary>Draw hatch pattern to a rectangle</summary>
            <param name="idx">[in] - Index of the pattern to draw</param>
            <param name="pDC">[in] - Draw into this dib</param>
            <param name="rect">[in] - coordinates of rect to fill</param>
            <param name="angle">[in] - angle for pattern display (radians)</param>
            <remarks>This is to draw a preview of a pattern</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatchPatternTable.DrawPattern(System.Int32,System.Drawing.IDeviceContext,System.Drawing.Rectangle,System.Double,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>Draw hatch pattern to a rectangle</summary>
            <param name="idx">[in] - Index of the pattern to draw</param>
            <param name="pDC">[in] - Draw into this dib</param>
            <param name="rect">[in] - coordinates of rect to fill</param>
            <param name="angle">[in] - angle for pattern display (radians)</param>
            <remarks>This is to draw a preview of a pattern</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatchPatternTable.DrawPattern(System.Int32,System.Drawing.IDeviceContext,System.Drawing.Rectangle,System.Double,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>Draw hatch pattern to a rectangle</summary>
            <param name="idx">[in] - Index of the pattern to draw</param>
            <param name="pDC">[in] - Draw into this dib</param>
            <param name="rect">[in] - coordinates of rect to fill</param>
            <param name="angle">[in] - angle for pattern display (radians)</param>
            <remarks>This is to draw a preview of a pattern</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatchPatternTable.GetSortedList(RMA.Rhino.IRhinoHatchPattern[]@)">
            <summary>
Gets an array of pointers to hatch patterns that is sorted by the values of CRhinoHatchPattern::m_sort_index.
</summary>
            <param name="sorted_list">
[out] this array is returned with length HatchPatternCount() and is sorted by the values of CRhinoLayer::m_sort_index.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatchPatternTable.GetSortedList(RMA.Rhino.IRhinoHatchPattern[]@,System.Boolean)">
            <summary>
Gets an array of pointers to hatch patterns that is sorted by the values of CRhinoHatchPattern::m_sort_index.
</summary>
            <param name="sorted_list">
[out] this array is returned with length HatchPatternCount() and is sorted by the values of CRhinoLayer::m_sort_index.
</param>
            <param name="bIgnoreDeleted">[in] true means don't include deleted hatch patterns.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatchPatternTable.UndeleteHatchPattern(System.Int32)">
            <summary>
Undeletes a hatch pattern that has been deleted by DeleteHatchPattern().
</summary>
            <param name="pattern_index">
[in] zero based index of tyle to undelete.
This must be in the range 0 &lt;= pattern_index &lt; HatchPatternCount().
</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatchPatternTable.DeleteHatchPatterns(RMA.OpenNURBS.Arrayint,System.Boolean)">
            <summary>Deletes multiple hatch patterns</summary>
            <param name="pattern_index">
[in] array zero based indices of hatch patterns to delete.
The indices must be in the range 0 &lt;= pattern_index &lt; HatchPatternCount().
</param>
            <param name="bQuiet">
[in] If true, no warning message box appears if a hatch pattern cannot be deleted
because it is the current hatch pattern or it contains active geometry.
</param>
            <returns>
true if successful. false if pattern_index is out of range or the
the hatch pattern cannot be deleted because it is the current pattern or
because there is geometry referencing this hatch pattern.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatchPatternTable.DeleteHatchPattern(System.Int32,System.Boolean)">
            <summary>Deletes hatch pattern</summary>
            <param name="pattern_index">
[in] zero based index of pattern to delete.
This must be in the range 0 &lt;= pattern_index &lt; HatchPatternCount().
</param>
            <param name="bQuiet">
[in] If true, no warning message box appears if a layer the hatch pattern
cannot be deleted because it is the current hatch pattern or it contains active geometry.
</param>
            <returns>
true if successful. false if pattern_index is out of range or the
the hatch pattern cannot be deleted because it is the current hatch pattern or
because it hatch pattern contains active geometry.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatchPatternTable.UndoModifyHatchPattern(System.Int32)">
            <summary>
If the hatch pattern has been modified and the modification can be undone,
then UndoModifyHatchPattern() will restore the hatch pattern to its previous state.
</summary>
            <returns>
True if the hatch pattern had been modified and the modifications were undone.
See Also: CRhinoHatchPattern::IsModified.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatchPatternTable.UndoModifyHatchPattern(System.Int32,System.UInt32)">
            <summary>
If the hatch pattern has been modified and the modification can be undone,
then UndoModifyHatchPattern() will restore the hatch pattern to its previous state.
</summary>
            <returns>
True if the hatch pattern had been modified and the modifications were undone.
See Also: CRhinoHatchPattern::IsModified.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatchPatternTable.ModifyHatchPattern(RMA.OpenNURBS.IOnHatchPattern,System.Int32)">
            <summary>Modify hatch pattern settings</summary>
            <param name="pattern">[in] new definition.  This information is copied.</param>
            <param name="pattern_index">
[in] zero based index of pattern to set.  This
must be in the range 0 &lt;= pattern_index &lt; HatchPatternCount().
</param>
            <returns>true if successful. false if pattern_index is out of range.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatchPatternTable.ModifyHatchPattern(RMA.OpenNURBS.IOnHatchPattern,System.Int32,System.Boolean)">
            <summary>Modify hatch pattern settings</summary>
            <param name="pattern">[in] new definition.  This information is copied.</param>
            <param name="pattern_index">
[in] zero based index of pattern to set.  This
must be in the range 0 &lt;= pattern_index &lt; HatchPatternCount().
</param>
            <param name="bQuiet">
[in] if true, information message boxes pop up when illegal changes are attempted.
</param>
            <returns>true if successful. false if pattern_index is out of range.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatchPatternTable.AddHatchPattern(RMA.OpenNURBS.IOnHatchPattern,System.Boolean,System.Int32@)">
            <summary>Adds a new hatch pattern with specified definition to the hatch pattern table.</summary>
            <param name="pattern">
[in] definition of new hatch pattern. The information in pattern is copied.
If pattern.Name() is empty then a unique name of the form
"HatchPattern 01" will be automatically created.
</param>
            <param name="bReference">
[in] true if this layer is a reference hatch pattern.
Reference hatch patterns are not saved in files.
</param>
            <param name="pIdx">
[out] If the hatch pattern is added, the index assigned it is returned here.
If the pattern is not added because of a name collision, the index
of the colliding record is returned here
If the pattern was not added because of some other problem, -1 is returned.
</param>
            <returns>
true    hatch pattern was added
false   hatch pattern not added
</returns>
            <remarks>
In some cases, calling AddHatchPattern() can cause the memory 
references previously returned by operator[] and 
CurrentHatchPattern() to become invalid.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatchPatternTable.AddHatchPattern(System.Boolean)">
            <summary>
Adds a new hatch pattern with default definition to the hatch pattern table.
</summary>
            <param name="bReference">
[in] true if this hatch pattern is a reference pattern. Reference hatch patterns are not saved in files.
</param>
            <returns>index of new hatch pattern</returns>
            <remarks>
In some cases, calling AddHatchPattern() can cause the memory 
references previously returned by operator[] and 
CurrentHatchPattern() to become invalid.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatchPatternTable.GetUnusedHatchPatternName(System.String@)">
            <summary>Gets unsed layer name used as default when creating new layers</summary>
            <param name="result">[out] this is the wString which receives new name</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatchPatternTable.FindHatchPattern(System.Guid)">
            <returns>
&gt;=0     index of the hatch pattern with the given name
-1      no hatch pattern has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatchPatternTable.FindHatchPattern(System.Guid,System.Boolean)">
            <param name="bIgnoreDeleted">
[in] true means don't search deleted hatch patterns.
</param>
            <returns>
&gt;=0     index of the hatch pattern with the given name
-1      no hatch pattern has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatchPatternTable.FindHatchPattern(System.String)">
            <summary>Finds the hatch pattern with a given name.</summary>
            <param name="name">
[in] name of hatch pattern to search for. The search ignores case.
</param>
            <returns>
&gt;=0     index of the hatch pattern with the given name
-1      no hatch pattern has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatchPatternTable.FindHatchPattern(System.String,System.Boolean)">
            <summary>Finds the hatch pattern with a given name.</summary>
            <param name="name">
[in] name of hatch pattern to search for. The search ignores case.
</param>
            <param name="bIgnoreDeleted">
[in] true means don't search deleted hatch patterns.
</param>
            <returns>
&gt;=0     index of the hatch pattern with the given name
-1      no hatch pattern has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatchPatternTable.CurrentHatchPatternIndex">
            <summary>
At all times, there is a "current" hatch pattern.  Unless otherwise
specified, new hatch objects are assigned to the current hatch pattern.
The current hatch pattern is never deleted.
</summary>
            <returns>
Zero based hatch pattern index of the current hatch pattern.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatchPatternTable.CurrentHatchPattern">
            <summary>
At all times, there is a "current" hatch pattern.  Unless otherwise
specified, new hatch objects are assigned the current hatch pattern.
The current hatch pattern is never deleted.
</summary>
            <returns>
Reference to the current hatch pattern.  Note that this reference
may become invalid after a call to AddHatchPattern().
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatchPatternTable.SetCurrentHatchPatternIndex(System.Int32)">
            <summary>
At all times, there is a "current" hatch pattern.  Unless otherwise
specified, new hatch objects are assigned to the current hatch pattern.
The current hatch pattern is never deleted.
</summary>
            <param name="pattern_index">
[in] value for new current hatch pattern.
0 &lt;= pattern_index &lt; HatchPatternCount().
</param>
            <returns>true if current hatch pattern index successfully set.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatchPatternTable.SetCurrentHatchPatternIndex(System.Int32,System.Boolean)">
            <summary>
At all times, there is a "current" hatch pattern.  Unless otherwise
specified, new hatch objects are assigned to the current hatch pattern.
The current hatch pattern is never deleted.
</summary>
            <param name="pattern_index">
[in] value for new current hatch pattern.
0 &lt;= pattern_index &lt; HatchPatternCount().
</param>
            <param name="bQuiet">
[in] if true, then no warning message box pops up if the current pattern request can't be satisfied.
</param>
            <returns>true if current hatch pattern index successfully set.</returns>
        </member>
        <member name="P:RMA.Rhino.MRhinoHatchPatternTable.Item(System.Int32)">
            <summary>
Conceptually, the hatch pattern table is an array of PatternCount()
hatch patterns.  The operator[] can be used to get individual
hatch patterns.  A hatch pattern is either active or deleted and this
state is reported by CRhinoHatchPattern::IsDeleted().
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatchPatternTable.HatchPatternCount">
            <summary>
Number of patterns in the hatch pattern table, including deleted patterns.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatchPatternTable.GetDefaultHatchPatternProperties(RMA.OpenNURBS.OnHatchPattern@)">
            <summary>
Initializes a CRhinoHatchPattern with the current default hatch pattern properties.
</summary>
            <param name="pattern">[out] properties returned here</param>
        </member>
        <member name="T:RMA.Rhino.MRhinoHatchPatternTable">
            <summary>A list of Hatch Pattern definitions</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoHatchPatternTable.DrawPattern(System.Int32,System.Drawing.IDeviceContext,System.Drawing.Rectangle,System.Double)">
            <summary>Draw hatch pattern to a rectangle</summary>
            <param name="idx">[in] - Index of the pattern to draw</param>
            <param name="pDC">[in] - Draw into this dib</param>
            <param name="rect">[in] - coordinates of rect to fill</param>
            <param name="angle">[in] - angle for pattern display (radians)</param>
            <remarks>This is to draw a preview of a pattern</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoHatchPatternTable.DrawPattern(System.Int32,System.Drawing.IDeviceContext,System.Drawing.Rectangle,System.Double,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>Draw hatch pattern to a rectangle</summary>
            <param name="idx">[in] - Index of the pattern to draw</param>
            <param name="pDC">[in] - Draw into this dib</param>
            <param name="rect">[in] - coordinates of rect to fill</param>
            <param name="angle">[in] - angle for pattern display (radians)</param>
            <remarks>This is to draw a preview of a pattern</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoHatchPatternTable.DrawPattern(System.Int32,System.Drawing.IDeviceContext,System.Drawing.Rectangle,System.Double,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>Draw hatch pattern to a rectangle</summary>
            <param name="idx">[in] - Index of the pattern to draw</param>
            <param name="pDC">[in] - Draw into this dib</param>
            <param name="rect">[in] - coordinates of rect to fill</param>
            <param name="angle">[in] - angle for pattern display (radians)</param>
            <remarks>This is to draw a preview of a pattern</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoHatchPatternTable.GetSortedList(RMA.Rhino.IRhinoHatchPattern[]@)">
            <summary>
Gets an array of pointers to hatch patterns that is sorted by the values of CRhinoHatchPattern::m_sort_index.
</summary>
            <param name="sorted_list">
[out] this array is returned with length HatchPatternCount() and is sorted by the values of CRhinoLayer::m_sort_index.
</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoHatchPatternTable.GetSortedList(RMA.Rhino.IRhinoHatchPattern[]@,System.Boolean)">
            <summary>
Gets an array of pointers to hatch patterns that is sorted by the values of CRhinoHatchPattern::m_sort_index.
</summary>
            <param name="sorted_list">
[out] this array is returned with length HatchPatternCount() and is sorted by the values of CRhinoLayer::m_sort_index.
</param>
            <param name="bIgnoreDeleted">[in] true means don't include deleted hatch patterns.</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoHatchPatternTable.FindHatchPattern(System.Guid)">
            <returns>
&gt;=0     index of the hatch pattern with the given name
-1      no hatch pattern has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoHatchPatternTable.FindHatchPattern(System.Guid,System.Boolean)">
            <param name="bIgnoreDeleted">
[in] true means don't search deleted hatch patterns.
</param>
            <returns>
&gt;=0     index of the hatch pattern with the given name
-1      no hatch pattern has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoHatchPatternTable.FindHatchPattern(System.String)">
            <summary>Finds the hatch pattern with a given name.</summary>
            <param name="name">
[in] name of hatch pattern to search for. The search ignores case.
</param>
            <returns>
&gt;=0     index of the hatch pattern with the given name
-1      no hatch pattern has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoHatchPatternTable.FindHatchPattern(System.String,System.Boolean)">
            <summary>Finds the hatch pattern with a given name.</summary>
            <param name="name">
[in] name of hatch pattern to search for. The search ignores case.
</param>
            <param name="bIgnoreDeleted">
[in] true means don't search deleted hatch patterns.
</param>
            <returns>
&gt;=0     index of the hatch pattern with the given name
-1      no hatch pattern has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoHatchPatternTable.CurrentHatchPatternIndex">
            <summary>
At all times, there is a "current" hatch pattern.  Unless otherwise
specified, new hatch objects are assigned to the current hatch pattern.
The current hatch pattern is never deleted.
</summary>
            <returns>Zero based hatch pattern index of the current hatch pattern.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoHatchPatternTable.CurrentHatchPattern">
            <summary>
At all times, there is a "current" hatch pattern.  Unless otherwise
specified, new hatch objects are assigned the current hatch pattern.
The current hatch pattern is never deleted.
</summary>
            <returns>
Reference to the current hatch pattern.  Note that this reference
may become invalid after a call to AddHatchPattern().
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoHatchPatternTable.HatchPatternCount">
            <returns>
Number of patterns in the hatch pattern table, including deleted patterns.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoHatchPatternTable.GetDefaultHatchPatternProperties(RMA.OpenNURBS.OnHatchPattern@)">
            <summary>
Initializes a CRhinoHatchPattern with the current default hatch pattern properties.
</summary>
            <param name="pattern">[out] properties returned here</param>
        </member>
        <member name="P:RMA.Rhino.IRhinoHatchPatternTable.Item(System.Int32)">
            <summary>
Conceptually, the hatch pattern table is an array of PatternCount()
hatch patterns.  The operator[] can be used to get individual
hatch patterns.  A hatch pattern is either active or deleted and this
state is reported by CRhinoHatchPattern::IsDeleted().
</summary>
        </member>
        <member name="T:RMA.Rhino.IRhinoHatchPatternTable">
            <summary>A list of Hatch Pattern definitions</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatchPattern.DrawPattern(System.Drawing.IDeviceContext,System.Drawing.Rectangle,System.Double,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>Draw a swatch of the pattern into a rectangle</summary>
            <param name="pDC">[in] - Draw into this dib</param>
            <param name="rect">[in] - coordinates of rect to fill</param>
            <param name="angle">[in] - angle for pattern display (radians)</param>
            <remarks>This is to draw a preview of a pattern</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatchPattern.Index">
            <summary>
Hatch Patterns are stored in a table and referenced by a zero based index.
</summary>
            <returns>
HatchPattern table index of this pattern.
-1 if this pattern is not in the table
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatchPattern.IsReference">
            <summary>
Rhino allows multiple files to be viewed simultaneously.
Hatch Patterns in the document are "normal" or "reference".
Reference Hatch Patterns are not saved.
</summary>
            <returns>
true if hatch pattern is in a reference file and will not be
saved as part of this document.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatchPattern.IsDeleted">
            <summary>
Deleted patterns are kept in the runtime hatch pattern table
so that undo will work with hatch patterns.  Call IsDeleted()
to determine if a hatch pattern is deleted.
</summary>
            <returns>true if hatch pattern is deleted.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoHatchPattern.CreateDisplay(RMA.OpenNURBS.IOnHatchPattern,RMA.OpenNURBS.IOnHatch,RMA.OpenNURBS.OnNurbsCurve[]@,RMA.OpenNURBS.ArrayOnLine@,RMA.OpenNURBS.OnBrep@)">
            <summary>
Creates the display graphics for a Hatch from the Hatch and HatchPattern definitions.
</summary>
            <param name="pattern">[in] - the hatch pattern to draw</param>
            <param name="hatch">
[in] - The hatch contains
3d plane for the display objects scale to apply to the pattern definition
rotation to apply to the pattern definition 2d boundary loops for the
hatched area in hatch plane coordinates
</param>
            <param name="bounds">
[out] - 3d boundary curves for the hatch
The first curve in the array is the outer boundary and the rest are inners
</param>
            <param name="lines">
[out] - 3d line segments representing the applied pattern
There may be no lines if the hatch uses a different fill type
</param>
            <param name="pBrep">
[out] - Trimmed planar brep used for solid fill hatch display
Will be NULL if the hatch isn't solid filled
</param>
            <returns>true for success, false for failure</returns>
        </member>
        <member name="P:RMA.Rhino.MRhinoHatchPattern.m_sort_index">
            <value>
Runtime index used to sort layers in layer dialog
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoHatchPattern.m_remap_index">
            <value>
Used for font index remapping during I/O operations. 
It is a runtime variable and should be ignored by 
everything except CRhinoDoc::Read3DM() and CRhinoDoc::Write3DM().
</value>
        </member>
        <member name="M:RMA.Rhino.IRhinoHatchPattern.DrawPattern(System.Drawing.IDeviceContext,System.Drawing.Rectangle,System.Double,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>Draw a swatch of the pattern into a rectangle</summary>
            <param name="pDC">[in] - Draw into this dib</param>
            <param name="rect">[in] - coordinates of rect to fill</param>
            <param name="angle">[in] - angle for pattern display (radians)</param>
            <remarks>This is to draw a preview of a pattern</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoHatchPattern.Index">
            <summary>
Hatch Patterns are stored in a table and referenced by a zero based index.
</summary>
            <returns>
HatchPattern table index of this pattern.
-1 if this pattern is not in the table
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoHatchPattern.IsReference">
            <summary>
Rhino allows multiple files to be viewed simultaneously.
Hatch Patterns in the document are "normal" or "reference".
Reference Hatch Patterns are not saved.
</summary>
            <returns>
true if hatch pattern is in a reference file and will not be
saved as part of this document.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoHatchPattern.IsDeleted">
            <summary>
Deleted patterns are kept in the runtime hatch pattern table
so that undo will work with hatch patterns.  Call IsDeleted()
to determine if a hatch pattern is deleted.
</summary>
            <returns>true if hatch pattern is deleted.</returns>
        </member>
        <member name="P:RMA.Rhino.IRhinoHatchPattern.m_sort_index">
            <value>
Runtime index used to sort layers in layer dialog
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoHatchPattern.m_remap_index">
            <value>
Used for font index remapping during I/O operations. 
It is a runtime variable and should be ignored by 
everything except CRhinoDoc::Read3DM() and CRhinoDoc::Write3DM().
</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoDimStyleTable.GetSortedList(RMA.Rhino.IRhinoDimStyle[]@)">
            <summary>
Gets an array of pointers to dim styles that is sorted by
the values of CRhinoDimStyle::m_sort_index.
</summary>
            <param name="sorted_list">
[out] this array is returned with length DimStyleCount() and is sorted by the values of
CRhinoLayer::m_sort_index.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDimStyleTable.GetSortedList(RMA.Rhino.IRhinoDimStyle[]@,System.Boolean)">
            <summary>
Gets an array of pointers to dim styles that is sorted by
the values of CRhinoDimStyle::m_sort_index.
</summary>
            <param name="sorted_list">
[out] this array is returned with length DimStyleCount() and is sorted by the values of
CRhinoLayer::m_sort_index.
</param>
            <param name="bIgnoreDeleted">[in] true means don't include deleted dim styles.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDimStyleTable.UndeleteDimStyle(System.Int32)">
            <summary>Undeletes a dim style that has been deleted by DeleteDimStyle().</summary>
            <param name="style_index">
[in] zero based index of tyle to undelete.
This must be in the range 0 &lt;= style_index &lt; DimStyleCount().
</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDimStyleTable.DeleteDimStyle(System.Int32,System.Boolean)">
            <summary>Deletes dim style</summary>
            <param name="style_index">
[in] zero based index of style to delete.
This must be in the range 0 &lt;= style_index &lt; DimStyleCount().
</param>
            <param name="bQuiet">
[in] If true, no warning message box appears if a layer
the dim style cannot be deleted because it is the current dim style
or it contains active geometry.
</param>
            <returns>
true if successful. false if style_index is out of range or the
the dim style cannot be deleted because it is the current dim style or
because it dim style contains active geometry.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDimStyleTable.UndoModifyDimStyle(System.Int32)">
            <summary>
If the dimsytle has been modified and the modification can be undone, then
UndoModifyDimStyle() will restore the dimstyle to its previous state.
</summary>
            <returns>
True if this dimstyle had been modified and the modifications were undone.
See Also: CRhinoDimStyle::IsModified.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDimStyleTable.UndoModifyDimStyle(System.Int32,System.UInt32)">
            <summary>
If the dimsytle has been modified and the modification can be undone, then
UndoModifyDimStyle() will restore the dimstyle to its previous state.
</summary>
            <returns>
True if this dimstyle had been modified and the modifications were undone.
See Also: CRhinoDimStyle::IsModified.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDimStyleTable.ModifyDimStyle(RMA.OpenNURBS.IOnDimStyle,System.Int32)">
            <summary>Modify dim style settings</summary>
            <param name="style">[in] new settings.  This information is copied.</param>
            <param name="style_index">
[in] zero based index of style to set.  This
must be in the range 0 &lt;= style_index &lt; DimStyleCount().
</param>
            <returns>true if successful. false if style_index is out of range.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDimStyleTable.ModifyDimStyle(RMA.OpenNURBS.IOnDimStyle,System.Int32,System.Boolean)">
            <summary>Modify dim style settings</summary>
            <param name="style">[in] new settings.  This information is copied.</param>
            <param name="style_index">
[in] zero based index of style to set.  This
must be in the range 0 &lt;= style_index &lt; DimStyleCount().
</param>
            <param name="bQuiet">
[in] if true, information message boxes pop up when illegal changes are attempted.
</param>
            <returns>true if successful. false if style_index is out of range.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDimStyleTable.AddDimStyle(RMA.OpenNURBS.IOnDimStyle,System.Boolean)">
            <summary>Adds a new dim style with specified definition to the dim style table.</summary>
            <param name="style">
[in] definition of new dim style.  The information in style is copied.  If style.Name() is empty
the a unique name of the form "DimStyle 01" will be automatically created.
</param>
            <param name="bReference">
[in] true if this layer is a reference dim style.
Reference dim styles are not saved in files.
</param>
            <returns>
&gt;=0     index of new dim style
-1      dim style not added because a dim style with that name already exists.
</returns>
            <remarks>
In some cases, calling AddDimStyle() can cause the memory 
references previously returned by operator[] and 
CurrentDimStyle() to become invalid.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDimStyleTable.AddDimStyle(System.Boolean)">
            <summary>Adds a new dim style with default definition to the dim style table.</summary>
            <param name="bReference">
[in] true if this dim style is a reference style. Reference dim styles are not saved in files.
</param>
            <returns>index of new dim style</returns>
            <remarks>
In some cases, calling AddDimStyle() can cause the memory 
references previously returned by operator[] and 
CurrentDimStyle() to become invalid.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDimStyleTable.GetUnusedDimStyleName(System.String@)">
            <summary>Gets unsed layer name used as default when creating new layers</summary>
            <param name="result">[out] this is the wString which receives new name</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoDimStyleTable.FindDimStyle(System.String)">
            <summary>Finds the dim style with a given name.</summary>
            <param name="name">
[in] name of dim style to search for.  The search ignores case.
</param>
            <returns>
&gt;=0     index of the dim style with the given name
-1      no dim style has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDimStyleTable.FindDimStyle(System.String,System.Boolean)">
            <summary>Finds the dim style with a given name.</summary>
            <param name="name">
[in] name of dim style to search for.  The search ignores case.
</param>
            <param name="bIgnoreDeleted">
[in] true means don't search deleted dim styles.
</param>
            <returns>
&gt;=0     index of the dim style with the given name
-1      no dim style has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDimStyleTable.CurrentDimStyleIndex">
            <summary>
At all times, there is a "current" dim style.  Unless otherwise
specified, new dimension objects are assigned to the current dim style.
The current dim style is never deleted.
</summary>
            <returns>Zero based dim style index of the current dim style.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDimStyleTable.CurrentDimStyle">
            <summary>
At all times, there is a "current" dim style.  Unless otherwise
specified, new dimension objects are assigned the current dim style.
The current dim style is never deleted.
</summary>
            <returns>
Reference to the current dim style.  Note that this reference
may become invalid after a call to AddDimStyle().
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDimStyleTable.SetCurrentDimStyleIndex(System.Int32)">
            <summary>
At all times, there is a "current" dim style.  Unless otherwise
specified, new dim objects are assigned to the current dim style.
The current dim style is never deleted.
</summary>
            <param name="style_index">
[in] value for new current dim style. 0 &lt;= style_index &lt; DimStyleCount().
</param>
            <returns>true if current dim style index successfully set.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDimStyleTable.SetCurrentDimStyleIndex(System.Int32,System.Boolean)">
            <summary>
At all times, there is a "current" dim style.  Unless otherwise
specified, new dim objects are assigned to the current dim style.
The current dim style is never deleted.
</summary>
            <param name="style_index">
[in] value for new current dim style. 0 &lt;= style_index &lt; DimStyleCount().
</param>
            <param name="bQuiet">
[in] if true, then no warning message box pops up if the
current style request can't be satisfied.
</param>
            <returns>true if current dim style index successfully set.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDimStyleTable.DimStyleCount">
            <summary>
Returns: Number of styles in the dim style table, including deleted styles.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDimStyleTable.GetDefaultDimStyleProperties(RMA.OpenNURBS.OnDimStyle@)">
            <summary>
Initializes an CRhinoDimStyle with the current default dimension style properties.
</summary>
            <param name="style">[out] properties returned here</param>
        </member>
        <member name="P:RMA.Rhino.MRhinoDimStyleTable.Item(System.Int32)">
            <value>
Conceptually, the dim style table is an array of DimStyleCount()
dim styles.  The operator[] can be used to get individual
dim styles.  A dim style is either active or deleted and this
state is reported by CRhinoDimStyle::IsDeleted().

Returns refererence to the style.  If style_index is out of range,
the current style is returned. Note that this reference
may become invalid after AddDimStyle() is called.
</value>
        </member>
        <member name="T:RMA.Rhino.MRhinoDimStyleTable">
            <summary>
CRhinoDimStyleTable class - A list of DimensionStyle settings groups
The base class is private because this dynamic array must be accessed and
modified in a controled way to insure the document is valid.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDimStyleTable.GetSortedList(RMA.Rhino.IRhinoDimStyle[]@)">
            <summary>
Gets an array of pointers to dim styles that is sorted by
the values of CRhinoDimStyle::m_sort_index.
</summary>
            <param name="sorted_list">
[out] this array is returned with length DimStyleCount() and is sorted by the values of
CRhinoLayer::m_sort_index.
</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoDimStyleTable.GetSortedList(RMA.Rhino.IRhinoDimStyle[]@,System.Boolean)">
            <summary>
Gets an array of pointers to dim styles that is sorted by
the values of CRhinoDimStyle::m_sort_index.
</summary>
            <param name="sorted_list">
[out] this array is returned with length DimStyleCount() and is sorted by the values of
CRhinoLayer::m_sort_index.
</param>
            <param name="bIgnoreDeleted">[in] true means don't include deleted dim styles.</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoDimStyleTable.GetUnusedDimStyleName(System.String@)">
            <summary>Gets unsed layer name used as default when creating new layers</summary>
            <param name="result">[out] this is the wString which receives new name</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoDimStyleTable.FindDimStyle(System.String)">
            <summary>Finds the dim style with a given name.</summary>
            <param name="name">
[in] name of dim style to search for.  The search ignores case.
</param>
            <returns>
&gt;=0     index of the dim style with the given name
-1      no dim style has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDimStyleTable.FindDimStyle(System.String,System.Boolean)">
            <summary>Finds the dim style with a given name.</summary>
            <param name="name">
[in] name of dim style to search for.  The search ignores case.
</param>
            <param name="bIgnoreDeleted">
[in] true means don't search deleted dim styles.
</param>
            <returns>
&gt;=0     index of the dim style with the given name
-1      no dim style has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDimStyleTable.CurrentDimStyleIndex">
            <summary>
At all times, there is a "current" dim style.  Unless otherwise
specified, new dimension objects are assigned to the current dim style.
The current dim style is never deleted.
</summary>
            <returns>Zero based dim style index of the current dim style.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDimStyleTable.CurrentDimStyle">
            <summary>
At all times, there is a "current" dim style.  Unless otherwise
specified, new dimension objects are assigned the current dim style.
The current dim style is never deleted.
</summary>
            <returns>
Reference to the current dim style.  Note that this reference
may become invalid after a call to AddDimStyle().
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDimStyleTable.DimStyleCount">
            <summary>
Returns: Number of styles in the dim style table, including deleted styles.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDimStyleTable.GetDefaultDimStyleProperties(RMA.OpenNURBS.OnDimStyle@)">
            <summary>
Initializes an CRhinoDimStyle with the current default dimension style properties.
</summary>
            <param name="style">[out] properties returned here</param>
        </member>
        <member name="P:RMA.Rhino.IRhinoDimStyleTable.Item(System.Int32)">
            <value>
Conceptually, the dim style table is an array of DimStyleCount()
dim styles.  The operator[] can be used to get individual
dim styles.  A dim style is either active or deleted and this
state is reported by CRhinoDimStyle::IsDeleted().

Returns refererence to the style.  If style_index is out of range,
the current style is returned. Note that this reference
may become invalid after AddDimStyle() is called.
</value>
        </member>
        <member name="T:RMA.Rhino.IRhinoDimStyleTable">
            <summary>
CRhinoDimStyleTable class - A list of DimensionStyle settings groups
The base class is private because this dynamic array must be accessed and
modified in a controled way to insure the document is valid.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDimStyle.DSxExtExtension">
            <summary>
Returns: True if the dimstyle has been modified and the modification can be undone. See Also: CRhinoDimStyleTable::UndoModifyDimStyle
</summary>
            <summary>
These functions are like the ON_DimStyle ones but with the 
values multiplied by DimScale()
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDimStyle.IsReference">
            <summary>
Rhino allows multiple files to be viewed simultaneously.
Dim styles in the document are "normal" or "reference".
Reference dim styles are not saved.
</summary>
            <returns>
true if dim style is in a reference file and will not be
saved as part of this document.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDimStyle.IsDeleted">
            <summary>
Deleted dim styles are kept in the runtime dim style table
so that undo will work with dim styles.  Call IsDeleted()
to determine if a dim style is deleted.
</summary>
            <returns>true if dim style is deleted.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDimStyle.SetDefaults">
            <summary>
override of virtual ON_Dimstyle::SetDefaults()
</summary>
        </member>
        <member name="P:RMA.Rhino.MRhinoDimStyle.m_sort_index">
            <value>
Runtime index used to sort dimstyles in dialogs
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoDimStyle.m_remap_index">
            <value>
Used for font index remapping during I/O operations. 
It is a runtime variable and should be ignored by 
everything except CRhinoDoc::Read3DM() and CRhinoDoc::Write3DM().
</value>
        </member>
        <member name="M:RMA.Rhino.IRhinoDimStyle.DSxExtExtension">
            <summary>
Returns: True if the dimstyle has been modified and the modification can be undone. See Also: CRhinoDimStyleTable::UndoModifyDimStyle
</summary>
            <summary>
These functions are like the ON_DimStyle ones but with the 
values multiplied by DimScale()
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDimStyle.IsReference">
            <summary>
Rhino allows multiple files to be viewed simultaneously.
Dim styles in the document are "normal" or "reference".
Reference dim styles are not saved.
</summary>
            <returns>
true if dim style is in a reference file and will not be
saved as part of this document.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDimStyle.IsDeleted">
            <summary>
Deleted dim styles are kept in the runtime dim style table
so that undo will work with dim styles.  Call IsDeleted()
to determine if a dim style is deleted.
</summary>
            <returns>true if dim style is deleted.</returns>
        </member>
        <member name="P:RMA.Rhino.IRhinoDimStyle.m_sort_index">
            <value>
Runtime index used to sort dimstyles in dialogs
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoDimStyle.m_remap_index">
            <value>
Used for font index remapping during I/O operations. 
It is a runtime variable and should be ignored by 
everything except CRhinoDoc::Read3DM() and CRhinoDoc::Write3DM().
</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoGroupTable.UndeleteGroup(System.Int32)">
            <summary>Undeletes a group that has been deleted by DeleteGroup().</summary>
            <param name="group_index">
[in] zero based index of group to undelete. This must be in the range
0 &lt;= group_index &lt; GroupCount().
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoGroupTable.DeleteGroup(System.Int32)">
            <summary>Deletes group</summary>
            <param name="group_index">
[in] zero based index of group to delete. This must be in the range
0 &lt;= group_index &lt; GroupCount().
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoGroupTable.ModifyGroup(RMA.OpenNURBS.IOnGroup,System.Int32)">
            <summary>Change group settings</summary>
            <param name="group">[in] new settings.  This information is copied.</param>
            <param name="group_index">
[in] zero based index of group to set. This can be in the range
0 &lt;= group_index &lt;= GroupCount().
If group_index==GroupCount(), a new group is added.
</param>
            <returns>
TRUE if successful. FALSE if group_index is out of range
or the settings attempt to lock or hide the current group.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGroupTable.ModifyGroup(RMA.OpenNURBS.IOnGroup,System.Int32,System.Boolean)">
            <summary>Change group settings</summary>
            <param name="group">[in] new settings.  This information is copied.</param>
            <param name="group_index">
[in] zero based index of group to set. This can be in the range
0 &lt;= group_index &lt;= GroupCount().
If group_index==GroupCount(), a new group is added.
</param>
            <param name="bQuiet">[in] TRUE to disable message boxes when illegal names are used.</param>
            <returns>
TRUE if successful. FALSE if group_index is out of range
or the settings attempt to lock or hide the current group.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGroupTable.AddGroup(RMA.OpenNURBS.IOnGroup,RMA.Rhino.IRhinoObject[])">
            <summary>Adds a new group to the group table.</summary>
            <param name="group">
[in] definition of new group. The information in group is copied.
If group.GroupName() is empty, a group name is automatically created.
The value of group.GroupIndex() is ignored.
</param>
            <param name="group_members">[in] list of objects to add to the group.</param>
            <returns>
&gt;=0 index of new group
-1 group not added because a group with that name already exists.
</returns>
            <remarks>
In some cases, calling AddGroup() can cause the pointers returned by
previous calls to CRhinoGroupTable::operator[] to become invalid.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGroupTable.AddGroup(RMA.OpenNURBS.IOnGroup,RMA.Rhino.IRhinoObject[],System.Boolean)">
            <summary>Adds a new group to the group table.</summary>
            <param name="group">
[in] definition of new group. The information in group is copied.
If group.GroupName() is empty, a group name is automatically created.
The value of group.GroupIndex() is ignored.
</param>
            <param name="group_members">[in] list of objects to add to the group.</param>
            <param name="bReference">
[in] TRUE if this group is a reference group. Reference groups are not saved in files.
</param>
            <returns>
&gt;=0 index of new group
-1 group not added because a group with that name already exists.
</returns>
            <remarks>
In some cases, calling AddGroup() can cause the pointers returned by
previous calls to CRhinoGroupTable::operator[] to become invalid.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGroupTable.AddGroup(RMA.OpenNURBS.IOnGroup)">
            <summary>Adds a new group to the group table.</summary>
            <param name="group">
[in] definition of new group. The information in group is copied.
If group.GroupName() is empty, a group name is automatically created.
The value of group.GroupIndex() is ignored.
</param>
            <returns>
&gt;=0 index of new group
-1 group not added because a group with that name already exists.
</returns>
            <remarks>
In some cases, calling AddGroup() can cause the pointers returned by operator[] to become invalid.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGroupTable.AddGroup(RMA.OpenNURBS.IOnGroup,System.Boolean)">
            <summary>Adds a new group to the group table.</summary>
            <param name="group">
[in] definition of new group. The information in group is copied.
If group.GroupName() is empty, a group name is automatically created.
The value of group.GroupIndex() is ignored.
</param>
            <param name="bReference">
[in] TRUE if this group is a reference group. Reference groups are not saved in files.
</param>
            <returns>
&gt;=0 index of new group
-1 group not added because a group with that name already exists.
</returns>
            <remarks>
In some cases, calling AddGroup() can cause the pointers returned by operator[] to become invalid.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGroupTable.FindGroup(System.String)">
            <summary>Finds the group with a given name.</summary>
            <param name="group_name">[in] name of group to search for. The search ignores case.</param>
            <returns>
&gt;=0     index of the group with the given name
-1      no group has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGroupTable.FindGroup(System.String,System.Boolean)">
            <summary>Finds the group with a given name.</summary>
            <param name="group_name">[in] name of group to search for. The search ignores case.</param>
            <param name="bIgnoreDeletedGroups">[in] TRUE means don't search deleted groups.</param>
            <returns>
&gt;=0     index of the group with the given name
-1      no group has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGroupTable.GroupCount">
            <summary>
Returns: Number of groups in the group table
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGroupTable.Document">
            <summary>Group tables store the list of groups in a Rhino document.</summary>
            <returns>CRhinoDocument that owns this group table.</returns>
        </member>
        <member name="P:RMA.Rhino.MRhinoGroupTable.Item(System.Int32)">
            <summary>
Conceptually, the group table is an array of GroupCount() groups.
The operator[] can be used to get individual groups.  A group is
either active or deleted and this state is reported by CRhinoGroup::IsDeleted().
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGroupTable.FindGroup(System.String)">
            <summary>Finds the group with a given name.</summary>
            <param name="group_name">[in] name of group to search for. The search ignores case.</param>
            <returns>
&gt;=0     index of the group with the given name
-1      no group has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoGroupTable.FindGroup(System.String,System.Boolean)">
            <summary>Finds the group with a given name.</summary>
            <param name="group_name">[in] name of group to search for. The search ignores case.</param>
            <param name="bIgnoreDeletedGroups">[in] TRUE means don't search deleted groups.</param>
            <returns>
&gt;=0     index of the group with the given name
-1      no group has the given name
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoGroupTable.GroupCount">
            <summary>
Returns: Number of groups in the group table
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGroupTable.Document">
            <summary>Group tables store the list of groups in a Rhino document.</summary>
            <returns>CRhinoDocument that owns this group table.</returns>
        </member>
        <member name="P:RMA.Rhino.IRhinoGroupTable.Item(System.Int32)">
            <summary>
Conceptually, the group table is an array of GroupCount() groups.
The operator[] can be used to get individual groups.  A group is
either active or deleted and this state is reported by CRhinoGroup::IsDeleted().
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoGroup.Members(RMA.Rhino.MRhinoObject[]@)">
            <summary>Get an array of all of the objects in this group</summary>
            <param name="members">an array to append the objects in the group</param>
            <returns>
TRUE Success
FALSE Failure
</returns>
            <remarks>Could return success even if the group is empty</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoGroup.IsReference">
            <summary>
Rhino allows multiple files to be viewed simultaneously.
Groups in the document are "normal" or "reference".
Reference groups are not saved.
</summary>
            <returns>
TRUE if group is in a "reference" and will not be saved as part of this document.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoGroup.IsDeleted">
            <summary>
Deleted groups are kept in the runtime group table so that undo will work with groups.
Call IsDeleted() to determine if a group is deleted.
</summary>
            <returns>TRUE if group is deleted.</returns>
        </member>
        <member name="P:RMA.Rhino.MRhinoGroup.m_remap_index">
            <value>
Runtime index used when remapping groups for import/export
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoGroup.m_sort_index">
            <value>
Runtime index used to sort groups
</value>
        </member>
        <member name="T:RMA.Rhino.MRhinoGroup">
            <summary>
CRhinoGroup contains a group definition and is stored in the CRhinoDoc group table.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoGroup.Members(RMA.Rhino.MRhinoObject[]@)">
            <summary>Get an array of all of the objects in this group</summary>
            <param name="members">an array to append the objects in the group</param>
            <returns>
TRUE Success
FALSE Failure
</returns>
            <remarks>Could return success even if the group is empty</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoGroup.IsReference">
            <summary>
Rhino allows multiple files to be viewed simultaneously.
Groups in the document are "normal" or "reference".
Reference groups are not saved.
</summary>
            <returns>
TRUE if group is in a "reference" and will not be saved as part of this document.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoGroup.IsDeleted">
            <summary>
Deleted groups are kept in the runtime group table so that undo will work with groups.
Call IsDeleted() to determine if a group is deleted.
</summary>
            <returns>TRUE if group is deleted.</returns>
        </member>
        <member name="P:RMA.Rhino.IRhinoGroup.m_remap_index">
            <value>
Runtime index used when remapping groups for import/export
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoGroup.m_sort_index">
            <value>
Runtime index used to sort groups
</value>
        </member>
        <member name="T:RMA.Rhino.IRhinoGroup">
            <summary>
CRhinoGroup contains a group definition and is stored in the CRhinoDoc group table.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoTextureMappingTable.CachedTextureCoordinates(RMA.OpenNURBS.IOnMappingChannel,RMA.OpenNURBS.IOnMesh)">
            <summary>
Get cached texture coordinates off a mesh.  If the coordinates
do not exist but can be calculated, they are calculated and returned.
</summary>
            <returns>A pointer to the texture coordinates, if they exist.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoTextureMappingTable.CachedTextureCoordinates(System.Guid,System.Int32,RMA.OpenNURBS.IOn3dmObjectAttributes,RMA.OpenNURBS.IOnMesh)">
            <summary>
Get cached texture coordinates off a mesh.  If the coordinates
do not exist but can be calculated, they are calculated and returned.
</summary>
            <returns>A pointer to the texture coordinates, if they exist.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoTextureMappingTable.UndoModifyTextureMapping(System.Int32,System.UInt32)">
            <summary>
If the texture_mapping has been modified and the modification can be undone,
then UndoModifyTextureMapping() will restore the texture_mapping to its previous state.
</summary>
            <returns>
True if this texture_mapping had been modified and the modifications were undone.
See Also: CRhinoTextureMapping::IsModified.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoTextureMappingTable.ModifyTextureMapping(RMA.OpenNURBS.IOnTextureMapping,System.Int32)">
            <summary>Modify texture_mapping settings</summary>
            <param name="texture_mapping">[in] new settings. This information is copied.</param>
            <param name="texture_mapping_index">
[in] zero based index of texture_mapping to set. This must be
in the range 0 &lt;= texture_mapping_index &lt; TextureMappingCount().
</param>
            <returns>
TRUE if successful. FALSE if texture_mapping_index is out of range or the
settings attempt to lock or hide the current texture_mapping.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoTextureMappingTable.ModifyTextureMapping(RMA.OpenNURBS.IOnTextureMapping,System.Int32,System.Boolean)">
            <summary>
Description: Modify texture_mapping settings Parameters: texture_mapping - [in] new settings. This information is copied. texture_mapping_index - [in] zero based index of texture_mapping to set. This must be in the range 0 &lt;= texture_mapping_index &lt; TextureMappingCount(). bQuiet - [in] if TRUE, then no message boxes pop up to explain failures. Returns: TRUE if successful. FALSE if texture_mapping_index is out of range or the settings attempt to lock or hide the current texture_mapping.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoTextureMappingTable.AddTextureMapping(RMA.OpenNURBS.IOnTextureMapping)">
            <summary>Adds a new texture_mapping to the texture_mapping table.</summary>
            <param name="texture_mapping">
[in] definition of new texture_mapping. The information in texture_mapping is copied.
If texture_mapping.TextureMappingName() is empty the a unique name of the form
"TextureMapping 01" will be automatically created.
</param>
            <returns>
&gt;=0 index of new texture_mapping
-1 texture_mapping not added because a texture_mapping with that name already exists.
</returns>
            <remarks>
In some cases, calling AddTextureMapping() can cause the memory references
returned by operator[] and CurrentTextureMapping() to become invalid.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoTextureMappingTable.AddTextureMapping(RMA.OpenNURBS.IOnTextureMapping,System.Boolean)">
            <summary>Adds a new texture_mapping to the texture_mapping table.</summary>
            <param name="texture_mapping">
[in] definition of new texture_mapping. The information in texture_mapping is copied.
If texture_mapping.TextureMappingName() is empty the a unique name of the form
"TextureMapping 01" will be automatically created.
</param>
            <param name="bReference">
[in] TRUE if this texture_mapping is a reference texture_mapping. Reference
texture_mappings are not saved in files.
</param>
            <returns>
&gt;=0 index of new texture_mapping
-1 texture_mapping not added because a texture_mapping with that name already exists.
</returns>
            <remarks>
In some cases, calling AddTextureMapping() can cause the memory references
returned by operator[] and CurrentTextureMapping() to become invalid.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoTextureMappingTable.FindTextureMapping(System.String,System.Boolean)">
            <summary>
Description: Conceptually, the texture_mapping table is an array of TextureMappingCount() texture_mappings. The operator[] can be used to get individual texture_mappings. A texture_mapping is either active or deleted and this state is reported by CRhinoTextureMapping::IsDeleted(). Parameters: texture_mapping_index - zero based array index or -1 for the default rendering texture_mapping. Returns: Refererence to the texture_mapping. If texture_mapping_index is out of range, the current texture_mapping is returned. Note that this reference may become invalid after AddTextureMapping() is called.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoTextureMappingTable.TextureMappingCount">
            <returns>
Number of texture_mappings in the texture_mapping table, including deleted texture_mappings.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoTextureMappingTable.Document">
            <returns>
CRhinoDocument that owns this texture_mapping table.
</returns>
        </member>
        <member name="P:RMA.Rhino.MRhinoTextureMappingTable.Item(System.Int32)">
            <summary>
Conceptually, the texture_mapping table is an array of TextureMappingCount()
texture_mappings.  The operator[] can be used to get individual
texture_mappings.  A texture_mapping is either active or deleted and this
state is reported by CRhinoTextureMapping::IsDeleted().
</summary>
        </member>
        <member name="T:RMA.Rhino.MRhinoTextureMappingTable">
            <summary>TextureMapping tables store the list of texture_mappings in a Rhino document.</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoTextureMappingTable.CachedTextureCoordinates(RMA.OpenNURBS.IOnMappingChannel,RMA.OpenNURBS.IOnMesh)">
            <summary>
Get cached texture coordinates off a mesh.  If the coordinates
do not exist but can be calculated, they are calculated and returned.
</summary>
            <returns>A pointer to the texture coordinates, if they exist.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoTextureMappingTable.CachedTextureCoordinates(System.Guid,System.Int32,RMA.OpenNURBS.IOn3dmObjectAttributes,RMA.OpenNURBS.IOnMesh)">
            <summary>
Get cached texture coordinates off a mesh.  If the coordinates
do not exist but can be calculated, they are calculated and returned.
</summary>
            <returns>A pointer to the texture coordinates, if they exist.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoTextureMappingTable.TextureMappingCount">
            <returns>
Number of texture_mappings in the texture_mapping table, including deleted texture_mappings.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoTextureMappingTable.Document">
            <returns>
CRhinoDocument that owns this texture_mapping table.
</returns>
        </member>
        <member name="P:RMA.Rhino.IRhinoTextureMappingTable.Item(System.Int32)">
            <summary>
Conceptually, the texture_mapping table is an array of TextureMappingCount()
texture_mappings.  The operator[] can be used to get individual
texture_mappings.  A texture_mapping is either active or deleted and this
state is reported by CRhinoTextureMapping::IsDeleted().
</summary>
        </member>
        <member name="T:RMA.Rhino.IRhinoTextureMappingTable">
            <summary>TextureMapping tables store the list of texture_mappings in a Rhino document.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoTextureMapping.IsReference">
            <summary>
Rhino allows multiple files to be viewed simultaneously. Texture mappings
in the document are "normal" or "reference". Reference
texture mappings are not saved.
</summary>
            <returns>TRUE if texture mapping is in a reference file and will not be saved as part of this document.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoTextureMapping.IsDeleted">
            <summary>
Deleted texture maps are kept in the runtime texture mapping table so that undo will work.
Call IsDeleted() to determine if a texture mapping is deleted.
</summary>
            <returns>TRUE if texture mapping is deleted.</returns>
        </member>
        <member name="P:RMA.Rhino.MRhinoTextureMapping.m_remap_index">
            <value>
Runtime index used when remapping texture_mappings for import/export
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoTextureMapping.m_sort_index">
            <value>
Runtime index used to sort texture_mappings in texture_mapping dialog
</value>
        </member>
        <member name="M:RMA.Rhino.IRhinoTextureMapping.IsReference">
            <summary>
Rhino allows multiple files to be viewed simultaneously. Texture mappings
in the document are "normal" or "reference". Reference
texture mappings are not saved.
</summary>
            <returns>TRUE if texture mapping is in a reference file and will not be saved as part of this document.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoTextureMapping.IsDeleted">
            <summary>
Deleted texture maps are kept in the runtime texture mapping table so that undo will work.
Call IsDeleted() to determine if a texture mapping is deleted.
</summary>
            <returns>TRUE if texture mapping is deleted.</returns>
        </member>
        <member name="P:RMA.Rhino.IRhinoTextureMapping.m_remap_index">
            <value>
Runtime index used when remapping texture_mappings for import/export
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoTextureMapping.m_sort_index">
            <value>
Runtime index used to sort texture_mappings in texture_mapping dialog
</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoMaterialTable.UndeleteMaterial(System.Int32)">
            <summary>Undeletes a material that has been deleted by DeleteMaterial().</summary>
            <param name="material_index">
[in] zero based index of material to undelete.
This must be in the range 0 &lt;= material_index &lt; MaterialCount().
</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoMaterialTable.DeleteMaterial(System.Int32)">
            <summary>Deletes material</summary>
            <param name="material_index">
[in] zero based index of material to delete.  This
must be in the range 0 &lt;= material_index &lt; MaterialCount().
</param>
            <returns>
TRUE if successful. FALSE if material_index is out of range or the
the material cannot be deleted because it is the current material or
because it material contains active geometry.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoMaterialTable.UndoModifyMaterial(System.Int32)">
            <summary>
If the material has been modified and the modification can be undone, then
UndoModifyMaterial() will restore the material to its previous state.
</summary>
            <returns>
True if this material had been modified and the modifications were undone.
See Also: CRhinoMaterial::IsModified.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoMaterialTable.UndoModifyMaterial(System.Int32,System.UInt32)">
            <summary>
If the material has been modified and the modification can be undone, then
UndoModifyMaterial() will restore the material to its previous state.
</summary>
            <returns>
True if this material had been modified and the modifications were undone.
See Also: CRhinoMaterial::IsModified.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoMaterialTable.ModifyMaterial(RMA.OpenNURBS.IOnMaterial,System.Int32)">
            <summary>Modify material settings</summary>
            <param name="material">[in] new settings.  This information is copied.</param>
            <param name="material_index">
[in] zero based index of material to set.  This
must be in the range 0 &lt;= material_index &lt; MaterialCount().
</param>
            <returns>
TRUE if successful. FALSE if material_index is out of range or the settings attempt
to lock or hide the current material.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoMaterialTable.ModifyMaterial(RMA.OpenNURBS.IOnMaterial,System.Int32,System.Boolean)">
            <summary>Modify material settings</summary>
            <param name="material">[in] new settings.  This information is copied.</param>
            <param name="material_index">
[in] zero based index of material to set.  This
must be in the range 0 &lt;= material_index &lt; MaterialCount().
</param>
            <param name="bQuiet">[in] if TRUE, then no message boxes pop up to explain failures.</param>
            <returns>
TRUE if successful. FALSE if material_index is out of range or the settings attempt
to lock or hide the current material.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoMaterialTable.AddMaterial(RMA.OpenNURBS.IOnMaterial)">
            <summary>Adds a new material to the material table.</summary>
            <param name="material">
[in] definition of new material. The information in material is copied.
If material.MaterialName() is empty then a unique name of the form
"Material 01" will be automatically created.
</param>
            <returns>
&gt;=0     index of new material
-1      material not added because a material with that name already exists.
</returns>
            <remarks>
In some cases, calling AddMaterial() can cause the memory 
references returned by operator[] and CurrentMaterial()
to become invalid.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoMaterialTable.AddMaterial(RMA.OpenNURBS.IOnMaterial,System.Boolean)">
            <summary>Adds a new material to the material table.</summary>
            <param name="material">
[in] definition of new material. The information in material is copied.
If material.MaterialName() is empty then a unique name of the form
"Material 01" will be automatically created.
</param>
            <param name="bReference">
[in] TRUE if this material is a reference material. Reference materials are not saved in files.
</param>
            <returns>
&gt;=0     index of new material
-1      material not added because a material with that name already exists.
</returns>
            <remarks>
In some cases, calling AddMaterial() can cause the memory 
references returned by operator[] and CurrentMaterial()
to become invalid.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoMaterialTable.SetCurrentMaterialIndex(System.Int32)">
            <summary>
At all times, there is a "current" material.  Unless otherwise
specified, new objects are assigned to the current material.
The current material is never locked, hidden, or deleted.
</summary>
            <param name="material_index">
[in] value for new current material. -1 &lt;= material_index &lt; MaterialCount().
</param>
            <returns>TRUE if current material index successfully set.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoMaterialTable.SetCurrentMaterialIndex(System.Int32,System.Boolean)">
            <summary>
At all times, there is a "current" material.  Unless otherwise
specified, new objects are assigned to the current material.
The current material is never locked, hidden, or deleted.
</summary>
            <param name="material_index">
[in] value for new current material. -1 &lt;= material_index &lt; MaterialCount().
</param>
            <param name="bQuiet">
[in] if TRUE, then no warning message box pops up if the current material request can't be satisfied.
</param>
            <returns>TRUE if current material index successfully set.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoMaterialTable.CurrentMaterialIndex">
            <summary>
At all times, there is a "current" material.  Unless otherwise
specified, new objects are assigned to the current layer.
The current layer is never locked, hidden, or deleted.
</summary>
            <returns>Zero based material table index of the current material.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoMaterialTable.GetMaterials(RMA.OpenNURBS.IOnMaterialRef,RMA.Rhino.IRhinoMaterial@,RMA.Rhino.IRhinoMaterial@)">
            <param name="material_ref">[in] material reference - can be NULL</param>
            <param name="front_material">
[out] Pointer to front face material (never NULL) NOTE WELL: This pointer will be invalid
if the material table is changed. NEVER use this as a long term reference to a material.
</param>
            <param name="back_material">
[out] Pointer to back face material (never NULL) NOTE WELL: This pointer will be invalid
if the material table is changed. NEVER use this as a long term reference to a material.
</param>
            <returns>Material for object's front faces.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoMaterialTable.GetMaterials(System.Guid,RMA.OpenNURBS.IOnRenderingAttributes,RMA.Rhino.IRhinoMaterial@,RMA.Rhino.IRhinoMaterial@)">
            <param name="plugin_id">
[in] rendering plugin. (RhinoApp().GetDefaultRenderApp() returns the active rendering id)
</param>
            <param name="rendering_attributes">[in] object or layer rendering attributes</param>
            <param name="front_material">
[out] Pointer to front face material (never NULL) NOTE WELL: This pointer will be invalid
if the material table is changed. NEVER use this as a long term reference to a material.
</param>
            <param name="back_material">
[out] Pointer to back face material (never NULL) NOTE WELL: This pointer will be invalid
if the material table is changed. NEVER use this as a long term reference to a material.
</param>
            <returns>Material for object's front faces.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoMaterialTable.GetMaterials(System.Guid,RMA.OpenNURBS.IOn3dmObjectAttributes,RMA.Rhino.IRhinoMaterial@,RMA.Rhino.IRhinoMaterial@)">
            <param name="plugin_id">
[in] rendering plugin. (RhinoApp().GetDefaultRenderApp() returns the active rendering id)
</param>
            <param name="object_attributes">[in] object attributes</param>
            <param name="front_material">
[out] Pointer to front face material (never NULL) NOTE WELL: This pointer will be invalid
if the material table is changed. NEVER use this as a long term reference to a material.
</param>
            <param name="back_material">
[out] Pointer to back face material (never NULL) NOTE WELL: This pointer will be invalid
if the material table is changed. NEVER use this as a long term reference to a material.
</param>
            <returns>Material for object's front faces.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoMaterialTable.GetMaterials(System.Guid,RMA.OpenNURBS.IOnLayer,RMA.Rhino.IRhinoMaterial@,RMA.Rhino.IRhinoMaterial@)">
            <param name="plugin_id">
[in] rendering plugin. (RhinoApp().GetDefaultRenderApp() returns the active rendering id)
</param>
            <param name="layer">[in]</param>
            <param name="front_material">
[out] Pointer to front face material (never NULL) NOTE WELL: This pointer will be invalid
if the material table is changed. NEVER use this as a long term reference to a material.
</param>
            <param name="back_material">
[out] Pointer to back face material (never NULL) NOTE WELL: This pointer will be invalid
if the material table is changed. NEVER use this as a long term reference to a material.
</param>
            <returns>Material for object's front faces.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoMaterialTable.FindMaterial(RMA.OpenNURBS.IOnMaterial)">
            <summary>
ignores name, material index, and material_id
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoMaterialTable.FindMaterial(RMA.OpenNURBS.IOnMaterial,System.Boolean)">
            <summary>
ignores name, material index, and material_id
</summary>
        </member>
        <member name="P:RMA.Rhino.MRhinoMaterialTable.Item(System.Int32)">
            <summary>
Conceptually, the material table is an array of MaterialCount()
materials.  The operator[] can be used to get individual
materials.  A material is either active or deleted and this
state is reported by CRhinoMaterial::IsDeleted().
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoMaterialTable.MaterialCount">
            <returns>
Number of materials in the material table, including deleted materials.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoMaterialTable.Document">
            <summary>
Material tables store the list of materials in a Rhino document.
</summary>
            <returns>CRhinoDocument that owns this material table.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoMaterialTable.CurrentMaterialIndex">
            <summary>
At all times, there is a "current" material.  Unless otherwise
specified, new objects are assigned to the current layer.
The current layer is never locked, hidden, or deleted.
</summary>
            <returns>Zero based material table index of the current material.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoMaterialTable.GetMaterials(RMA.OpenNURBS.IOnMaterialRef,RMA.Rhino.IRhinoMaterial@,RMA.Rhino.IRhinoMaterial@)">
            <param name="material_ref">[in] material reference - can be NULL</param>
            <param name="front_material">
[out] Pointer to front face material (never NULL) NOTE WELL: This pointer will be invalid
if the material table is changed. NEVER use this as a long term reference to a material.
</param>
            <param name="back_material">
[out] Pointer to back face material (never NULL) NOTE WELL: This pointer will be invalid
if the material table is changed. NEVER use this as a long term reference to a material.
</param>
            <returns>Material for object's front faces.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoMaterialTable.GetMaterials(System.Guid,RMA.OpenNURBS.IOnRenderingAttributes,RMA.Rhino.IRhinoMaterial@,RMA.Rhino.IRhinoMaterial@)">
            <param name="plugin_id">
[in] rendering plugin. (RhinoApp().GetDefaultRenderApp() returns the active rendering id)
</param>
            <param name="rendering_attributes">[in] object or layer rendering attributes</param>
            <param name="front_material">
[out] Pointer to front face material (never NULL) NOTE WELL: This pointer will be invalid
if the material table is changed. NEVER use this as a long term reference to a material.
</param>
            <param name="back_material">
[out] Pointer to back face material (never NULL) NOTE WELL: This pointer will be invalid
if the material table is changed. NEVER use this as a long term reference to a material.
</param>
            <returns>Material for object's front faces.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoMaterialTable.GetMaterials(System.Guid,RMA.OpenNURBS.IOn3dmObjectAttributes,RMA.Rhino.IRhinoMaterial@,RMA.Rhino.IRhinoMaterial@)">
            <param name="plugin_id">
[in] rendering plugin. (RhinoApp().GetDefaultRenderApp() returns the active rendering id)
</param>
            <param name="object_attributes">[in] object attributes</param>
            <param name="front_material">
[out] Pointer to front face material (never NULL) NOTE WELL: This pointer will be invalid
if the material table is changed. NEVER use this as a long term reference to a material.
</param>
            <param name="back_material">
[out] Pointer to back face material (never NULL) NOTE WELL: This pointer will be invalid
if the material table is changed. NEVER use this as a long term reference to a material.
</param>
            <returns>Material for object's front faces.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoMaterialTable.GetMaterials(System.Guid,RMA.OpenNURBS.IOnLayer,RMA.Rhino.IRhinoMaterial@,RMA.Rhino.IRhinoMaterial@)">
            <param name="plugin_id">
[in] rendering plugin. (RhinoApp().GetDefaultRenderApp() returns the active rendering id)
</param>
            <param name="layer">[in]</param>
            <param name="front_material">
[out] Pointer to front face material (never NULL) NOTE WELL: This pointer will be invalid
if the material table is changed. NEVER use this as a long term reference to a material.
</param>
            <param name="back_material">
[out] Pointer to back face material (never NULL) NOTE WELL: This pointer will be invalid
if the material table is changed. NEVER use this as a long term reference to a material.
</param>
            <returns>Material for object's front faces.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoMaterialTable.FindMaterial(RMA.OpenNURBS.IOnMaterial)">
            <summary>
ignores name, material index, and material_id
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoMaterialTable.FindMaterial(RMA.OpenNURBS.IOnMaterial,System.Boolean)">
            <summary>
ignores name, material index, and material_id
</summary>
        </member>
        <member name="P:RMA.Rhino.IRhinoMaterialTable.Item(System.Int32)">
            <summary>
Conceptually, the material table is an array of MaterialCount()
materials.  The operator[] can be used to get individual
materials.  A material is either active or deleted and this
state is reported by CRhinoMaterial::IsDeleted().
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoMaterialTable.MaterialCount">
            <returns>
Number of materials in the material table, including deleted materials.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoMaterialTable.Document">
            <summary>
Material tables store the list of materials in a Rhino document.
</summary>
            <returns>CRhinoDocument that owns this material table.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoMaterial.InUse">
            <summary>
Returns: Number of objects and layers that use this material.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoMaterial.MaterialChannel(System.Int32)">
            <summary>
Returns: The material for the requested channel.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoMaterial.EmapBitmap">
            <summary>
Returns: Envrionment map bitmap or NULL
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoMaterial.BumpBitmap">
            <summary>
Returns: bump map bitmap or NULL
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoMaterial.TextureBitmap">
            <summary>
Returns: texture map bitmap or NULL
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoMaterial.IsDefaultMaterial">
            <summary>
By default Rhino layers and objects are assigned the default rendering material.
</summary>
            <returns>TRUE if this material is the default rendering material.</returns>
            <remarks>The default material is returned by RhinoApp().AppSettings().DefaultMaterial().</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoMaterial.IsReference">
            <summary>
Rhino allows multiple files to be viewed simultaneously.
Layers in the document are "normal" or "reference".
Reference layers are not saved.
</summary>
            <returns>
TRUE if layer is in a reference file and will not be saved as part of this document.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoMaterial.IsDeleted">
            <summary>
Deleted materials are kept in the runtime layer table
so that undo will work with layers.  Call IsDeleted()
to determine if a material is deleted.
</summary>
            <returns>TRUE if layer is deleted.</returns>
        </member>
        <member name="P:RMA.Rhino.MRhinoMaterial.m_remap_index">
            <value>
Runtime index used when remapping materials for import/export
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoMaterial.m_sort_index">
            <value>
Runtime index used to sort materials in material dialog
</value>
        </member>
        <member name="M:RMA.Rhino.IRhinoMaterial.InUse">
            <summary>
Returns: Number of objects and layers that use this material.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoMaterial.MaterialChannel(System.Int32)">
            <summary>
Returns: The material for the requested channel.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoMaterial.EmapBitmap">
            <summary>
Returns: Envrionment map bitmap or NULL
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoMaterial.BumpBitmap">
            <summary>
Returns: bump map bitmap or NULL
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoMaterial.TextureBitmap">
            <summary>
Returns: texture map bitmap or NULL
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoMaterial.IsDefaultMaterial">
            <summary>
By default Rhino layers and objects are assigned the default rendering material.
</summary>
            <returns>TRUE if this material is the default rendering material.</returns>
            <remarks>The default material is returned by RhinoApp().AppSettings().DefaultMaterial().</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoMaterial.IsReference">
            <summary>
Rhino allows multiple files to be viewed simultaneously.
Layers in the document are "normal" or "reference".
Reference layers are not saved.
</summary>
            <returns>
TRUE if layer is in a reference file and will not be saved as part of this document.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoMaterial.IsDeleted">
            <summary>
Deleted materials are kept in the runtime layer table
so that undo will work with layers.  Call IsDeleted()
to determine if a material is deleted.
</summary>
            <returns>TRUE if layer is deleted.</returns>
        </member>
        <member name="P:RMA.Rhino.IRhinoMaterial.m_remap_index">
            <value>
Runtime index used when remapping materials for import/export
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoMaterial.m_sort_index">
            <value>
Runtime index used to sort materials in material dialog
</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoBitmapTable.ExportToFiles(System.String)">
            <summary>Export all the bitmaps in the table to files.</summary>
            <param name="dirpath">
[in] full path to the directory where the bitmaps should be saved.
If NULL, a dialog is used to interactively get the directory name.
</param>
            <returns>
Number of bitmaps written.
See Also: CRhinoBitmap::ExportToFile
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoBitmapTable.ExportToFiles(System.String,System.Int32)">
            <summary>Export all the bitmaps in the table to files.</summary>
            <param name="dirpath">
[in] full path to the directory where the bitmaps should be saved.
If NULL, a dialog is used to interactively get the directory name.
</param>
            <param name="overwrite">
[in] 0 = no, 1 = yes, 2 = ask
</param>
            <returns>
Number of bitmaps written.
See Also: CRhinoBitmap::ExportToFile
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoBitmapTable.GetSortedList(RMA.Rhino.IRhinoBitmap[]@)">
            <summary>Gets an array of pointers to bitmaps that is sorted by the values of CRhinoBitmap::m_sort_index.</summary>
            <param name="sorted_list">
[out] this array is returned with length BitmapCount() and is sorted by the values of
CRhinoBitmap::m_sort_index.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoBitmapTable.DeleteBitmap(System.String)">
            <summary>Deletes bitmap</summary>
            <returns>
TRUE if successful. FALSE if bitmap_index is out of range or the
the bitmap cannot be deleted because it is the current bitmap or
because it bitmap contains active geometry.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoBitmapTable.AddBitmap(RMA.OpenNURBS.OnBitmap)">
            <summary>Adds a new bitmap with specified name to the bitmap table.</summary>
            <param name="pBitmap">
[in] an bitmap created with either new ON_WindowsBitmapEx() or new ON_EmbeddedBitmap().
If pBitmap-&gt;m_name is not set, a name will be provided.
</param>
            <returns>
NULL if the bitmap cannot be added or the name is in use.
See Also: CRhinoFileUtilities::FindFile CRhinoBitmapTable::Bitmap
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoBitmapTable.AddBitmap(RMA.OpenNURBS.OnBitmap,System.Boolean)">
            <summary>Adds a new bitmap with specified name to the bitmap table.</summary>
            <param name="pBitmap">
[in] an bitmap created with either new ON_WindowsBitmapEx() or new ON_EmbeddedBitmap().
If pBitmap-&gt;m_name is not set, a name will be provided.
</param>
            <param name="bReplaceExisting">
[in] If true and the there is alread a bitmap using the specified name, then that bitmap is replace.
If false and there is already a bitmap using the specified name, then NULL is returned.
</param>
            <returns>
NULL if the bitmap cannot be added or the name is in use.
See Also: CRhinoFileUtilities::FindFile CRhinoBitmapTable::Bitmap
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoBitmapTable.AddBitmap(System.String)">
            <summary>Adds a new bitmap with specified name to the bitmap table.</summary>
            <param name="bitmap_filename">
[in] If NULL or empty, then a unique name of the form "Bitmap 01" will be automatically created.
</param>
            <returns>
NULL if the bitmap cannot be found on disk or the name is in use.
See Also: CRhinoFileUtilities::FindFile CRhinoBitmapTable::Bitmap
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoBitmapTable.AddBitmap(System.String,System.Boolean)">
            <summary>Adds a new bitmap with specified name to the bitmap table.</summary>
            <param name="bitmap_filename">
[in] If NULL or empty, then a unique name of the form "Bitmap 01" will be automatically created.
</param>
            <param name="bReplaceExisting">
[in] If true and the there is alread a bitmap using the specified name, then that bitmap is replace.
If false and there is already a bitmap using the specified name, then NULL is returned.
</param>
            <returns>
NULL if the bitmap cannot be found on disk or the name is in use.
See Also: CRhinoFileUtilities::FindFile CRhinoBitmapTable::Bitmap
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoBitmapTable.Bitmap(System.String)">
            <summary>Get a bitmap.</summary>
            <param name="bitmap_filename">[in] name of bitmap to search for. The search ignores case.</param>
            <returns>NULL if the bitmap could not be found, otherwise a pointer to the bitmap is returned.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoBitmapTable.Bitmap(System.String,System.Boolean)">
            <summary>Get a bitmap.</summary>
            <param name="bitmap_filename">[in] name of bitmap to search for. The search ignores case.</param>
            <param name="bLoadFromFile">
[in] if true, and the bitmap is on disk but not in the current table, then the bitmap is added to the table.
</param>
            <returns>NULL if the bitmap could not be found, otherwise a pointer to the bitmap is returned.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoBitmapTable.FindBitmap(System.Guid,System.Boolean)">
            <summary>
Parameters: i - [in] 0 &lt;= i &lt; BitmapCount() Returns: Pointer to bitmap or NULL.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoBitmapTable.BitmapCount">
            <summary>
Description:
 Bitmap tables store the list of bitmaps in a
 Rhino document.
Returns:
  CRhinoDocument that owns this bitmap table.
</summary>
            <summary>
Returns: Number of bitmaps in the table.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoBitmapTable.ExportToFiles(System.String)">
            <summary>Export all the bitmaps in the table to files.</summary>
            <param name="dirpath">
[in] full path to the directory where the bitmaps should be saved.
If NULL, a dialog is used to interactively get the directory name.
</param>
            <returns>
Number of bitmaps written.
See Also: CRhinoBitmap::ExportToFile
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoBitmapTable.ExportToFiles(System.String,System.Int32)">
            <summary>Export all the bitmaps in the table to files.</summary>
            <param name="dirpath">
[in] full path to the directory where the bitmaps should be saved.
If NULL, a dialog is used to interactively get the directory name.
</param>
            <param name="overwrite">
[in] 0 = no, 1 = yes, 2 = ask
</param>
            <returns>
Number of bitmaps written.
See Also: CRhinoBitmap::ExportToFile
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoBitmapTable.GetSortedList(RMA.Rhino.IRhinoBitmap[]@)">
            <summary>Gets an array of pointers to bitmaps that is sorted by the values of CRhinoBitmap::m_sort_index.</summary>
            <param name="sorted_list">
[out] this array is returned with length BitmapCount() and is sorted by the values of
CRhinoBitmap::m_sort_index.
</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoBitmapTable.Bitmap(System.String)">
            <summary>Get a bitmap.</summary>
            <param name="bitmap_filename">[in] name of bitmap to search for. The search ignores case.</param>
            <returns>NULL if the bitmap could not be found, otherwise a pointer to the bitmap is returned.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoBitmapTable.Bitmap(System.String,System.Boolean)">
            <summary>Get a bitmap.</summary>
            <param name="bitmap_filename">[in] name of bitmap to search for. The search ignores case.</param>
            <param name="bLoadFromFile">
[in] if true, and the bitmap is on disk but not in the current table, then the bitmap is added to the table.
</param>
            <returns>NULL if the bitmap could not be found, otherwise a pointer to the bitmap is returned.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoBitmapTable.BitmapCount">
            <summary>
Description:
 Bitmap tables store the list of bitmaps in a
 Rhino document.
Returns:
  CRhinoDocument that owns this bitmap table.
</summary>
            <summary>
Returns: Number of bitmaps in the table.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoBitmap.ExportToFile(System.String)">
            <summary>Write the bitmap to a file.</summary>
            <param name="fullpath">[in] full path, including file name and extension, name of the file to write.</param>
            <returns>
True if successful.
See Also: CRhinoBitmapTable::ExportToFiles
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoBitmap.BitmapTableIndex">
            <summary>Get array index of the bitmap in the bitmap table.</summary>
            <returns>
-1: The bitmap is not in the bitmap table
&gt;=0: Index of the bitmap in the bitmap table.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoBitmap.Dib">
            <summary>Gets a CRhinoDib of the bitmap</summary>
            <returns>If successful, a pointer to a CRhinoDib. The caller is responsible for deleting this CRhinoDib.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoBitmap.Dib(RMA.Rhino.MRhinoDib)">
            <summary>Gets a CRhinoDib of the bitmap</summary>
            <param name="dib">[in] if not NULL, the dib is put into this bitmap.</param>
            <returns>If successful, a pointer to a CRhinoDib. The caller is responsible for deleting this CRhinoDib.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoBitmap.BitmapName">
            <summary>
Returns: Bitmap name. When the bitmap is an embedded bitmap file, the full path to the file is returned.
</summary>
        </member>
        <member name="P:RMA.Rhino.MRhinoBitmap.m_remap_index">
            <value>
Runtime index used when remapping bitmaps for import/export
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoBitmap.m_sort_index">
            <value>
Runtime index used to sort bitmaps in bitmap dialog
</value>
        </member>
        <member name="M:RMA.Rhino.IRhinoBitmap.ExportToFile(System.String)">
            <summary>Write the bitmap to a file.</summary>
            <param name="fullpath">[in] full path, including file name and extension, name of the file to write.</param>
            <returns>
True if successful.
See Also: CRhinoBitmapTable::ExportToFiles
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoBitmap.BitmapTableIndex">
            <summary>Get array index of the bitmap in the bitmap table.</summary>
            <returns>
-1: The bitmap is not in the bitmap table
&gt;=0: Index of the bitmap in the bitmap table.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoBitmap.Dib">
            <summary>Gets a CRhinoDib of the bitmap</summary>
            <returns>If successful, a pointer to a CRhinoDib. The caller is responsible for deleting this CRhinoDib.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoBitmap.Dib(RMA.Rhino.MRhinoDib)">
            <summary>Gets a CRhinoDib of the bitmap</summary>
            <param name="dib">[in] if not NULL, the dib is put into this bitmap.</param>
            <returns>If successful, a pointer to a CRhinoDib. The caller is responsible for deleting this CRhinoDib.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoBitmap.BitmapName">
            <summary>
Returns: Bitmap name. When the bitmap is an embedded bitmap file, the full path to the file is returned.
</summary>
        </member>
        <member name="P:RMA.Rhino.IRhinoBitmap.m_remap_index">
            <value>
Runtime index used when remapping bitmaps for import/export
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoBitmap.m_sort_index">
            <value>
Runtime index used to sort bitmaps in bitmap dialog
</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoNativeReplaceColorDialog.ColorDialog(System.Windows.Forms.IWin32Window,RMA.OpenNURBS.OnColor@,System.Boolean,System.String)">
            <summary>Method which gets called by Rhino when it is ready to display a color picker dialog.</summary>
            <param name="hWndParent">
[in] Handle to window that is the parent for the color dialog.
If this is NULL the main Rhino window handle is used.
</param>
            <param name="color">
[in/out] Used initially as the default color for the dialog.
If ColorDialog() returns true then it should be set to selected color.
</param>
            <param name="bIncludeButtonColors">
[in] If true then the color dialog should include standard button face and button text color options,
these are used by the tool bar button bitmap editor.
</param>
            <param name="lpsDialogTitle">[in] Dialog title</param>
            <returns>true if OK button was pressed in dialog or false if dialog was canceled.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoReplaceColorDialog.CurrentColorDialog">
            <summary>Call this method to get the current color dialog replacement.</summary>
            <returns>the current color dialog replacement.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoReplaceColorDialog.PreviousColorDialog">
            <summary>Call this method to get the color dialog replacement that was active prior to this one.</summary>
            <returns>the color dialog replacement that was active prior to this one.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoReplaceColorDialog.ColorDialog(System.Windows.Forms.IWin32Window,RMA.OpenNURBS.OnColor@,System.Boolean,System.String)">
            <summary>Method which gets called by Rhino when it is ready to display a color picker dialog.</summary>
            <param name="hWndParent">
[in] Handle to window that is the parent for the color dialog.
If this is NULL the main Rhino window handle is used.
</param>
            <param name="color">
[in/out] Used initially as the default color for the dialog.
If ColorDialog() returns true then it should be set to selected color.
</param>
            <param name="bIncludeButtonColors">
[in] If true then the color dialog should include standard button face and button text color options,
these are used by the tool bar button bitmap editor.
</param>
            <param name="lpsDialogTitle">[in] Dialog title</param>
            <returns>true if OK button was pressed in dialog or false if dialog was canceled.</returns>
        </member>
        <member name="P:RMA.Rhino.MRhinoContourInput.m_CountIncrement">
            <value>
default is 1
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoContourInput.m_bShowCount">
            <value>
default is false
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoContourInput.m_bGroupByContourPlane">
            <value>
default is false
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoContourInput.m_bAddOutputToDocument">
            <value>
default is false
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoContourInput.m_JoinCurves">
            <value>
0 = NoJoin, 1 = ByPolySurface, 2 = ByContourPlane
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoContourInput.m_AssignLayerBy">
            <value>
0 = CurrentLayer, 1 = InputObject
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoContourInput.m_limit_range">
            <value>
true if contours are only to be made between m_basept and m_endpt
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoContourInput.m_interval">
            <value>
distance between contours
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoContourInput.m_endpt">
            <value>
endpoint for vector that is normal to contour planes and used as contour limit if m_limit_range is true
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoContourInput.m_basept">
            <value>
basepoint for vector that is normal to contour planes and used as contour limit if m_limit_range is true
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoContourInput.m_CountIncrement">
            <value>
default is 1
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoContourInput.m_bShowCount">
            <value>
default is false
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoContourInput.m_bGroupByContourPlane">
            <value>
default is false
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoContourInput.m_bAddOutputToDocument">
            <value>
default is false
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoContourInput.m_JoinCurves">
            <value>
0 = NoJoin, 1 = ByPolySurface, 2 = ByContourPlane
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoContourInput.m_AssignLayerBy">
            <value>
0 = CurrentLayer, 1 = InputObject
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoContourInput.m_limit_range">
            <value>
true if contours are only to be made between m_basept and m_endpt
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoContourInput.m_interval">
            <value>
distance between contours
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoContourInput.m_endpt">
            <value>
endpoint for vector that is normal to contour planes and used as contour limit if m_limit_range is true
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoContourInput.m_basept">
            <value>
basepoint for vector that is normal to contour planes and used as contour limit if m_limit_range is true
</value>
        </member>
        <member name="M:RMA.Rhino.MRhinoDump.AppendText(System.String)">
            <summary>
appends UNICODE text to log
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDocProperties.SetGridDefaults(RMA.OpenNURBS.IOn3dmConstructionPlaneGridDefaults)">
            <summary>default settings for construction plane grids</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDocProperties.GridDefaults">
            <summary>default settings for construction plane grids</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDocProperties.DisplayCurvesAndIsocurvesInRenderedViews">
            <summary>
Rendered view display mode settings
If from_doc == true then values are always returned from CRhinoDocProperties
otherwise CRhinoAppSettings::GetRenderedViewSettingsFromDoc() determines
where the values are returned from.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDocProperties.DisplayCurvesAndIsocurvesInRenderedViews(System.Boolean)">
            <summary>
Rendered view display mode settings
If from_doc == true then values are always returned from CRhinoDocProperties
otherwise CRhinoAppSettings::GetRenderedViewSettingsFromDoc() determines
where the values are returned from.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDocProperties.RemoveNamedView(System.Int32)">
            <summary>Get zero based index of named view</summary>
            <param name="view_index">[in]</param>
            <returns>TRUE if view was removed.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDocProperties.NamedViewIndex(RMA.OpenNURBS.IOn3dmView)">
            <summary>Get zero based index of named view</summary>
            <param name="view">[in]</param>
            <returns>
0 based index of named view or -1 if view is not one of documents named views.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDocProperties.AddNamedView(RMA.OpenNURBS.IOn3dmView)">
            <summary>Add named construction plane to document.</summary>
            <param name="named_view">[in]</param>
            <remarks>
If named_view has an empty name, a unique name is automatically created.
If there is already a named view with the same name, that view is replaced.
</remarks>
            <returns>
&gt;= 0 : success 0 based index of named view.
-1 : failure invalid plane
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDocProperties.AddNamedConstructionPlane(RMA.OpenNURBS.IOn3dmConstructionPlane)">
            <summary>Add named construction plane to document.</summary>
            <param name="named_cplane">[in]</param>
            <remarks>
If named_cplane has an empty name, a unique name is automatically created.
If there is already a named onstruction plane with the same name, that
construction plane is replaced.
</remarks>
            <returns>
&gt;= 0 : success 0 based index of named construction plane.
-1 : failure invalid plane
See Also: CRhinoDocProperties::NamedConstructionPlane
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDocProperties.NamedView(System.String)">
            <summary>Find a named view</summary>
            <param name="name">[in]</param>
            <returns>pointer to named construction plane</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDocProperties.RemoveNamedConstructionPlane(System.Int32)">
            <summary>Get zero based index of named construction plane</summary>
            <param name="cplane_index">[in]</param>
            <returns>TRUE if plane was removed.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDocProperties.NamedConstructionPlaneIndex(RMA.OpenNURBS.IOn3dmConstructionPlane)">
            <summary>Get zero based index of named construction plane</summary>
            <param name="cplane">[in]</param>
            <returns>
0 based index of named construction plane or -1 if cplane is not one of documents named construction planes.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDocProperties.NamedConstructionPlane(System.String)">
            <summary>Find a named construction plane</summary>
            <param name="name">[in]</param>
            <returns>pointer to named construction plane</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoDocProperties.AnnotationSettings">
            <summary>
settings used when annotation objects are created
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDocProperties.AnalysisMeshSettings">
            <summary>
settings used for automatically created analysis meshes
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDocProperties.RenderMeshSettings">
            <summary>
settings used for automatically created rendering meshes
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoDocProperties.SetFromSettings(RMA.OpenNURBS.IOn3dmSettings)">
            <remarks>
These settings fields are ignored because they are specified elsewhere.
settings.m_views                   CRhinoDoc::GetViewList
settings.m_current_layer_index     CRhinoDoc::m_layer_table
settings.m_current_material_index  CRhinoDoc::m_material_table
settings.m_current_material_source CRhinoDoc::m_material_table
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoDocProperties.GetCurrentSettings(RMA.OpenNURBS.On3dmSettings@)">
            <summary>Fill in an ON_3dmSettings class with the values of the current document settings.</summary>
            <param name="settings">[out]</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoDocProperties.GridDefaults">
            <summary>default settings for construction plane grids</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDocProperties.DisplayCurvesAndIsocurvesInRenderedViews">
            <summary>
Rendered view display mode settings
If from_doc == true then values are always returned from CRhinoDocProperties
otherwise CRhinoAppSettings::GetRenderedViewSettingsFromDoc() determines
where the values are returned from.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDocProperties.DisplayCurvesAndIsocurvesInRenderedViews(System.Boolean)">
            <summary>
Rendered view display mode settings
If from_doc == true then values are always returned from CRhinoDocProperties
otherwise CRhinoAppSettings::GetRenderedViewSettingsFromDoc() determines
where the values are returned from.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDocProperties.NamedViewIndex(RMA.OpenNURBS.IOn3dmView)">
            <summary>
Description: Get zero based index of named view Paramters: view - [in] Returns: 0 based index of named view or -1 if view is not one of documents named views. See Also: CRhinoDocProperties::NamedView CRhinoDocProperties::NamedViewIndex CRhinoDocProperties::AddNamedView CRhinoDocProperties::RemoveNamedViewIndex
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDocProperties.NamedView(System.String)">
            <summary>Find a named view</summary>
            <param name="name">[in]</param>
            <returns>pointer to named construction plane</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDocProperties.NamedConstructionPlaneIndex(RMA.OpenNURBS.IOn3dmConstructionPlane)">
            <summary>Get zero based index of named construction plane</summary>
            <param name="cplane">[in]</param>
            <returns>
0 based index of named construction plane or -1 if cplane is not one of documents named construction planes.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDocProperties.NamedConstructionPlane(System.String)">
            <summary>Find a named construction plane</summary>
            <param name="name">[in]</param>
            <returns>pointer to named construction plane</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoDocProperties.AnnotationSettings">
            <summary>
settings used when annotation objects are created
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDocProperties.AnalysisMeshSettings">
            <summary>
settings used for automatically created analysis meshes
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDocProperties.RenderMeshSettings">
            <summary>
settings used for automatically created rendering meshes
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoDocProperties.GetCurrentSettings(RMA.OpenNURBS.On3dmSettings@)">
            <summary>Fill in an ON_3dmSettings class with the values of the current document settings.</summary>
            <param name="settings">[out]</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoAnnotationSettings.op_Equality(RMA.Rhino.MRhinoAnnotationSettings,RMA.Rhino.IRhinoAnnotationSettings)">
            <summary>
the compare operators are used to test for changed settings
</summary>
        </member>
        <member name="T:RMA.Rhino.MRhinoAnnotationSettings">
            <summary>Doc scope settings that apply to annotation objects</summary>
        </member>
        <member name="T:RMA.Rhino.IRhinoAnnotationSettings">
            <summary>Doc scope settings that apply to annotation objects</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.CopyFrom(RMA.Rhino.IRhinoViewport)">
            <summary>
Similar to an operator= except this will not modify the viewport id unless told to.
Items not copied are: m_draw_step, m_vp_iteration, m_xform_iteration, m_dp
                     m_view_stack, m_view_stack_index, m_cplane_stack, m_cplane_stack_index
</summary>
            <param name="src">[in]: CRhinoViewport ot copy information from</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.CopyFrom(RMA.Rhino.IRhinoViewport,System.Boolean)">
            <summary>
Similar to an operator= except this will not modify the viewport id unless told to.
Items not copied are: m_draw_step, m_vp_iteration, m_xform_iteration, m_dp
                     m_view_stack, m_view_stack_index, m_cplane_stack, m_cplane_stack_index
</summary>
            <param name="src">[in]: CRhinoViewport ot copy information from</param>
            <param name="copy_id">
[in]: If true, this viewport's id will be changed to match that of src. This is
typically NOT something that you want to do. This set to true for operations
like printing in order to work with a temporary CRhinoViewport that is an
exact duplicate of teh src viewport
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.IsPageViewMainViewport">
            <summary>
Determines if this viewport is the main viewport for a page view. Page views
should be able to be panned and zoomed, but not rotated or changed to a
different camera view vector. This is used by functions that attempt to set the
viewport's projection. If the projection is not compatible with a page view and
IsPageViewMainViewport() == true, then the setting of the projection is not allowed
</summary>
            <returns>true if thie viewport is the main viewport for a CRhinoPageView</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.ClientToScreenPort(System.Drawing.Point@)">
            <summary>
Convert a point in parent CRhinoView client window coordinates to the ON_Viewport screen port
client coordinates. The screen port of a CRhinoViewport may not match the client area of
the parent CRhinoView. This occurs in cases when the CRhinoViewport is a nested child viewport
</summary>
            <param name="pt">
[in/out]: point in client coordinates of parent CRhinoView window as input. This is
converted to the screen port client coordinates of the ON_Viewport as output
</param>
            <returns>true if the point is inside of the CRhinoViewport's screen port rectangle</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.GetPickXform(System.Drawing.Rectangle,RMA.OpenNURBS.OnXform@)">
            <summary>
GetPickXform takes a rectangle in screen coordinates and returns 
a transformation that maps the 3d frustum defined by the rectangle
to a -1/+1 clipping coordinate box.
</summary>
            <param name="rect">screen coordinates of a rectangle defining the picking frustum</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.GetPickXform(System.Int32,System.Int32,RMA.OpenNURBS.OnXform@)">
            <summary>
GetPickXform takes a rectangle in screen coordinates and returns 
a transformation that maps the 3d frustum defined by the rectangle
to a -1/+1 clipping coordinate box.
</summary>
            <param name="x">screen coordinates of a mouse click</param>
            <param name="y">screen coordinates of a mouse click</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.GetMarkedObjectXform(System.Int32@,RMA.OpenNURBS.OnXform@)">
            <summary>Get the display transformation that is applied to marked objects.</summary>
            <param name="mark_value">[out]</param>
            <param name="marked_object_xform">[out]</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetMarkedObjectXform(System.Int32,RMA.OpenNURBS.IOnXform)">
            <summary>Set the display transformation that is applied to marked objects.</summary>
            <param name="mark_value">
[in] if not zero, then objects with this mark value are displayed using the marked_object_xform.
</param>
            <param name="marked_object_xform">[in]</param>
            <remarks>
The default marked object transformation is the identity. The marked object
transformation is intended to be used when inserting models.
See Also: CRhinoViewport::SetModelXform CRhinoViewport::GetMarkedObjectXform
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.GetDisplayXform(RMA.OpenNURBS.OnXform@)">
            <summary>
Get the display transformation that is applied to the projected geometry immediately before it is drawn.
</summary>
            <param name="display_xform">[out]</param>
            <remarks>
The default display transformation is the identity. The display transformation is
intended to be used in printing applications. The camera and projection transformations
are handled in the m_v settings.
See Also: CRhinoViewport::SetDisplayXform
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetDisplayXform(RMA.OpenNURBS.IOnXform)">
            <summary>
Set the display transformation that is applied to the projected geometry immediately before it is drawn.
</summary>
            <param name="display_xform">[in]</param>
            <remarks>
The default display transformation is the identity. The display transformation
is intended to be used in printing applications. The camera and projection
transformations are handled in the m_v settings.
See Also: CRhinoViewport::SetModelXform CRhinoViewport::GetDisplayXform
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.GetModelXform(RMA.OpenNURBS.OnXform@)">
            <summary>Get the model transformation that is applied to geometry before it is drawn.</summary>
            <param name="model_xform">[out]</param>
            <remarks>
The default model transformation is the identity. The model transformation
is intended to be used for dynamic drawing of objects. The camera and
projection transformations are handled in the m_v settings.
See Also: CRhinoViewport::SetModelXform
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetModelXform(RMA.OpenNURBS.IOnXform)">
            <summary>Set the model transformation that is applied to geometry before it is drawn.</summary>
            <param name="model_xform">[in]</param>
            <remarks>
The default model transformation is the identity. The model transformation
is intended to be used for dynamic drawing of objects. The camera and projection
transformations are handled in the m_v settings.
See Also: CRhinoViewport::SetDisplayXform CRhinoViewport::GetModelXform
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.Magnify(System.Double,System.Int32)">
            <param name="style">
0 performs a dolly magnification by moving the camera towards/away from
the target so that the amount of the screen subtended by an object changes.
1 performs a zoom magnification by adjusting the lense angle           
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.Magnify(System.Double,System.Int32,System.Drawing.Point)">
            <param name="style">
0 performs a dolly magnification by moving the camera towards/away from
the target so that the amount of the screen subtended by an object changes.
1 performs a zoom magnification by adjusting the lense angle           
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.InOutDolly(System.Double)">
            <summary>
out &lt; 0 &lt; in
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DownUpDolly(System.Double)">
            <summary>
down &lt; 0 &lt; up
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.LeftRightDolly(System.Double)">
            <summary>
left &lt; 0 &lt; right
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DownUpRotate(System.Double)">
            <summary>
down &lt; 0 &lt; up
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.LeftRightRotate(System.Double)">
            <summary>
left &lt; 0 &lt; right
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.MouseRotateCamera(System.Drawing.Point,System.Drawing.Point)">
            <summary>
Rotate view around camera location.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.MouseRotateView(System.Drawing.Point,System.Drawing.Point)">
            <summary>
Rotate view around target.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DollyExtents(RMA.OpenNURBS.IOnBoundingBox,RMA.OpenNURBS.IOn.coordinate_system)">
            <summary>
Dolly the camera (change its location) so that the bbox is centered in the viewport
and fills the central region of the viewport. The "target" point is updated
to be the center of the bounding box.
</summary>
            <param name="bbox">[in]</param>
            <param name="cs">
[in] coordinates system of the bounding box.
NOTE WELL: If cs is anything besides ON::world_cs, the the coodinates are with
respect to the current projection returned by this-&gt;VP(). Note that the call
to DollyExtents will change the projection so that any non-world coordinate bbox
will not be valid after the function returns. If this is confusing, then
restrict yourself to using world coordinate bounding boxes and cs = ON::world_cs.
</param>
            <remarks>
The Rhino "ZoomExtents" command uses DollyExtents to calculate the
view projection. Technically, "zoom" would leave the camera location
fixed and modify the camera angle.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.IsPlanView">
            <returns>true if construction plane z axis is parallel to camera direction.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.ClearUndoInformation">
            <summary>Clears saved view projections and cplanes.</summary>
            <remarks>
This function should be used only in special circumstances, like when a new file is read.
Calling this function destroys the information needed in commands likeUndoView and
CPlaneNext/CPlanePrevious.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.ClearUndoInformation(System.Boolean)">
            <summary>Clears saved view projections and cplanes.</summary>
            <param name="bClearProjections">[in] if true, then saved view projections are cleared.</param>
            <remarks>
This function should be used only in special circumstances, like when a new file is read.
Calling this function destroys the information needed in commands likeUndoView and
CPlaneNext/CPlanePrevious.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.ClearUndoInformation(System.Boolean,System.Boolean)">
            <summary>Clears saved view projections and cplanes.</summary>
            <param name="bClearProjections">[in] if true, then saved view projections are cleared.</param>
            <param name="bClearCPlanes">[in] if true, then saved construction planes are cleared.</param>
            <remarks>
This function should be used only in special circumstances, like when a new file is read.
Calling this function destroys the information needed in commands likeUndoView and
CPlaneNext/CPlanePrevious.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.PrevViewProjection">
            <summary>
Sets the view projection and target to the settings that
were active before the last call to NextViewProjection.
</summary>
            <returns>true if the view stack was popped.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.NextViewProjection">
            <summary>
Sets the view projection and target to the settings that
were active before the last call to PrevView.
</summary>
            <returns>true if the view stack was popped.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.PopViewProjection">
            <summary>
Sets the view projection and target to the settings
at the top of the view stack and removes those settings
from the view stack.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.PushViewProjection">
            <summary>Appends the current view projection and target to the viewport's view stack.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetToPerspectiveView">
            <summary>Set view to bird's eye perspective projection.</summary>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetToPerspectiveView(System.String)">
            <summary>Set view to bird's eye perspective projection.</summary>
            <param name="sViewName">[in] if not NULL, then view name is also set</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetToPerspectiveView(System.String,System.Boolean)">
            <summary>Set view to bird's eye perspective projection.</summary>
            <param name="sViewName">[in] if not NULL, then view name is also set</param>
            <param name="bUpdateConstructionPlane">[in] if true, then the construction plane is set to the view plane.</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetToBackView">
            <summary>Set view to parallel projection with world Z pointing up and world X pointing to the left.</summary>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetToBackView(System.String)">
            <summary>Set view to parallel projection with world Z pointing up and world X pointing to the left.</summary>
            <param name="sViewName">[in] if not NULL, then view name is also set</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetToBackView(System.String,System.Boolean)">
            <summary>Set view to parallel projection with world Z pointing up and world X pointing to the left.</summary>
            <param name="sViewName">[in] if not NULL, then view name is also set</param>
            <param name="bUpdateConstructionPlane">[in] if true, then the construction plane is set to the view plane.</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetToFrontView">
            <summary>Set view to parallel projection with world Z pointing up and world X pointing to the right.</summary>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetToFrontView(System.String)">
            <summary>Set view to parallel projection with world Z pointing up and world X pointing to the right.</summary>
            <param name="sViewName">[in] if not NULL, then view name is also set</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetToFrontView(System.String,System.Boolean)">
            <summary>Set view to parallel projection with world Z pointing up and world X pointing to the right.</summary>
            <param name="sViewName">[in] if not NULL, then view name is also set</param>
            <param name="bUpdateConstructionPlane">[in] if true, then the construction plane is set to the view plane.</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetToRightView">
            <summary>Set view to parallel projection with world Z pointing up and world Y pointing to the right.</summary>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetToRightView(System.String)">
            <summary>Set view to parallel projection with world Z pointing up and world Y pointing to the right.</summary>
            <param name="sViewName">[in] if not NULL, then view name is also set</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetToRightView(System.String,System.Boolean)">
            <summary>Set view to parallel projection with world Z pointing up and world Y pointing to the right.</summary>
            <param name="sViewName">[in] if not NULL, then view name is also set</param>
            <param name="bUpdateConstructionPlane">[in] if true, then the construction plane is set to the view plane.</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetToLeftView">
            <summary>Set view to parallel projection with world Z pointing up and world Y pointing to the left.</summary>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetToLeftView(System.String)">
            <summary>Set view to parallel projection with world Z pointing up and world Y pointing to the left.</summary>
            <param name="sViewName">[in] if not NULL, then view name is also set</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetToLeftView(System.String,System.Boolean)">
            <summary>Set view to parallel projection with world Z pointing up and world Y pointing to the left.</summary>
            <param name="sViewName">[in] if not NULL, then view name is also set</param>
            <param name="bUpdateConstructionPlane">[in] if true, then the construction plane is set to the view plane.</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetToBottomView">
            <summary>Set view to parallel projection with world Y pointing down and world X pointing to the right.</summary>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetToBottomView(System.String)">
            <summary>Set view to parallel projection with world Y pointing down and world X pointing to the right.</summary>
            <param name="sViewName">[in] if not NULL, then view name is also set</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetToBottomView(System.String,System.Boolean)">
            <summary>Set view to parallel projection with world Y pointing down and world X pointing to the right.</summary>
            <param name="sViewName">[in] if not NULL, then view name is also set</param>
            <param name="bUpdateConstructionPlane">[in] if true, then the construction plane is set to the view plane.</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetToTopView">
            <summary>Set view to parallel top view projection.</summary>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetToTopView(System.String)">
            <summary>Set view to parallel top view projection.</summary>
            <param name="sViewName">[in] if not NULL, then view name is also set</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetToTopView(System.String,System.Boolean)">
            <summary>Set view to parallel top view projection.</summary>
            <param name="sViewName">[in] if not NULL, then view name is also set</param>
            <param name="bUpdateConstructionPlane">[in] if true, then the construction plane is set to the view plane.</param>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.GetElevatorHeight(RMA.OpenNURBS.IOnLine,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,System.Boolean,System.Double,System.Double@)">
            <summary>Calculate elevator mode point</summary>
            <param name="world_line">[in] line from near to far clipping plane that projects to mouse point.</param>
            <param name="elevator_basepoint">[in]</param>
            <param name="elevator_axis">[in] unit vector</param>
            <param name="bGridSnap">[in] true if grid snap is enabled. When in doubt, use value of RhinoApp().AppSettings().GridSnap().</param>
            <param name="grid_snap_spacing">[in] grid snap distance. When in doubt, use value of ConstructionPlane().m_snap_spacing</param>
            <param name="elevator_height">[out] elevator height returned here.</param>
            <returns>
true if point is successfully calculated.  The 3d location
is elevator_basepoint + elevator_height*elevator_axis.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.IsZUp">
            <summary>viewports are either x-up, y-up, or z-up</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.IsYUp">
            <summary>viewports are either x-up, y-up, or z-up</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.IsXUp">
            <summary>viewports are either x-up, y-up, or z-up</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.ShowWorldAxes">
            <summary>
controls display of world axes icon
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.ShowConstructionAxes">
            <summary>
controls display of construction plane axes
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.ShowConstructionGrid">
            <summary>
controls display of construction plane grid
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.PrevConstructionPlane">
            <summary>
Sets the construction plane to the plane that was active before
the last call to NextConstructionPlane or SetConstructionPlane.
</summary>
            <returns>true if a construction plane was popped.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.NextConstructionPlane">
            <summary>
Sets the construction plane to the plane that was
active before the last call to PrevConstructionPlane.
</summary>
            <returns>true if a construction plane was popped.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.PopConstructionPlane">
            <summary>
Sets the construction plane to the plane that was
active before the last call to PushConstructionPlane.
</summary>
            <returns>true if a construction plane was popped.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.PushConstructionPlane(RMA.OpenNURBS.IOn3dmConstructionPlane)">
            <summary>
Pushes the current construction plane on the viewport's
construction plane stack and sets the construction plane to cplane.
</summary>
            <returns>true if a construction plane was popped.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetConstructionPlane(RMA.OpenNURBS.IOn3dmConstructionPlane)">
            <summary>Sets the construction plane to cplane.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.ConstructionPlane">
            <summary>
Returns: Viewport construction plane
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetCameraDirection(RMA.OpenNURBS.IOn3dVector)">
            <summary>
Set viewport camera direction. By default the target location is changed so that the
vector from the camera location to the target is parallel to the camera direction.
</summary>
            <param name="camera_direction">[in] new camera direction</param>
            <remarks>
See the remarks section of CRhinoViewport::SetTarget for important details.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetCameraDirection(RMA.OpenNURBS.IOn3dVector,System.Boolean)">
            <summary>
Set viewport camera direction. By default the target location is changed so that the
vector from the camera location to the target is parallel to the camera direction.
</summary>
            <param name="camera_direction">[in] new camera direction</param>
            <param name="bUpdateTargetLocation">
[in] if true, the target location is changed so that the vector from the camera
location to the target is parallel to the camera direction. If false, the target
location is not changed.
See the remarks section of CRhinoViewport::SetTarget for important details.
</param>
            <remarks>
See the remarks section of CRhinoViewport::SetTarget for important details.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetCameraLocation(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Set viewport camera location. By default the target location is changed so that
the vector from the camera location to the target is parallel to the camera direction vector.
</summary>
            <param name="camera_location">[in] new target location</param>
            <remarks>
See the remarks section of CRhinoViewport::SetTarget for important details.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetCameraLocation(RMA.OpenNURBS.IOn3dPoint,System.Boolean)">
            <summary>
Set viewport camera location. By default the target location is changed so that
the vector from the camera location to the target is parallel to the camera direction vector.
</summary>
            <param name="camera_location">[in] new target location</param>
            <param name="bUpdateTargetLocation">
[in] if true, the target location is changed so that the vector from the camera
location to the target is parallel to the camera direction vector. If false, the
target location is not changed. See the remarks section of CRhinoViewport::SetTarget
for important details.
</param>
            <remarks>
See the remarks section of CRhinoViewport::SetTarget for important details.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetTargetAndCameraLocation(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Set viewport camera location and target location. By default the camera direction
vector is changed so that it is parallel to the vector from the camera location to the target location.
</summary>
            <param name="target_location">[in] new target location</param>
            <param name="camera_location">[in] new camera location</param>
            <remarks>
See the remarks section of CRhinoViewport::SetTarget for important details.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetTargetAndCameraLocation(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,System.Boolean)">
            <summary>
Set viewport camera location and target location. By default the camera direction
vector is changed so that it is parallel to the vector from the camera location to the target location.
</summary>
            <param name="target_location">[in] new target location</param>
            <param name="camera_location">[in] new camera location</param>
            <param name="bUpdateCameraDirection">
[in] if true, the camera direction vector is changed so that it is parallel
to the vector from the camera location to the target location. If false, the
camera direction vector is not changed. See the remarks section of
CRhinoViewport::SetTarget for important details.
</param>
            <remarks>
See the remarks section of CRhinoViewport::SetTarget for important details.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetTarget(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Set viewport target point. By default the camera location is translated so that
the camera direction vector is parallel to the vector from the camera location
to the target location.
</summary>
            <param name="target_location">[in] new target location</param>
            <remarks>
In general, Rhino users expect to have the camera direction vector and the vector
from the camera location to the target location to be parallel. If you use the
CRhinoViewport functions listed in the see also section to set the camera location,
camera direction, and target point, then the relationship between these three points
and vectors is automatically maintained. If you directly manipulate the camera by
using the CRhinoViewport::SetVP member function, then you should carefully set the
target by calling SetTarget() with bUpdateCameraLocation=false.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetTarget(RMA.OpenNURBS.IOn3dPoint,System.Boolean)">
            <summary>
Set viewport target point. By default the camera location is translated so that
the camera direction vector is parallel to the vector from the camera location
to the target location.
</summary>
            <param name="target_location">[in] new target location</param>
            <param name="bUpdateCameraLocation">
[in] if true, the camera location is translated so that the camera direction vector
is parallel to the vector from the camera location to the target location.
If false, the camera location is not changed. See the remarks section for important details.
</param>
            <remarks>
In general, Rhino users expect to have the camera direction vector and the vector
from the camera location to the target location to be parallel. If you use the
CRhinoViewport functions listed in the see also section to set the camera location,
camera direction, and target point, then the relationship between these three points
and vectors is automatically maintained. If you directly manipulate the camera by
using the CRhinoViewport::SetVP member function, then you should carefully set the
target by calling SetTarget() with bUpdateCameraLocation=false.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.Target">
            <summary>
viewport target point
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetView(RMA.OpenNURBS.IOn3dmView)">
            <summary>
Expert user function to set viewport projection, target location, name, display mode,
window location in the Rhino mainframe, construction plane, background bitmap and wallpaper bitmap.
</summary>
            <param name="view">[in]</param>
            <remarks>
This function is primarily used to save and restore view settings. If you want
to modify specific viewport settings, use the functions listed in the see also section.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.View">
            <summary>
Get complete information about the viewport projection, target location, name,
display mode, window location in the Rhino mainframe, construction plane,
background bitmap and wallpaper bitmap.
</summary>
            <returns>
view informtion as an ON_3dmView.
See Also: CRhinoViewport::SetView
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.IsTraceImage">
            <summary>Verifies the existance of background bitmap.</summary>
            <returns>True if a background bitmap exists. False otherwise</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetTraceImage(RMA.OpenNURBS.IOn3dmViewTraceImage)">
            <summary>Sets the background bitmap</summary>
            <param name="traceimage">[in]</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.IsWallpaperImage">
            <summary>Verifies the existance of a wallpaper.</summary>
            <returns>True if a wallpaper exists. False otherwise</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetWallpaperImage(RMA.OpenNURBS.IOn3dmWallpaperImage)">
            <summary>Sets the wallpaper bitmap.</summary>
            <param name="wallpaper">[in]</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetVP(RMA.OpenNURBS.IOnViewport,System.Boolean)">
            <summary>Set viewport camera projection.</summary>
            <param name="bUpdateTargetLocation">
[in] if true, the target location is changed so that the vector from the camera
location to the target is parallel to the camera direction vector.
If false, the target location is not changed. See the remarks section of
CRhinoViewport::SetTarget for important details.
</param>
            <remarks>
See the remarks section of CRhinoViewport::SetTarget for important details.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.VP">
            <summary>Get viewport projection information.</summary>
            <returns>
viewport projection information as an ON_Viewport.
See Also: CRhinoViewport::SetVP
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawTangentBar(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector)">
            <summary>Draws a tangent line segment decoration.</summary>
            <param name="mid_point">[in] midpoint of line segment</param>
            <param name="direction_vector">[in] unit vector direction of line segment.</param>
            <remarks>
These are the line segments used to indicate curve tangents.
Generally, direction_vector should have length = 1. For special
situations when a shorter/longer tangent bar is desired,
See Also: CRhinoViewport::SetDrawColor, CRhinoViewport::DrawDirectionArrow ON_Viewport::GetWorldToScreenScale,
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawTangentBar(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.On3dPoint)">
            <summary>Draws a tangent line segment decoration.</summary>
            <param name="mid_point">[in] midpoint of line segment</param>
            <param name="direction_vector">[in] unit vector direction of line segment.</param>
            <param name="start_point">[out] if not NULL, the start of the tangent bar is returned here.</param>
            <remarks>
These are the line segments used to indicate curve tangents.
Generally, direction_vector should have length = 1. For special
situations when a shorter/longer tangent bar is desired,
See Also: CRhinoViewport::SetDrawColor, CRhinoViewport::DrawDirectionArrow ON_Viewport::GetWorldToScreenScale,
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawTangentBar(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.On3dPoint,RMA.OpenNURBS.On3dPoint)">
            <summary>Draws a tangent line segment decoration.</summary>
            <param name="mid_point">[in] midpoint of line segment</param>
            <param name="direction_vector">[in] unit vector direction of line segment.</param>
            <param name="start_point">[out] if not NULL, the start of the tangent bar is returned here.</param>
            <param name="end_point">[out] if not NULL, the end of the tangent bar is returned here.</param>
            <remarks>
These are the line segments used to indicate curve tangents.
Generally, direction_vector should have length = 1. For special
situations when a shorter/longer tangent bar is desired,
See Also: CRhinoViewport::SetDrawColor, CRhinoViewport::DrawDirectionArrow ON_Viewport::GetWorldToScreenScale,
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawDirectionArrow(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector)">
            <summary>Draws a direction arrow decoration.</summary>
            <param name="tail_point">[in] start of the arrow.</param>
            <param name="direction_vector">
[in] direction of arrow. A vector with a length of 1 unit draws the standard arrow dectoration.
</param>
            <remarks>
These are the arrows used to indicate curve direction and surface normals.
See Also: CRhinoViewport::SetDrawColor, CRhinoViewport::DrawTangentBar, ON_Viewport::GetWorldToScreenScale,
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawDirectionArrow(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.On3dPoint)">
            <summary>Draws a direction arrow decoration.</summary>
            <param name="tail_point">[in] start of the arrow.</param>
            <param name="direction_vector">
[in] direction of arrow. A vector with a length of 1 unit draws the standard arrow dectoration.
</param>
            <param name="head_point">[out] if not NULL, the location of the arrow tip is returned here.</param>
            <remarks>
These are the arrows used to indicate curve direction and surface normals.
See Also: CRhinoViewport::SetDrawColor, CRhinoViewport::DrawTangentBar, ON_Viewport::GetWorldToScreenScale,
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawWorldAxes">
            <summary>
viewport decorations
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawArrow(RMA.OpenNURBS.IOnPlane,RMA.Rhino.IRhinoArrowhead)">
            <summary>
Draws an arrow symobl.  The plane is in world coordinates (WCS)
and provides a 2d coordinate plane (ECS) for the arrow.
</summary>
            <param name="plane">in wcs points - arrow points are in plane (ECS) coordinates</param>
            <param name="arrow">arrow symbol to draw</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawString(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOn2dVector,RMA.Rhino.IRhinoText)">
            <summary>Draws text on an arbitrary plane</summary>
            <param name="rotation">rotation in plane (sin(angle),cosine(angle))</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawString(System.String,System.Int32,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Draws text with specified color, font and height</summary>
            <param name="string">string to draw, can return a modified string</param>
            <param name="slength">length of the string</param>
            <param name="point">definition point, either lower-left or middle</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawString(System.String,System.Int32,RMA.OpenNURBS.IOn3dPoint,System.Int32)">
            <summary>Draws text with specified color, font and height</summary>
            <param name="string">string to draw, can return a modified string</param>
            <param name="slength">length of the string</param>
            <param name="point">definition point, either lower-left or middle</param>
            <param name="bMiddle">true: middle justified, false: lower-left justified</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawString(System.String,System.Int32,RMA.OpenNURBS.IOn3dPoint,System.Int32,System.Int32)">
            <summary>Draws text with specified color, font and height</summary>
            <param name="string">string to draw, can return a modified string</param>
            <param name="slength">length of the string</param>
            <param name="point">definition point, either lower-left or middle</param>
            <param name="bMiddle">true: middle justified, false: lower-left justified</param>
            <param name="rotation">Text rotation in 1/10 degrees</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawString(System.String,System.Int32,RMA.OpenNURBS.IOn3dPoint,System.Int32,System.Int32,System.Int32)">
            <summary>Draws text with specified color, font and height</summary>
            <param name="string">string to draw, can return a modified string</param>
            <param name="slength">length of the string</param>
            <param name="point">definition point, either lower-left or middle</param>
            <param name="bMiddle">true: middle justified, false: lower-left justified</param>
            <param name="rotation">Text rotation in 1/10 degrees</param>
            <param name="height">height in pixels</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawString(System.String,System.Int32,RMA.OpenNURBS.IOn3dPoint,System.Int32,System.Int32,System.Int32,System.String)">
            <summary>Draws text with specified color, font and height</summary>
            <param name="string">string to draw, can return a modified string</param>
            <param name="slength">length of the string</param>
            <param name="point">definition point, either lower-left or middle</param>
            <param name="bMiddle">true: middle justified, false: lower-left justified</param>
            <param name="rotation">Text rotation in 1/10 degrees</param>
            <param name="height">height in pixels</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawString(RMA.OpenNURBS.IOn3dPoint,System.String,System.Int32)">
            <summary>
Draws text like Windows ::TextOut(). The 3d world coordinate point is mapped
to a screen point in each viewport and the string begins at that point.
</summary>
            <param name="count">number of characters to draw</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawString(RMA.OpenNURBS.IOn3dPoint,System.String)">
            <summary>
Draws text like Windows ::TextOut().  The 3d world coordinate point is mapped 
to a screen point in each viewport and the string begins at that point.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawDot(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Draws a round circle with the text in the circle. This tool is used for things like
the "A", "B", "C", "D" in the NetworkSrf
dialog and the the "1", "2", ... in the PerspectiveMatch command.
</summary>
            <param name="point">[in] 3d world location of the dot</param>
            <returns>True if successful.</returns>
            <remarks>Default transforms the point to screen coordinates and calls the DrawDot(screen_x,screen_y,text).</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawDot(RMA.OpenNURBS.IOn3dPoint,System.String)">
            <summary>
Draws a round circle with the text in the circle. This tool is used for things like
the "A", "B", "C", "D" in the NetworkSrf
dialog and the the "1", "2", ... in the PerspectiveMatch command.
</summary>
            <param name="point">[in] 3d world location of the dot</param>
            <param name="text">[in] NULL for an empty dot or a short (generally 1 character or number) string.</param>
            <returns>True if successful.</returns>
            <remarks>Default transforms the point to screen coordinates and calls the DrawDot(screen_x,screen_y,text).</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawDot(RMA.OpenNURBS.IOn3dPoint,System.String,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Draws a round circle with the text in the circle. This tool is used for things like
the "A", "B", "C", "D" in the NetworkSrf
dialog and the the "1", "2", ... in the PerspectiveMatch command.
</summary>
            <param name="point">[in] 3d world location of the dot</param>
            <param name="text">[in] NULL for an empty dot or a short (generally 1 character or number) string.</param>
            <param name="dot_color">[in] color of dot</param>
            <returns>True if successful.</returns>
            <remarks>Default transforms the point to screen coordinates and calls the DrawDot(screen_x,screen_y,text).</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawDot(RMA.OpenNURBS.IOn3dPoint,System.String,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Draws a round circle with the text in the circle. This tool is used for things like
the "A", "B", "C", "D" in the NetworkSrf
dialog and the the "1", "2", ... in the PerspectiveMatch command.
</summary>
            <param name="point">[in] 3d world location of the dot</param>
            <param name="text">[in] NULL for an empty dot or a short (generally 1 character or number) string.</param>
            <param name="dot_color">[in] color of dot</param>
            <param name="text_color">
[in] text color. If text_color is ON_unset_color, then white is used if the
dot_color is dark and black is used if the dot_color is light.
</param>
            <returns>True if successful.</returns>
            <remarks>Default transforms the point to screen coordinates and calls the DrawDot(screen_x,screen_y,text).</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawDot(System.Int32,System.Int32)">
            <summary>
Draws a round circle with the text in the circle. This tool is used for things
like the "A", "B", "C", "D" in the NetworkSrf 
dialog and the the "1", "2", ... in the PerspectiveMatch command.
</summary>
            <param name="screen_x">[in] 0 = screen left</param>
            <param name="screen_y">[in] 0 = screen top</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawDot(System.Int32,System.Int32,System.String)">
            <summary>
Draws a round circle with the text in the circle. This tool is used for things
like the "A", "B", "C", "D" in the NetworkSrf 
dialog and the the "1", "2", ... in the PerspectiveMatch command.
</summary>
            <param name="screen_x">[in] 0 = screen left</param>
            <param name="screen_y">[in] 0 = screen top</param>
            <param name="text">[in] NULL for an empty dot or a short (generally 1 character or number) string.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawDot(System.Int32,System.Int32,System.String,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Draws a round circle with the text in the circle. This tool is used for things
like the "A", "B", "C", "D" in the NetworkSrf 
dialog and the the "1", "2", ... in the PerspectiveMatch command.
</summary>
            <param name="screen_x">[in] 0 = screen left</param>
            <param name="screen_y">[in] 0 = screen top</param>
            <param name="text">[in] NULL for an empty dot or a short (generally 1 character or number) string.</param>
            <param name="dot_color">[in] color of dot</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawDot(System.Int32,System.Int32,System.String,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Draws a round circle with the text in the circle. This tool is used for things
like the "A", "B", "C", "D" in the NetworkSrf 
dialog and the the "1", "2", ... in the PerspectiveMatch command.
</summary>
            <param name="screen_x">[in] 0 = screen left</param>
            <param name="screen_y">[in] 0 = screen top</param>
            <param name="text">[in] NULL for an empty dot or a short (generally 1 character or number) string.</param>
            <param name="dot_color">[in] color of dot</param>
            <param name="text_color">
[in] text color. If text_color is ON_unset_color, then white is used if
the dot_color is dark and black is used if the dot_color is light.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawRhinoObject(RMA.Rhino.IRhinoObject,RMA.OpenNURBS.IOnXform)">
            <summary>Draws a transformed instance definition</summary>
            <param name="object">[in]</param>
            <param name="xform">
[in] The object is drawn as if this transformtion had been applied to its geometry.
The object itself is not modified.
</param>
            <remarks>
This funtion can be slow and should not be used in drawing code that is
called every time the mouse moves.
See Also: CRhinoViewport::DrawInstanceDefinition
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawRhinoObject(RMA.Rhino.IRhinoObject,RMA.OpenNURBS.IOnXform,RMA.OpenNURBS.IOnColor)">
            <summary>Draws a transformed instance definition</summary>
            <param name="object">[in]</param>
            <param name="xform">
[in] The object is drawn as if this transformtion had been applied to its geometry.
The object itself is not modified.
</param>
            <param name="color">
[in] By default, the object is drawn in the color returned by
CRhinoObject::ObjectDrawColor(true). If color is not ON_UNSET_COLOR,
then the objects are drawn in the specified color.
</param>
            <remarks>
This funtion can be slow and should not be used in drawing code that is
called every time the mouse moves.
See Also: CRhinoViewport::DrawInstanceDefinition
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawBrep(RMA.OpenNURBS.IOnBrep)">
            <summary>Draws a wireframe brep.</summary>
            <param name="brep">[in]</param>
            <remarks>
This funtion can be slow and should not be used in drawing code that
is called every time the mouse moves.
See Also: CRhinoViewport::DrawSurface CRhBrepDisplay::Draw
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawBrep(RMA.OpenNURBS.IOnBrep,System.Int32)">
            <summary>Draws a wireframe brep.</summary>
            <param name="brep">[in]</param>
            <param name="display_density">[in] ON_3dmObjectAttributes.m_wire_density value</param>
            <remarks>
This funtion can be slow and should not be used in drawing code that
is called every time the mouse moves.
See Also: CRhinoViewport::DrawSurface CRhBrepDisplay::Draw
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawBezierCage(RMA.OpenNURBS.IOnBezierSurface)">
            <summary>Draws a wireframe bezier cage.</summary>
            <param name="bezier_cage">[in]</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawBezierCage(RMA.OpenNURBS.IOnBezierSurface,System.Int32)">
            <summary>Draws a wireframe bezier cage.</summary>
            <param name="bezier_cage">[in]</param>
            <param name="display_density">[in] ON_3dmObjectAttributes.m_wire_density value</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawNurbsCage(RMA.OpenNURBS.IOnNurbsCage)">
            <summary>Draws a wireframe NURBS cage.</summary>
            <param name="nurbs_cage">[in]</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawNurbsCage(RMA.OpenNURBS.IOnNurbsCage,System.Int32)">
            <summary>Draws a wireframe NURBS cage.</summary>
            <param name="nurbs_cage">[in]</param>
            <param name="display_density">[in] ON_3dmObjectAttributes.m_wire_density value</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawBezierSurface(RMA.OpenNURBS.IOnBezierSurface)">
            <summary>Draws a wireframe bezier surface.</summary>
            <param name="bezier_surface">[in]</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawBezierSurface(RMA.OpenNURBS.IOnBezierSurface,System.Int32)">
            <summary>Draws a wireframe bezier surface.</summary>
            <param name="bezier_surface">[in]</param>
            <param name="display_density">[in] ON_3dmObjectAttributes.m_wire_density value</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawNurbsSurface(RMA.OpenNURBS.IOnNurbsSurface)">
            <summary>Draws a wireframe NURBS surface.</summary>
            <param name="nurbs_surface">[in]</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawNurbsSurface(RMA.OpenNURBS.IOnNurbsSurface,System.Int32)">
            <summary>Draws a wireframe NURBS surface.</summary>
            <param name="nurbs_surface">[in]</param>
            <param name="display_density">[in] ON_3dmObjectAttributes.m_wire_density value</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawSurface(RMA.OpenNURBS.IOnSurface)">
            <summary>Draws a wireframe surface.</summary>
            <param name="surface">[in]</param>
            <remarks>
This funtion can be slow and should not be used in drawing code that is
called every time the mouse moves.
See Also: CRhinoViewport::DrawNurbsSurface CRhinoViewport::DrawBezierSurface CRhinoViewport::DrawSurface CRhinoViewport::DrawBrep
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawSurface(RMA.OpenNURBS.IOnSurface,System.Int32)">
            <summary>Draws a wireframe surface.</summary>
            <param name="surface">[in]</param>
            <param name="display_density">[in] ON_3dmObjectAttributes.m_wire_density value</param>
            <remarks>
This funtion can be slow and should not be used in drawing code that is
called every time the mouse moves.
See Also: CRhinoViewport::DrawNurbsSurface CRhinoViewport::DrawBezierSurface CRhinoViewport::DrawSurface CRhinoViewport::DrawBrep
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawBezier(RMA.OpenNURBS.IOnBezierCurve)">
            <summary>Draws a bezier curve in a viewport window.</summary>
            <param name="bezier_curve">[in]</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawFalseColorMesh(RMA.OpenNURBS.IOnMesh,System.Boolean)">
            <summary>Draws false color mesh.</summary>
            <param name="mesh">[in] mesh with vertex colors</param>
            <param name="bCullCW">[in] true to cull clockwise triangles</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawFalseColorMesh(RMA.OpenNURBS.IOnMesh,System.Boolean,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>Draws false color mesh.</summary>
            <param name="mesh">[in] mesh with vertex colors</param>
            <param name="bCullCW">[in] true to cull clockwise triangles</param>
            <param name="edge_color">[in] if not ON_UNSET_COLOR, then mesh wireframe is drawn in this color.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawEmapMesh(RMA.OpenNURBS.IOnMesh,RMA.Rhino.IRhinoEmapAnalysisSettings,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Boolean)">
            <summary>Draws environment mapped mesh.</summary>
            <param name="mesh">[in] mesh with vertex normals</param>
            <param name="emap_info">[in] environment map settings</param>
            <param name="mesh_color">[in] diffuse color</param>
            <param name="bCullCW">[in] true to cull clockwise triangles</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawEmapMesh(RMA.OpenNURBS.IOnMesh,RMA.Rhino.IRhinoEmapAnalysisSettings,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Boolean,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>Draws environment mapped mesh.</summary>
            <param name="mesh">[in] mesh with vertex normals</param>
            <param name="emap_info">[in] environment map settings</param>
            <param name="mesh_color">[in] diffuse color</param>
            <param name="bCullCW">[in] true to cull clockwise triangles</param>
            <param name="edge_color">[in] if not ON_UNSET_COLOR, then mesh wireframe is drawn in this color.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawZebraMesh(RMA.OpenNURBS.IOnMesh,RMA.Rhino.IRhinoZebraAnalysisSettings,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Boolean)">
            <summary>Draws a zebra stripe mesh.</summary>
            <param name="mesh">[in] mesh with vertex normals</param>
            <param name="zebra_info">[in] zebra stripe settings</param>
            <param name="mesh_color">[in] color for non-stripe areas</param>
            <param name="bCullCW">[in] true to cull clockwise triangles</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawZebraMesh(RMA.OpenNURBS.IOnMesh,RMA.Rhino.IRhinoZebraAnalysisSettings,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Boolean,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>Draws a zebra stripe mesh.</summary>
            <param name="mesh">[in] mesh with vertex normals</param>
            <param name="zebra_info">[in] zebra stripe settings</param>
            <param name="mesh_color">[in] color for non-stripe areas</param>
            <param name="bCullCW">[in] true to cull clockwise triangles</param>
            <param name="edge_color">[in] if not ON_UNSET_COLOR, then mesh wireframe is drawn in this color.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawRenderPreviewMesh(RMA.OpenNURBS.IOnMesh,RMA.Rhino.IRhinoMaterial,System.Boolean,System.Boolean)">
            <param name="bCullCW">true to cull clockwise triangles</param>
            <param name="bHighlighted">true if mesh is highlighed</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawShadedMesh(RMA.OpenNURBS.IOnMesh,System.Boolean,System.Boolean,System.Boolean)">
            <param name="bCullCW">true to cull clockwise triangles</param>
            <param name="bFlatShade">true for flat shading</param>
            <param name="bHighlighted">true if mesh is highlighed</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawWireframeMesh(RMA.OpenNURBS.IOnMesh,System.Boolean)">
            <param name="bCullCW">true to cull clockwise triangles</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawNurbsCurve(RMA.OpenNURBS.IOnNurbsCurve)">
            <summary>Draws a NURBS curve in a viewport window.</summary>
            <param name="nurbs_curve">[in]</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawNormalCurvatureGraph(RMA.OpenNURBS.IOnSurface,System.Int32,RMA.Rhino.IRhinoCurvatureGraphSettings)">
            <summary>Draw the surface's normal curvature along surface iso parametric curves.</summary>
            <param name="surface">[in]</param>
            <param name="wire_density">[in] Density of iso-curves</param>
            <param name="hair_settings">
[in] If NULL, RhinoApp().AppSettings().CurvatureGraphSettings() are used.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawCurvatureGraph(RMA.OpenNURBS.IOnCurve,RMA.Rhino.IRhinoCurvatureGraphSettings)">
            <summary>Draws the curve's curvature hair graph in a viewport window.</summary>
            <param name="curve">[in]</param>
            <param name="hair_settings">
[in] If NULL, the settings from RhinoApp().AppSettings().CurvatureGraphSettings() are used.
</param>
            <remarks>
This funtion can be slow and should not be used in drawing code
that is called every time the mouse moves.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawCurve(RMA.OpenNURBS.IOnCurve)">
            <summary>Draws a curve in a viewport window.</summary>
            <param name="curve">[in]</param>
            <remarks>
This funtion can be slow and should not be used in drawing code that is
called every time the mouse moves.
See Also: CRhinoViewport::DrawNurbsCurve CRhinoViewport::DrawBezier CRhinoViewport::DrawCurve
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawLight(RMA.OpenNURBS.IOnLight,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>Draws a wireframe icon of a light.</summary>
            <param name="light">[in]</param>
            <param name="wireframe_color">[in] color to use for wireframe</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawBox(RMA.OpenNURBS.IArrayOn3dPoint)">
            <summary>Draw a wireframe box.</summary>
            <param name="box_corners">
[in] array of eight box corners
       7______________6
       |\             |
       | \            | 
       |  \ _____________\ 
       |   4          |   5
       |   |          |   |
       |   |          |   |
       3---|----------2   |
       \   |          \   |
        \  |           \  |
         \ |            \ |
          \0_____________\1
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawCone(RMA.OpenNURBS.IOnCone)">
            <summary>Draw a wireframe cone.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawCylinder(RMA.OpenNURBS.IOnCylinder)">
            <summary>Draw a wireframe cylinder.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawTorus(RMA.OpenNURBS.IOnTorus)">
            <summary>Draw a wireframe torus.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawSphere(RMA.OpenNURBS.IOnSphere)">
            <summary>Draw a wireframe sphere.</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawInferenceLine(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Draw inference line used in gesture based snapping</summary>
            <param name="P">[in] world 3d start</param>
            <param name="Q">[in] world 3d end</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawInferenceLine(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>Draw inference line used in gesture based snapping</summary>
            <param name="P">[in] world 3d start</param>
            <param name="Q">[in] world 3d end</param>
            <param name="color">[in] if = ON_UNSET_COLOR, then the system inference color is used.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawInferenceLine(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32)">
            <summary>Draw inference line used in gesture based snapping</summary>
            <param name="P">[in] world 3d start</param>
            <param name="Q">[in] world 3d end</param>
            <param name="color">[in] if = ON_UNSET_COLOR, then the system inference color is used.</param>
            <param name="type">[in] 0 = chord, 1 = ray from P through Q 2 = infinite line</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawInferencePoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Draw inference point used in gesture based snapping</summary>
            <param name="P">[in]world 3d</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawInferencePoint(RMA.OpenNURBS.IOn3dPoint,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>Draw inference point used in gesture based snapping</summary>
            <param name="P">[in]world 3d</param>
            <param name="color">[in] if = ON_UNSET_COLOR, then the system inference color is used.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawCrossHairs(RMA.OpenNURBS.IOnPlane,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Draw cross hairs across the entire viewport that run along the plane's x and y axes.
</summary>
            <param name="plane">[in] the cross hairs run along the plane's x and y axes.</param>
            <param name="color">[in]</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawConstructionPlane(RMA.OpenNURBS.IOn3dmConstructionPlane,System.Boolean,System.Boolean)">
            <summary>Draw a construction plane grid.</summary>
            <param name="bShowConstructionGrid">[in] if true, the construction grid is drawn</param>
            <param name="bShowConstructionAxes">[in] if true, the construction grid X and Y axes are drawn</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawConstructionPlane(RMA.OpenNURBS.IOn3dmConstructionPlane,System.Boolean,System.Boolean,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>Draw a construction plane grid.</summary>
            <param name="bShowConstructionGrid">[in] if true, the construction grid is drawn</param>
            <param name="bShowConstructionAxes">[in] if true, the construction grid X and Y axes are drawn</param>
            <param name="thin_line_color">
[in] color used to draw thin grid lines. The default is RhinoApp().AppSettings().GridThinLineColor().
If thin_line_color != ON_UNSET_COLOR, then this specified color is used.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawConstructionPlane(RMA.OpenNURBS.IOn3dmConstructionPlane,System.Boolean,System.Boolean,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>Draw a construction plane grid.</summary>
            <param name="bShowConstructionGrid">[in] if true, the construction grid is drawn</param>
            <param name="bShowConstructionAxes">[in] if true, the construction grid X and Y axes are drawn</param>
            <param name="thin_line_color">
[in] color used to draw thin grid lines. The default is RhinoApp().AppSettings().GridThinLineColor().
If thin_line_color != ON_UNSET_COLOR, then this specified color is used.
</param>
            <param name="thick_line_color">
[in] color used to draw thick grid lines. The default is RhinoApp().AppSettings().GridThickLineColor().
If thick_line_color != ON_UNSET_COLOR, then this specified color is used.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawConstructionPlane(RMA.OpenNURBS.IOn3dmConstructionPlane,System.Boolean,System.Boolean,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>Draw a construction plane grid.</summary>
            <param name="bShowConstructionGrid">[in] if true, the construction grid is drawn</param>
            <param name="bShowConstructionAxes">[in] if true, the construction grid X and Y axes are drawn</param>
            <param name="thin_line_color">
[in] color used to draw thin grid lines. The default is RhinoApp().AppSettings().GridThinLineColor().
If thin_line_color != ON_UNSET_COLOR, then this specified color is used.
</param>
            <param name="thick_line_color">
[in] color used to draw thick grid lines. The default is RhinoApp().AppSettings().GridThickLineColor().
If thick_line_color != ON_UNSET_COLOR, then this specified color is used.
</param>
            <param name="grid_x_axis_color">
[in] color used to draw the X axis. The default is RhinoApp().AppSettings().GridXAxisColor().
If grid_x_axis_color != ON_UNSET_COLOR, then this specified color is used.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawConstructionPlane(RMA.OpenNURBS.IOn3dmConstructionPlane,System.Boolean,System.Boolean,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>Draw a construction plane grid.</summary>
            <param name="bShowConstructionGrid">[in] if true, the construction grid is drawn</param>
            <param name="bShowConstructionAxes">[in] if true, the construction grid X and Y axes are drawn</param>
            <param name="thin_line_color">
[in] color used to draw thin grid lines. The default is RhinoApp().AppSettings().GridThinLineColor().
If thin_line_color != ON_UNSET_COLOR, then this specified color is used.
</param>
            <param name="thick_line_color">
[in] color used to draw thick grid lines. The default is RhinoApp().AppSettings().GridThickLineColor().
If thick_line_color != ON_UNSET_COLOR, then this specified color is used.
</param>
            <param name="grid_x_axis_color">
[in] color used to draw the X axis. The default is RhinoApp().AppSettings().GridXAxisColor().
If grid_x_axis_color != ON_UNSET_COLOR, then this specified color is used.
</param>
            <param name="grid_y_axis_color">
[in] color used to draw the Y axis. The default is RhinoApp().AppSettings().GridYAxisColor().
If grid_y_axis_color != ON_UNSET_COLOR, then this specified color is used.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawStep">
            <summary>
Returns: Current drawing step.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetClippingPlanes(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
set optimal clipping planes to view objects in a world coordinate 3d bounding box
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.IsVisible(RMA.OpenNURBS.IOn3dPoint)">
            <returns>true if the world coordinate point is visible in the viewing frustum.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.IsVisible(RMA.OpenNURBS.IOnBoundingBox)">
            <returns>
true if some portion world coordinate bounding box is
potentially visible in the viewing frustum.
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.InterruptDrawing">
            <summary>
During dynamic view changes, the mouse sometimes moves
faster than the view can update.  If you are drawing
something that may take a long time, periodically call
InterruptDrawing() to see if you should stop.
</summary>
            <returns>true if you should stop drawing and return.</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.GetLightingModel(RMA.OpenNURBS.ArrayOnLight@)">
            <summary>
Gets lighting model to use for displaying this CRhinoViewport in its current mode.
</summary>
            <param name="lights">[out] world coordinate lighting model returned here.</param>
            <returns>
number of lights.
See Also: CRhinoLightTable::GetLightingModel
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DrawColor">
            <summary>Get current drawing color used by all the CRhinoViewport drawing tools.</summary>
            <returns>
Current drawing color
See Also: CRhinoViewport::SetDrawColor
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetDrawColor(System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>Sets the color used by all the CRhinoViewport drawing tools.</summary>
            <param name="color">[in]</param>
            <returns>Previous drawing color</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.GetZBuffer(RMA.Rhino.MRhinoZBuffer@)">
            <summary>
Retrieves the exact contents of the this viewport's entire z-buffer.
Meaning, what you see is what you get...If you want to change the output
contents of the z-buffer, (ie. forced shading) then you should construct
your own CRhinoZBuffer object using this viewport, make the appropirate
CRhinoZBuffer method calls, and then "Capture()" the z-buffer
(see CRhinoZBuffer for details). 
</summary>
            <param name="buffer">output parameter that will contain all captured z-buffer info.</param>
            <returns>
true: If z-buffer was successfully captured...
false: If no z-buffer was captured (or some other failure ocurred).
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.ZBufferWireDepth">
            <summary>
Points and lines can be drawn at their natural depth, always in front, or always in back.
</summary>
            <returns>
-1: points and lines are always "in back"
0: points and lines are drawn at their natural depth.
1: points and lines are always "in front"
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetZBufferWireDepth(System.Int32)">
            <summary>
Wireframe objects (points, curves, annotation, ...) can be drawn at their natural depth,
always in front, or always in back.
</summary>
            <param name="wire_depth">
-1: wireframe objects are always "in back"
0: wireframe objects are drawn at their natural depth.
1: wireframe objects are always "in front"
</param>
            <returns>Previous value.</returns>
            <remarks>
Generally, the z-buffer wire depth is 0. Highlighted wireframe objects are drawn
with a z-buffer depth of +1.
</remarks>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.ZBiasWire">
            <returns>
Current zbias value.
See Also: CRhinoViewport::SetZBiasWire
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetZBiasWire(System.Int32)">
            <summary>
When wire zbias is not zero, the depth of the point and line geometry in shaded
views is biased towards or away from the camera. This is useful when displaying
curves on surfaces and planes on constuction grids.
</summary>
            <param name="zbias">
&gt;0: apply near bias
&lt;0: apply far bias
0: no bias
</param>
            <returns>
Previous value of zbias
See Also: CRhinoViewport::ZBiasWire
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SelectedShade">
            <returns>
True if only selected objects are shaded.
See Also: CRhinoViewport::EnableSelectedShade
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.GhostedShade">
            <returns>
True if curve and point objects can be seen through transparent solid shaded objects.
See Also: CRhinoViewport::EnableGhostedShade
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.XrayShade">
            <returns>
True if curve and point objects shine through solid shaded objects.
See Also: CRhinoViewport::EnableXrayShade
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.FlatShade">
            <returns>
True if all mesh objects in this viewport will be flat shaded.
See Also: CRhinoViewport::EnableFlatShade
</returns>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.EnableSelectedShade">
            <summary>
By default, all surface and mesh objects are shaded in shaded viewports. If bSelectedShade is true,
then only selected mesh and solid objects are shaded.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.EnableSelectedShade(System.Boolean)">
            <summary>
By default, all surface and mesh objects are shaded in shaded viewports. If bSelectedShade is true,
then only selected mesh and solid objects are shaded.
</summary>
            <param name="bSelectedShade">[in] If true, only selected mesh and surface objects are shaded in shaded.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.EnableGhostedShade">
            <summary>
By default, curves and points in shaded viewports are obscured if the are behind a solid objects.
If ghost shading is enabled, then curves and points are seen through transparent solid objects.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.EnableGhostedShade(System.Boolean)">
            <summary>
By default, curves and points in shaded viewports are obscured if the are behind a solid objects.
If ghost shading is enabled, then curves and points are seen through transparent solid objects.
</summary>
            <param name="bGhostedShade">
[in] If true, all curve and point object in this viewport will be seen through transparent solid objects.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.EnableXrayShade">
            <summary>
By default, curves and points in shaded viewports are obscured if the are behind a solid objects.
If x-ray shading is enabled, then curves and points shine through solid objects.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.EnableXrayShade(System.Boolean)">
            <summary>
By default, curves and points in shaded viewports are obscured if the are behind a solid objects.
If x-ray shading is enabled, then curves and points shine through solid objects.
</summary>
            <param name="bXrayShade">
[in] If true, all curve and point object in this viewport will shine through solid objects.
</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.EnableFlatShade">
            <summary>
By default, shaded viewports can either use smooth shading. If flat shading is enabled,
then mesh objects are flat shaded.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.EnableFlatShade(System.Boolean)">
            <summary>
By default, shaded viewports can either use smooth shading. If flat shading is enabled,
then mesh objects are flat shaded.
</summary>
            <param name="bFlatShade">[in] If true, all mesh objects in this viewport will be flat shaded.</param>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DisplayModeIsShaded">
            <summary>
Determine if this viewport's display attributes support "shading".
This assumption here is that if shading is supported, then objects will be shaded.
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetDisplayMode(System.Guid@)">
            <summary>
A viewport's display mode can be determined by using the uuid of
one of the predefined or user defined display attributes,
(see CDisplayPipelineAttributes)...
</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.DisplayMode">
            <summary>A viewport's display mode can be wireframe, shaded, or render preview</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.SetDisplayMode(RMA.OpenNURBS.IOn.display_mode)">
            <summary>A viewport's display mode can be wireframe, shaded, or render preview</summary>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.ChangeCounter">
            <summary>
The value of change counter is incremented every time the view
projection or construction plane changes. The user can the mouse
and nestable view manipulation commands to change a view at any time.
The value value of change counter can be used to detect these changes
in code that is sensitive to the view projection.
</summary>
            <returns>current value of change counter.</returns>
            <example>
 change_counter0 = vp.ChangeCounter().
 ...
 if ( change_counter0 != vp.ChangeCounter() )
 {
   view projection changed
 }
</example>
        </member>
        <member name="M:RMA.Rhino.MRhinoViewport.ParentView">
            <summary>Gets the parent view, if there is one.</summary>
            <returns>A pointer to the parent view or NULL.</returns>
            <remarks>
Every CRhinoView has an associated CRhinoViewport that does all the 3d display work.
Those associated viewports return the CRhinoView as their parent view. However,
CRhinoViewports are used in other image creating contexts that do not have a parent
CRhinoView. If you call ParentView, you MUST check for NULL return values.
</remarks>
        </member>
        <member name="P:RMA.Rhino.MRhinoViewport.m_v">
            <value>
viewport settings
</value>
        </member>
        <member name="P:RMA.Rhino.MRhinoViewport.m_bSpecialView">
            <value>
Default to false. Used to determine how if objects are displayed in this viewport.
Is the viewport is "special", it only shows objects with m_bSpecialViewport == true
as an attribute and this viewport's ID is in the attributes display material list
</value>
        </member>
        <member name="M:RMA.Rhino.IRhinoViewport.IsPageViewMainViewport">
            <summary>
Determines if this viewport is the main viewport for a page view. Page views
should be able to be panned and zoomed, but not rotated or changed to a
different camera view vector. This is used by functions that attempt to set the
viewport's projection. If the projection is not compatible with a page view and
IsPageViewMainViewport() == true, then the setting of the projection is not allowed
</summary>
            <returns>true if thie viewport is the main viewport for a CRhinoPageView</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoViewport.ClientToScreenPort(System.Drawing.Point@)">
            <summary>
Convert a point in parent CRhinoView client window coordinates to the ON_Viewport screen port
client coordinates. The screen port of a CRhinoViewport may not match the client area of
the parent CRhinoView. This occurs in cases when the CRhinoViewport is a nested child viewport
</summary>
            <param name="pt">
[in/out]: point in client coordinates of parent CRhinoView window as input. This is
converted to the screen port client coordinates of the ON_Viewport as output
</param>
            <returns>true if the point is inside of the CRhinoViewport's screen port rectangle</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoViewport.GetPickXform(System.Drawing.Rectangle,RMA.OpenNURBS.OnXform@)">
            <summary>
GetPickXform takes a rectangle in screen coordinates and returns 
a transformation that maps the 3d frustum defined by the rectangle
to a -1/+1 clipping coordinate box.
</summary>
            <param name="rect">screen coordinates of a rectangle defining the picking frustum</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoViewport.GetPickXform(System.Int32,System.Int32,RMA.OpenNURBS.OnXform@)">
            <summary>
GetPickXform takes a rectangle in screen coordinates and returns 
a transformation that maps the 3d frustum defined by the rectangle
to a -1/+1 clipping coordinate box.
</summary>
            <param name="x">screen coordinates of a mouse click</param>
            <param name="y">screen coordinates of a mouse click</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoViewport.GetMarkedObjectXform(System.Int32@,RMA.OpenNURBS.OnXform@)">
            <summary>Get the display transformation that is applied to marked objects.</summary>
            <param name="mark_value">[out]</param>
            <param name="marked_object_xform">[out]</param>
        </member>
        <member name="M:RMA.Rhino.IRhinoViewport.GetDisplayXform(RMA.OpenNURBS.OnXform@)">
            <summary>
Get the display transformation that is applied to the projected geometry immediately before it is drawn.
</summary>
            <param name="display_xform">[out]</param>
            <remarks>
The default display transformation is the identity. The display transformation is
intended to be used in printing applications. The camera and projection transformations
are handled in the m_v settings.
See Also: CRhinoViewport::SetDisplayXform
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoViewport.GetModelXform(RMA.OpenNURBS.OnXform@)">
            <summary>Get the model transformation that is applied to geometry before it is drawn.</summary>
            <param name="model_xform">[out]</param>
            <remarks>
The default model transformation is the identity. The model transformation
is intended to be used for dynamic drawing of objects. The camera and
projection transformations are handled in the m_v settings.
See Also: CRhinoViewport::SetModelXform
</remarks>
        </member>
        <member name="M:RMA.Rhino.IRhinoViewport.IsPlanView">
            <returns>true if construction plane z axis is parallel to camera direction.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoViewport.GetElevatorHeight(RMA.OpenNURBS.IOnLine,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,System.Boolean,System.Double,System.Double@)">
            <summary>Calculate elevator mode point</summary>
            <param name="world_line">[in] line from near to far clipping plane that projects to mouse point.</param>
            <param name="elevator_basepoint">[in]</param>
            <param name="elevator_axis">[in] unit vector</param>
            <param name="bGridSnap">[in] true if grid snap is enabled. When in doubt, use value of RhinoApp().AppSettings().GridSnap().</param>
            <param name="grid_snap_spacing">[in] grid snap distance. When in doubt, use value of ConstructionPlane().m_snap_spacing</param>
            <param name="elevator_height">[out] elevator height returned here.</param>
            <returns>
true if point is successfully calculated.  The 3d location
is elevator_basepoint + elevator_height*elevator_axis.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoViewport.IsZUp">
            <summary>viewports are either x-up, y-up, or z-up</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoViewport.IsYUp">
            <summary>viewports are either x-up, y-up, or z-up</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoViewport.IsXUp">
            <summary>viewports are either x-up, y-up, or z-up</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoViewport.ShowWorldAxes">
            <summary>
controls display of world axes icon
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoViewport.ShowConstructionAxes">
            <summary>
controls display of construction plane axes
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoViewport.ShowConstructionGrid">
            <summary>
controls display of construction plane grid
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoViewport.ConstructionPlane">
            <summary>
Returns: Viewport construction plane
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoViewport.Target">
            <summary>
viewport target point
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoViewport.View">
            <summary>
Get complete information about the viewport projection, target location, name,
display mode, window location in the Rhino mainframe, construction plane,
background bitmap and wallpaper bitmap.
</summary>
            <returns>
view informtion as an ON_3dmView.
See Also: CRhinoViewport::SetView
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoViewport.VP">
            <summary>Get viewport projection information.</summary>
            <returns>
viewport projection information as an ON_Viewport.
See Also: CRhinoViewport::SetVP
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoViewport.DrawStep">
            <summary>
Returns: Current drawing step.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoViewport.IsVisible(RMA.OpenNURBS.IOn3dPoint)">
            <returns>true if the world coordinate point is visible in the viewing frustum.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoViewport.IsVisible(RMA.OpenNURBS.IOnBoundingBox)">
            <returns>
true if some portion world coordinate bounding box is
potentially visible in the viewing frustum.
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoViewport.InterruptDrawing">
            <summary>
During dynamic view changes, the mouse sometimes moves
faster than the view can update.  If you are drawing
something that may take a long time, periodically call
InterruptDrawing() to see if you should stop.
</summary>
            <returns>true if you should stop drawing and return.</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoViewport.DrawColor">
            <summary>Get current drawing color used by all the CRhinoViewport drawing tools.</summary>
            <returns>
Current drawing color
See Also: CRhinoViewport::SetDrawColor
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoViewport.GetZBuffer(RMA.Rhino.MRhinoZBuffer@)">
            <summary>
Retrieves the exact contents of the this viewport's entire z-buffer.
Meaning, what you see is what you get...If you want to change the output
contents of the z-buffer, (ie. forced shading) then you should construct
your own CRhinoZBuffer object using this viewport, make the appropirate
CRhinoZBuffer method calls, and then "Capture()" the z-buffer
(see CRhinoZBuffer for details). 
</summary>
            <param name="buffer">output parameter that will contain all captured z-buffer info.</param>
            <returns>
true: If z-buffer was successfully captured...
false: If no z-buffer was captured (or some other failure ocurred).
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoViewport.ZBufferWireDepth">
            <summary>
Points and lines can be drawn at their natural depth, always in front, or always in back.
</summary>
            <returns>
-1: points and lines are always "in back"
0: points and lines are drawn at their natural depth.
1: points and lines are always "in front"
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoViewport.ZBiasWire">
            <returns>
Current zbias value.
See Also: CRhinoViewport::SetZBiasWire
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoViewport.SelectedShade">
            <returns>
True if only selected objects are shaded.
See Also: CRhinoViewport::EnableSelectedShade
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoViewport.GhostedShade">
            <returns>
True if curve and point objects can be seen through transparent solid shaded objects.
See Also: CRhinoViewport::EnableGhostedShade
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoViewport.XrayShade">
            <returns>
True if curve and point objects shine through solid shaded objects.
See Also: CRhinoViewport::EnableXrayShade
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoViewport.FlatShade">
            <returns>
True if all mesh objects in this viewport will be flat shaded.
See Also: CRhinoViewport::EnableFlatShade
</returns>
        </member>
        <member name="M:RMA.Rhino.IRhinoViewport.DisplayModeIsShaded">
            <summary>
Determine if this viewport's display attributes support "shading".
This assumption here is that if shading is supported, then objects will be shaded.
</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoViewport.DisplayMode">
            <summary>A viewport's display mode can be wireframe, shaded, or render preview</summary>
        </member>
        <member name="M:RMA.Rhino.IRhinoViewport.ChangeCounter">
            <summary>
The value of change counter is incremented every time the view
projection or construction plane changes. The user can the mouse
and nestable view manipulation commands to change a view at any time.
The value value of change counter can be used to detect these changes
in code that is sensitive to the view projection.
</summary>
            <returns>current value of change counter.</returns>
            <example>
 change_counter0 = vp.ChangeCounter().
 ...
 if ( change_counter0 != vp.ChangeCounter() )
 {
   view projection changed
 }
</example>
        </member>
        <member name="M:RMA.Rhino.IRhinoViewport.ParentView">
            <summary>Gets the parent view, if there is one.</summary>
            <returns>A pointer to the parent view or NULL.</returns>
            <remarks>
Every CRhinoView has an associated CRhinoViewport that does all the 3d display work.
Those associated viewports return the CRhinoView as their parent view. However,
CRhinoViewports are used in other image creating contexts that do not have a parent
CRhinoView. If you call ParentView, you MUST check for NULL return values.
</remarks>
        </member>
        <member name="P:RMA.Rhino.IRhinoViewport.m_v">
            <value>
viewport settings
</value>
        </member>
        <member name="P:RMA.Rhino.IRhinoViewport.m_bSpecialView">
            <value>
Default to false. Used to determine how if objects are displayed in this viewport.
Is the viewport is "special", it only shows objects with m_bSpecialViewport == true
as an attribute and this viewport's ID is in the attributes display material list
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.DestroyCache">
            <summary>
Destroys cached searching and bounding box information.
Call if you modify the m_object_table or m_idef_table.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.DumpUserDataTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of user data table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.DumpHistoryRecordTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of object table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.DumpObjectTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of object table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.DumpIDefTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of instance definition table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.DumpHatchPatternTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of hatch pattern table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.DumpDimStyleTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of dimstyle table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.DumpFontTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of font table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.DumpGroupTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of group table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.DumpLightTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of light table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.DumpLayerTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of layer table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.DumpLinetypeTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of line type table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.DumpMaterialTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of render material table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.DumpTextureMappingTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of texture mapping table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.DumpBitmapTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of bitmap table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.DumpSummary(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of model properties and settings
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.Dump(RMA.OpenNURBS.OnTextLog)">
            <summary>text dump of entire model</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.GetUnusedLayerName(System.String)">
            <summary>
Get layer name that is not currently in use.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.LayerIndex(System.String)">
            <summary>Get layer definition from layer table.</summary>
            <param name="layer_name">[in] name to search for</param>
            <returns>Index of the layer or -1 if it is not found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.UsesIDef(RMA.OpenNURBS.IOnInstanceRef,System.Guid)">
            <summary>See if the instance reference iref refers to an instance definition.</summary>
            <param name="iref">[in]</param>
            <param name="idef_uuid">[in] id of idef we are looking for</param>
            <returns>
0 iref does not use idef
1 iref directly references idef
&gt;1 iref has a nested reference to idef (nesting depth returned)
-1 iref.m_instance_definition_uuid is not valid
-2 invalid idef found
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.IDefIndex(System.String)">
            <summary>Get instance definition index from instance definition name.</summary>
            <param name="idef_name">[in] name to search for</param>
            <returns>Index of the instance definition or -1 if it is not found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.IDefIndex(System.Guid)">
            <summary>Get instance definition from instance definition table.</summary>
            <param name="idef_uuid">[in] instance definition uuid.</param>
            <returns>Index of the instance definition or -1 if it is not found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.ObjectIndex(System.Guid)">
            <summary>Get index of object in m_object_table from object_uuid.</summary>
            <param name="object_uuid">[in] object uuid.</param>
            <returns>Index of the object or -1 if it is not found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.WireframeColor(System.Int32)">
            <summary>Get wireframe drawing color from object attributes.</summary>
            <param name="object_index">[in] m_object_table[] index</param>
            <returns>Wireframe drawing color.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.WireframeColor(RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <summary>Get wireframe drawing color from object attributes.</summary>
            <param name="attributes">[in] object attributes.</param>
            <returns>Wireframe drawing color.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.GetLinetype(System.Int32,RMA.OpenNURBS.OnLinetype@)">
            <summary>Get linetype from object_index.</summary>
            <param name="object_index">[in] m_object_table[] index</param>
            <param name="linetype">[out] linetype</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.GetLinetype(RMA.OpenNURBS.IOn3dmObjectAttributes,RMA.OpenNURBS.OnLinetype@)">
            <summary>Get linetype from object attributes.</summary>
            <param name="attributes">[in] object attributes.</param>
            <param name="linetype">[out] linetype</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.GetRenderMaterial(System.Int32,RMA.OpenNURBS.OnMaterial@)">
            <summary>Get render material from object_index.</summary>
            <param name="object_index">[in] m_object_table[] index</param>
            <param name="material">[out] render material</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.GetRenderMaterial(RMA.OpenNURBS.IOn3dmObjectAttributes,RMA.OpenNURBS.OnMaterial@)">
            <summary>Get render material from object attributes.</summary>
            <param name="attributes">[in] object attributes.</param>
            <param name="material">[out] render material</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.BoundingBox">
            <summary>
Returns: Bounding box of every object in m_object_table[].
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.Audit(System.Boolean,System.Int32@,RMA.OpenNURBS.OnTextLog,RMA.OpenNURBS.Arrayint)">
            <summary>
Check a model to make sure it is valid and, if possible and requrested, attempt to repair.
</summary>
            <param name="bAttemptRepair">[in] if true and a problem is found, the problem is repaired.</param>
            <param name="repair_count">[out] number of successful repairs.</param>
            <param name="text_log">
[in] if not NULL and errors are found, a description of the problem is put in this text_log.
</param>
            <param name="warnings">
[out] If problems were found, warning ids are appended to this list.
1 m_material_table[] flaws
2 layer table is not perfect.
3 some m_object_table[].m_attributes.m_uuid was nil or not unique.
4 some m_object_table[].IsValid() is false
5 some m_idef_table[] has an invalid or duplicate name
6 warning some m_idef_table[].m_object_uuid[] is not valid
7 warning some m_object_table[].m_object is null
8 warning some m_object_table[].m_object-&gt;IsValid() is false
9 warning some m_object_table[].m_attributes is not valid
10 linetype table is not perfect.
11 lineset table is not perfect.
12 some m_idef_table[].m_uuid was nil or not unique.
13 some m_texture_mapping_table[i].m_mapping_id was nil or not unique.
14 some m_material_table[i].m_material_id was nil or not unique.
15 some m_light_table[i].m_light_id was nil or not unique.
</param>
            <returns>
True if model is valid and false if the model has serious
&lt;0 model has serious errors
=0 model is ok
&gt;0 number of problems that were found.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.Polish">
            <summary>
Quickly fills in the little details, like making sure there is at least
one layer and table indices make sense. For a full blown check and repair,
call Audit(true).
See Also: ONX_Model::Audit
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.IsValid">
            <summary>Check a model to make sure it is valid.</summary>
            <returns>True if the model is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.IsValid(RMA.OpenNURBS.OnTextLog)">
            <summary>Check a model to make sure it is valid.</summary>
            <param name="text_log">
[in] if not NULL and errors are found, a description of the problem is put in this text_log.
</param>
            <returns>True if the model is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.Write(System.String)">
            <summary>
Writes contents of this model to an openNURBS archive. I STRONGLY suggested
that you call Polish() before calling Write so that your file has all the
"fluff" that makes it complete. If the model is not valid, then Write
will refuse to write it.
</summary>
            <returns>
True if archive is written with no error.
False if errors occur. Error details are logged in error_log.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.Write(System.String,System.Int32)">
            <summary>
Writes contents of this model to an openNURBS archive. I STRONGLY suggested
that you call Polish() before calling Write so that your file has all the
"fluff" that makes it complete. If the model is not valid, then Write
will refuse to write it.
</summary>
            <param name="version">
[in] Version of the openNURBS archive to write. Must be 2, 3 or 4.
Rhino 2.x can read version 2 files.
Rhino 3.x can read version 2 and 3 files.
Rhino 4.x can read version 2, 3 and 4 files.
Use version 4 when possible.
</param>
            <returns>
True if archive is written with no error.
False if errors occur. Error details are logged in error_log.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.Write(System.String,System.Int32,System.String)">
            <summary>
Writes contents of this model to an openNURBS archive. I STRONGLY suggested
that you call Polish() before calling Write so that your file has all the
"fluff" that makes it complete. If the model is not valid, then Write
will refuse to write it.
</summary>
            <param name="version">
[in] Version of the openNURBS archive to write. Must be 2, 3 or 4.
Rhino 2.x can read version 2 files.
Rhino 3.x can read version 2 and 3 files.
Rhino 4.x can read version 2, 3 and 4 files.
Use version 4 when possible.
</param>
            <param name="sStartSectionComment">
[in] Brief ASCII desciption of your app, today's date, etc.
</param>
            <returns>
True if archive is written with no error.
False if errors occur. Error details are logged in error_log.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.Write(System.String,System.Int32,System.String,RMA.OpenNURBS.OnTextLog)">
            <summary>
Writes contents of this model to an openNURBS archive. I STRONGLY suggested
that you call Polish() before calling Write so that your file has all the
"fluff" that makes it complete. If the model is not valid, then Write
will refuse to write it.
</summary>
            <param name="version">
[in] Version of the openNURBS archive to write. Must be 2, 3 or 4.
Rhino 2.x can read version 2 files.
Rhino 3.x can read version 2 and 3 files.
Rhino 4.x can read version 2, 3 and 4 files.
Use version 4 when possible.
</param>
            <param name="sStartSectionComment">
[in] Brief ASCII desciption of your app, today's date, etc.
</param>
            <param name="error_log">[out] any archive writing errors are logged here.</param>
            <returns>
True if archive is written with no error.
False if errors occur. Error details are logged in error_log.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.Write(RMA.OpenNURBS.OnBinaryArchive)">
            <summary>
Writes contents of this model to an openNURBS archive. I STRONGLY suggested
that you call Polish() before calling Write so that your file has all the
"fluff" that makes it complete. If the model is not valid, then Write
will refuse to write it.
</summary>
            <param name="archive">[in] archive to write to</param>
            <returns>
True if archive is written with no error.
False if errors occur. Error details are logged in error_log.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.Write(RMA.OpenNURBS.OnBinaryArchive,System.Int32)">
            <summary>
Writes contents of this model to an openNURBS archive. I STRONGLY suggested
that you call Polish() before calling Write so that your file has all the
"fluff" that makes it complete. If the model is not valid, then Write
will refuse to write it.
</summary>
            <param name="archive">[in] archive to write to</param>
            <param name="version">
[in] Version of the openNURBS archive to write. Must be 2, 3 or 4.
Rhino 2.x can read version 2 files.
Rhino 3.x can read version 2 and 3 files.
Rhino 4.x can read version 2, 3 and 4 files.
Use version 4 when possible.
</param>
            <returns>
True if archive is written with no error.
False if errors occur. Error details are logged in error_log.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.Write(RMA.OpenNURBS.OnBinaryArchive,System.Int32,System.String)">
            <summary>
Writes contents of this model to an openNURBS archive. I STRONGLY suggested
that you call Polish() before calling Write so that your file has all the
"fluff" that makes it complete. If the model is not valid, then Write
will refuse to write it.
</summary>
            <param name="archive">[in] archive to write to</param>
            <param name="version">
[in] Version of the openNURBS archive to write. Must be 2, 3 or 4.
Rhino 2.x can read version 2 files.
Rhino 3.x can read version 2 and 3 files.
Rhino 4.x can read version 2, 3 and 4 files.
Use version 4 when possible.
</param>
            <param name="sStartSectionComment">
[in] Brief ASCII desciption of your app, today's date, etc.
</param>
            <returns>
True if archive is written with no error.
False if errors occur. Error details are logged in error_log.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.Write(RMA.OpenNURBS.OnBinaryArchive,System.Int32,System.String,RMA.OpenNURBS.OnTextLog)">
            <summary>
Writes contents of this model to an openNURBS archive. I STRONGLY suggested
that you call Polish() before calling Write so that your file has all the
"fluff" that makes it complete. If the model is not valid, then Write
will refuse to write it.
</summary>
            <param name="archive">[in] archive to write to</param>
            <param name="version">
[in] Version of the openNURBS archive to write. Must be 2, 3 or 4.
Rhino 2.x can read version 2 files.
Rhino 3.x can read version 2 and 3 files.
Rhino 4.x can read version 2, 3 and 4 files.
Use version 4 when possible.
</param>
            <param name="sStartSectionComment">
[in] Brief ASCII desciption of your app, today's date, etc.
</param>
            <param name="error_log">[out] any archive writing errors are logged here.</param>
            <returns>
True if archive is written with no error.
False if errors occur. Error details are logged in error_log.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.Read(RMA.OpenNURBS.OnBinaryArchive@)">
            <summary>Reads an openNURBS archive and saves the information in this model</summary>
            <param name="archive">[in] archive to read from</param>
            <returns>
true if archive is read with no error.
False if errors occur. Error details are logged in error_log.
If crc errors are in the archive, then m_crc_error_count is set
to the number of errors.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.Read(RMA.OpenNURBS.OnBinaryArchive@,RMA.OpenNURBS.OnTextLog)">
            <summary>Reads an openNURBS archive and saves the information in this model</summary>
            <param name="archive">[in] archive to read from</param>
            <param name="error_log">[out] any archive reading errors are logged here.</param>
            <returns>
true if archive is read with no error.
False if errors occur. Error details are logged in error_log.
If crc errors are in the archive, then m_crc_error_count is set
to the number of errors.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.Destroy">
            <summary>
Destroys contents of this model and leaves it ready to be reused.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnXModel.m_crc_error_count">
            <value>
Number of crc errors found during archive reading.
If &gt; 0, then the archive is corrupt.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnXModel.m_file_length">
            <value>
length of archive returned by ON_BinaryArchive::Read3dmEndMark()
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnXModel.m_settings">
            <value>
Settings include tolerance, and unit system, and defaults used
for creating views and objects.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnXModel.m_properties">
            <value>
Properties include revision history, notes, information about
the applicaton that created the file, and an option preview image.
</value>
        </member>
        <member name="T:RMA.OpenNURBS.OnXModel">
            <summary>
Pedegodgical example of all the things in an OpenNURBS 3dm archive.
The openNURBS examples use ONX_Model to store the information
read from 3dm archives.  Please study example_read.cpp for
details.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.DumpUserDataTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of user data table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.DumpHistoryRecordTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of object table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.DumpObjectTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of object table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.DumpIDefTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of instance definition table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.DumpHatchPatternTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of hatch pattern table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.DumpDimStyleTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of dimstyle table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.DumpFontTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of font table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.DumpGroupTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of group table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.DumpLightTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of light table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.DumpLayerTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of layer table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.DumpLinetypeTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of line type table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.DumpMaterialTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of render material table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.DumpTextureMappingTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of texture mapping table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.DumpBitmapTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of bitmap table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.DumpSummary(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of model properties and settings
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.Dump(RMA.OpenNURBS.OnTextLog)">
            <summary>text dump of entire model</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.GetUnusedLayerName(System.String)">
            <summary>
Get layer name that is not currently in use.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.LayerIndex(System.String)">
            <summary>Get layer definition from layer table.</summary>
            <param name="layer_name">[in] name to search for</param>
            <returns>Index of the layer or -1 if it is not found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.UsesIDef(RMA.OpenNURBS.IOnInstanceRef,System.Guid)">
            <summary>See if the instance reference iref refers to an instance definition.</summary>
            <param name="iref">[in]</param>
            <param name="idef_uuid">[in] id of idef we are looking for</param>
            <returns>
0 iref does not use idef
1 iref directly references idef
&gt;1 iref has a nested reference to idef (nesting depth returned)
-1 iref.m_instance_definition_uuid is not valid
-2 invalid idef found
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.IDefIndex(System.String)">
            <summary>Get instance definition index from instance definition name.</summary>
            <param name="idef_name">[in] name to search for</param>
            <returns>Index of the instance definition or -1 if it is not found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.IDefIndex(System.Guid)">
            <summary>Get instance definition from instance definition table.</summary>
            <param name="idef_uuid">[in] instance definition uuid.</param>
            <returns>Index of the instance definition or -1 if it is not found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.ObjectIndex(System.Guid)">
            <summary>Get index of object in m_object_table from object_uuid.</summary>
            <param name="object_uuid">[in] object uuid.</param>
            <returns>Index of the object or -1 if it is not found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.WireframeColor(System.Int32)">
            <summary>Get wireframe drawing color from object attributes.</summary>
            <param name="object_index">[in] m_object_table[] index</param>
            <returns>Wireframe drawing color.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.WireframeColor(RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <summary>Get wireframe drawing color from object attributes.</summary>
            <param name="attributes">[in] object attributes.</param>
            <returns>Wireframe drawing color.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.GetLinetype(System.Int32,RMA.OpenNURBS.OnLinetype@)">
            <summary>Get linetype from object_index.</summary>
            <param name="object_index">[in] m_object_table[] index</param>
            <param name="linetype">[out] linetype</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.GetLinetype(RMA.OpenNURBS.IOn3dmObjectAttributes,RMA.OpenNURBS.OnLinetype@)">
            <summary>Get linetype from object attributes.</summary>
            <param name="attributes">[in] object attributes.</param>
            <param name="linetype">[out] linetype</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.GetRenderMaterial(System.Int32,RMA.OpenNURBS.OnMaterial@)">
            <summary>Get render material from object_index.</summary>
            <param name="object_index">[in] m_object_table[] index</param>
            <param name="material">[out] render material</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.GetRenderMaterial(RMA.OpenNURBS.IOn3dmObjectAttributes,RMA.OpenNURBS.OnMaterial@)">
            <summary>Get render material from object attributes.</summary>
            <param name="attributes">[in] object attributes.</param>
            <param name="material">[out] render material</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.BoundingBox">
            <summary>
Returns: Bounding box of every object in m_object_table[].
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.IsValid">
            <summary>Check a model to make sure it is valid.</summary>
            <returns>True if the model is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.IsValid(RMA.OpenNURBS.OnTextLog)">
            <summary>Check a model to make sure it is valid.</summary>
            <param name="text_log">
[in] if not NULL and errors are found, a description of the problem is put in this text_log.
</param>
            <returns>True if the model is valid.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnXModel.m_crc_error_count">
            <value>
Number of crc errors found during archive reading.
If &gt; 0, then the archive is corrupt.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnXModel.m_file_length">
            <value>
length of archive returned by ON_BinaryArchive::Read3dmEndMark()
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnXModel.m_settings">
            <value>
Settings include tolerance, and unit system, and defaults used
for creating views and objects.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnXModel.m_properties">
            <value>
Properties include revision history, notes, information about
the applicaton that created the file, and an option preview image.
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnXModel">
            <summary>
Pedegodgical example of all the things in an OpenNURBS 3dm archive.
The openNURBS examples use ONX_Model to store the information
read from 3dm archives.  Please study example_read.cpp for
details.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnXModel_RenderLight">
            <summary>Used to store render light table light definition and attributes in an ONX_Model.</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnXModel_RenderLight">
            <summary>Used to store render light table light definition and attributes in an ONX_Model.</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnX_Model_RenderLight">
            <summary>Use OnXModel_RenderLight instead</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnX_Model_RenderLight">
            <summary>Use IOnXModel_RenderLight instead</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnXModel_Object.m_bDeleteObject">
            <value>
If m_bDeleteObject is true, then m_object will be deleted when
the last ONX_Model_Object that refers to it is destroyed.  The
default value of m_bDeleteObject is false.
</value>
        </member>
        <member name="T:RMA.OpenNURBS.OnXModel_Object">
            <summary>Used to store geometry table object definition and attributes in an ONX_Model.</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnXModel_Object.m_bDeleteObject">
            <value>
If m_bDeleteObject is true, then m_object will be deleted when
the last ONX_Model_Object that refers to it is destroyed.  The
default value of m_bDeleteObject is false.
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnXModel_Object">
            <summary>Used to store geometry table object definition and attributes in an ONX_Model.</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnX_Model_UserData">
            <summary>Used to store user data information in an ONX_Model.</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnX_Model_UserData">
            <summary>Used to store user data information in an ONX_Model.</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnHistoryRecord.m_record_id">
            <value>
Each history record has a unique id that is assigned
when the record is added to Rhino's history record table.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnHistoryRecord.m_version">
            <value>
A YYYYMMDDn version number that gets updated when
a command changes.  This version is checked so that
new versions of a command's ReplayHistory don't 
attempt to use information saved in old files.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnHistoryRecord.m_command_id">
            <value>
CRhinoCommand::CommandId() value of the command that
created this history record.  Each time the command
is run, it can create a history record.
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnHistoryRecord.ValueReport(RMA.OpenNURBS.OnTextLog)">
            <summary>Print a list of the values in text_log.</summary>
            <param name="text_log">[in]</param>
            <returns>Number of values listed.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHistoryRecord.IsAntecedent(System.Guid)">
            <summary>Determine if object is an antecedent (input) in this history record</summary>
            <param name="object_uuid">[in]</param>
            <returns>true if object_uuid is the id of an input object.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnHistoryRecord.m_record_id">
            <value>
Each history record has a unique id that is assigned
when the record is added to Rhino's history record table.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnHistoryRecord.m_version">
            <value>
A YYYYMMDDn version number that gets updated when
a command changes.  This version is checked so that
new versions of a command's ReplayHistory don't 
attempt to use information saved in old files.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnHistoryRecord.m_command_id">
            <value>
CRhinoCommand::CommandId() value of the command that
created this history record.  Each time the command
is run, it can create a history record.
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHistoryRecord.ValueReport(RMA.OpenNURBS.OnTextLog)">
            <summary>Print a list of the values in text_log.</summary>
            <param name="text_log">[in]</param>
            <returns>Number of values listed.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHistoryRecord.IsAntecedent(System.Guid)">
            <summary>Determine if object is an antecedent (input) in this history record</summary>
            <param name="object_uuid">[in]</param>
            <returns>true if object_uuid is the id of an input object.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnDetailView.m_boundary">
            <value>
2d curve in page layout coordinates in mm
(0,0) = lower left corner of page
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnDetailView.m_view">
            <value>
A view with ON_3dmView::m_view_type = ON::nested_view_type
This field is used for IO purposes only.  Runtime detail
view projection information is on CRhDetailViewObject.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnDetailView.m_page_per_model_ratio">
            <value>
m_page_per_model_ratio is the ratio of page length / model length
where both lengths are in the same unit system
(ex. 1/4" on page = 1' in model = 0.25/12 = 0.02083)
(    1mm on page  = 1m in model = 1/1000  = 0.001)
If m_page_per_model_ratio &gt; 0.0, then the detail
is drawn using the specified scale.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDetailView.m_boundary">
            <value>
2d curve in page layout coordinates in mm
(0,0) = lower left corner of page
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDetailView.m_view">
            <value>
A view with ON_3dmView::m_view_type = ON::nested_view_type
This field is used for IO purposes only.  Runtime detail
view projection information is on CRhDetailViewObject.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDetailView.m_page_per_model_ratio">
            <value>
m_page_per_model_ratio is the ratio of page length / model length
where both lengths are in the same unit system
(ex. 1/4" on page = 1' in model = 0.25/12 = 0.02083)
(    1mm on page  = 1m in model = 1/1000  = 0.001)
If m_page_per_model_ratio &gt; 0.0, then the detail
is drawn using the specified scale.
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnMMX_Polyline.Clean">
            <summary>
Description:
 Removes duplicate points that result in zero length segments.
Parameters:
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMMX_Polyline.Clean(System.Double)">
            <summary>
Description:
 Removes duplicate points that result in zero length segments.
Parameters:
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMMX_Polyline.#ctor">
            <summary>
see ON_SimpleArray class definition comments for constructor documentation
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMMX_POINT.m_MeshVertex_ID">
            <value>
ID for a set of points that theoretically ought to match
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMMX_POINT.m_MMX_Set_PT">
            <value>
the point chosen to be the intersection for the entire set.  Chosen based on a logical best answer (point that is on an edge or vertex)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMMX_POINT.m_MMX_Set_ID">
            <value>
ID for a set of points that theoretically ought to match
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMMX_POINT.m_overlap_sn">
            <value>
ON_MMX_POINT overlap serial number. -1 if the ON_MMX_POINT does not have mmx_overlap as it's type.  
No more than 2 ON_MMX_POINT should have the same m_overlap_sn.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMMX_POINT.m_sn">
            <value>
ON_MMX_POINT serial number
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMMX_POINT.m_type">
            <value>
The m_type field determines how the values in the other fields are interpreted. mmx_point = intersection point on mesh mmx_overlap = overlap endpoints on mesh:
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMMX_POINT.m_A">
            <value>
Nothing that needs a constructor can be in this class.
In particular, NO simple arrays.  I want to be able
to safely use memset((ptr,0,sizeof(ON_MESH_X_EVENT))
to create one of these.
Should be something really simple along the lines of ...
This is just a suggestion
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMMX_POINT.m_MeshVertex_ID">
            <value>
ID for a set of points that theoretically ought to match
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMMX_POINT.m_MMX_Set_PT">
            <value>
the point chosen to be the intersection for the entire set.  Chosen based on a logical best answer (point that is on an edge or vertex)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMMX_POINT.m_MMX_Set_ID">
            <value>
ID for a set of points that theoretically ought to match
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMMX_POINT.m_overlap_sn">
            <value>
ON_MMX_POINT overlap serial number. -1 if the ON_MMX_POINT does not have mmx_overlap as it's type.  
No more than 2 ON_MMX_POINT should have the same m_overlap_sn.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMMX_POINT.m_sn">
            <value>
ON_MMX_POINT serial number
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMMX_POINT.m_type">
            <value>
The m_type field determines how the values in the other fields are interpreted. mmx_point = intersection point on mesh mmx_overlap = overlap endpoints on mesh:
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMMX_POINT.m_A">
            <value>
Nothing that needs a constructor can be in this class.
In particular, NO simple arrays.  I want to be able
to safely use memset((ptr,0,sizeof(ON_MESH_X_EVENT))
to create one of these.
Should be something really simple along the lines of ...
This is just a suggestion
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnMESH_POINT.GetTriangle(System.Int32@,System.Int32@,System.Int32@)">
            <summary>
Gets the mesh face indices of the triangle where the intersection is on the face
takes into consideration the way the quad was split during the intersection
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMESH_POINT.SetTopologyComponentIndex(System.Double@)">
            <summary>
Description: Set the topological component of the this mesh point. Parameters: edge_parameter - [out] optional - can be NULL If the component is an edge, then *edge_parameter is set (0 &lt; *edge_parameter &lt; 1). If the component is not an edge, then *edge_parameter is set to ON_UNSET_VALUE. Returns: Component index of the topological component.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMESH_POINT.m_sn">
            <value>
ON_MESH_POINT serial number
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMESH_POINT.m_P">
            <value>
3d location
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMESH_POINT.m_Triangle">
            <value>
Face triangle where the intersection takes place;
0 is unset
A is 0,1,2
B is 0,2,3
C is 0,1,3
D is 1,2,3
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMESH_POINT.m_face_index">
            <value>
Mesh face index
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMESH_POINT.m_edge_index">
            <value>
default is -1.  If this ON_MESH_POINT is the result of intersecting an edge of m_mesh with a face of another mesh then this
should be set to that edge index and that edge will be one of the edges of the face at m_face_index.  If this ON_MESH_POINT 
is the result of intersecting an edge of another mesh with the face m_face_index of m_mesh then m_edge_index will remain -1;
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMESH_POINT.m_et">
            <value>
parameter on line defined by topedge.m_vi[0] to topedge.m_vi[1] if m_ci.m_type = ON_COMPONENT_INDEX::meshtop_edge
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMESH_POINT.GetTriangle(System.Int32@,System.Int32@,System.Int32@)">
            <summary>
Gets the mesh face indices of the triangle where the intersection is on the face
takes into consideration the way the quad was split during the intersection
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMESH_POINT.m_sn">
            <value>
ON_MESH_POINT serial number
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMESH_POINT.m_P">
            <value>
3d location
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMESH_POINT.m_Triangle">
            <value>
Face triangle where the intersection takes place;
0 is unset
A is 0,1,2
B is 0,2,3
C is 0,1,3
D is 1,2,3
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMESH_POINT.m_face_index">
            <value>
Mesh face index
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMESH_POINT.m_edge_index">
            <value>
default is -1.  If this ON_MESH_POINT is the result of intersecting an edge of m_mesh with a face of another mesh then this
should be set to that edge index and that edge will be one of the edges of the face at m_face_index.  If this ON_MESH_POINT 
is the result of intersecting an edge of another mesh with the face m_face_index of m_mesh then m_edge_index will remain -1;
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMESH_POINT.m_et">
            <value>
parameter on line defined by topedge.m_vi[0] to topedge.m_vi[1] if m_ci.m_type = ON_COMPONENT_INDEX::meshtop_edge
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurface.BaseSurface">
            <summary>
Returns: Base surface;
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurface.SetBaseSurface(RMA.OpenNURBS.OnSurface,System.Boolean)">
            <summary>Sets base surface to a surface that is optionally managed by the ON_OffsetSurface class.</summary>
            <param name="base_surface">
[in] points to a base surface the caller insures will exist for the lifetime of the ON_OffsetSurface class.
</param>
            <param name="bManage">
[in] if true, the base_surface must point to a surface that is on the heap and the surface will be deleted by ~ON_OffsetSurface.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurface.SetBaseSurface(RMA.OpenNURBS.IOnSurface)">
            <summary>Sets base surface to a surface that is not managed by the ON_OffsetSurface class.</summary>
            <param name="base_surface">
[in] points to a base surface the caller insures will exist for the lifetime of the ON_OffsetSurface class.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="T:RMA.OpenNURBS.OnOffsetSurface">
            <summary>
This is still a work in progress.  In particular, this surface class can
not be saved in files, used as a brep surface, added to Rhino, etc.

As of January 2004, it is useful for calculating offset meshes and any
other fitting and approximation tools that requires a surface evaluator
but do not need NURBS forms, isocurves, and so on.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOffsetSurface.BaseSurface">
            <summary>
Returns: Base surface;
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnOffsetSurface">
            <summary>
This is still a work in progress.  In particular, this surface class can
not be saved in files, used as a brep surface, added to Rhino, etc.

As of January 2004, it is useful for calculating offset meshes and any
other fitting and approximation tools that requires a surface evaluator
but do not need NURBS forms, isocurves, and so on.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurfaceFunction.Destroy">
            <summary>
Resets this class if you want to reuse it.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurfaceFunction.PointAt(System.Double,System.Double)">
            <summary>Value of the offset function at any surface parameter.</summary>
            <param name="s">[in] (s,t) is a base surface evaluation parameter</param>
            <param name="t">[in] (s,t) is a base surface evaluation parameter</param>
            <returns>Point on the offset surface.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurfaceFunction.EvaluateDistance(System.Double,System.Double,System.Int32,System.Double[]@)">
            <summary>Value of the offset distance at any surface parameter.</summary>
            <param name="s">[in] (s,t) is a base surface evaluation parameter</param>
            <param name="t">[in] (s,t) is a base surface evaluation parameter</param>
            <param name="num_der">[in] number of derivatives</param>
            <param name="value">
[out] value and derivatives of distance function
value[0] = distance, value[1] = 1rst derivative,
value[2] = 2nd derivative, ...
</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurfaceFunction.DistanceAt(System.Double,System.Double)">
            <summary>Value of the offset distance at any surface parameter.</summary>
            <param name="s">[in] (s,t) is a base surface evaluation parameter</param>
            <param name="t">[in] (s,t) is a base surface evaluation parameter</param>
            <returns>offset distance at the surface parameter</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurfaceFunction.OffsetDistance(System.Int32)">
            <param name="i">[in] an index &gt;= 0 and &lt; OffsetPointCount()</param>
            <returns>Offset distance specified using SetOffsetPoint().</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurfaceFunction.OffsetSurfaceParameter(System.Int32)">
            <param name="i">[in] an index &gt;= 0 and &lt; OffsetPointCount()</param>
            <returns>Surface parameter specified using SetOffsetPoint().</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurfaceFunction.OffsetPointCount">
            <summary>
Returns: Number of points specified using SetOffsetPoint().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurfaceFunction.SetDistance(System.Int32,System.Double)">
            <summary>Set the offset distance for an existing point</summary>
            <param name="index">[in] index of the point to set</param>
            <param name="distance">[in] new distance</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurfaceFunction.SetPoint(System.Int32,System.Double,System.Double)">
            <summary>Sets the surface parameters of an existing offset point.</summary>
            <param name="index">[in] index of the point to set</param>
            <param name="s">[in] (s,t) is a base surface evaluation parameter</param>
            <param name="t">[in] (s,t) is a base surface evaluation parameter</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurfaceFunction.SetOffsetPoint(System.Double,System.Double,System.Double)">
            <summary>
Sets the offset distance at a point. Call this function once for each
point wher the user specifies an offset. 
</summary>
            <param name="s">[in] (s,t) is a base surface evaluation parameter</param>
            <param name="t">[in] (s,t) is a base surface evaluation parameter</param>
            <param name="distance">[in] distance is the offset distance.</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurfaceFunction.SetOffsetPoint(System.Double,System.Double,System.Double,System.Double)">
            <summary>
Sets the offset distance at a point. Call this function once for each
point wher the user specifies an offset. 
</summary>
            <param name="s">[in] (s,t) is a base surface evaluation parameter</param>
            <param name="t">[in] (s,t) is a base surface evaluation parameter</param>
            <param name="distance">[in] distance is the offset distance.</param>
            <param name="radius">
[in] if radius&gt;0, then this value will be the the approximate radius of the offset "bump".
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurfaceFunction.SideTangency(System.Int32)">
            <param name="side">
0 = south side
1 = east side
2 = north side
3 = west side
</param>
            <returns>True if side tangency is enabled.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurfaceFunction.SetSideTangency(System.Int32,System.Boolean)">
            <summary>
Use set SetSideTangency if you want the offset surface and base surface
to have the same unit normals along a side of the surfaces's parameter spaces.
</summary>
            <param name="side">
0 = south side
1 = east side
2 = north side
3 = west side
</param>
            <param name="bEnable">[in] true to enable tangency, false to disable tangency</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurfaceFunction.BaseSurface">
            <summary>
Returns: Base surface specified SetBaseSurface().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurfaceFunction.SetBaseSurface(RMA.OpenNURBS.IOnSurface)">
            <summary>Sets base surface for the offset function.</summary>
            <param name="srf">
[in] pointer to the base surface.
This surface must remain valid while
the ON_OffsetSurfaceFunction class is used.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOffsetSurfaceFunction.PointAt(System.Double,System.Double)">
            <summary>Value of the offset function at any surface parameter.</summary>
            <param name="s">[in] (s,t) is a base surface evaluation parameter</param>
            <param name="t">[in] (s,t) is a base surface evaluation parameter</param>
            <returns>Point on the offset surface.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOffsetSurfaceFunction.EvaluateDistance(System.Double,System.Double,System.Int32,System.Double[]@)">
            <summary>Value of the offset distance at any surface parameter.</summary>
            <param name="s">[in] (s,t) is a base surface evaluation parameter</param>
            <param name="t">[in] (s,t) is a base surface evaluation parameter</param>
            <param name="num_der">[in] number of derivatives</param>
            <param name="value">
[out] value and derivatives of distance function
value[0] = distance, value[1] = 1rst derivative,
value[2] = 2nd derivative, ...
</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOffsetSurfaceFunction.DistanceAt(System.Double,System.Double)">
            <summary>Value of the offset distance at any surface parameter.</summary>
            <param name="s">[in] (s,t) is a base surface evaluation parameter</param>
            <param name="t">[in] (s,t) is a base surface evaluation parameter</param>
            <returns>offset distance at the surface parameter</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOffsetSurfaceFunction.OffsetDistance(System.Int32)">
            <param name="i">[in] an index &gt;= 0 and &lt; OffsetPointCount()</param>
            <returns>Offset distance specified using SetOffsetPoint().</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOffsetSurfaceFunction.OffsetSurfaceParameter(System.Int32)">
            <param name="i">[in] an index &gt;= 0 and &lt; OffsetPointCount()</param>
            <returns>Surface parameter specified using SetOffsetPoint().</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOffsetSurfaceFunction.OffsetPointCount">
            <summary>
Returns: Number of points specified using SetOffsetPoint().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOffsetSurfaceFunction.SideTangency(System.Int32)">
            <param name="side">
0 = south side
1 = east side
2 = north side
3 = west side
</param>
            <returns>True if side tangency is enabled.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOffsetSurfaceFunction.BaseSurface">
            <summary>
Returns: Base surface specified SetBaseSurface().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnObjRef.ProxyReferenceCount">
            <summary>
Returns:
0: This ON_ObjRef is not counting references.
&gt;0: Number of references.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnObjRef.SetProxy(RMA.OpenNURBS.OnObject,RMA.OpenNURBS.OnObject,System.Boolean)">
            <summary>
Expert user tool to initialize the ON_ObjRef m__proxy1, m__proxy2, and m__proxy_ref_count fields.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnObjRef.DecrementProxyReferenceCount">
            <summary>
Expert user tool to decrement reference counts. Most users will never need
to call this tool. It is called by ~ON_ObjRef and used in rare cases when a
ON_ObjRef needs to reference an object only by uuid and component index.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjRef.m__iref">
            <value>
If m__iref[] is not empty, then m_uuid identifies
and instance reference (ON_InstanceRef/CRhinoInstanceObject)
and m__iref[] records the chain of instance references from
the base piece of geometry to the instance reference.
The top level instance reference is last in the list.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjRef.m_evp">
            <value>
If m_point != ON_UNSET_POINT and m_evp.m_t_type != 0, then
m_evp records the records the m_geometry evaluation
parameters for the m_point.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjRef.m_osnap_mode">
            <value>
If the point was the result of some type of object snap, then
the object snap is recorded here.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjRef.m_point">
            <value>
If m_point != ON_UNSET_POINT, then the ObjRef resolves to 
a point location.  The point location is saved here so the
information can persist if the object itself vanishes.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjRef.m_parent_geometry">
            <value>
The m_geometry and m_parent_geometry pointers are runtime values
that point to the object being referenced.  The destructor 
~ON_ObjRef  does not delete the objects these pointers reference.

m_geometry_type records the type of geometry m_geometry points to.

When the referenced object is a subobject, like a part of a brep 
or mesh, m_geometry points to the subobject and m_parent_geometry 
points to the parent object, like the brep or mesh.  In this case
m_component_index records the location of the subobject.

Parts of instance reference objects:
 When the geometry belongs to an instance reference
 m_uuid is the id of the CRhinoInstanceObject,
 m_parent_geometry points to the instance definition
 geometry or a transformed proxy, and m_geometry points
 to the piece of m_geometry.  The m__iref[] array records
 the connection between the instance reference and the
 geometry the ON_ObjRef refers to.

 For example if the ON_ObjRef is to an edge of a brep in
 and instance reference, m_uuid would be the Rhino id of
 the CRhinoInstanceObject, m_parent_geometry would point
 to a, possibly proxy, ON_Brep object, m_geometry would point
 to the ON_BrepEdge in the ON_Brep, m_component_index would
 record the edge's index in the ON_Brep.m_E[] array and 
 m_geometry_type would be ON::curve_object or ON::brep_edge.
 m__iref-&gt;Last() would contain the information about the
 top level instance reference.  If the brep was at the bottom
 of a chain of instance references, m__iref[0] would be the
 reference that immediately used the brep.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjRef.m_geometry">
            <value>
The m_geometry and m_parent_geometry pointers are runtime values
that point to the object being referenced.  The destructor 
~ON_ObjRef  does not delete the objects these pointers reference.

m_geometry_type records the type of geometry m_geometry points to.

When the referenced object is a subobject, like a part of a brep 
or mesh, m_geometry points to the subobject and m_parent_geometry 
points to the parent object, like the brep or mesh.  In this case
m_component_index records the location of the subobject.

Parts of instance reference objects:
 When the geometry belongs to an instance reference
 m_uuid is the id of the CRhinoInstanceObject,
 m_parent_geometry points to the instance definition
 geometry or a transformed proxy, and m_geometry points
 to the piece of m_geometry.  The m__iref[] array records
 the connection between the instance reference and the
 geometry the ON_ObjRef refers to.

 For example if the ON_ObjRef is to an edge of a brep in
 and instance reference, m_uuid would be the Rhino id of
 the CRhinoInstanceObject, m_parent_geometry would point
 to a, possibly proxy, ON_Brep object, m_geometry would point
 to the ON_BrepEdge in the ON_Brep, m_component_index would
 record the edge's index in the ON_Brep.m_E[] array and 
 m_geometry_type would be ON::curve_object or ON::brep_edge.
 m__iref-&gt;Last() would contain the information about the
 top level instance reference.  If the brep was at the bottom
 of a chain of instance references, m__iref[0] would be the
 reference that immediately used the brep.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjRef.m_uuid">
            <value>
In Rhino, this uuid is the persistent id of the CRhinoObject
that owns the referenced geometry.  The value of the
CRhinoObject id is stored on ON_3dmObjectAttributes.m_uuid.
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnObjRef.ProxyReferenceCount">
            <summary>
Returns: 0: This ON_ObjRef is not counting references. &gt;0: Number of references.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjRef.m__iref">
            <value>
If m__iref[] is not empty, then m_uuid identifies
and instance reference (ON_InstanceRef/CRhinoInstanceObject)
and m__iref[] records the chain of instance references from
the base piece of geometry to the instance reference.
The top level instance reference is last in the list.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjRef.m_evp">
            <value>
If m_point != ON_UNSET_POINT and m_evp.m_t_type != 0, then
m_evp records the records the m_geometry evaluation
parameters for the m_point.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjRef.m_osnap_mode">
            <value>
If the point was the result of some type of object snap, then
the object snap is recorded here.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjRef.m_point">
            <value>
If m_point != ON_UNSET_POINT, then the ObjRef resolves to 
a point location.  The point location is saved here so the
information can persist if the object itself vanishes.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjRef.m_parent_geometry">
            <value>
The m_geometry and m_parent_geometry pointers are runtime values
that point to the object being referenced.  The destructor 
~ON_ObjRef  does not delete the objects these pointers reference.

m_geometry_type records the type of geometry m_geometry points to.

When the referenced object is a subobject, like a part of a brep 
or mesh, m_geometry points to the subobject and m_parent_geometry 
points to the parent object, like the brep or mesh.  In this case
m_component_index records the location of the subobject.

Parts of instance reference objects:
 When the geometry belongs to an instance reference
 m_uuid is the id of the CRhinoInstanceObject,
 m_parent_geometry points to the instance definition
 geometry or a transformed proxy, and m_geometry points
 to the piece of m_geometry.  The m__iref[] array records
 the connection between the instance reference and the
 geometry the ON_ObjRef refers to.

 For example if the ON_ObjRef is to an edge of a brep in
 and instance reference, m_uuid would be the Rhino id of
 the CRhinoInstanceObject, m_parent_geometry would point
 to a, possibly proxy, ON_Brep object, m_geometry would point
 to the ON_BrepEdge in the ON_Brep, m_component_index would
 record the edge's index in the ON_Brep.m_E[] array and 
 m_geometry_type would be ON::curve_object or ON::brep_edge.
 m__iref-&gt;Last() would contain the information about the
 top level instance reference.  If the brep was at the bottom
 of a chain of instance references, m__iref[0] would be the
 reference that immediately used the brep.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjRef.m_geometry">
            <value>
The m_geometry and m_parent_geometry pointers are runtime values
that point to the object being referenced.  The destructor 
~ON_ObjRef  does not delete the objects these pointers reference.

m_geometry_type records the type of geometry m_geometry points to.

When the referenced object is a subobject, like a part of a brep 
or mesh, m_geometry points to the subobject and m_parent_geometry 
points to the parent object, like the brep or mesh.  In this case
m_component_index records the location of the subobject.

Parts of instance reference objects:
 When the geometry belongs to an instance reference
 m_uuid is the id of the CRhinoInstanceObject,
 m_parent_geometry points to the instance definition
 geometry or a transformed proxy, and m_geometry points
 to the piece of m_geometry.  The m__iref[] array records
 the connection between the instance reference and the
 geometry the ON_ObjRef refers to.

 For example if the ON_ObjRef is to an edge of a brep in
 and instance reference, m_uuid would be the Rhino id of
 the CRhinoInstanceObject, m_parent_geometry would point
 to a, possibly proxy, ON_Brep object, m_geometry would point
 to the ON_BrepEdge in the ON_Brep, m_component_index would
 record the edge's index in the ON_Brep.m_E[] array and 
 m_geometry_type would be ON::curve_object or ON::brep_edge.
 m__iref-&gt;Last() would contain the information about the
 top level instance reference.  If the brep was at the bottom
 of a chain of instance references, m__iref[0] would be the
 reference that immediately used the brep.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjRef.m_uuid">
            <value>
In Rhino, this uuid is the persistent id of the CRhinoObject
that owns the referenced geometry.  The value of the
CRhinoObject id is stored on ON_3dmObjectAttributes.m_uuid.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjRef_IRefID.m_evp">
            <value>
If this ON_ObjRef_IRefID is the first entry in the
ON_ObjRef.m__iref[] array, then it references a "real"
piece of geometry (not a nested instance reference).  
If there is an evaluation parameter for the geometry,
it is saved in m_evp.
In all other cases, m_evp is not set.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjRef_IRefID.m_component_index">
            <value>
If this ON_ObjRef_IRefID is the first entry in the
ON_ObjRef.m__iref[] array, then it references a "real"
piece of geometry (not a nested instance reference).  
If the reference is to a subobject of the real piece
of geometry, then m_component_index records
the subobject index.
In all other cases, m_component_index is not set.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjRef_IRefID.m_geometry_xform">
            <value>
m_geometry_xform is the transformation to map the
base geometry to world coordinates.  If the
instance reference is not nested, then
m_geometry_xform = m_iref_xform.  If the instance
reference is nested, then
 m_geometry_xform = m_iref_xform * .... * T1
where the Ts are the transformations from the children.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjRef_IRefID.m_idef_geometry_index">
            <value>
m_geometry_index is the index of the uuid of the pertinant
piece of geometry in the ON_InstanceRef.m_object_uuid[] 
array.  This index is identical to the index of the
geometry's CRhinoObject in the
CRhinoInstanceDefinition.m_objects[] array.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjRef_IRefID.m_idef_uuid">
            <value>
m_idef_uuid is the instance definition id stored in
ON_InstanceRef.m_instance_definition_uuid and
ON_InstanceDefinition.m_uuid.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjRef_IRefID.m_iref_xform">
            <value>
m_iref_xform is the value stored in ON_InstanceRef.m_xform.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjRef_IRefID.m_iref_uuid">
            <value>
m_iref_uuid is the CRhinoInstanceObject's uuid stored
in its ON_3dmObjectAttributes.m_uuid.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjRef_IRefID.m_evp">
            <value>
If this ON_ObjRef_IRefID is the first entry in the
ON_ObjRef.m__iref[] array, then it references a "real"
piece of geometry (not a nested instance reference).  
If there is an evaluation parameter for the geometry,
it is saved in m_evp.
In all other cases, m_evp is not set.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjRef_IRefID.m_component_index">
            <value>
If this ON_ObjRef_IRefID is the first entry in the
ON_ObjRef.m__iref[] array, then it references a "real"
piece of geometry (not a nested instance reference).  
If the reference is to a subobject of the real piece
of geometry, then m_component_index records
the subobject index.
In all other cases, m_component_index is not set.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjRef_IRefID.m_geometry_xform">
            <value>
m_geometry_xform is the transformation to map the
base geometry to world coordinates.  If the
instance reference is not nested, then
m_geometry_xform = m_iref_xform.  If the instance
reference is nested, then
 m_geometry_xform = m_iref_xform * .... * T1
where the Ts are the transformations from the children.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjRef_IRefID.m_idef_geometry_index">
            <value>
m_geometry_index is the index of the uuid of the pertinant
piece of geometry in the ON_InstanceRef.m_object_uuid[] 
array.  This index is identical to the index of the
geometry's CRhinoObject in the
CRhinoInstanceDefinition.m_objects[] array.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjRef_IRefID.m_idef_uuid">
            <value>
m_idef_uuid is the instance definition id stored in
ON_InstanceRef.m_instance_definition_uuid and
ON_InstanceDefinition.m_uuid.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjRef_IRefID.m_iref_xform">
            <value>
m_iref_xform is the value stored in ON_InstanceRef.m_xform.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjRef_IRefID.m_iref_uuid">
            <value>
m_iref_uuid is the CRhinoInstanceObject's uuid stored
in its ON_3dmObjectAttributes.m_uuid.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjRefEvaluationParameter.m_t_ci">
            <value>
Not necesarily the same as m_component_index
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjRefEvaluationParameter.m_s(System.Int32)">
            <value>
curve/surface/cage domains
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjRefEvaluationParameter.m_t_type">
            <value>
If m_point != ON_UNSET_POINT and m_t_type != 0, then
m_t_type, m_t, and m_t_ci record the m_geometry evaluation
parameters of the m_point.

 m_t_type values

0: no parameter values; m_t_ci and m_t[] have no meaning.

1: m_geometry points to a curve, m_t[0] is a curve
  parameter for m_point, and m_t_ci has no meaning.

2: m_geometry points to surface or single faced brep,
  (m_t[0],m_t[1]) is a surface parameter for m_point,
  and m_t_ci has no meaning.
  In this case, m_component_index may not be set or,
  if m_geometry points to a brep face, m_component_index
  may identify the face in the parent brep.

3: m_geometry points to a brep edge with an associated
  trim and m_t[0] is the edge parameter for m_point.
  m_t_ci is the ON_BrepTrim component index and m_t[1]
  is the ON_BrepTrim parameter that corresponds to the
  edge point.  m_s[0] and m_s[1] are normalized parameters.
  In this case m_component_index identifies the
  the edge in the brep and m_t_ci identifies a trim.

4: m_geometry points to a mesh or mesh face and 
  m_t_ci identifies the mesh face.
  If the face is a triangle, the barycentric coordinates
  of m_point are(m_t[0], m_t[1], m_t[2]) and m_t[3] is zero. 
  If the mesh face is a quadrangle, the barycentric coordinates
  of m_point are (m_t[0], m_t[1], m_t[2], m_t[3]) and at least 
  one of the coordinates is zero.  In both cases, the point
  can be evaluated using the formula
  m_t[0]*mesh.m_V[f.vi[0]] + ... + m_t[3]*mesh.m_V[f.vi[3]],
  where f = mesh.m_F[m_component_index.m_index].
  In this case, if m_geometry points to a mesh, then
  m_component_index !=  m_t_ci.

5: m_geometry points to a mesh or mesh edge and m_t_ci
  identifies the mesh edge. The normalized coordinate of
  the point on the mesh edge is m_t[0].  The point can be evaluated
  using the formula
  m_t[0]*mesh.m_V[v0] + (1.0-m_t[0])*mesh.m_V[v1],
  where v0 and v1 are the indices of the mesh vertices at
  the edge's ends.
  In this case, if m_geometry points to a mesh, then
  m_component_index !=  m_t_ci.

6: m_geometry points to a NURBS cage and (m_t[0],m_t[1],m_t[2])
  are cage evaluation parameters.

7: m_geometry points to an annotation object and m_t_ci identifies
  a point on the annotation object.

8: m_geometry points to a mesh or mesh vertex object and m_t_ci
  identifies a vertex on the mesh object.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjRefEvaluationParameter.m_t_ci">
            <value>
Not necesarily the same as m_component_index
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjRefEvaluationParameter.m_s(System.Int32)">
            <value>
curve/surface/cage domains
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjRefEvaluationParameter.m_t_type">
            <value>
If m_point != ON_UNSET_POINT and m_t_type != 0, then
m_t_type, m_t, and m_t_ci record the m_geometry evaluation
parameters of the m_point.

 m_t_type values

0: no parameter values; m_t_ci and m_t[] have no meaning.

1: m_geometry points to a curve, m_t[0] is a curve
  parameter for m_point, and m_t_ci has no meaning.

2: m_geometry points to surface or single faced brep,
  (m_t[0],m_t[1]) is a surface parameter for m_point,
  and m_t_ci has no meaning.
  In this case, m_component_index may not be set or,
  if m_geometry points to a brep face, m_component_index
  may identify the face in the parent brep.

3: m_geometry points to a brep edge with an associated
  trim and m_t[0] is the edge parameter for m_point.
  m_t_ci is the ON_BrepTrim component index and m_t[1]
  is the ON_BrepTrim parameter that corresponds to the
  edge point.  m_s[0] and m_s[1] are normalized parameters.
  In this case m_component_index identifies the
  the edge in the brep and m_t_ci identifies a trim.

4: m_geometry points to a mesh or mesh face and 
  m_t_ci identifies the mesh face.
  If the face is a triangle, the barycentric coordinates
  of m_point are(m_t[0], m_t[1], m_t[2]) and m_t[3] is zero. 
  If the mesh face is a quadrangle, the barycentric coordinates
  of m_point are (m_t[0], m_t[1], m_t[2], m_t[3]) and at least 
  one of the coordinates is zero.  In both cases, the point
  can be evaluated using the formula
  m_t[0]*mesh.m_V[f.vi[0]] + ... + m_t[3]*mesh.m_V[f.vi[3]],
  where f = mesh.m_F[m_component_index.m_index].
  In this case, if m_geometry points to a mesh, then
  m_component_index !=  m_t_ci.

5: m_geometry points to a mesh or mesh edge and m_t_ci
  identifies the mesh edge. The normalized coordinate of
  the point on the mesh edge is m_t[0].  The point can be evaluated
  using the formula
  m_t[0]*mesh.m_V[v0] + (1.0-m_t[0])*mesh.m_V[v1],
  where v0 and v1 are the indices of the mesh vertices at
  the edge's ends.
  In this case, if m_geometry points to a mesh, then
  m_component_index !=  m_t_ci.

6: m_geometry points to a NURBS cage and (m_t[0],m_t[1],m_t[2])
  are cage evaluation parameters.

7: m_geometry points to an annotation object and m_t_ci identifies
  a point on the annotation object.

8: m_geometry points to a mesh or mesh vertex object and m_t_ci
  identifies a vertex on the mesh object.
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnDimStyle.DimExtension">
            <summary>
added version 1.3
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnDimStyle.InvalidateField(RMA.OpenNURBS.IOnDimStyle.eField)">
            <summary>
mark a single field as invalid
Setting a field value marks that field as valid
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnDimStyle.Composite(RMA.OpenNURBS.IOnDimStyle)">
            <summary>
replace the values in this with any valid fields in override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnDimStyle.LengthFactor">
            <summary>
added at ver 1.3
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnDimStyle.op_Implicit(RMA.OpenNURBS.IOn3dmAnnotationSettings)~RMA.OpenNURBS.OnDimStyle">
            <summary>
C++ default copy construction and operator= work fine.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_leaderarrowsize">
            <value>
fields added version 1.5 Mar 23 06
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_dimextension">
            <value>
(dimdle) dimension line extension past the "tip" location
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_valid">
            <value>
flags of what fields are being used
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_alternate_suffix">
            <value>
string following alternate value string
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_alternate_prefix">
            <value>
string preceding alternate value string
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_suffix">
            <value>
string following dimension value string
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_prefix">
            <value>
string preceding dimension value string
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_alternate_angleresolution">
            <value>
for decimal degrees, digits past decimal
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_alternate_angleformat">
            <value>
0: decimal degrees, ...
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_alternate_lengthresolution">
            <value>
depends on m_lengthformat
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_alternate_lengthformat">
            <value>
0: decimal, 1: feet, 2: feet &amp; inches
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_alternate_lengthfactor">
            <value>
(dimaltf) model units multiplier for alternate length display
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_bAlternate">
            <value>
(dimalt) display alternate dimension string (or not)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_lengthfactor">
            <value>
(dimlfac) model units multiplier for length display
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_fontindex">
            <value>
index of the ON_Font used by this dimstyle
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_lengthresolution">
            <value>
depends on m_lengthformat
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_angleresolution">
            <value>
for decimal degrees, digits past decimal
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_angleformat">
            <value>
0: decimal degrees, ...
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_lengthformat">
            <value>
0: decimal, 1: feet, 2: feet &amp; inches
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_angularunits">
            <value>
0: degrees, 1: radians
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_arrowtype">
            <value>
0: filled narrow triangular arrow
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_textalign">
            <value>
text alignment relative to the dimension line
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_textheight">
            <value>
model unit height of dimension text before applying dimscale
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_textgap">
            <value>
gap around the text for clipping dim line
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_centermark">
            <value>
size of the + at circle centers
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_arrowsize">
            <value>
length of an arrow - may mean different things to different arrows
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_extoffset">
            <value>
extension line offset
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_extextension">
            <value>
extension line extension
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_dimstyle_index">
            <value>
Index in the dimstyle table
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_dimstyle_name">
            <value>
String name of the style
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnDimStyle.DimExtension">
            <summary>
added version 1.3
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnDimStyle.LengthFactor">
            <summary>
added at ver 1.3
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_leaderarrowsize">
            <value>
fields added version 1.5 Mar 23 06
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_dimextension">
            <value>
(dimdle) dimension line extension past the "tip" location
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_valid">
            <value>
flags of what fields are being used
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_alternate_suffix">
            <value>
string following alternate value string
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_alternate_prefix">
            <value>
string preceding alternate value string
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_suffix">
            <value>
string following dimension value string
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_prefix">
            <value>
string preceding dimension value string
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_alternate_angleresolution">
            <value>
for decimal degrees, digits past decimal
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_alternate_angleformat">
            <value>
0: decimal degrees, ...
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_alternate_lengthresolution">
            <value>
depends on m_lengthformat
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_alternate_lengthformat">
            <value>
0: decimal, 1: feet, 2: feet &amp; inches
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_alternate_lengthfactor">
            <value>
(dimaltf) model units multiplier for alternate length display
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_bAlternate">
            <value>
(dimalt) display alternate dimension string (or not)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_lengthfactor">
            <value>
(dimlfac) model units multiplier for length display
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_fontindex">
            <value>
index of the ON_Font used by this dimstyle
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_lengthresolution">
            <value>
depends on m_lengthformat
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_angleresolution">
            <value>
for decimal degrees, digits past decimal
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_angleformat">
            <value>
0: decimal degrees, ...
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_lengthformat">
            <value>
0: decimal, 1: feet, 2: feet &amp; inches
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_angularunits">
            <value>
0: degrees, 1: radians
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_arrowtype">
            <value>
0: filled narrow triangular arrow
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_textalign">
            <value>
text alignment relative to the dimension line
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_textheight">
            <value>
model unit height of dimension text before applying dimscale
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_textgap">
            <value>
gap around the text for clipping dim line
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_centermark">
            <value>
size of the + at circle centers
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_arrowsize">
            <value>
length of an arrow - may mean different things to different arrows
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_extoffset">
            <value>
extension line offset
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_extextension">
            <value>
extension line extension
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_dimstyle_index">
            <value>
Index in the dimstyle table
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_dimstyle_name">
            <value>
String name of the style
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatch.SetPatternIndex(System.Int32)">
            <summary>Set the index of the hatch's pattern</summary>
            <param name="index">[in] pattern index to set</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatch.PatternIndex">
            <summary>Get the index of the hatch's pattern</summary>
            <returns>index of the pattern</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatch.LoopCurve3d(System.Int32)">
            <summary>Get the 3d curve corresponding to loop[index]</summary>
            <param name="index">[in] which loop to get</param>
            <returns>
pointer to 3d curve of loop at index NULL if index is out of range or curve
can't be made Caller deletes the returned curve
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatch.Loop(System.Int32)">
            <summary>Get the loop at index</summary>
            <param name="index">[in] which loop to get</param>
            <returns>pointer to loop at index NULL if index is out of range</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatch.RemoveLoop(System.Int32)">
            <summary>Remove a loop in the hatch</summary>
            <param name="index">[in] zero based index of the loop to remove.</param>
            <returns>true if success</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatch.InsertLoop(System.Int32,RMA.OpenNURBS.OnHatchLoop)">
            <summary>Insert a loop to the hatch at the specified index</summary>
            <param name="index">[in] zero based index of the position where insert the loop to.</param>
            <param name="loop">[in] the loop to insert</param>
            <returns>
true if success
false if index is lower than 0 or greater than current loop count.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatch.AddLoop(RMA.OpenNURBS.OnHatchLoop)">
            <summary>Add a loop to the hatch</summary>
            <param name="loop">[in] the loop to add</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatch.LoopCount">
            <summary>Get the number of loops used by this hatch</summary>
            <returns>the number of loops</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatch.SetPatternScale(System.Double)">
            <summary>
Sets the scale applied to the hatch pattern when it is mapped to the hatch's plane
</summary>
            <param name="scale">[in] The scale</param>
            <remarks>The pattern is scaled around the hatch's plane origin by this value</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatch.PatternScale">
            <summary>
Gets the scale applied to the hatch pattern when it is mapped to the hatch's plane
</summary>
            <returns>The scale</returns>
            <remarks>The pattern is scaled around the hatch's plane origin by this value</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatch.SetPatternRotation(System.Double)">
            <summary>
Sets the rotation applied to the hatch pattern when it is mapped to the hatch's plane
</summary>
            <param name="rotation">[in] The rotation in radians</param>
            <remarks>The pattern is rotated counter-clockwise around the hatch's plane origin by this value</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatch.PatternRotation">
            <summary>
Gets the rotation applied to the hatch pattern when it is mapped to the hatch's plane
</summary>
            <returns>The rotation in radians</returns>
            <remarks>The pattern is rotated counter-clockwise around the hatch's plane origin by this value</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatch.SetPlane(RMA.OpenNURBS.IOnPlane)">
            <summary>
Set the plane defining the hatch's coordinate system
</summary>
            <param name="plane">[in] the plane to set</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatch.Plane">
            <summary>Get the plane defining the hatch's coordinate system</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatch.Create(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.IOnCurve[],System.Int32,System.Double,System.Double)">
            <summary>Create a hatch from input geometry and parameters</summary>
            <param name="plane">[IN] - ON_Plane to make the hatch on</param>
            <param name="loops">[IN] - Array of boundary loops with the outer one first</param>
            <param name="pattern_index">[IN] - Index into the hatch table</param>
            <param name="pattern_rotation">[IN] - ccw in radians about plane origin</param>
            <param name="pattern_scale">[IN] - Scale factor for pattern definition</param>
            <returns>true = success, false = failure</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatch.#ctor">
            <summary>
Default constructor
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnHatch">
            <summary>
Represents a hatch in planar boundary loop or loops 
This is a 2d entity with a plane defining a local coordinate system
The loops, patterns, angles, etc are all in this local coordinate system

The ON_Hatch object manages the plane and loop array
Fill definitions are in the ON_HatchPattern or class derived from ON_HatchPattern
ON_Hatch has an index to get the pattern definition from the pattern table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatch.PatternIndex">
            <summary>Get the index of the hatch's pattern</summary>
            <returns>index of the pattern</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatch.LoopCurve3d(System.Int32)">
            <summary>Get the 3d curve corresponding to loop[index]</summary>
            <param name="index">[in] which loop to get</param>
            <returns>
pointer to 3d curve of loop at index NULL if index is out of range or curve
can't be made Caller deletes the returned curve
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatch.Loop(System.Int32)">
            <summary>Get the loop at index</summary>
            <param name="index">[in] which loop to get</param>
            <returns>pointer to loop at index NULL if index is out of range</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatch.LoopCount">
            <summary>Get the number of loops used by this hatch</summary>
            <returns>the number of loops</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatch.PatternScale">
            <summary>
Gets the scale applied to the hatch pattern when it is mapped to the hatch's plane
</summary>
            <returns>The scale</returns>
            <remarks>The pattern is scaled around the hatch's plane origin by this value</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatch.PatternRotation">
            <summary>
Gets the rotation applied to the hatch pattern when it is mapped to the hatch's plane
</summary>
            <returns>The rotation in radians</returns>
            <remarks>The pattern is rotated counter-clockwise around the hatch's plane origin by this value</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatch.Plane">
            <summary>Get the plane defining the hatch's coordinate system</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnHatch">
            <summary>
Represents a hatch in planar boundary loop or loops 
This is a 2d entity with a plane defining a local coordinate system
The loops, patterns, angles, etc are all in this local coordinate system

The ON_Hatch object manages the plane and loop array
Fill definitions are in the ON_HatchPattern or class derived from ON_HatchPattern
ON_Hatch has an index to get the pattern definition from the pattern table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchPattern.SetHatchLines(RMA.OpenNURBS.IArrayOnHatchLine)">
            <summary>Set all of the hatch lines at once. Existing hatchlines are deleted.</summary>
            <param name="lines">[in] Array of lines to add. Lines are copied</param>
            <returns>number of lines added</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchPattern.RemoveAllHatchLines">
            <summary>
Remove all of the hatch lines from the pattern
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchPattern.RemoveHatchLine(System.Int32)">
            <summary>Remove a hatch line from the pattern</summary>
            <param name="index">[in] Index of the line to remove</param>
            <returns>true - success false - index out of range</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchPattern.HatchLine(System.Int32)">
            <summary>Get the ON_HatchLine at index</summary>
            <param name="index">[in] Index of the line to get</param>
            <returns>the hatch line NULL if index is out of range</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchPattern.AddHatchLine(RMA.OpenNURBS.IOnHatchLine)">
            <summary>Add an ON_HatchLine to the pattern</summary>
            <param name="line">[in] the line to add</param>
            <returns>&gt;= 0 index of the new line -1 on failure</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchPattern.HatchLineCount">
            <summary>Get the number of ON_HatchLines in the pattern</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchPattern.Index">
            <summary>Return the table index of the pattern</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchPattern.SetIndex(System.Int32)">
            <summary>Set the table index of the pattern</summary>
            <param name="index">[in] the new index</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchPattern.Description">
            <summary>Return a short text description of the pattern type</summary>
            <returns>The description string</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchPattern.GetDescription(System.String@)">
            <summary>Get a short description of the pattern</summary>
            <param name="string">[out] The string is returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchPattern.SetDescription(System.String)">
            <summary>Set the name of the pattern</summary>
            <param name="pDescription">[in] the new description</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchPattern.Name">
            <summary>Get the name of the pattern</summary>
            <returns>The name string</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchPattern.GetName(System.String@)">
            <summary>Get the name of the pattern</summary>
            <param name="string">[out] The name is returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchPattern.SetName(System.String)">
            <summary>Set the name of the pattern</summary>
            <param name="pName">[in] the new name</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchPattern.SetFillType(RMA.OpenNURBS.IOnHatchPattern.eFillType)">
            <summary>Set the pattern's fill type</summary>
            <param name="type">[in] the new filltype</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchPattern.FillType">
            <summary>
Return the pattern's fill type
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnHatchPattern.m_lines">
            <value>
used by line hatches
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnHatchPattern.m_description">
            <value>
String description of the pattern
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnHatchPattern.m_hatchpattern_name">
            <value>
String name of the pattern
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnHatchPattern.m_hatchpattern_index">
            <value>
Index in the hatch pattern table
</value>
        </member>
        <member name="T:RMA.OpenNURBS.OnHatchPattern">
            <summary>
Fill definition for a hatch
The hatch  will be one of 
 ON_Hatch::ftLines     - pat file style definition
 ON_Hatch::ftGradient  - uses a color function
 ON_Hatch::ftSolid     - uses entity color
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchPattern.HatchLine(System.Int32)">
            <summary>Get the ON_HatchLine at index</summary>
            <param name="index">[in] Index of the line to get</param>
            <returns>the hatch line NULL if index is out of range</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchPattern.HatchLineCount">
            <summary>Get the number of ON_HatchLines in the pattern</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchPattern.Index">
            <summary>
Description: Return the table index of the pattern Parameters: Returns: The table index
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchPattern.Description">
            <summary>Return a short text description of the pattern type</summary>
            <returns>The description string</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchPattern.GetDescription(System.String@)">
            <summary>Get a short description of the pattern</summary>
            <param name="string">[out] The string is returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchPattern.Name">
            <summary>Get the name of the pattern</summary>
            <returns>The name string</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchPattern.GetName(System.String@)">
            <summary>Get the name of the pattern</summary>
            <param name="string">[out] The name is returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchPattern.FillType">
            <summary>
Return the pattern's fill type
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnHatchPattern.m_lines">
            <value>
used by line hatches
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnHatchPattern.m_description">
            <value>
String description of the pattern
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnHatchPattern.m_hatchpattern_name">
            <value>
String name of the pattern
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnHatchPattern.m_hatchpattern_index">
            <value>
Index in the hatch pattern table
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnHatchPattern">
            <summary>
Fill definition for a hatch
The hatch  will be one of 
 ON_Hatch::ftLines     - pat file style definition
 ON_Hatch::ftGradient  - uses a color function
 ON_Hatch::ftSolid     - uses entity color
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLine.GetPatternLength">
            <summary>Get the total length of a pattern repeat</summary>
            <returns>Pattern length</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLine.GetLineData(System.Double@,RMA.OpenNURBS.On2dPoint@,RMA.OpenNURBS.On2dVector@,RMA.OpenNURBS.Arraydouble@)">
            <summary>Get the line's angle, base, offset and dashes in one function call</summary>
            <param name="angle">[out] angle in radians CCW from x-axis</param>
            <param name="base">[out] origin of the master line</param>
            <param name="offset">[out] offset for line replications</param>
            <param name="dashes">[out] the dash array for the line</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLine.SetPattern(RMA.OpenNURBS.IArraydouble)">
            <summary>Specify a new dash array</summary>
            <param name="dashes">[in] array of dash lengths</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLine.AppendDash(System.Double)">
            <summary>Add a dash to the pattern</summary>
            <param name="dash">[in] length to append - &lt; 0 for a gap</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLine.Dash(System.Int32)">
            <summary>Get the dash length at index</summary>
            <param name="index">[in] the dash to get</param>
            <returns>the length of the dash ( gap if negative)</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLine.DashCount">
            <summary>Get the number of gaps + dashes in the line</summary>
            <returns>nummber of dashes in the line</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLine.SetOffset(RMA.OpenNURBS.IOn2dVector)">
            <summary>
Set this line's 2d offset for line repetitions
Offset().x is shift parallel to line
Offset().y is spacing perpendicular to line
</summary>
            <param name="offset">[in] the shift,spacing for repeated lines</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLine.Offset">
            <summary>
Get this line's 2d offset for line repetitions Offset().x is shift parallel
to line Offset().y is spacing perpendicular to line
</summary>
            <returns>the offset</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLine.SetBase(RMA.OpenNURBS.IOn2dPoint)">
            <summary>Set this line's 2d basepoint</summary>
            <param name="base">[in] the basepoint</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLine.Base">
            <summary>Get this line's 2d basepoint</summary>
            <returns>the base point</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLine.SetAngle(System.Double)">
            <summary>Set angle of the hatch line. CCW from x-axis</summary>
            <param name="angle">[in] angle in radians</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLine.Angle">
            <summary>Get angle of the hatch line. CCW from x-axis</summary>
            <returns>The angle in radians</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLine.Read(RMA.OpenNURBS.OnBinaryArchive@)">
            <summary>
restore definition from binary archive
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLine.Write(RMA.OpenNURBS.OnBinaryArchive@)">
            <summary>
serialize definition to binary archive
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLine.Dump(RMA.OpenNURBS.OnTextLog@)">
            <summary>
for debugging
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnHatchLine">
            <summary>
Represents one line of a hatch pattern
Similar to AutoCAD's .pat file definition
ON_HatchLine's are used by ON_HatchPattern
to specify the dashes and offset patterns of the lines.

Each line has the following information:
Angle is the direction of the line CCW from the x axis
The first line origin is at base
Each line repetition is offset by offset from the previous line
 offset.x is parallel to the line and 
 offset.y is perpendicular to the line
The base and offset values are rotated by the line's angle to 
 produce a location in the hatch pattern's coordinate system
There can be gaps and dashes specified for drawing the line

If there are no dashes, the line is solid
Negative length dashes are gaps
Positive length dashes are drawn as line segments
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchLine.GetPatternLength">
            <summary>Get the total length of a pattern repeat</summary>
            <returns>Pattern length</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchLine.GetLineData(System.Double@,RMA.OpenNURBS.On2dPoint@,RMA.OpenNURBS.On2dVector@,RMA.OpenNURBS.Arraydouble@)">
            <summary>Get the line's angle, base, offset and dashes in one function call</summary>
            <param name="angle">[out] angle in radians CCW from x-axis</param>
            <param name="base">[out] origin of the master line</param>
            <param name="offset">[out] offset for line replications</param>
            <param name="dashes">[out] the dash array for the line</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchLine.Dash(System.Int32)">
            <summary>Get the dash length at index</summary>
            <param name="index">[in] the dash to get</param>
            <returns>the length of the dash ( gap if negative)</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchLine.DashCount">
            <summary>Get the number of gaps + dashes in the line</summary>
            <returns>nummber of dashes in the line</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchLine.Offset">
            <summary>
Get this line's 2d offset for line repetitions Offset().x is shift parallel
to line Offset().y is spacing perpendicular to line
</summary>
            <returns>the offset</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchLine.Base">
            <summary>Get this line's 2d basepoint</summary>
            <returns>the base point</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchLine.Angle">
            <summary>Get angle of the hatch line. CCW from x-axis</summary>
            <returns>The angle in radians</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchLine.Write(RMA.OpenNURBS.OnBinaryArchive@)">
            <summary>
serialize definition to binary archive
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchLine.Dump(RMA.OpenNURBS.OnTextLog@)">
            <summary>
for debugging
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnHatchLine">
            <summary>
Represents one line of a hatch pattern
Similar to AutoCAD's .pat file definition
ON_HatchLine's are used by ON_HatchPattern
to specify the dashes and offset patterns of the lines.

Each line has the following information:
Angle is the direction of the line CCW from the x axis
The first line origin is at base
Each line repetition is offset by offset from the previous line
 offset.x is parallel to the line and 
 offset.y is perpendicular to the line
The base and offset values are rotated by the line's angle to 
 produce a location in the hatch pattern's coordinate system
There can be gaps and dashes specified for drawing the line

If there are no dashes, the line is solid
Negative length dashes are gaps
Positive length dashes are drawn as line segments
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLoop.SetType(RMA.OpenNURBS.IOnHatchLoop.eLoopType)">
            <summary>Specify the type flag of the loop</summary>
            <param name="type">[in] ltInner or ltOuter</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLoop.Type">
            <summary>Get the type flag of the loop</summary>
            <returns>eLoopType::ltInner or eLoopType::ltOuter</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLoop.SetCurve(RMA.OpenNURBS.IOnCurve)">
            <summary>Specify the 2d loop curve in the hatch's plane coordinates</summary>
            <param name="curve">[in] 2d input curve</param>
            <returns>true: success, false, curve couldn't be duplicated</returns>
            <remarks>The curve is copied</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLoop.Curve">
            <summary>Get a closed 2d curve boundary loop</summary>
            <returns>Pointer to loop's 2d curve</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLoop.Dump(RMA.OpenNURBS.OnTextLog@)">
            <summary>
for debugging
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLoop.#ctor">
            <summary>
class ON_HatchLoop
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnHatchLoop">
            <summary>Represents a 3d boundary loop curve</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchLoop.Type">
            <summary>Get the type flag of the loop</summary>
            <returns>eLoopType::ltInner or eLoopType::ltOuter</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchLoop.Curve">
            <summary>Get a closed 2d curve boundary loop</summary>
            <returns>Pointer to loop's 2d curve</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchLoop.Dump(RMA.OpenNURBS.OnTextLog@)">
            <summary>
for debugging
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnHatchLoop">
            <summary>Represents a 3d boundary loop curve</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnTextDot.m_display">
            <value>
some future display flags -
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnTextDot.m_height">
            <value>
in points
</value>
        </member>
        <member name="T:RMA.OpenNURBS.OnTextDot">
            <summary>A simple dot with text that doesn't rotate witn the world axes</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTextDot.m_display">
            <value>
some future display flags -
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTextDot.m_height">
            <value>
in points
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnTextDot">
            <summary>A simple dot with text that doesn't rotate witn the world axes</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLeader2.GetV2Form(RMA.OpenNURBS.OnLeader@)">
            <summary>Converts an ON_Leader2 to the v2 form ON_Leader</summary>
            <param name="leader">[out] - the result of the conversion</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnLeader2.RemovePoint">
            <summary>Remove point from the leader</summary>
            <returns>
TRUE Success
False Failure
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLeader2.RemovePoint(System.Int32)">
            <summary>Remove point from the leader</summary>
            <param name="index">[in] the point to delete</param>
            <returns>
TRUE Success
False Failure
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLeader2.AddPoint(RMA.OpenNURBS.IOn2dPoint)">
            <summary>Add point to the leader</summary>
            <param name="point">[in] The point to add</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnLeader2.Dim3dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLeader2.Dim2dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="T:RMA.OpenNURBS.OnLeader2">
            <summary>
The annotation's dimstyle controls the position of TEXT,
the size of the arrowheads, and the amount the ends of 
linear dimension's extension lines extend beyond the 
dimension lines.

Leaders:
 Polyline with N=m_points.Count() points (N &gt;= 2).

                 [N-2] ----- [N-1] TEXT
                   /         (tail)
                  /
                 /
       [1]------[2]
       /
      /
     /
   [0] (arrow)

Leaders ignore the m_userpositionedtext setting.  If the
default leader text handling is not adequate, then use
a leader with no text and an ON_TextEntity2.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLeader2.Dim3dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLeader2.Dim2dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="T:RMA.OpenNURBS.IOnLeader2">
            <summary>
The annotation's dimstyle controls the position of TEXT,
the size of the arrowheads, and the amount the ends of 
linear dimension's extension lines extend beyond the 
dimension lines.

Leaders:
 Polyline with N=m_points.Count() points (N &gt;= 2).

                 [N-2] ----- [N-1] TEXT
                   /         (tail)
                  /
                 /
       [1]------[2]
       /
      /
     /
   [0] (arrow)

Leaders ignore the m_userpositionedtext setting.  If the
default leader text handling is not adequate, then use
a leader with no text and an ON_TextEntity2.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextEntity2.SetFontIndex(System.Int32)">
            <summary>Set the Font index in the Font Table for the text</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextEntity2.FontIndex">
            <summary>Get the Font index in the Font Table for the text</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextEntity2.FontIndex">
            <summary>
Get the Font index in the Font Table for the text
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnOrdinateDimension2.CalcKinkPoints(RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOn2dPoint,System.Int32,System.Double,RMA.OpenNURBS.On2dPoint@,RMA.OpenNURBS.On2dPoint@)">
            <summary>Calculates the 2d point locations of the dimension line kinks</summary>
            <param name="p0">[in] - End points of the dimension line</param>
            <param name="p1">[in] - End points of the dimension line</param>
            <param name="direction">[in] - orientation of the dimension</param>
            <param name="default_offset">[in] - Use this if offsets are ON_UNSET_VALUE</param>
            <param name="k0">[out] - The kink points</param>
            <param name="k1">[out] - The kink points</param>
            <remarks>
The offsets must be set to the right values before calling this,
or If they are ON_UNSET_VALUE, they will be set to the defaults
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnOrdinateDimension2.SetKinkOffset(System.Int32,System.Double)">
            <summary>
Set the offset distance parallel to the dimension line direction of from the
text end of the dimension line to the offset point
If the offset point hasn't been explicitly defined, returns ON_UNSET_VALUE
and a default should be used to find the point.
</summary>
            <param name="index">[in] - which offset distance to return (0 is closer to the text)</param>
            <param name="offset">[in] - the offset distance to set</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnOrdinateDimension2.KinkOffset(System.Int32)">
            <summary>
Returns the offset distance parallel to the dimension line direction of from the
text end of the dimension line to the offset point
If the offset point hasn't been explicitly defined, returns ON_UNSET_VALUE
and a default should be used to find the point.
</summary>
            <param name="index">[in] - which offset distance to return (0 is closer to the text)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnOrdinateDimension2.DefaultText">
            <summary>
static function to provide the default UserText string for the object. Returns the default string to use
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnOrdinateDimension2.SetDirection(System.Int32)">
            <summary>Sets the direction ( X or Y) that the ordinate dimension measures</summary>
            <param name="direction">
-1: direction determined by dim point and leader point
0: measures parallel to the entity plane x axis
1: measures parallel to the entity plane y axis
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnOrdinateDimension2.Direction">
            <summary>Gets the direction ( X or Y) that the ordinate dimension measures</summary>
            <returns>
-1: direction determined by dim point and leader point
0: measures parallel to the entity plane x axis
1: measures parallel to the entity plane y axis
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnOrdinateDimension2.ImpliedDirection">
            <summary>
Gets the direction ( X or Y) that the ordinate dimension measures
based on the relative location of the defining point and leader endpoint
</summary>
            <returns>
0: measures parallel to the entity plane x axis
1: measures parallel to the entity plane y axis
</returns>
            <remarks>This does not consider the dimension's explicit Direction setting</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnOrdinateDimension2.SetStyleIndex(System.Int32)">
            <summary>
Set the DimStyle index in the dimstyle table for the dimension
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnOrdinateDimension2.StyleIndex">
            <summary>
Get the DimStyle index in the dimstyle table for the dimension
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnOrdinateDimension2.Dim3dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnOrdinateDimension2.Dim3dPoint(System.Int32,System.Double)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <param name="default_offset">[in] - kink offset to use if m_kink_offset_0 or m_kink_offset_1 are ON_UNSET_VALUE</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnOrdinateDimension2.Dim2dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnOrdinateDimension2.Dim2dPoint(System.Int32,System.Double)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <param name="default_offset">[in] - kink offset to use if m_kink_offset_0 or m_kink_offset_1 are ON_UNSET_VALUE</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnOrdinateDimension2.m_kink_offset_1">
            <value>
from first break point to second break point
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnOrdinateDimension2.m_kink_offset_0">
            <value>
from leader_end_point to first break point
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnOrdinateDimension2.m_direction">
            <value>
-1 == underermined
0 == x direction
1 == y direction
</value>
        </member>
        <member name="T:RMA.OpenNURBS.OnOrdinateDimension2">
            <summary>
In the picture below, [n] means ON_Annotation2::m_points[n].
Measures in X direction

                     [1]
                      |
                      |
                      |
                      |
                      |
                     [0]
     +
[plane origin]                                      [plane origin]
                                                         +

    or - Measures in Y direction                                                   *---[1]       
                                                                                  /
                                                                                 /
                 [0]--------------------[1]                   [0]---------------*


                                                                            * = calculated, not stored


     +     
[plane origin]


The reference point of for the dimension is at the entity plane origin
The "x" and "y" coordinates of [1] can be any value.
The "x" and "y" coordinates of [2] can be any value.
If Direction is "x", the dimension measures along the "x" axis
If Direction is "y", the dimension measures along the "y" axis
If Direction is "x" and [1][x] &lt;&gt; [0][x], an offset segment is drawn
If Direction is "y" and [1][y] &lt;&gt; [0][y], an offset segment is drawn
The dimension lines are always drawn in the X or Y directions of the entity plane
The distance represented by the dimension is measured from the 
 plane origin to point [0], parallel to the appropriate axis.
The points of the offset segment are calculated rather than stored
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOrdinateDimension2.CalcKinkPoints(RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOn2dPoint,System.Int32,System.Double,RMA.OpenNURBS.On2dPoint@,RMA.OpenNURBS.On2dPoint@)">
            <summary>Calculates the 2d point locations of the dimension line kinks</summary>
            <param name="p0">[in] - End points of the dimension line</param>
            <param name="p1">[in] - End points of the dimension line</param>
            <param name="direction">[in] - orientation of the dimension</param>
            <param name="default_offset">[in] - Use this if offsets are ON_UNSET_VALUE</param>
            <param name="k0">[out] - The kink points</param>
            <param name="k1">[out] - The kink points</param>
            <remarks>
The offsets must be set to the right values before calling this,
or If they are ON_UNSET_VALUE, they will be set to the defaults
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOrdinateDimension2.KinkOffset(System.Int32)">
            <summary>
Returns the offset distance parallel to the dimension line direction of from the
text end of the dimension line to the offset point
If the offset point hasn't been explicitly defined, returns ON_UNSET_VALUE
and a default should be used to find the point.
</summary>
            <param name="index">[in] - which offset distance to return (0 is closer to the text)</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOrdinateDimension2.Direction">
            <summary>Gets the direction ( X or Y) that the ordinate dimension measures</summary>
            <returns>
-1: direction determined by dim point and leader point
0: measures parallel to the entity plane x axis
1: measures parallel to the entity plane y axis
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOrdinateDimension2.ImpliedDirection">
            <summary>
Gets the direction ( X or Y) that the ordinate dimension measures
based on the relative location of the defining point and leader endpoint
</summary>
            <returns>
0: measures parallel to the entity plane x axis
1: measures parallel to the entity plane y axis
</returns>
            <remarks>This does not consider the dimension's explicit Direction setting</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOrdinateDimension2.StyleIndex">
            <summary>
Get the DimStyle index in the dimstyle table for the dimension
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOrdinateDimension2.Dim3dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOrdinateDimension2.Dim3dPoint(System.Int32,System.Double)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <param name="default_offset">[in] - kink offset to use if m_kink_offset_0 or m_kink_offset_1 are ON_UNSET_VALUE</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOrdinateDimension2.Dim2dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOrdinateDimension2.Dim2dPoint(System.Int32,System.Double)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <param name="default_offset">[in] - kink offset to use if m_kink_offset_0 or m_kink_offset_1 are ON_UNSET_VALUE</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnOrdinateDimension2.m_kink_offset_1">
            <value>
from first break point to second break point
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnOrdinateDimension2.m_kink_offset_0">
            <value>
from leader_end_point to first break point
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnOrdinateDimension2.m_direction">
            <value>
-1 == underermined
0 == x direction
1 == y direction
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnOrdinateDimension2">
            <summary>
In the picture below, [n] means ON_Annotation2::m_points[n].
Measures in X direction

                     [1]
                      |
                      |
                      |
                      |
                      |
                     [0]
     +
[plane origin]                                      [plane origin]
                                                         +

    or - Measures in Y direction                                                   *---[1]       
                                                                                  /
                                                                                 /
                 [0]--------------------[1]                   [0]---------------*


                                                                            * = calculated, not stored


     +     
[plane origin]


The reference point of for the dimension is at the entity plane origin
The "x" and "y" coordinates of [1] can be any value.
The "x" and "y" coordinates of [2] can be any value.
If Direction is "x", the dimension measures along the "x" axis
If Direction is "y", the dimension measures along the "y" axis
If Direction is "x" and [1][x] &lt;&gt; [0][x], an offset segment is drawn
If Direction is "y" and [1][y] &lt;&gt; [0][y], an offset segment is drawn
The dimension lines are always drawn in the X or Y directions of the entity plane
The distance represented by the dimension is measured from the 
 plane origin to point [0], parallel to the appropriate axis.
The points of the offset segment are calculated rather than stored
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnAngularDimension2.GetDimensionArcSegments(System.Drawing.Rectangle,System.Int32,RMA.OpenNURBS.IOnXform,RMA.OpenNURBS.IOnDimStyle,System.Double,RMA.OpenNURBS.IOnViewport,System.Double[],System.Boolean@)">
            <summary>Get the annotation plane angles of the dimension arc.</summary>
            <param name="gdi_text_rect">[in] Windows rect (left &lt; right, top &lt; bottom) that bounds text.</param>
            <param name="gdi_height_of_I">[in] Height of an I in the text.</param>
            <param name="gdi_to_world">[in] transform returned by ON_Annotation2::GetTextXform().</param>
            <param name="a">[out] angles at the ends of the arc segment(s) and the arrow tips</param>
            <param name="bInside">[out] true if arrowheads go inside, false if they go outside</param>
            <returns>
number of arc segments to draw
0: the input or class is not valid
1: A single arc from a[0] to a[1] with arrow heads at a[4] &amp; a[5].
2: Two arcs from a[0] to a[1] &amp; from a[2] to a[3]. Arrowheads are at a[4] &amp; a[5].
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnAngularDimension2.ConvertBack(RMA.OpenNURBS.OnAngularDimension2@)">
            <summary>Convert back to the version of ON_Annotation used in Rhino 2</summary>
            <param name="target">[out] the old-style object</param>
            <returns>
TRUE Success
False Failure
See Also: ON_AnnotationObject::ConvertBack()
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnAngularDimension2.DefaultText">
            <summary>
static function to provide the default UserText string for the object. Returns the default string to use
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnAngularDimension2.SetStyleIndex(System.Int32)">
            <summary>
Set the DimStyle index in the dimstyle table for the dimension
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnAngularDimension2.StyleIndex">
            <summary>
Get the DimStyle index in the dimstyle table for the dimension
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnAngularDimension2.Angle">
            <summary>
Get the measured angle in radians
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnAngularDimension2.SetAngle(System.Double)">
            <summary>
Set the measured angle in radians
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnAngularDimension2.CreateFromArc(RMA.OpenNURBS.IOnArc)">
            <summary>Set the plane and definition points from a 3d arc.</summary>
            <returns>
TRUE Success
FALSE Failure
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnAngularDimension2.CreateFromPoints(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@)">
            <summary>Set the plane and definition points from 3d points in world coordinates.</summary>
            <param name="apex">[in] 3d apex of the dimension (center of arc)</param>
            <param name="p0">[in] 3d point on first line</param>
            <param name="p1">[in] 3d point on second line</param>
            <param name="arcpt">[in] 3d point on dimension arc (determines radius of arc)</param>
            <param name="Normal">[in] normal of the plane on which to make the dimension (must be perpendicular to p0-apex and p1-apex)</param>
            <returns>
TRUE Success 
FALSE Failure
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnAngularDimension2.Dim3dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnAngularDimension2.Dim2dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnAngularDimension2.m_radius">
            <value>
radius for dimension arc
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnAngularDimension2.m_angle">
            <value>
angle being dimensioned
</value>
        </member>
        <member name="T:RMA.OpenNURBS.OnAngularDimension2">
            <summary>
The annotation dimstyle controls the position of TEXT,
the size of the arrowheads, and the amount the ends of 
linear dimension extension lines extend beyond the 
dimension lines.

In the picture below, [n] means ON_Annotation2::m_points[n].

[0] = if m_userpositionedtext=true, this is the center of text.
     If m_userpositionedtext=false, this point is not used and
     the center of the text is at the arc's midpoint.

Always counter clockwise arc in m_plane with center = (0,0)
[1] = a point somewhere on the line from the center through the start point.
     The distance from center to [1] can be any value.
[2] = a point somewhere on the line from the center through the end point.
     The distance from center to [2] can be any value.
[3] = a point on the interior of the arc.  The distance 
     from (0,0) to [3] is the radius of the arc.

             /
           [2]
           /
          /         [0]TEXT
         /
        /    [3]
-----(0,0)----------[1]---
      /
     /
    /
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAngularDimension2.GetDimensionArcSegments(System.Drawing.Rectangle,System.Int32,RMA.OpenNURBS.IOnXform,RMA.OpenNURBS.IOnDimStyle,System.Double,RMA.OpenNURBS.IOnViewport,System.Double[],System.Boolean@)">
            <summary>Get the annotation plane angles of the dimension arc.</summary>
            <param name="gdi_text_rect">[in] Windows rect (left &lt; right, top &lt; bottom) that bounds text.</param>
            <param name="gdi_height_of_I">[in] Height of an I in the text.</param>
            <param name="gdi_to_world">[in] transform returned by ON_Annotation2::GetTextXform().</param>
            <param name="a">[out] angles at the ends of the arc segment(s) and the arrow tips</param>
            <param name="bInside">[out] true if arrowheads go inside, false if they go outside</param>
            <returns>
number of arc segments to draw
0: the input or class is not valid
1: A single arc from a[0] to a[1] with arrow heads at a[4] &amp; a[5].
2: Two arcs from a[0] to a[1] &amp; from a[2] to a[3]. Arrowheads are at a[4] &amp; a[5].
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAngularDimension2.StyleIndex">
            <summary>
Get the DimStyle index in the dimstyle table for the dimension
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAngularDimension2.Angle">
            <summary>
Get the measured angle in radians
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAngularDimension2.Dim3dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAngularDimension2.Dim2dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAngularDimension2.m_radius">
            <value>
radius for dimension arc
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAngularDimension2.m_angle">
            <value>
angle being dimensioned
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnAngularDimension2">
            <summary>
The annotation dimstyle controls the position of TEXT,
the size of the arrowheads, and the amount the ends of 
linear dimension extension lines extend beyond the 
dimension lines.

In the picture below, [n] means ON_Annotation2::m_points[n].

[0] = if m_userpositionedtext=true, this is the center of text.
     If m_userpositionedtext=false, this point is not used and
     the center of the text is at the arc's midpoint.

Always counter clockwise arc in m_plane with center = (0,0)
[1] = a point somewhere on the line from the center through the start point.
     The distance from center to [1] can be any value.
[2] = a point somewhere on the line from the center through the end point.
     The distance from center to [2] can be any value.
[3] = a point on the interior of the arc.  The distance 
     from (0,0) to [3] is the radius of the arc.

             /
           [2]
           /
          /         [0]TEXT
         /
        /    [3]
-----(0,0)----------[1]---
      /
     /
    /
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnRadialDimension2.DefaultDiameterText">
            <summary>
static function to provide the default UserText string for the object. Returns the default string to use
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnRadialDimension2.SetStyleIndex(System.Int32)">
            <summary>
Set the DimStyle index in the dimstyle table for the dimension
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnRadialDimension2.StyleIndex">
            <summary>
Get the DimStyle index in the dimstyle table for the dimension
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnRadialDimension2.CreateFromPoints(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,System.Double)">
            <summary>Set the plane and definition points from WCS 3d input</summary>
            <param name="center">[in] center of circle</param>
            <param name="arrowtip">[in] 3d point on the circle at the dimension arrow tip</param>
            <param name="xaxis">[in] x axis of the dimension's plane</param>
            <param name="normal">[in] normal to the dimension's plane</param>
            <param name="offset_distance">[in] distance from arrow tip to knee point</param>
            <returns>
TRUE Success
FALSE Failure
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnRadialDimension2.Dim3dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnRadialDimension2.Dim2dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="T:RMA.OpenNURBS.OnRadialDimension2">
            <summary>
The annotation dimstyle controls the position of TEXT,
and the size of the arrowheads.

In the picture below, [n] means ON_Annotation2::m_points[n].

Radial dimensions do not permit user positioned text

      knee
       [3]--------[2] TEXT
       /         (tail)
      /
     /
   [1] (arrow head here)

+ [0] = (usually at (0,0) = center of circle)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnRadialDimension2.StyleIndex">
            <summary>
Get the DimStyle index in the dimstyle table for the dimension
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnRadialDimension2.Dim3dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnRadialDimension2.Dim2dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="T:RMA.OpenNURBS.IOnRadialDimension2">
            <summary>
The annotation dimstyle controls the position of TEXT,
and the size of the arrowheads.

In the picture below, [n] means ON_Annotation2::m_points[n].

Radial dimensions do not permit user positioned text

      knee
       [3]--------[2] TEXT
       /         (tail)
      /
     /
   [1] (arrow head here)

+ [0] = (usually at (0,0) = center of circle)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinearDimension2.GetDimensionLineSegments(System.Drawing.Rectangle,System.Int32,RMA.OpenNURBS.IOnXform,RMA.OpenNURBS.IOnDimStyle,System.Double,RMA.OpenNURBS.IOnViewport,System.Double[],System.Boolean@)">
            <summary>
Get the annotation plane x coordinates of the dimension line.
The y coordinate of the dimension line is m_ponts[1].y.
</summary>
            <param name="gdi_text_rect">
[in] Windows rect (left &lt; right, top &lt; bottom) that bounds text.
The baseline of the text should be at y=0 in the rect coordinates.
</param>
            <param name="gdi_height_of_I">[in] Height of an I in the text in the same.</param>
            <param name="gdi_to_world">[in] transform returned by ON_Annotation2::GetTextXform().</param>
            <param name="bInside">
[out] true if arrowheads go inside extension lines, false if they go outside
</param>
            <returns>
0: the input or class is not valid
1: A single line from x[0] to x[1] with arrow heads at both ends. Arrowtips at x[4] &amp; x[5]
2: Two lines from x[0] to x[1] and from x[1] to x[2]. The Arrowtips at x[4] &amp; x[5]
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinearDimension2.DefaultText">
            <summary>
static function to provide the default UserText string for the object. Returns the default string to use
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinearDimension2.SetStyleIndex(System.Int32)">
            <summary>Set the DimStyle index in the dimstyle table for the dimension</summary>
            <param name="arg1">[in] the new index</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinearDimension2.StyleIndex">
            <summary>
Get the DimStyle index in the dimstyle table for the dimension
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinearDimension2.Dim3dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinearDimension2.Dim2dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinearDimension2.Repair">
            <summary>
Checks the linear dimension and repairs any point locations or flags that are not set correctly.
</summary>
            <returns>
0: linear dimension is damaged beyond repair
1: linear dimension was perfect and nothing needed to be repaired.
2: linear dimension had flaws that were repaired.
</returns>
        </member>
        <member name="T:RMA.OpenNURBS.OnLinearDimension2">
            <summary>
Subclass of ON_Annotation2 to provide linear dimensions

The annotation's dimstyle controls the position of TEXT,
the size of the arrowheads, and the amount the ends of 
linear dimension's extension lines extend beyond the 
dimension lines.

In the picture below, [n] means ON_Annotation2::m_points[n].
                                                [2]
                                                 |
   |                                             |
  [1]-------------------------------------------[3]
   |                                             |
   |                       TEXT
   |                       [4]
  [0]

The x and y coordinates of [0] can be any value.

The x coordinate of [1] = x of [0]
The y coordinate of [1] can be any value.

The x coordinate of [1] = x coordinate of 0.0;
The y coordinate of [1] can be any value.

The x and y coordinates of [2] can be any value.

The x coordinate of [3] = x coordinate of [2].
The y coordinate of [3] = y coordinate of [1].
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLinearDimension2.GetDimensionLineSegments(System.Drawing.Rectangle,System.Int32,RMA.OpenNURBS.IOnXform,RMA.OpenNURBS.IOnDimStyle,System.Double,RMA.OpenNURBS.IOnViewport,System.Double[],System.Boolean@)">
            <summary>
Get the annotation plane x coordinates of the dimension line.
The y coordinate of the dimension line is m_ponts[1].y.
</summary>
            <param name="gdi_text_rect">
[in] Windows rect (left &lt; right, top &lt; bottom) that bounds text.
The baseline of the text should be at y=0 in the rect coordinates.
</param>
            <param name="gdi_height_of_I">[in] Height of an I in the text in the same.</param>
            <param name="gdi_to_world">[in] transform returned by ON_Annotation2::GetTextXform().</param>
            <param name="bInside">
[out] true if arrowheads go inside extension lines, false if they go outside
</param>
            <returns>
0: the input or class is not valid
1: A single line from x[0] to x[1] with arrow heads at both ends. Arrowtips at x[4] &amp; x[5]
2: Two lines from x[0] to x[1] and from x[1] to x[2]. The Arrowtips at x[4] &amp; x[5]
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLinearDimension2.StyleIndex">
            <summary>
Get the DimStyle index in the dimstyle table for the dimension
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLinearDimension2.Dim3dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLinearDimension2.Dim2dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="T:RMA.OpenNURBS.IOnLinearDimension2">
            <summary>
Subclass of ON_Annotation2 to provide linear dimensions

The annotation's dimstyle controls the position of TEXT,
the size of the arrowheads, and the amount the ends of 
linear dimension's extension lines extend beyond the 
dimension lines.

In the picture below, [n] means ON_Annotation2::m_points[n].
                                                [2]
                                                 |
   |                                             |
  [1]-------------------------------------------[3]
   |                                             |
   |                       TEXT
   |                       [4]
  [0]

The x and y coordinates of [0] can be any value.

The x coordinate of [1] = x of [0]
The y coordinate of [1] can be any value.

The x coordinate of [1] = x coordinate of 0.0;
The y coordinate of [1] can be any value.

The x and y coordinates of [2] can be any value.

The x coordinate of [3] = x coordinate of [2].
The y coordinate of [3] = y coordinate of [1].
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.GetTextPoint(RMA.OpenNURBS.On2dPoint@)">
            <summary>
Get the annotation plane coordinates (ECS) of the point that is used to position the text.
The relative position of the text to this points depends on the type of annotation,
the dimstyle's text alignment flag, and the view projection.
This point is not the same as the base point of the text.
</summary>
            <returns>True if text_point is set.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.GetTextXform(System.Drawing.Rectangle,RMA.OpenNURBS.IOnFont,RMA.OpenNURBS.IOnDimStyle,System.Double,RMA.OpenNURBS.IOnViewport,RMA.OpenNURBS.OnXform@)">
            <summary>Get the transformation that maps the annotation's text to world coordinates.</summary>
            <param name="gdi_text_rect">
[in] Windows gdi rect of text when it is drawn with LOGFONT lfHeight = ON_Font::normal_font_height.
</param>
            <param name="dimscale">
[in] Global dimension scaling value. If you are using the Rhino SDK, this value is returned by CRhinoDoc::Properties().AnnotationSettings().DimScale().
</param>
            <returns>True if xform is set.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.GetTextXform(System.Drawing.Rectangle,System.Int32,System.Double,System.Double,RMA.OpenNURBS.IOn.eTextDisplayMode,System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.OnXform@)">
            <summary>
Get the transformation that maps the annotation's text to world coordinates.
</summary>
            <param name="gdi_text_rect">
[in] Windows gdi rect of text when it is drawn with
LOGFONT lfHeight = ON_Font::normal_font_height.
</param>
            <param name="gdi_height_of_I">[in] Value returned by ON_Font::HeightOfI().</param>
            <param name="dimstyle_textheight">
[in] Height of text in world units.
If the annotation is an ON_TextEntity2, this is the m_textheight value.
If the annotation is not an ON_TextEntity2, pass in the value returned
by the dimension style's ON_DimStyle::TextHeight()
</param>
            <param name="dimstyle_textgap">
[in] The value of the annotation's dimension style's ON_DimStyle::TextGap().
</param>
            <param name="dimstyle_textalignment">[in] ON::TextDisplayMode(ON_DimStyle::TextAlignment()).</param>
            <param name="dimscale">
[in] Global dimension scaling value. If you are using the Rhino SDK, this value is
returned by CRhinoDoc::Properties().AnnotationSettings().DimScale().
</param>
            <param name="cameraX">[in] zero or the view's unit camera right vector</param>
            <param name="cameraY">[in] zero or the view's unit camera up vector</param>
            <param name="xform">[out]</param>
            <returns>True if xform is set.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.Justification">
            <summary>Get the text justification</summary>
            <returns>The justification for the text in this object</returns>
            <remarks>
This is not implemented on all annotation objects.
The default SetJustification() does nothing The default Justification() always returns 0
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.SetJustification(System.UInt32)">
            <summary>Set the text justification</summary>
            <param name="justification">[in] See enum eJustification for meanings</param>
            <remarks>
This is not implemented on all annotation objects.
The default SetJustification() does nothing The default Justification() always returns 0
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.ConvertBack(RMA.OpenNURBS.OnAnnotation@)">
            <summary>Convert back to the version of ON_Annotation used in Rhino 2</summary>
            <param name="target">[out] the old-style object</param>
            <returns>
TRUE Success
False Failure
See Also: ON_AngularDimension::ConvertBack()
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.DefaultText">
            <summary>
static function to provide the default UserText string for the object Returns the default string to use
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.ReservePoints(System.Int32)">
            <summary>Set the object's point array to a specified length</summary>
            <param name="length">[in] the new size of the array</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.GetWCStoECSXform(RMA.OpenNURBS.OnXform@)">
            <summary>
Gets a transform matrix to change from to 3d WCS to the object's 2d ECS
</summary>
            <param name="xform">set to produce the WCS to ECS transform</param>
            <returns>
TRUE Success
FALSE Failure
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.GetECStoWCSXform(RMA.OpenNURBS.OnXform@)">
            <summary>
Gets a transform matrix to change from the object's 2d ECS to 3d WCS
</summary>
            <param name="arg1">[out] xform set to produce the ECS to WCS transform</param>
            <returns>
TRUE Success
FALSE Failure
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.TextDisplayMode">
            <remarks>
This is the way the text is oriented with respect to the dimension line or screen:
Above line, In LIne, Horizontal
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.SetTextDisplayMode(RMA.OpenNURBS.IOn.eTextDisplayMode)">
            <summary>Set the text display mode for the annotation</summary>
            <remarks>
This is the way the text is oriented with respect to the dimension line or screen:
Above line, In LIne, Horizontal
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.UserPositionedText">
            <summary>
get a flag indication that the dimension text has been moved
from the default location.
</summary>
            <returns>
TRUE    The text has been moved
FALSE   The text is in the default location
</returns>
            <remarks>
If the text is in the default location, it should be repositioned
automatically when the dimension is adjusted.
If it has been moved, it should not be automatically positioned.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.SetUserPositionedText(System.Boolean)">
            <summary>
set a flag indication that the dimension text has been moved
from the default location.
</summary>
            <param name="bUserPositionedText">
TRUE to indicate that the text has been placed by the user.
FALSE to indicate that it hasn't
</param>
            <remarks>
If the text is in the default location, it should be repositioned
automatically when the dimension is adjusted.
If it has been moved, it should not be automatically positioned.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.UserText">
            <summary>get the string value of the user text, with no substitution for "&lt;&gt;"</summary>
            <remarks>
UserText is the string that gets printed when the dimensoin is drawn.
If it contains the token "&lt;&gt;", that token is replaced
with the measured value for the dimension, formatted according to the DimStyle settings.
"&lt;&gt;" is the default for linear dimensions.
Other dimensions include "&lt;&gt;" in their default string
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.SetUserText(System.String)">
            <summary>set the string value of the user text, with no substitution for "&lt;&gt;"</summary>
            <remarks>
UserText is the string that gets printed when the dimensoin is drawn.
If it contains the token "&lt;&gt;", that token is replaced
with the measured value for the dimension, formatted according to the DimStyle settings.
"&lt;&gt;" is the default for linear dimensions.
Other dimensions include "&lt;&gt;" in their default string
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.Point(System.Int32)">
            <summary>Get individual definition point for the annotation</summary>
            <param name="index">[in] index of the point to set in ECS 2d coordinates</param>
            <returns>the point coordinates in ECS</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.SetPoint(System.Int32,RMA.OpenNURBS.IOn2dPoint)">
            <summary>Set individual definition point for the annotation</summary>
            <param name="index">[in] index of the point to set in ECS 2d coordinates</param>
            <param name="pt">[in] the new point value</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.Points">
            <summary>get the object's whole points array at once</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.SetPoints(RMA.OpenNURBS.IOn2dPointArray)">
            <summary>set the object's whole points array at once</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.PointCount">
            <summary>Returns the number of definition points this object has</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.Plane">
            <summary>get the plane for the object's ECS</summary>
            <returns>the object's ECS plane in WCS coords</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.SetPlane(RMA.OpenNURBS.IOnPlane)">
            <summary>set the plane for the object's ECS</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.Type">
            <summary>
gets the object type member to a specific annotation type:
dtDimLinear, dtDimAligned, dtDimAngular, etc.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.SetType(RMA.OpenNURBS.IOn.eAnnotationType)">
            <summary>
sets the object type member to a specific annotation type:
dtDimLinear, dtDimAligned, dtDimAngular, etc.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.Height">
            <summary>Get the height of the text in this annotation</summary>
            <remarks>Height is in model units</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.SetHeight(System.Double)">
            <summary>Set the height of the text in this annotation</summary>
            <param name="arg1">[in] double new text height to set</param>
            <remarks>Height is in model units</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.NumericValue">
            <returns>
Dimension type
Linear dim:  distance between arrow tips
Radial dim:  radius or diameter depending on m_type value
Angular dim: angle in degrees
Leader:      ON_UNSET_VALUE
Text:        ON_UNSET_VALUE
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.SetIndex(System.Int32)">
            <summary>
Set the index in the appropriate table for either the font or dimstyle of this object
</summary>
            <param name="arg1">[in] int the new index</param>
            <remarks>
If the object is a text object the index is of object's font in the Font Table
If the object is anything else, the index is of the object's dimstyle in the DimStyle Table
Derived objects can use FontIndex() and StyleIndex() to set/get these same values.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.Index">
            <summary>get the index in the appropriate table for either the font or dimstyle of this object</summary>
            <remarks>
If the object is a text object the index is of object's font in the Font Table
If the object is anything else, the index is of the object's dimstyle in the DimStyle Table
Derived objects can use FontIndex() and StyleIndex() to set/get these same values.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.IsDimension">
            <summary>Query if the annotation object is a dimension</summary>
            <returns>
TRUE It is a dimension
FALSE Its not a dimension
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.IsLeader">
            <summary>Query if the annotation object is a leader</summary>
            <returns>
TRUE It is a leader
FALSE Its not a leader
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.IsText">
            <summary>Query if the annotation object is a text object</summary>
            <returns>
TRUE It is text
FALSE Its not text
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.Create">
            <summary>
convert from old style annotation
</summary>
            <summary>
Sets initial defaults
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnAnnotation2.m_justification">
            <value>
Left, Center, Right / Bottom, Middle, Top text justification
See eTextJustification above
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnAnnotation2.m_textheight">
            <value>
Text height in model units
This is used by text, but not by dimensions
Dimensions get their height from dimension styles
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnAnnotation2.m_index">
            <value>
For dimensions, this is the ON_DimStyle index
For text, its the ON_Font index
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnAnnotation2.m_userpositionedtext">
            <value>
TRUE: User has positioned text
FALSE: use default location
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnAnnotation2.m_usertext">
            <value>
"&lt;&gt;", or user override
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnAnnotation2.m_points">
            <value>
Definition points for the dimension.
These are 2d coordinates in m_plane.
The location of these points depends on the
type of annotation class.  There is a comment
at the start of the definions for
ON_LinearDimension2, ON_RadialDimension2,
ON_AngularDimension2, ON_TextEntity2, and
ON_Leader2 that explains how the points are used.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnAnnotation2.m_plane">
            <value>
m_plane is the plane containing the annotation.
All parts of the annotation that are not
text lie in this plane. If
m_textdisplaymode != dtHorizontal, then
the text lies in the plane too.  
(ECS reference plane in WCS coordinates.)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnAnnotation2.m_textdisplaymode">
            <value>
m_textdisplaymode controls the orientation
of the text.
If m_textdisplaymode = dtHorizontal, then
the text is always horizontal and in the
view plane.  Otherwise it lies in m_plane.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnAnnotation2.m_type">
            <value>
enum for tyoe of annotation DimLinear, DimRadius, etc.
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.GetTextPoint(RMA.OpenNURBS.On2dPoint@)">
            <summary>
Get the annotation plane coordinates (ECS) of the point that is used to position the text.
The relative position of the text to this points depends on the type of annotation,
the dimstyle's text alignment flag, and the view projection.
This point is not the same as the base point of the text.
</summary>
            <returns>True if text_point is set.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.GetTextXform(System.Drawing.Rectangle,RMA.OpenNURBS.IOnFont,RMA.OpenNURBS.IOnDimStyle,System.Double,RMA.OpenNURBS.IOnViewport,RMA.OpenNURBS.OnXform@)">
            <summary>Get the transformation that maps the annotation's text to world coordinates.</summary>
            <param name="gdi_text_rect">
[in] Windows gdi rect of text when it is drawn with LOGFONT lfHeight = ON_Font::normal_font_height.
</param>
            <param name="dimscale">
[in] Global dimension scaling value. If you are using the Rhino SDK, this value is returned by CRhinoDoc::Properties().AnnotationSettings().DimScale().
</param>
            <returns>True if xform is set.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.GetTextXform(System.Drawing.Rectangle,System.Int32,System.Double,System.Double,RMA.OpenNURBS.IOn.eTextDisplayMode,System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.OnXform@)">
            <summary>
Get the transformation that maps the annotation's text to world coordinates.
</summary>
            <param name="gdi_text_rect">
[in] Windows gdi rect of text when it is drawn with
LOGFONT lfHeight = ON_Font::normal_font_height.
</param>
            <param name="gdi_height_of_I">[in] Value returned by ON_Font::HeightOfI().</param>
            <param name="dimstyle_textheight">
[in] Height of text in world units.
If the annotation is an ON_TextEntity2, this is the m_textheight value.
If the annotation is not an ON_TextEntity2, pass in the value returned
by the dimension style's ON_DimStyle::TextHeight()
</param>
            <param name="dimstyle_textgap">
[in] The value of the annotation's dimension style's ON_DimStyle::TextGap().
</param>
            <param name="dimstyle_textalignment">[in] ON::TextDisplayMode(ON_DimStyle::TextAlignment()).</param>
            <param name="dimscale">
[in] Global dimension scaling value. If you are using the Rhino SDK, this value is
returned by CRhinoDoc::Properties().AnnotationSettings().DimScale().
</param>
            <param name="cameraX">[in] zero or the view's unit camera right vector</param>
            <param name="cameraY">[in] zero or the view's unit camera up vector</param>
            <param name="xform">[out]</param>
            <returns>True if xform is set.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.GetWCStoECSXform(RMA.OpenNURBS.OnXform@)">
            <summary>
Gets a transform matrix to change from to 3d WCS to the object's 2d ECS
</summary>
            <param name="xform">set to produce the WCS to ECS transform</param>
            <returns>
TRUE Success
FALSE Failure
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.GetECStoWCSXform(RMA.OpenNURBS.OnXform@)">
            <summary>
Gets a transform matrix to change from the object's 2d ECS to 3d WCS
</summary>
            <param name="arg1">[out] xform set to produce the ECS to WCS transform</param>
            <returns>
TRUE Success
FALSE Failure
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.TextDisplayMode">
            <remarks>
This is the way the text is oriented with respect to the dimension line or screen:
Above line, In LIne, Horizontal
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.UserPositionedText">
            <summary>
get a flag indication that the dimension text has been moved
from the default location.
</summary>
            <returns>
TRUE    The text has been moved
FALSE   The text is in the default location
</returns>
            <remarks>
If the text is in the default location, it should be repositioned
automatically when the dimension is adjusted.
If it has been moved, it should not be automatically positioned.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.UserText">
            <summary>get the string value of the user text, with no substitution for "&lt;&gt;"</summary>
            <remarks>
UserText is the string that gets printed when the dimensoin is drawn.
If it contains the token "&lt;&gt;", that token is replaced
with the measured value for the dimension, formatted according to the DimStyle settings.
"&lt;&gt;" is the default for linear dimensions.
Other dimensions include "&lt;&gt;" in their default string
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.Point(System.Int32)">
            <summary>Get individual definition point for the annotation</summary>
            <param name="index">[in] index of the point to set in ECS 2d coordinates</param>
            <returns>the point coordinates in ECS</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.Points">
            <summary>get the object's whole points array at once</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.PointCount">
            <summary>Returns the number of definition points this object has</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.Plane">
            <summary>get the plane for the object's ECS</summary>
            <returns>the object's ECS plane in WCS coords</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.Type">
            <summary>
gets the object type member to a specific annotation type:
dtDimLinear, dtDimAligned, dtDimAngular, etc.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.Height">
            <summary>Get the height of the text in this annotation</summary>
            <remarks>Height is in model units</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.NumericValue">
            <returns>
Dimension type
Linear dim:  distance between arrow tips
Radial dim:  radius or diameter depending on m_type value
Angular dim: angle in degrees
Leader:      ON_UNSET_VALUE
Text:        ON_UNSET_VALUE
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.Index">
            <summary>get the index in the appropriate table for either the font or dimstyle of this object</summary>
            <remarks>
If the object is a text object the index is of object's font in the Font Table
If the object is anything else, the index is of the object's dimstyle in the DimStyle Table
Derived objects can use FontIndex() and StyleIndex() to set/get these same values.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.IsDimension">
            <summary>Query if the annotation object is a dimension</summary>
            <returns>
TRUE It is a dimension
FALSE Its not a dimension
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.IsLeader">
            <summary>Query if the annotation object is a leader</summary>
            <returns>
TRUE It is a leader
FALSE Its not a leader
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.IsText">
            <summary>Query if the annotation object is a text object</summary>
            <returns>
TRUE It is text
FALSE Its not text
</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAnnotation2.m_justification">
            <value>
Left, Center, Right / Bottom, Middle, Top text justification
See eTextJustification above
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAnnotation2.m_textheight">
            <value>
Text height in model units
This is used by text, but not by dimensions
Dimensions get their height from dimension styles
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAnnotation2.m_index">
            <value>
For dimensions, this is the ON_DimStyle index
For text, its the ON_Font index
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAnnotation2.m_userpositionedtext">
            <value>
TRUE: User has positioned text
FALSE: use default location
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAnnotation2.m_usertext">
            <value>
"&lt;&gt;", or user override
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAnnotation2.m_points">
            <value>
Definition points for the dimension.
These are 2d coordinates in m_plane.
The location of these points depends on the
type of annotation class.  There is a comment
at the start of the definions for
ON_LinearDimension2, ON_RadialDimension2,
ON_AngularDimension2, ON_TextEntity2, and
ON_Leader2 that explains how the points are used.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAnnotation2.m_plane">
            <value>
m_plane is the plane containing the annotation.
All parts of the annotation that are not
text lie in this plane. If
m_textdisplaymode != dtHorizontal, then
the text lies in the plane too.  
(ECS reference plane in WCS coordinates.)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAnnotation2.m_textdisplaymode">
            <value>
m_textdisplaymode controls the orientation
of the text.
If m_textdisplaymode = dtHorizontal, then
the text is always horizontal and in the
view plane.  Otherwise it lies in m_plane.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAnnotation2.m_type">
            <value>
enum for tyoe of annotation DimLinear, DimRadius, etc.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnAnnotation2Text.m_rect">
            <value>
m_rect is a Windows gdi RECT that bounds text 
("x" increases to the right and "y" increases downwards).
If all fields are 0, then m_rect is not set.
If left &lt; right and top &lt; bottom, then the rect bounds 
the text when it is drawn with its font's 
lfHeight=ON_Font::normal_font_height and (0,0) left baseline
point of the leftmost character on the first line
of text. If (x,y) is a point on the drawn text, then
left &lt;= x &lt; right and top &lt;= y &lt; bottom.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAnnotation2Text.m_rect">
            <value>
m_rect is a Windows gdi RECT that bounds text 
("x" increases to the right and "y" increases downwards).
If all fields are 0, then m_rect is not set.
If left &lt; right and top &lt; bottom, then the rect bounds 
the text when it is drawn with its font's 
lfHeight=ON_Font::normal_font_height and (0,0) left baseline
point of the leftmost character on the first line
of text. If (x,y) is a point on the drawn text, then
left &lt;= x &lt; right and top &lt;= y &lt; bottom.
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation.GeWCStoECSXform(RMA.OpenNURBS.OnXform@)">
            <summary>
Converts from WCS 3d points to 2d points in annotation
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation.GetECStoWCSXform(RMA.OpenNURBS.OnXform@)">
            <summary>
to convert world 3d points to and from annotation 2d points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation.Destroy">
            <summary>
memory is uninitialized
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation.Create">
            <summary>
initialize class's fields assuming memory is uninitialized
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnAnnotation.m_userpositionedtext">
            <value>
TRUE: User has positioned text
FALSE: use default location
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnAnnotation.m_defaulttext">
            <value>
The displayed text string
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnAnnotation.m_usertext">
            <value>
"&lt;&gt;", or user override
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnAnnotation.m_points">
            <value>
Definition points for the dimension
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnAnnotation.m_plane">
            <value>
ECS reference plane in WCS coordinates
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnAnnotation.m_textdisplaymode">
            <value>
how the text is displayed
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnAnnotation.m_type">
            <value>
enum for type of annotation
DimLinear, DimRadius, etc.
</value>
        </member>
        <member name="T:RMA.OpenNURBS.OnAnnotation">
            <summary>
used to serialize definitions of annotation
objects (dimensions, text blocks, etc.).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation.GeWCStoECSXform(RMA.OpenNURBS.OnXform@)">
            <summary>
Converts from WCS 3d points to 2d points in annotation
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation.GetECStoWCSXform(RMA.OpenNURBS.OnXform@)">
            <summary>
to convert world 3d points to and from annotation 2d points
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAnnotation.m_userpositionedtext">
            <value>
TRUE: User has positioned text
FALSE: use default location
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAnnotation.m_defaulttext">
            <value>
The displayed text string
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAnnotation.m_usertext">
            <value>
"&lt;&gt;", or user override
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAnnotation.m_points">
            <value>
Definition points for the dimension
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAnnotation.m_plane">
            <value>
ECS reference plane in WCS coordinates
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAnnotation.m_textdisplaymode">
            <value>
how the text is displayed
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAnnotation.m_type">
            <value>
enum for type of annotation
DimLinear, DimRadius, etc.
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnAnnotation">
            <summary>
used to serialize definitions of annotation
objects (dimensions, text blocks, etc.).
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnAnnotationArrow">
            <summary>3d annotation arrow</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnAnnotationArrow">
            <summary>3d annotation arrow</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnAnnotationTextDot">
            <summary>
3d annotation dot with text
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnAnnotationTextDot">
            <summary>
3d annotation dot with text
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.DisplayMaterialRefCount">
            <summary>
Returns: Number of diplay material refences.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.RemoveAllDisplayMaterialRefs">
            <summary>
Remove the entire display material reference list.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.RemoveDisplayMaterialRef(System.Guid)">
            <summary>
Remove a display material reference from the list. Parameters: viewport_id - [in] Any display material references with this viewport id will be removed. If nil, then viewport_id is ignored. display_material_id - [in] Any display material references that match the viewport_id and have this display_material_id will be removed. If nil, then display_material_id is ignored. Returns: True if a display material reference was removed. See Also: ON_3dmObjectAttributes::FindDisplayMaterialRef ON_3dmObjectAttributes::AddDisplayMaterialRef
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.RemoveDisplayMaterialRef(System.Guid,System.Guid)">
            <summary>
Remove a display material reference from the list. Parameters: viewport_id - [in] Any display material references with this viewport id will be removed. If nil, then viewport_id is ignored. display_material_id - [in] Any display material references that match the viewport_id and have this display_material_id will be removed. If nil, then display_material_id is ignored. Returns: True if a display material reference was removed. See Also: ON_3dmObjectAttributes::FindDisplayMaterialRef ON_3dmObjectAttributes::AddDisplayMaterialRef
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.AddDisplayMaterialRef(RMA.OpenNURBS.IOnDisplayMaterialRef)">
            <summary>
Add a display material reference to the attributes. If there is an existing entry
with a matching viewport id, the existing entry is replaced.
</summary>
            <param name="display_material">[in]</param>
            <returns>True if input is valid (material id != nil)</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.FindDisplayMaterialId(System.Guid,System.Guid@)">
            <summary>Quick way to see if a viewport has a special material.</summary>
            <param name="viewport_id">[in]</param>
            <param name="display_material_id">[out]</param>
            <returns>True if a material_id is assigned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.FindDisplayMaterialRef(RMA.OpenNURBS.IOnDisplayMaterialRef,RMA.OpenNURBS.OnDisplayMaterialRef)">
            <summary>
Searches for a matching display material. For a given viewport id, there is at most one display material.
For a given display material id, there can be multiple viewports.  If there is a display reference in the
list with a nil viewport id, then the display material will be used in all viewports that are not explictly
referenced in other ON_DisplayMaterialRefs.
</summary>
            <param name="search_material">[in]</param>
            <param name="found_material">
[out] optional, may be NULL
If FindDisplayMaterialRef(), the input value of search_material is never changed.
If FindDisplayMaterialRef() returns true, the chart shows the output value of display_material.
When there are multiple possibilities for a match, the matches at the top of the chart have
higher priority.

search_material  found_material
input value      output value
(nil,nil)        (nil,did) if (nil,did) is in the list.
(nil,did)        (vid,did) if (vid,did) is in the list.
(nil,did)        (nil,did) if (nil,did) is in the list.
(vid,nil)        (vid,did) if (vid,did) is in the list
(vid,nil)        (vid,did) if (nil,did) is in the list
(vid,did)        (vid,did) if (vid,did) is in the list.
</param>
            <returns>True if a matching display material is found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.RemoveFromAllGroups">
            <summary>
Removes object from all groups.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.RemoveFromTopGroup">
            <summary>
removes the object from the last group in the group list
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.RemoveFromGroup(System.Int32)">
            <summary>
Removes object from the group with specified index.  If the 
object is not in the group, nothing is changed.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.AddToGroup(System.Int32)">
            <summary>
Adds object to the group with specified index by appending index to
group list (If the object is already in group, nothing is changed.)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.IsInGroups(RMA.OpenNURBS.IArrayint)">
            <summary>
Returns TRUE if object is in any of the groups in the list
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.IsInGroup(System.Int32)">
            <summary>
Returns TRUE if object is in group with the specified index
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.TopGroup">
            <summary>
Returns the index of the last group in the group list
or -1 if the object is not in any groups
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.GetGroupList(RMA.OpenNURBS.Arrayint@)">
            <summary>
Returns and array an array of GroupCount() zero based 
group indices.  If GroupCount() is zero, then GroupList()
returns NULL.
</summary>
            <summary>
Returns GroupCount() and puts a list of zero based group indices 
into the array.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.GroupCount">
            <summary>
group interface
returns number of groups object belongs to
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.SetMaterialSource(RMA.OpenNURBS.IOn.object_material_source)">
            <summary>
Specifies if the simple material should be the one indicated by the material index or the one indicated by the object's layer. Parameters: ms - [in]
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.MaterialSource">
            <summary>
Determine if the simple material should come from the object or from it's layer. High qualigy rendering plug-ins should use m_rendering_attributes. Returns: Where to get material information if you do are too lazy to look in m_rendering_attributes.m_materials[].
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.ApplyParentalControl(RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <summary>
If "this" has attributes (color, plot weight, ...) with "by parent" sources, then the values of those attributes on parent_attributes are copied. Parameters: parent_attributes - [in] control_limits - [in] The bits in control_limits determine which attributes may may be copied. 1: visibility 2: color 4: render material 8: plot color 0x10: plot weight 0x20: linetype Returns: The bits in the returned integer indicate which attributes were actuall modified. 1: visibility 2: color 4: render material 8: plot color 0x10: plot weight 0x20: linetype
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.ApplyParentalControl(RMA.OpenNURBS.IOn3dmObjectAttributes,System.UInt32)">
            <summary>
If "this" has attributes (color, plot weight, ...) with "by parent" sources, then the values of those attributes on parent_attributes are copied. Parameters: parent_attributes - [in] control_limits - [in] The bits in control_limits determine which attributes may may be copied. 1: visibility 2: color 4: render material 8: plot color 0x10: plot weight 0x20: linetype Returns: The bits in the returned integer indicate which attributes were actuall modified. 1: visibility 2: color 4: render material 8: plot color 0x10: plot weight 0x20: linetype
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.SetDisplayMode(RMA.OpenNURBS.IOn.display_mode)">
            <summary>
See DisplayMode().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.DisplayMode">
            <summary>
OpenNURBS objects can be displayed in one of three ways: wireframe,
shaded, or render preview.  If the display mode is ON::default_display,
then the display mode of the viewport detrmines how the object
is displayed.  If the display mode is ON::wireframe_display,
ON::shaded_display, or ON::renderpreview_display, then the object is
forced to display in that mode.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.SetPlotColorSource(RMA.OpenNURBS.IOn.plot_color_source)">
            <summary>
See PlotColorSource().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.PlotColorSource">
            <summary>
The color used to plot an OpenNURBS object on paper is specified 
in one of three ways.
If PlotColorSource() is ON::plot_color_from_layer, then the object's layer 
ON_Layer::PlotColor() is used.
If PlotColorSource() is ON::plot_color_from_object, then value of PlotColor() is used.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.SetColorSource(RMA.OpenNURBS.IOn.object_color_source)">
            <summary>
See ColorSource().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.ColorSource">
            <summary>
The color used to display an OpenNURBS object is specified in one of three ways.
If ColorSource() is ON::color_from_layer, then the object's layer 
ON_Layer::Color() is used.
If ColorSource() is ON::color_from_object, then value of m_color is used.
If ColorSource() is ON::color_from_material, then the diffuse color of the object's
render material is used.  See ON_3dmObjectAttributes::MaterialSource() to
determine where to get the definition of the object's render material.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.SetLinetypeSource(RMA.OpenNURBS.IOn.object_linetype_source)">
            <summary>
See LinetypeSource().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.LinetypeSource">
            <summary>
The Linetype used to display an OpenNURBS object is specified in one of two ways.
If LinetypeSource() is ON::linetype_from_layer, then the object's layer 
ON_Layer::Linetype() is used.
If LinetypeSource() is ON::linetype_from_object, then value of m_linetype is used.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.SetVisible(System.Boolean)">
            <summary>Controls object visibility</summary>
            <param name="bVisible">[in] true to make object visible, false to make object invisible</param>
            <remarks>See Also: ON_3dmObjectAttributes::IsVisible</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.IsVisible">
            <summary>
Returns: Returns true if object is visible. See Also: ON_3dmObjectAttributes::SetVisible
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.IsInstanceDefinitionObject">
            <summary>
Use this query to determine if an object is part of an instance definition.
</summary>
            <returns>True if the object is part of an instance definition.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.SetMode(RMA.OpenNURBS.IOn.object_mode)">
            <summary>
See Mode().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.Mode">
            <summary>
An OpenNURBS object must be in one of three modes: normal, locked
or hidden.  If an object is in normal mode, then the object's layer
controls visibility and selectability.  If an object is locked, then
the object's layer controls visibility by the object cannot be selected.
If the object is hidden, it is not visible and it cannot be selected.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.Default">
            <summary>
Initializes all attributes to the default values.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.Transform(RMA.OpenNURBS.IOnXform)">
            <returns>True if successful. (xform is invertable or didn't need to be).</returns>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmObjectAttributes.m_space">
            <summary>
Starting with V4, objects can be in either model space
or page space.  If an object is in page space, then
m_viewport_id is not nil and identifies the page it 
is on.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmObjectAttributes.m_viewport_id">
            <summary>
If m_viewport_id is nil, the object is active in
all viewports. If m_viewport_id is not nil, then 
this object is only active in a specific view.  
This field is primarily used to assign page space
objects to a specific page, but it can also be used 
to restrict model space to a specific view.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmObjectAttributes.m_wire_density">
            <value>
When a surface object is displayed in wireframe, m_wire_density controls
how many isoparametric wires are used.
 value    number of isoparametric wires
 0        boundary and knot wires 
 1        boundary and knot wires and, if there are no interior knots, a single interior wire.
 N&gt;=2     boundary and knot wires and (N+1) interior wires
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmObjectAttributes.m_object_decoration">
            <value>
Used to indicate an object has a decoration (like an arrowhead on a curve)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmObjectAttributes.m_plot_weight_mm">
            <value>
Plot weight in millimeters.
 =0.0 means use the default width
 &lt;0.0 means don't plot (visible for screen display, but does not show on plot)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmObjectAttributes.m_plot_color">
            <value>
If ON::plot_color_from_object == PlotColorSource(), then m_color is the object's
display color.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmObjectAttributes.m_color">
            <value>
If ON::color_from_object == ColorSource(), then m_color is the object's
display color.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmObjectAttributes.m_material_index">
            <value>
Rendering material:
 If you want something simple and fast, set 
 m_material_index to the index of the rendering material 
 and ignore m_rendering_attributes.
 If you are developing a high quality plug-in renderer, 
 and a user is assigning one of your fabulous rendering 
 materials to this object, then add rendering material
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmObjectAttributes.m_linetype_index">
            <value>
Linetype definitions in an OpenNURBS model are stored in a linetype table.
The linetype table is conceptually an array of ON_Linetype classes.  Every
OpenNURBS object in a model references some linetype.  The object's linetype
is specified by zero based indicies into the ON_Linetype array.
index 0 is reserved for continuous linetype (no pattern)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmObjectAttributes.m_layer_index">
            <value>
Layer definitions in an OpenNURBS model are stored in a layer table.
The layer table is conceptually an array of ON_Layer classes.  Every
OpenNURBS object in a model is on some layer.  The object's layer
is specified by zero based indicies into the ON_Layer array.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmObjectAttributes.m_url">
            <value>
OpenNURBS objects may have an URL.  There are no restrictions on what
value this URL may have.  As an example, if the object came from a
commercial part library, the URL might point to the definition of that
part.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmObjectAttributes.m_name">
            <value>
OpenNURBS object have optional text names.  More than one object in
a model can have the same name and some objects may have no name.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmObjectAttributes.m_uuid">
            <value>
Every OpenNURBS object has a UUID (universally unique identifier).  The
default value is NULL.  When an OpenNURBS object is added to a model, the
value is checked.  If the value is NULL, a new UUID is created.  If the
value is not NULL but it is already used by another object in the model,
a new UUID is created.  If the value is not NULL and it is not used by 
another object in the model, then that value persists. When an object
is updated, by a move for example, the value of m_uuid persists.
</value>
        </member>
        <member name="T:RMA.OpenNURBS.On3dmObjectAttributes">
            <summary>
Top level OpenNURBS objects have geometry and attributes.  The
geometry is stored in some class derived from ON_Geometry and 
the attributes are stored in an ON_3dmObjectAttributes class.
Examples of attributes are object name, object id, display 
attributes, group membership, layer membership, and so on.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dmObjectAttributes.DisplayMaterialRefCount">
            <returns>Number of diplay material refences.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dmObjectAttributes.FindDisplayMaterialId(System.Guid,System.Guid@)">
            <summary>Quick way to see if a viewport has a special material.</summary>
            <param name="viewport_id">[in]</param>
            <param name="display_material_id">[out]</param>
            <returns>True if a material_id is assigned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dmObjectAttributes.FindDisplayMaterialRef(RMA.OpenNURBS.IOnDisplayMaterialRef,RMA.OpenNURBS.OnDisplayMaterialRef)">
            <summary>
Searches for a matching display material. For a given viewport id, there is at most one display material.
For a given display material id, there can be multiple viewports.  If there is a display reference in the
list with a nil viewport id, then the display material will be used in all viewports that are not explictly
referenced in other ON_DisplayMaterialRefs.
</summary>
            <param name="search_material">[in]</param>
            <param name="found_material">
[out] optional, may be NULL
If FindDisplayMaterialRef(), the input value of search_material is never changed.
If FindDisplayMaterialRef() returns true, the chart shows the output value of display_material.
When there are multiple possibilities for a match, the matches at the top of the chart have
higher priority.

search_material  found_material
input value      output value
(nil,nil)        (nil,did) if (nil,did) is in the list.
(nil,did)        (vid,did) if (vid,did) is in the list.
(nil,did)        (nil,did) if (nil,did) is in the list.
(vid,nil)        (vid,did) if (vid,did) is in the list
(vid,nil)        (vid,did) if (nil,did) is in the list
(vid,did)        (vid,did) if (vid,did) is in the list.
</param>
            <returns>True if a matching display material is found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dmObjectAttributes.IsInGroups(RMA.OpenNURBS.IArrayint)">
            <summary>
Returns TRUE if object is in any of the groups in the list
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dmObjectAttributes.IsInGroup(System.Int32)">
            <summary>
Returns TRUE if object is in group with the specified index
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dmObjectAttributes.TopGroup">
            <summary>
Returns the index of the last group in the group list
or -1 if the object is not in any groups
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dmObjectAttributes.GetGroupList(RMA.OpenNURBS.Arrayint@)">
            <summary>
Returns and array an array of GroupCount() zero based 
group indices.  If GroupCount() is zero, then GroupList()
returns NULL.
</summary>
            <summary>
Returns GroupCount() and puts a list of zero based group indices 
into the array.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dmObjectAttributes.GroupCount">
            <summary>
returns number of groups object belongs to
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dmObjectAttributes.MaterialSource">
            <summary>
Determine if the simple material should come from the object or from it's layer.
High quality rendering plug-ins should use m_rendering_attributes.
</summary>
            <returns>
Where to get material information if you do are too lazy to look in m_rendering_attributes.m_materials[].
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dmObjectAttributes.DisplayMode">
            <summary>
OpenNURBS objects can be displayed in one of three ways: wireframe,
shaded, or render preview.  If the display mode is ON::default_display,
then the display mode of the viewport detrmines how the object
is displayed.  If the display mode is ON::wireframe_display,
ON::shaded_display, or ON::renderpreview_display, then the object is
forced to display in that mode.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dmObjectAttributes.PlotColorSource">
            <summary>
The color used to plot an OpenNURBS object on paper is specified 
in one of three ways.
If PlotColorSource() is ON::plot_color_from_layer, then the object's layer 
ON_Layer::PlotColor() is used.
If PlotColorSource() is ON::plot_color_from_object, then value of PlotColor() is used.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dmObjectAttributes.ColorSource">
            <summary>
The color used to display an OpenNURBS object is specified in one of three ways.
If ColorSource() is ON::color_from_layer, then the object's layer 
ON_Layer::Color() is used.
If ColorSource() is ON::color_from_object, then value of m_color is used.
If ColorSource() is ON::color_from_material, then the diffuse color of the object's
render material is used.  See ON_3dmObjectAttributes::MaterialSource() to
determine where to get the definition of the object's render material.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dmObjectAttributes.LinetypeSource">
            <summary>
The Linetype used to display an OpenNURBS object is specified in one of two ways.
If LinetypeSource() is ON::linetype_from_layer, then the object's layer 
ON_Layer::Linetype() is used.
If LinetypeSource() is ON::linetype_from_object, then value of m_linetype is used.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dmObjectAttributes.IsVisible">
            <summary>
Returns true if object is visible. See Also: ON_3dmObjectAttributes::SetVisible
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dmObjectAttributes.IsInstanceDefinitionObject">
            <summary>Use this query to determine if an object is part of an instance definition.</summary>
            <returns>True if the object is part of an instance definition.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dmObjectAttributes.Mode">
            <summary>
An OpenNURBS object must be in one of three modes: normal, locked
or hidden.  If an object is in normal mode, then the object's layer
controls visibility and selectability.  If an object is locked, then
the object's layer controls visibility by the object cannot be selected.
If the object is hidden, it is not visible and it cannot be selected.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmObjectAttributes.m_space">
            <summary>
Starting with V4, objects can be in either model space
or page space.  If an object is in page space, then
m_viewport_id is not nil and identifies the page it 
is on.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmObjectAttributes.m_viewport_id">
            <summary>
If m_viewport_id is nil, the object is active in
all viewports. If m_viewport_id is not nil, then 
this object is only active in a specific view.  
This field is primarily used to assign page space
objects to a specific page, but it can also be used 
to restrict model space to a specific view.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmObjectAttributes.m_wire_density">
            <value>
When a surface object is displayed in wireframe, m_wire_density controls
how many isoparametric wires are used.
 value    number of isoparametric wires
 0        boundary and knot wires 
 1        boundary and knot wires and, if there are no interior knots, a single interior wire.
 N&gt;=2     boundary and knot wires and (N+1) interior wires
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmObjectAttributes.m_object_decoration">
            <value>
Used to indicate an object has a decoration (like an arrowhead on a curve)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmObjectAttributes.m_plot_weight_mm">
            <value>
Plot weight in millimeters.
 =0.0 means use the default width
 &lt;0.0 means don't plot (visible for screen display, but does not show on plot)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmObjectAttributes.m_plot_color">
            <value>
If ON::plot_color_from_object == PlotColorSource(), then m_color is the object's
display color.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmObjectAttributes.m_color">
            <value>
If ON::color_from_object == ColorSource(), then m_color is the object's
display color.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmObjectAttributes.m_material_index">
            <value>
Rendering material:
 If you want something simple and fast, set 
 m_material_index to the index of the rendering material 
 and ignore m_rendering_attributes.
 If you are developing a high quality plug-in renderer, 
 and a user is assigning one of your fabulous rendering 
 materials to this object, then add rendering material
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmObjectAttributes.m_linetype_index">
            <value>
Linetype definitions in an OpenNURBS model are stored in a linetype table.
The linetype table is conceptually an array of ON_Linetype classes.  Every
OpenNURBS object in a model references some linetype.  The object's linetype
is specified by zero based indicies into the ON_Linetype array.
index 0 is reserved for continuous linetype (no pattern)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmObjectAttributes.m_layer_index">
            <value>
Layer definitions in an OpenNURBS model are stored in a layer table.
The layer table is conceptually an array of ON_Layer classes.  Every
OpenNURBS object in a model is on some layer.  The object's layer
is specified by zero based indicies into the ON_Layer array.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmObjectAttributes.m_url">
            <value>
OpenNURBS objects may have an URL.  There are no restrictions on what
value this URL may have.  As an example, if the object came from a
commercial part library, the URL might point to the definition of that
part.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmObjectAttributes.m_name">
            <value>
OpenNURBS object have optional text names.  More than one object in
a model can have the same name and some objects may have no name.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmObjectAttributes.m_uuid">
            <value>
Every OpenNURBS object has a UUID (universally unique identifier).  The
default value is NULL.  When an OpenNURBS object is added to a model, the
value is checked.  If the value is NULL, a new UUID is created.  If the
value is not NULL but it is already used by another object in the model,
a new UUID is created.  If the value is not NULL and it is not used by 
another object in the model, then that value persists. When an object
is updated, by a move for example, the value of m_uuid persists.
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOn3dmObjectAttributes">
            <summary>
Top level OpenNURBS objects have geometry and attributes.  The
geometry is stored in some class derived from ON_Geometry and 
the attributes are stored in an ON_3dmObjectAttributes class.
Examples of attributes are object name, object id, display 
attributes, group membership, layer membership, and so on.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmSettings.m_plugin_list">
            <value>
Plugins that were loaded when the file was saved.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmSettings.m_linetype_display_scale">
            <value>
World scale factor to apply to non-solid linetypes
for model display.  For plotting, the linetype settings
are used without scaling.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmSettings.m_GridDefaults">
            <value>
default settings for construction plane grids
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmSettings.m_current_wire_density">
            <value>
Surface wireframe density
 @untitled table
 0       boundary + "knot" wires 
 1       boundary + "knot" wires + 1 interior wire if no interior "knots"
 N&gt;=2    boundry + "knot" wires + (N-1) interior wires
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmSettings.m_current_layer_index">
            <value>
These fields determine what layer, material, color, line style, and
wire density are used for new objects.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmSettings.m_active_view_id">
            <value>
id of "active" viewport
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmSettings.m_views">
            <value>
current viewports
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmSettings.m_AnnotationSettings">
            <value>
settings used when annotation objects are created
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmSettings.m_AnalysisMeshSettings">
            <value>
settings used for automatically created analysis meshes
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmSettings.m_CustomRenderMeshSettings">
            <value>
saved custom settings
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmSettings.m_RenderMeshSettings">
            <value>
settings used for automatically created rendering meshes
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmSettings.m_PageUnitsAndTolerances">
            <value>
Page space (printing/paper) tolerances and unit system
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmSettings.m_ModelUnitsAndTolerances">
            <value>
Model space tolerances and unit system
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmSettings.m_earth_anchor_point">
            <value>
If set, this is the model's location on the earth.
This information is used when the model is used
with GIS information.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmSettings.m_model_basepoint">
            <value>
Model basepoint is used when the file is read as
an instance definition and is the point that is
mapped to the origin in the instance definition.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmSettings.m_model_URL">
            <value>
model URL (can be empty)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmSettings.m_plugin_list">
            <value>
Plugins that were loaded when the file was saved.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmSettings.m_linetype_display_scale">
            <value>
World scale factor to apply to non-solid linetypes
for model display.  For plotting, the linetype settings
are used without scaling.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmSettings.m_GridDefaults">
            <value>
default settings for construction plane grids
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmSettings.m_current_wire_density">
            <value>
Surface wireframe density
 0       boundary + "knot" wires 
 1       boundary + "knot" wires + 1 interior wire if no interior "knots"
 N&gt;=2    boundry + "knot" wires + (N-1) interior wires
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmSettings.m_current_layer_index">
            <value>
These fields determine what layer, material, color, line style, and
wire density are used for new objects.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmSettings.m_active_view_id">
            <value>
id of "active" viewport
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmSettings.m_views">
            <value>
current viewports
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmSettings.m_AnnotationSettings">
            <value>
settings used when annotation objects are created
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmSettings.m_AnalysisMeshSettings">
            <value>
settings used for automatically created analysis meshes
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmSettings.m_CustomRenderMeshSettings">
            <value>
saved custom settings
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmSettings.m_RenderMeshSettings">
            <value>
settings used for automatically created rendering meshes
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmSettings.m_PageUnitsAndTolerances">
            <value>
Page space (printing/paper) tolerances and unit system
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmSettings.m_ModelUnitsAndTolerances">
            <value>
Model space tolerances and unit system
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmSettings.m_earth_anchor_point">
            <value>
If set, this is the model's location on the earth.
This information is used when the model is used
with GIS information.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmSettings.m_model_basepoint">
            <value>
Model basepoint is used when the file is read as
an instance definition and is the point that is
mapped to the origin in the instance definition.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmSettings.m_model_URL">
            <value>
model URL (can be empty)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmIOSettings.m_idef_link_update">
            <value>
linked instance defintion settings
0 = use ON_InstanceDefinition setting
      The ON_InstanceDefinition::m_idef_update_type
      field controls when and with how much
      prompting embedded or linked idefs get updated.
1 = prompt
      Ignore m_idef_update_type settings.
      If an embedded or linked idef needs to 
      be updated, ask the user what to do.
2 = always update - no prompting
      Ignore m_idef_update_type settings.
      If an embedded or linked idef needs to 
      be updated, silently update it.
3 = never update - no prompting
      Ignore m_idef_update_type settings.
      Do not update embedded or linked idefs.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmIOSettings.m_bSaveTextureBitmapsInFile">
            <value>
bitmaps associated with rendering materials
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmIOSettings.m_idef_link_update">
            <value>
linked instance defintion settings
0 = use ON_InstanceDefinition setting
      The ON_InstanceDefinition::m_idef_update_type
      field controls when and with how much
      prompting embedded or linked idefs get updated.
1 = prompt
      Ignore m_idef_update_type settings.
      If an embedded or linked idef needs to 
      be updated, ask the user what to do.
2 = always update - no prompting
      Ignore m_idef_update_type settings.
      If an embedded or linked idef needs to 
      be updated, silently update it.
3 = never update - no prompting
      Ignore m_idef_update_type settings.
      Do not update embedded or linked idefs.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmIOSettings.m_bSaveTextureBitmapsInFile">
            <value>
bitmaps associated with rendering materials
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnEarthAnchorPoint.GetModelToEarthXform(RMA.OpenNURBS.IOnUnitSystem,RMA.OpenNURBS.OnXform@)">
            <summary>
Get a transformation from model coordinates to earth coordinates.
This transformation assumes the model is small enough that the curvature of the earth can be ignored.
</summary>
            <param name="model_unit_system">[in]</param>
            <param name="model_to_earth">[out] Transformation from model coordinates to earth locations (degrees latitude,degrees longitude,elevation in meters)</param>
            <remarks>
If M is a point in model coordinates and E = model_to_earth*M, then
E.x = latitude in decimal degrees
E.y = longitude in decimal degrees
E.z = elevation in meters above mean sea level
Because the earth is not flat, there is a small amount of error when
using a linear transformation to calculate oblate spherical coordinates.
This error is small. If the distance from P to M is d meters,
then the approximation error is
  latitude error &lt;=
  longitude error &lt;=
  elevation error &lt;= 6379000*((1 + (d/6356000)^2)-1) meters
In particular, if every point in the model is within 1000 meters
of the m_model_basepoint, then the maximum approximation errors are
  latitude error &lt;=
  longitude error &lt;=
  elevation error &lt;= 8 centimeters
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnEarthAnchorPoint.GetModelCompass(RMA.OpenNURBS.OnPlane@)">
            <summary>
Parameters: model_compass - [out] A plane in model coordinates whose xaxis points East, yaxis points North and zaxis points up. The origin is set to m_model_basepoint.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnEarthAnchorPoint.m_url_tag">
            <value>
UI link text for m_url
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnEarthAnchorPoint.m_id">
            <value>
unique id for this anchor point
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnEarthAnchorPoint.m_model_east">
            <value>
in model coordinates
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnEarthAnchorPoint.m_model_north">
            <value>
in model coordinates
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnEarthAnchorPoint.m_model_basepoint">
            <value>
Corresponding model point in model coordinates.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnEarthAnchorPoint.m_earth_basepoint_elevation_zero">
            <value>
0 = ground level
1 = mean sea level
2 = center of earth
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnEarthAnchorPoint.m_earth_basepoint_elevation">
            <value>
in meters
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnEarthAnchorPoint.m_earth_basepoint_longitude">
            <value>
Longitude (degrees):   0 = prime meridian (Greenwich meridian)
in decimal degrees
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnEarthAnchorPoint.m_earth_basepoint_latitude">
            <value>
Latitude (degrees):  +90 = north pole, 0 = equator, -90 = south pole
in decimal degrees
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEarthAnchorPoint.GetModelToEarthXform(RMA.OpenNURBS.IOnUnitSystem,RMA.OpenNURBS.OnXform@)">
            <summary>
Get a transformation from model coordinates to earth coordinates.
This transformation assumes the model is small enough that the curvature of the earth can be ignored.
</summary>
            <param name="model_unit_system">[in]</param>
            <param name="model_to_earth">[out] Transformation from model coordinates to earth locations (degrees latitude,degrees longitude,elevation in meters)</param>
            <remarks>
If M is a point in model coordinates and E = model_to_earth*M, then
E.x = latitude in decimal degrees
E.y = longitude in decimal degrees
E.z = elevation in meters above mean sea level
Because the earth is not flat, there is a small amount of error when
using a linear transformation to calculate oblate spherical coordinates.
This error is small. If the distance from P to M is d meters,
then the approximation error is
  latitude error &lt;=
  longitude error &lt;=
  elevation error &lt;= 6379000*((1 + (d/6356000)^2)-1) meters
In particular, if every point in the model is within 1000 meters
of the m_model_basepoint, then the maximum approximation errors are
  latitude error &lt;=
  longitude error &lt;=
  elevation error &lt;= 8 centimeters
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEarthAnchorPoint.GetModelCompass(RMA.OpenNURBS.OnPlane@)">
            <summary>
Parameters: model_compass - [out] A plane in model coordinates whose xaxis points East, yaxis points North and zaxis points up. The origin is set to m_model_basepoint.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnEarthAnchorPoint.m_url_tag">
            <value>
UI link text for m_url
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnEarthAnchorPoint.m_id">
            <value>
unique id for this anchor point
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnEarthAnchorPoint.m_model_east">
            <value>
in model coordinates
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnEarthAnchorPoint.m_model_north">
            <value>
in model coordinates
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnEarthAnchorPoint.m_model_basepoint">
            <value>
Corresponding model point in model coordinates.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnEarthAnchorPoint.m_earth_basepoint_elevation_zero">
            <value>
0 = ground level
1 = mean sea level
2 = center of earth
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnEarthAnchorPoint.m_earth_basepoint_elevation">
            <value>
in meters
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnEarthAnchorPoint.m_earth_basepoint_longitude">
            <value>
Longitude (degrees):   0 = prime meridian (Greenwich meridian)
in decimal degrees
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnEarthAnchorPoint.m_earth_basepoint_latitude">
            <value>
Latitude (degrees):  +90 = north pole, 0 = equator, -90 = south pole
in decimal degrees
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmRenderSettings.m_shadowmap_style">
            <value>
0 = none, 1 = normal, 2 = best
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmRenderSettings.m_antialias_style">
            <value>
0 = none, 1 = normal, 2 = best
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmRenderSettings.m_background_style">
            <value>
0 = solid color, 1 = "wallpaper" image
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmRenderSettings.m_image_us">
            <value>
unit system to use when converting image pixel size and dpi
information into a print size.  Default = inches
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmRenderSettings.m_image_dpi">
            <value>
Number of dots/inch (dots=pixels) to use when printing and 
saving bitmaps. The default is 72.0 dots/inch.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmRenderSettings.m_image_height">
            <value>
image height in pixels
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmRenderSettings.m_image_width">
            <value>
image width in pixels
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmRenderSettings.m_bCustomImageSize">
            <value>
FALSE: image pixel size = current viewport size
TRUE:  image pixel size = m_image_width X m_image_height pixels
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmRenderSettings.m_shadowmap_style">
            <value>
0 = none, 1 = normal, 2 = best
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmRenderSettings.m_antialias_style">
            <value>
0 = none, 1 = normal, 2 = best
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmRenderSettings.m_background_style">
            <value>
0 = solid color, 1 = "wallpaper" image
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmRenderSettings.m_image_us">
            <value>
unit system to use when converting image pixel size and dpi
information into a print size.  Default = inches
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmRenderSettings.m_image_dpi">
            <value>
Number of dots/inch (dots=pixels) to use when printing and 
saving bitmaps. The default is 72.0 dots/inch.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmRenderSettings.m_image_height">
            <value>
image height in pixels
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmRenderSettings.m_image_width">
            <value>
image width in pixels
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmRenderSettings.m_bCustomImageSize">
            <value>
FALSE: image pixel size = current viewport size
TRUE:  image pixel size = m_image_width X m_image_height pixels
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmView.m_wallpaper_image">
            <value>
wallpaper image
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmView.m_trace_image">
            <value>
tracing image
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmView.m_bShowWorldAxes">
            <value>
world axes icon
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmView.m_cplane">
            <value>
construction plane
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmView.m_page_settings">
            <value>
If m_view_type == ON::page_view_type, then the m_page_settings
records the page size.  Otherwise, m_page_settings should
be ignored.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmView.m_view_type">
            <value>
model, page, or nested
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmView.m_position">
            <value>
position of view in parent window 
(relative display device coordinates)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmView.m_display_mode_id">
            <value>
If m_display_mode_id is nil, then use m_display_mode
to show one of the "standard" (wireframe, shaded, rendered)
display modes.  If m_display_mode_id is not nil, then
ignore m_display_mode.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmView.m_name">
            <value>
name on window
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmView.m_bLockedProjection">
            <value>
If true, the the camera location, camera direction,
and lens angle should not be changed.
It is ok to adjust clipping planes.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmView.m_clipping_planes">
            <value>
clipping planes
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmView.m_vp">
            <value>
view projection information
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmView.m_wallpaper_image">
            <value>
wallpaper image
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmView.m_trace_image">
            <value>
tracing image
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmView.m_bShowWorldAxes">
            <value>
world axes icon
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmView.m_cplane">
            <value>
construction plane
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmView.m_page_settings">
            <value>
If m_view_type == ON::page_view_type, then the m_page_settings
records the page size.  Otherwise, m_page_settings should
be ignored.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmView.m_view_type">
            <value>
model, page, or nested
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmView.m_position">
            <value>
position of view in parent window 
(relative display device coordinates)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmView.m_display_mode_id">
            <value>
If m_display_mode_id is nil, then use m_display_mode
to show one of the "standard" (wireframe, shaded, rendered)
display modes.  If m_display_mode_id is not nil, then
ignore m_display_mode.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmView.m_name">
            <value>
name on window
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmView.m_bLockedProjection">
            <value>
If true, the the camera location, camera direction,
and lens angle should not be changed.
It is ok to adjust clipping planes.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmView.m_clipping_planes">
            <value>
clipping planes
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmView.m_vp">
            <value>
view projection information
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmPageSettings.m_left_margin_mm">
            <value>
Page margins in millimeters
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmPageSettings.m_width_mm">
            <value>
Overall size of the page in millimeters
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmPageSettings.m_left_margin_mm">
            <value>
Page margins in millimeters
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmPageSettings.m_width_mm">
            <value>
Overall size of the page in millimeters
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmWallpaperImage.m_bHidden">
            <value>
true if image is currently hidden from view
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmWallpaperImage.m_bGrayScale">
            <value>
true if image should be black and white
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmWallpaperImage.m_bHidden">
            <value>
true if image is currently hidden from view
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmWallpaperImage.m_bGrayScale">
            <value>
true if image should be black and white
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmViewTraceImage.m_bFiltered">
            <value>
true if image should be filtered (bilinear) before displayed.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmViewTraceImage.m_bHidden">
            <value>
true if image is currently hidden from view
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmViewTraceImage.m_bGrayScale">
            <value>
true if image should be black and white
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmViewTraceImage.m_plane">
            <value>
view window relative position and state in parent frame
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmViewTraceImage.m_bFiltered">
            <value>
true if image should be filtered (bilinear) before displayed.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmViewTraceImage.m_bHidden">
            <value>
true if image is currently hidden from view
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmViewTraceImage.m_bGrayScale">
            <value>
true if image should be black and white
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmViewTraceImage.m_plane">
            <value>
view window relative position and state in parent frame
</value>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmViewPosition.#ctor">
            <summary>
view window relative position and state in parent frame
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmViewPosition.m_bMaximized">
            <value>
TRUE if view window is maximized
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmViewPosition.m_wnd_left">
            <value>
0.0 to 1.0
</value>
        </member>
        <member name="T:RMA.OpenNURBS.On3dmViewPosition">
            <summary>view window relative position and state in parent frame</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmViewPosition.m_bMaximized">
            <value>
TRUE if view window is maximized
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmViewPosition.m_wnd_left">
            <value>
0.0 to 1.0
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOn3dmViewPosition">
            <summary>view window relative position and state in parent frame</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmConstructionPlane.m_name">
            <value>
true=grid is drawn at its depth as a 3d plane
and grid lines obscure things behind the grid.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmConstructionPlane.m_bDepthBuffer">
            <value>
false=grid is always drawn behind 3d geometry
true=grid is drawn at its depth as a 3d plane
and grid lines obscure things behind the grid.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmConstructionPlane.m_grid_thick_frequency">
            <value>
thick line frequency
0: none, 
1: all lines are thick, 
2: every other is thick, ...
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmConstructionPlane.m_grid_line_count">
            <value>
number of grid lines in each direction
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmConstructionPlane.m_snap_spacing">
            <value>
when "grid snap" is enabled, the
distance between snap points.  Typically
this is the same distance as grid spacing.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmConstructionPlane.m_grid_spacing">
            <value>
distance between grid lines
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmConstructionPlane.m_name">
            <value>
true=grid is drawn at its depth as a 3d plane
and grid lines obscure things behind the grid.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmConstructionPlane.m_bDepthBuffer">
            <value>
false=grid is always drawn behind 3d geometry
true=grid is drawn at its depth as a 3d plane
and grid lines obscure things behind the grid.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmConstructionPlane.m_grid_thick_frequency">
            <value>
thick line frequency
0: none, 
1: all lines are thick, 
2: every other is thick, ...
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmConstructionPlane.m_grid_line_count">
            <value>
number of grid lines in each direction
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmConstructionPlane.m_snap_spacing">
            <value>
when "grid snap" is enabled, the
distance between snap points.  Typically
this is the same distance as grid spacing.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmConstructionPlane.m_grid_spacing">
            <value>
distance between grid lines
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmConstructionPlaneGridDefaults.m_grid_thick_frequency">
            <value>
thick line frequency
0: none, 
1: all lines are thick, 
2: every other is thick, ...
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmConstructionPlaneGridDefaults.m_grid_line_count">
            <value>
number of grid lines in each direction
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmConstructionPlaneGridDefaults.m_snap_spacing">
            <value>
when "grid snap" is enabled, the
distance between snap points.  Typically
this is the same distance as grid spacing.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmConstructionPlaneGridDefaults.m_grid_spacing">
            <value>
distance between grid lines
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmConstructionPlaneGridDefaults.m_grid_thick_frequency">
            <value>
thick line frequency
0: none, 
1: all lines are thick, 
2: every other is thick, ...
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmConstructionPlaneGridDefaults.m_grid_line_count">
            <value>
number of grid lines in each direction
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmConstructionPlaneGridDefaults.m_snap_spacing">
            <value>
when "grid snap" is enabled, the
distance between snap points.  Typically
this is the same distance as grid spacing.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmConstructionPlaneGridDefaults.m_grid_spacing">
            <value>
distance between grid lines
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOn3dmConstructionPlaneGridDefaults">
            <summary>
Default settings used for construction plane grids
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmAnnotationSettings.m_facename">
            <value>
[LF_FACESIZE] // windows font name
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmAnnotationSettings.m_resolution">
            <value>
depends on m_lengthformat
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmAnnotationSettings.m_textalign">
            <value>
0: above line, 1: in line, 2: horizontal
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmAnnotationSettings.m_angleformat">
            <value>
0: decimal degrees, ...
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmAnnotationSettings.m_lengthformat">
            <value>
0: decimal, ...
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmAnnotationSettings.m_angularunits">
            <value>
0: degrees, 1: radians
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmAnnotationSettings.m_arrowtype">
            <value>
0: filled narrow triangular arrow
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmAnnotationSettings.m_dimunits">
            <value>
units used to measure the dimension
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmAnnotationSettings.m_dimdle">
            <value>
added 12/28/05 LW
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmAnnotationSettings.m_dimscale">
            <value>
model size / plotted size
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmAnnotationSettings.m_facename">
            <value>
[LF_FACESIZE] // windows font name
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmAnnotationSettings.m_resolution">
            <value>
depends on m_lengthformat
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmAnnotationSettings.m_textalign">
            <value>
0: above line, 1: in line, 2: horizontal
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmAnnotationSettings.m_angleformat">
            <value>
0: decimal degrees, ...
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmAnnotationSettings.m_lengthformat">
            <value>
0: decimal, ...
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmAnnotationSettings.m_angularunits">
            <value>
0: degrees, 1: radians
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmAnnotationSettings.m_arrowtype">
            <value>
0: filled narrow triangular arrow
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmAnnotationSettings.m_dimunits">
            <value>
units used to measure the dimension
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmAnnotationSettings.m_dimdle">
            <value>
added 12/28/05 LW
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmAnnotationSettings.m_dimscale">
            <value>
model size / plotted size
</value>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmUnitsAndTolerances.Scale(RMA.OpenNURBS.IOn.unit_system)">
            <summary>
Returns scale factor that needs to be applied to change from
the argument's unit system to m_unit_system.  
When m_unit_system is not ON::custom_unit_system,
Scale(us) = ON::UnitScale(us,m_unit_system).  When Scale(us)
When m_unit_system is ON::custom_unit_system,
Scale(us) = ON::UnitScale(us,ON::meters)*m_custom_unit_scale.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmUnitsAndTolerances.m_distance_display_precision">
            <value>
decimal mode: number of decimal places
fractional modes:
   denominator = (1/2)^m_distance_display_precision
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmUnitsAndTolerances.m_relative_tolerance">
            <value>
fraction &gt;= 0 and &lt; 1 (default = 1%)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmUnitsAndTolerances.m_angle_tolerance">
            <value>
in radians (default = 3 degrees)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmUnitsAndTolerances.m_absolute_tolerance">
            <value>
in units (default = 1/100)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmUnitsAndTolerances.m_unit_system">
            <value>
ON::unit_system m_unit_system;
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dmUnitsAndTolerances.Scale(RMA.OpenNURBS.IOn.unit_system)">
            <summary>
Returns scale factor that needs to be applied to change from
the argument's unit system to m_unit_system.  
When m_unit_system is not ON::custom_unit_system,
Scale(us) = ON::UnitScale(us,m_unit_system).  When Scale(us)
When m_unit_system is ON::custom_unit_system,
Scale(us) = ON::UnitScale(us,ON::meters)*m_custom_unit_scale.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmUnitsAndTolerances.m_distance_display_precision">
            <value>
decimal mode: number of decimal places
fractional modes:
   denominator = (1/2)^m_distance_display_precision
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmUnitsAndTolerances.m_relative_tolerance">
            <value>
fraction &gt;= 0 and &lt; 1 (default = 1%)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmUnitsAndTolerances.m_angle_tolerance">
            <value>
in radians (default = 3 degrees)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmUnitsAndTolerances.m_absolute_tolerance">
            <value>
in units (default = 1/100)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmUnitsAndTolerances.m_unit_system">
            <value>
ON::unit_system m_unit_system;
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmProperties.m_Application">
            <value>
application that created 3DM file
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmProperties.m_PreviewImage">
            <value>
preview image of model
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmProperties.m_Application">
            <value>
application that created 3DM file
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmProperties.m_PreviewImage">
            <value>
preview image of model
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmApplication.m_application_details">
            <value>
whatever you want
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmApplication.m_application_URL">
            <value>
URL
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmApplication.m_application_name">
            <value>
short name like "Rhino 2.0"
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmApplication.m_application_details">
            <value>
whatever you want
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmApplication.m_application_URL">
            <value>
URL
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmApplication.m_application_name">
            <value>
short name like "Rhino 2.0"
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmNotes.m_window_left">
            <value>
last window position
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmNotes.m_bHTML">
            <value>
TRUE if notes are in HTML
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmNotes.m_bVisible">
            <value>
TRUE if notes window is showing
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmNotes.m_notes">
            <value>
UNICODE
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmNotes.m_window_left">
            <value>
last window position
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmNotes.m_bHTML">
            <value>
TRUE if notes are in HTML
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmNotes.m_bVisible">
            <value>
TRUE if notes window is showing
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmNotes.m_notes">
            <value>
UNICODE
</value>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmRevisionHistory.NewRevision">
            <summary>
returns updated revision count
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnInstanceRef.m_bbox">
            <value>
Bounding box for this reference.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnInstanceRef.m_xform">
            <value>
Transformation for this reference.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnInstanceRef.m_instance_definition_uuid">
            <value>
Unique id of the instance definition (ON_InstanceDefinition) 
in the instance definition table that defines the geometry
used by this reference.
</value>
        </member>
        <member name="T:RMA.OpenNURBS.OnInstanceRef">
            <summary>
An ON_InstanceRef is a reference to an instance definition
along with transformation to apply to the definition.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnInstanceRef.m_bbox">
            <value>
Bounding box for this reference.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnInstanceRef.m_xform">
            <value>
Transformation for this reference.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnInstanceRef.m_instance_definition_uuid">
            <value>
Unique id of the instance definition (ON_InstanceDefinition) 
in the instance definition table that defines the geometry
used by this reference.
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnInstanceRef">
            <summary>
An ON_InstanceRef is a reference to an instance definition
along with transformation to apply to the definition.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInstanceDefinition.SetUnitSystem(RMA.OpenNURBS.IOn.unit_system)">
            <summary>
Description: Sets m_us and m_unit_scale.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInstanceDefinition.SourceArchiveCheckSum">
            <summary>
Returns: Check sum of source archive.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInstanceDefinition.SourceArchive">
            <summary>
Returns: Name of source archive.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInstanceDefinition.SetSourceArchive(System.String,RMA.OpenNURBS.IOnCheckSum,RMA.OpenNURBS.IOnInstanceDefinition.IDEF_UPDATE_TYPE)">
            <summary>
If the instance definition is linked or embedded, use SetSource to specify the source archive.
</summary>
            <param name="source_archive">[in] name of source archive</param>
            <param name="checksum">[in] check sum used to detect changed</param>
            <param name="update_type">[in] See comments for ON_InstanceDefinition::IDEF_UPDATE_TYPE</param>
            <remarks>
In all cases, the complete instance definition geometry is stored in the 3dm archive.
When an instance definition is linked or embedded, applications can examine the source
archive settings and update the definition when appropriate. The checksum can be used
to detect changed files.
</remarks>
        </member>
        <member name="P:RMA.OpenNURBS.OnInstanceDefinition.m_source_archive_checksum">
            <value>
used to detect when idef is out of synch with source archive.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnInstanceDefinition.m_source_bRelativePath">
            <value>
True if the filename in m_source_archive is
a relative the location of the 3dm file
containing this instance definition.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnInstanceDefinition.m_source_archive">
            <value>
filename used to update idef (it can be empty or relative)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnInstanceDefinition.m_idef_update_depth">
            <value>
Controls how much geometry is read when
a linked idef is updated.
 0: read everything, included nested linked idefs
 1: skip nested linked idefs.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnInstanceDefinition.m_url_tag">
            <value>
UI link text for m_url
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnInstanceDefinition.m_description">
            <value>
It can be empty and duplicates
may exist. Instance reference use
m_uuid to find instance definitions.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnInstanceDefinition.m_name">
            <value>
The "name" is for human comfort.
It can be empty and duplicates may exist. Instance reference use
m_uuid to find instance definitions.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnInstanceDefinition.m_uuid">
            <value>
unique id for this instance definition
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnInstanceDefinition.m_object_uuid">
            <value>
list of object ids in the instance geometry table.
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInstanceDefinition.SourceArchiveCheckSum">
            <summary>
Returns: Check sum of source archive.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInstanceDefinition.SourceArchive">
            <summary>
Returns: Name of source archive.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnInstanceDefinition.m_source_archive_checksum">
            <value>
used to detect when idef is out of synch with source archive.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnInstanceDefinition.m_source_bRelativePath">
            <value>
True if the filename in m_source_archive is
a relative the location of the 3dm file
containing this instance definition.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnInstanceDefinition.m_source_archive">
            <value>
filename used to update idef (it can be empty or relative)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnInstanceDefinition.m_idef_update_depth">
            <value>
Controls how much geometry is read when
a linked idef is updated.
 0: read everything, included nested linked idefs
 1: skip nested linked idefs.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnInstanceDefinition.m_url_tag">
            <value>
UI link text for m_url
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnInstanceDefinition.m_description">
            <value>
It can be empty and duplicates
may exist. Instance reference use
m_uuid to find instance definitions.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnInstanceDefinition.m_name">
            <value>
The "name" is for human comfort.
It can be empty and duplicates may exist. Instance reference use
m_uuid to find instance definitions.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnInstanceDefinition.m_uuid">
            <value>
unique id for this instance definition
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnInstanceDefinition.m_object_uuid">
            <value>
list of object ids in the instance geometry table.
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnInstanceDefinition.IDEF_UPDATE_TYPE">
            <summary>
IDEF_UPDATE_TYPE lists the possible relationships between
the instance definition geometry and the archive 
(m_source_archive) containing the original defition.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnInstanceDefinition">
            <summary>
An ON_InstanceDefinition defines the geometry used by instance references.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnEmbeddedBitmap.m_biffer_crc32">
            <value>
32 bit crc from ON_CRC32
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnEmbeddedBitmap.m_free_buffer">
            <value>
1 = ~ON_EmbeddedBitmap will onfree m_buffer.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnEmbeddedBitmap.m_biffer_crc32">
            <value>
32 bit crc from ON_CRC32
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnEmbeddedBitmap.m_free_buffer">
            <value>
1 = ~ON_EmbeddedBitmap will onfree m_buffer.
</value>
        </member>
        <member name="T:RMA.OpenNURBS.OnWindowsBitmapEx">
            <summary>
ON_WindowsBitmapEx is identical to ON_WindowsBitmap except that
it's Read/Write functions save bitmap names.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnWindowsBitmapEx">
            <summary>
ON_WindowsBitmapEx is identical to ON_WindowsBitmap except that
it's Read/Write functions save bitmap names.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnWindowsBitmap.IsContiguous">
            <summary>
Description: Create an ON_WindowsBitmap from a contiguous bitmap. Copies src. Parameters: src - [in] contiguous Windows device independent bitmap. Remarks: If the current Windows BITMAPINFO is identical to ON_WindowsBITMAPINFO, then the result of this call is identical to int color_count = number of colors in bitmap's palette; ON_WindowsBitmap::Create( &amp;src, &amp;src.bmiColors[color_count], true ). See Also: ON_WindowsBitmap::Create
</summary>
            <summary>
Description: Create an ON_WindowsBitmap from a contiguous bitmap. Copies src. Parameters: src - [in] contiguous Windows device independent bitmap. See Also: ON_WindowsBitmap::Create
</summary>
            <summary>
True if m_bmi and m_bits are in a single contiguous block of memory.
False if m_bmi and m_bits are in two blocks of memory.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnWindowsBitmap.Pixel(System.Int32,System.Int32)">
            <param name="i">0 &lt;= i &lt; width</param>
            <param name="j">0 &lt;= j &lt; height</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnWindowsBitmap.SizeofPalette">
            <summary>
number of bytes in palette
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnWindowsBitmap.PaletteColorCount">
            <summary>
number of colors in palette
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnWindowsBitmap.Create(System.Int32,System.Int32,System.Int32)">
            <param name="bpp">bits per pixel ( 1, 2, 4, 8, 16, 24, or 32 )</param>
        </member>
        <member name="T:RMA.OpenNURBS.OnWindowsBitmap">
            <summary>
Uncompressed 8 bpp, 24 bpp, or 32 bpp Windows device 
independent bitmaps (DIB)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnWindowsBitmap.IsContiguous">
            <summary>
True if m_bmi and m_bits are in a single contiguous block of memory.
False if m_bmi and m_bits are in two blocks of memory.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnWindowsBitmap.Pixel(System.Int32,System.Int32)">
            <param name="i">0 &lt;= i &lt; width</param>
            <param name="j">0 &lt;= j &lt; height</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnWindowsBitmap.SizeofPalette">
            <summary>
number of bytes in palette
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnWindowsBitmap.PaletteColorCount">
            <summary>
number of colors in palette
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnWindowsBitmap">
            <summary>
Uncompressed 8 bpp, 24 bpp, or 32 bpp Windows device 
independent bitmaps (DIB)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBitmap.SizeofImage">
            <summary>size of current map in bytes</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBitmap.SizeofScan">
            <summary>number of bytes per scan line</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBitmap.Height">
            <summary>
&gt;0 means it's a bottom-up bitmap with origin at lower right
&lt;0 means it's a top-down bitmap with origin at upper left
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBitmap.m_ON_Bitmap_class_id">
            <value>
virtual base class for bitmap objects
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBitmap.m_bitmap_filename">
            <value>
full path to file
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBitmap.m_bitmap_name">
            <value>
descriptive name
</value>
        </member>
        <member name="T:RMA.OpenNURBS.OnBitmap">
            <summary>
virtual base class for bitmap objects
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBitmap.SizeofImage">
            <summary>size of current map in bytes</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBitmap.SizeofScan">
            <summary>number of bytes per scan line</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBitmap.BitsPerPixel">
            <summary>
&lt;0 means it's a top-down bitmap with origin at upper left
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBitmap.Height">
            <summary>
&gt;0 means it's a bottom-up bitmap with origin at lower right
&lt;0 means it's a top-down bitmap with origin at upper left
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBitmap.m_bitmap_filename">
            <value>
full path to file
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBitmap.m_bitmap_name">
            <value>
descriptive name
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnBitmap">
            <summary>
virtual base class for bitmap objects
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Clear_user_i">
            <summary>
zero all brep's m_*_user values
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Clear_face_user_i">
            <summary>
zero all brep's m_face_user values
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Clear_loop_user_i">
            <summary>
zero all brep's m_loop_user values
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Clear_trim_user_i">
            <summary>
zero all brep's m_trim_user values
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Clear_edge_user_i">
            <summary>
zero all brep's m_edge_user values
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Clear_edge_user_i(System.Int32)">
            <summary>
zero all brep's m_edge_user values
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Clear_vertex_user_i">
            <summary>
set every brep m_*_user value to u
</summary>
            <summary>
zero all brep's m_vertex_user values
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.RemoveWireVertices">
            <summary>Remove vertices that are not connected to an edge.</summary>
            <returns>Number of vertices that were deleted.</returns>
            <remarks>
After you finish cleaning up the brep, you need to call ON_Brep::Compact()
to remove deleted vertices from the m_V[] array.
See Also: ON_Brep::RemoveWireEdges
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.RemoveWireEdges">
            <summary>Remove edges that are not connected to a face.</summary>
            <returns>Number of edges that were removed.</returns>
            <remarks>
After you finish cleaning up the brep, you need to call ON_Brep::Compact()
to remove unused edge, trim, and vertex information from the brep's m_E[],
m_V[], m_T[], m_C2[], and m_C3[] arrays.

If you want to remove wire edges and wiere After you finish cleaning up the brep,
you need to call ON_Brep::Compact() to remove deleted vertices from the m_V[] array.
See Also: ON_Brep::RemoveWireVertices
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.RemoveWireEdges(System.Boolean)">
            <summary>Remove edges that are not connected to a face.</summary>
            <param name="bDeleteVertices">
[in] if true, then the vertices at the ends of the wire edges are deleted
if they are not connected to face trimming edges.
</param>
            <returns>Number of edges that were removed.</returns>
            <remarks>
After you finish cleaning up the brep, you need to call ON_Brep::Compact()
to remove unused edge, trim, and vertex information from the brep's m_E[],
m_V[], m_T[], m_C2[], and m_C3[] arrays. Remarks: If you want to remove wire
edges and wiere After you finish cleaning up the brep, you need to call
ON_Brep::Compact() to remove deleted vertices from the m_V[] array.
See Also: ON_Brep::RemoveWireVertices
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.CloseTrimGap(RMA.OpenNURBS.OnBrepTrim@,RMA.OpenNURBS.OnBrepTrim@)">
            <summary>Expert user tool to remove any gap between adjacent trims.</summary>
            <param name="trim0">[in]</param>
            <param name="trim1">[in]</param>
            <returns>True if successful.</returns>
            <remarks>
The trims must be in the same trimming loop. The vertex at the end of teim0 must
be the same as the vertex at the start of trim1. The trim's m_iso and m_type
flags need to be correctly set.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.ChangeVertex(System.Int32,System.Int32,System.Boolean)">
            <summary>Expert user tool to move trims and edges from one vertex to another.</summary>
            <param name="old_vi">[in] index of old vertex</param>
            <param name="new_vi">[in] index of new vertex</param>
            <param name="bClearTolerances">
[in] if true, then tolerances of edges and trims that are connected ot the old
vertex are set to ON_UNSET_VALUE. vertex_index - [in] if &gt;= 0, this the edge
is collapsed to this vertex. Otherwise a vertex is automatically selected or created.
</param>
            <returns>True if successful.</returns>
            <remarks>
After you finish cleaning up the brep, you need to call ON_Brep::Compact()
to remove unused edge, trim, and vertex information from the brep's m_E[],
m_V[], m_T[], m_C2[], and m_C3[] arrays.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.CollapseEdge(System.Int32)">
            <summary>
Expert user tool to collapse a "short" edge to a vertex. The edge is
removed and the topology is repaired so that everything that used to connect to
the edge connects the specified vertex.
</summary>
            <param name="edge_index">[in] index of edge to remove</param>
            <returns>True if edge was successfully collapsed.</returns>
            <remarks>
After you finish cleaning up the brep, you need to call ON_Brep::Compact()
to remove unused edge, trim, and vertex information from the brep's m_E[],
m_V[], m_T[], m_C2[], and m_C3[] arrays.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.CollapseEdge(System.Int32,System.Boolean)">
            <summary>
Expert user tool to collapse a "short" edge to a vertex. The edge is
removed and the topology is repaired so that everything that used to connect to
the edge connects the specified vertex.
</summary>
            <param name="edge_index">[in] index of edge to remove</param>
            <param name="bCloseTrimGap">
[in] if true and the removal of the edge creates a gap in the parameter space trimming loop,
then the 2d trim curves will be adjusted to close the gap.
</param>
            <returns>True if edge was successfully collapsed.</returns>
            <remarks>
After you finish cleaning up the brep, you need to call ON_Brep::Compact()
to remove unused edge, trim, and vertex information from the brep's m_E[],
m_V[], m_T[], m_C2[], and m_C3[] arrays.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.CollapseEdge(System.Int32,System.Boolean,System.Int32)">
            <summary>
Expert user tool to collapse a "short" edge to a vertex. The edge is
removed and the topology is repaired so that everything that used to connect to
the edge connects the specified vertex.
</summary>
            <param name="edge_index">[in] index of edge to remove</param>
            <param name="bCloseTrimGap">
[in] if true and the removal of the edge creates a gap in the parameter space trimming loop,
then the 2d trim curves will be adjusted to close the gap.
</param>
            <param name="vertex_index">
[in] if &gt;= 0, this the edge is collapsed to this vertex. Otherwise a vertex is
automatically selected or created.
</param>
            <returns>True if edge was successfully collapsed.</returns>
            <remarks>
After you finish cleaning up the brep, you need to call ON_Brep::Compact()
to remove unused edge, trim, and vertex information from the brep's m_E[],
m_V[], m_T[], m_C2[], and m_C3[] arrays.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.RemoveNesting(System.Boolean)">
            <summary>
Removes nested polycurves from the m_C2[] and m_C3[] arrays.
</summary>
            <param name="bExtractSingleSegments">
[in] if true, polycurves with a single segment are replaced with the segment curve.
</param>
            <returns>True if any nesting was removed and false if no nesting was removed.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.RemoveNesting(System.Boolean,System.Boolean)">
            <summary>
Removes nested polycurves from the m_C2[] and m_C3[] arrays.
</summary>
            <param name="bExtractSingleSegments">
[in] if true, polycurves with a single segment are replaced with the segment curve.
</param>
            <param name="bEdges">[in] if true, the m_C3[] array is processed</param>
            <returns>True if any nesting was removed and false if no nesting was removed.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.RemoveNesting(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
Removes nested polycurves from the m_C2[] and m_C3[] arrays.
</summary>
            <param name="bExtractSingleSegments">
[in] if true, polycurves with a single segment are replaced with the segment curve.
</param>
            <param name="bEdges">[in] if true, the m_C3[] array is processed</param>
            <param name="bTrimCurves">[in] if true, the m_C2[] array is processed.</param>
            <returns>True if any nesting was removed and false if no nesting was removed.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.RemoveSlits(RMA.OpenNURBS.OnBrepFace@)">
            <summary>remove slit trims and slit boundaries from a face</summary>
            <param name="F">[in] brep face</param>
            <returns>true if any slits were removed</returns>
            <remarks>Caller should call Compact() when done.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.RemoveSlits">
            <summary>remove slit trims and slit boundaries from each face</summary>
            <returns>true if any slits were removed</returns>
            <remarks>Caller should call Compact() afterwards.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Face(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary> Get face from face index or component index.</summary>
            <param name="face_index">[in] either an index into m_F[] or a component index of type brep_face.</param>
            <returns>
If the index is a valid face index or a valid face component index,
then a pointer to the ON_BrepFace is returned. Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepFace&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Face(System.Int32)">
            <summary> Get face from face index or component index.</summary>
            <param name="face_index">[in] either an index into m_F[] or a component index of type brep_face.</param>
            <returns>
If the index is a valid face index or a valid face component index,
then a pointer to the ON_BrepFace is returned. Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepFace&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Loop(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get loop from loop index or component index.</summary>
            <param name="loop_index">[in] either an index into m_L[] or a component index of type brep_loop.</param>
            <returns>
If the index is a valid loop index or a valid loop component index,
then a pointer to the ON_BrepLoop is returned. Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepLoop&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Loop(System.Int32)">
            <summary>Get loop from loop index or component index.</summary>
            <param name="loop_index">[in] either an index into m_L[] or a component index of type brep_loop.</param>
            <returns>
If the index is a valid loop index or a valid loop component index,
then a pointer to the ON_BrepLoop is returned. Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepLoop&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Trim(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get trim from trim index or component index.</summary>
            <param name="trim_index">[in] either an index into m_T[] or a component index of type brep_trim.</param>
            <returns>
If the index is a valid trim index or a valid trim component index,
then a pointer to the ON_BrepTrim is returned. Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepTrim&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Trim(System.Int32)">
            <summary>Get trim from trim index or component index.</summary>
            <param name="trim_index">[in] either an index into m_T[] or a component index of type brep_trim.</param>
            <returns>
If the index is a valid trim index or a valid trim component index,
then a pointer to the ON_BrepTrim is returned. Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepTrim&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Edge(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get trim from edge index or component index.</summary>
            <param name="edge_index">[in] either an index into m_E[] or a component index of type brep_edge.</param>
            <returns>
If the index is a valid edge index or a valid edge component index,
then a pointer to the ON_BrepEdge is returned.
Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepEdge&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Edge(System.Int32)">
            <summary>Get trim from edge index or component index.</summary>
            <param name="edge_index">[in] either an index into m_E[] or a component index of type brep_edge.</param>
            <returns>
If the index is a valid edge index or a valid edge component index,
then a pointer to the ON_BrepEdge is returned.
Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepEdge&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Vertex(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get vertex from trim index or component index</summary>
            <param name="vertex_index">[in] either an index into m_V[] or a component index of type brep_vertex.</param>
            <returns>
If the index is a valid vertex index or a valid vertex component index,
then a pointer to the ON_BrepVertex is returned. Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepVertex&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Vertex(System.Int32)">
            <summary>Get vertex from trim index or component index</summary>
            <param name="vertex_index">[in] either an index into m_V[] or a component index of type brep_vertex.</param>
            <returns>
If the index is a valid vertex index or a valid vertex component index,
then a pointer to the ON_BrepVertex is returned. Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepVertex&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.BrepComponent(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get a brep component from its index.</summary>
            <param name="component_index">[in]</param>
            <returns>
A const pointer to the component. Do not delete the returned object.
It points to an object managed by this brep.
</returns>
            <remarks>
See Also:
ON_Brep::Face
ON_Brep::Edge
ON_Brep::Loop
ON_Brep::Trim 
ON_Brep::Vertex
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NextEdge(System.Int32,System.Int32)">
            <summary>
This is a simple tool for getting running through the edges that begin and end at a vertex.
</summary>
            <param name="current_edge_index">[in]</param>
            <param name="endi">[in] 0 = use the edge start vertex, 1 = use the edge end vertex</param>
            <returns>
edge index of the next edge or -1 if there is only one edge that begins or ends at the vertex.
</returns>
            <remarks>
This is a tool that simplifies searching through the ON_BrepVertex.m_ei[] array.
The edges are in no particular order.
See Also: ON_Brep::NextEdge
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NextEdge(System.Int32,System.Int32,System.Int32@)">
            <summary>
This is a simple tool for getting running through the edges that begin and end at a vertex.
</summary>
            <param name="current_edge_index">[in]</param>
            <param name="endi">[in] 0 = use the edge start vertex, 1 = use the edge end vertex</param>
            <param name="next_endi">
[out] 0 if next edge begins at the vertex, 1 if next edge ends at the vertex
</param>
            <returns>
edge index of the next edge or -1 if there is only one edge that begins or ends at the vertex.
</returns>
            <remarks>
This is a tool that simplifies searching through the ON_BrepVertex.m_ei[] array.
The edges are in no particular order.
See Also: ON_Brep::NextEdge
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.PrevEdge(System.Int32,System.Int32)">
            <summary>
This is a simple tool for getting running through the edges that begin and end at a vertex.
</summary>
            <param name="current_edge_index">[in]</param>
            <param name="endi">[in] 0 = use the edge start vertex, 1 = use the edge end vertex</param>
            <returns>
edge index of the previous edge or -1 if there is only one edge that begins or ends at the vertex.
</returns>
            <remarks>
This is a tool that simplifies searching through the ON_BrepVertex.m_ei[] array.
The edges are in no particular order.
See Also: ON_Brep::NextEdge
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.PrevEdge(System.Int32,System.Int32,System.Int32@)">
            <summary>
This is a simple tool for getting running through the edges that begin and end at a vertex.
</summary>
            <param name="current_edge_index">[in]</param>
            <param name="endi">[in] 0 = use the edge start vertex, 1 = use the edge end vertex</param>
            <param name="prev_endi">
[out] 0 if previous edge begins at the vertex, 1 if previous edge ends at the vertex
</param>
            <returns>
edge index of the previous edge or -1 if there is only one edge that begins or ends at the vertex.
</returns>
            <remarks>
This is a tool that simplifies searching through the ON_BrepVertex.m_ei[] array.
The edges are in no particular order.
See Also: ON_Brep::NextEdge
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NextTrim(System.Int32)">
            <summary>
for moving around loops - returns trim index of next trim in loop
</summary>
            <param name="index">index of current trim (m_trim_index)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.PrevTrim(System.Int32)">
            <summary>
for moving around loops - returns trim index of prev trim in loop
</summary>
            <param name="index">index of current trim (m_trim_index)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.CullUnusedSurfaces">
            <summary>
culls surfaces not referenced by a face
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.CullUnused2dCurves">
            <summary>
culls 3d curves not referenced by an edge
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.CullUnused3dCurves">
            <summary>
culls 2d curves not referenced by a trim
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.CullUnusedVertices">
            <summary>
culls vertices with m_vertex_index == -1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.CullUnusedEdges">
            <summary>
culls edges with m_edge_index == -1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.CullUnusedTrims">
            <summary>
culls trims with m_trim_index == -1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.CullUnusedLoops">
            <summary>
culls loops with m_loop_index == -1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.CullUnusedFaces">
            <summary>
culls faces with m_face_index == -1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Compact">
            <summary>
Uses the CullUnused*() members to delete any unreferenced objects from arrays,
reindexes as needed, and shrinks arrays to minimum required size.
</summary>
            <remarks>
See Also:
ON_Brep::CullUnusedFaces
ON_Brep::CullUnusedLoops
ON_Brep::CullUnusedTrims 
ON_Brep::CullUnusedEdges
ON_Brep::CullUnusedVertices
ON_Brep::CullUnused3dCurves
ON_Brep::CullUnused2dCurves 
ON_Brep::CullUnusedSurfaces
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.ShrinkSurfaces">
            <summary>
Sometimes the ON_Surface used by a face extends far beyond the face's outer boundary.
ShrinkSurfaces calls ON_Shrink::ShrinkSurface on each face to remove portions of surfaces
that extend beyond their face's outer boundary loop.
</summary>
            <returns>
true successful
false failure
</returns>
            <remarks>
If a surface needs to be shrunk it is copied. After shrinking, you may want
to call ON_Brep::CullUnusedSurfaces to remove any unused surfaces.
See Also: ON_Brep::ShrinkSurface ON_Brep::CullUnusedSurfaces
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.ShrinkSurface(RMA.OpenNURBS.OnBrepFace@)">
            <summary>
Sometimes the ON_Surface used by a face extends far beyond the face's outer boundary.
ShrinkSurface uses ON_Surface::Trim to remove portions of the surface that extend beyond
the face's outer boundary loop.
</summary>
            <param name="face">[in] face to test and whose surface should be shrunk.</param>
            <returns>
true successful
false failure
</returns>
            <remarks>
If a surface needs to be shrunk it is copied. After shrinking, you may want
to call ON_Brep::CullUnusedSurfaces to remove any unused surfaces.
See Also: ON_Brep::ShrinkSurfaces ON_Brep::CullUnusedSurfaces
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.ShrinkSurface(RMA.OpenNURBS.OnBrepFace@,System.Int32)">
            <summary>
Sometimes the ON_Surface used by a face extends far beyond the face's outer boundary.
ShrinkSurface uses ON_Surface::Trim to remove portions of the surface that extend beyond
the face's outer boundary loop.
</summary>
            <param name="face">[in] face to test and whose surface should be shrunk.</param>
            <param name="DisableSide">
[in] This is a bit field. A set bit indicates not to shrink the surface on a given side.
The default of 0 enables shrinking on all four sides.
value  meaning
0x0001 Dont shrink on the west side of domain.
0x0002 Dont shrink on the south side of domain.
0x0004 Dont shrink on the east side of domain.
0x0008 Dont shrink on the north side of domain.
</param>
            <returns>
true successful
false failure
</returns>
            <remarks>
If a surface needs to be shrunk it is copied. After shrinking, you may want
to call ON_Brep::CullUnusedSurfaces to remove any unused surfaces.
See Also: ON_Brep::ShrinkSurfaces ON_Brep::CullUnusedSurfaces
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Standardize">
            <summary>Standardize all trims, edges, and faces in the brep.</summary>
            <remarks>
After standardizing, there may be unused curves and surfaces in the brep.
Call ON_Brep::Compact to remove these unused curves and surfaces.
See Also:
ON_Brep::StandardizeTrimCurves
ON_Brep::StandardizeEdgeCurves
ON_Brep::StandardizeFaceSurface
ON_Brep::Compact
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.StardardizeFaceSurfaces">
            <summary>
Standardize all faces in the brep.
See Also: ON_Brep::StandardizeFaceSurface ON_Brep::Standardize
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.StandardizeFaceSurface(System.Int32)">
            <summary>
Standardizes the relationship between an ON_BrepFace and the 3d surface it uses.
When done, the face will be the only face that references its 3d surface,
and the orientations of the face and 3d surface will be the same.
</summary>
            <param name="face_index">[in] index of face to standardize.</param>
            <remarks>See Also: ON_Brep::StardardizeFaceSurfaces ON_Brep::Standardize</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.StandardizeTrimCurves">
            <summary>
Standardize all trims in the brep.
See Also: ON_Brep::StandardizeTrimCurve ON_Brep::Standardize
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.StandardizeTrimCurve(System.Int32)">
            <summary>
Standardizes the relationship between an ON_BrepTrim and the 2d curve it uses.
When done, the trim will be the only trim that references its 2d curve,
the domains of the trim and 2d curve will be the same, and the trim will use
the entire locus of the 2d curve.
</summary>
            <param name="trim_index">[in] index of trim to standardize.</param>
            <remarks>
See Also: ON_Brep::StandardizeTrimCurves ON_Brep::Standardize
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.StandardizeEdgeCurves(System.Boolean)">
            <summary>Standardize all edges in the brep.</summary>
            <param name="bAdjustEnds">[in] if true, move edge curve endpoints to vertices</param>
            <remarks>See Also: ON_Brep::StandardizeEdgeCurve ON_Brep::Standardize</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.StandardizeEdgeCurve(System.Int32,System.Boolean)">
            <summary>
Standardizes the relationship between an ON_BrepEdge and the 3d curve it uses.
When done, the edge will be the only edge that references its 3d curve, the domains
of the edge and 3d curve will be the same, and the edge will use the entire locus
of the 3d curve.
</summary>
            <param name="edge_index">[in] index of edge to standardize.</param>
            <param name="bAdjustEnds">[in] if true, move edge curve endpoints to vertices</param>
            <remarks>See Also: ON_Brep::StandardizeEdgeCurves ON_Brep::Standardize</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.ExtractFace(System.Int32)">
            <summary>Extract a face from a brep.</summary>
            <param name="face_index">[in] index of face to extract</param>
            <returns>Single face brep.</returns>
            <remarks>
See Also: ON_Brep::DeleteFace, ON_Brep::DuplicateFace
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.DuplicateFaces(System.Int32[],System.Boolean)">
            <summary>Duplicate a a subset of a brep</summary>
            <param name="face_index">[in] array of face indices</param>
            <param name="bDuplicateMeshes">[in] if true, any attached meshes are duplicated</param>
            <returns>A brep made by duplicating the faces listed in the face_index[] array.</returns>
            <remarks>
The m_vertex_user.i, m_edge_user.i, m_face_user.i, m_loop_user.i,
and m_trim_user.i values of the returned brep are are set to the 
indices of the objects they duplicate.
See Also:
ON_Brep::DuplicateFace
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.DuplicateFace(System.Int32,System.Boolean)">
            <summary>Duplicate a single brep face.</summary>
            <param name="face_index">[in] index of face to duplicate</param>
            <param name="bDuplicateMeshes">[in] if true, any attached meshes are duplicated</param>
            <returns>Single face brep.</returns>
            <remarks>
The m_vertex_user.i, m_edge_user.i, m_face_user.i, m_loop_user.i,
and m_trim_user.i values of the returned brep are are set to the 
indices of the objects they duplicate.
See Also:
ON_Brep::DeleteFace, ON_Brep::ExtractFace
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.RegionTopology">
            <summary>
Get region topology information:
In order to keep the ON_Brep class efficient, rarely used
region topology information is not maintained.  If you 
require this information, call RegionTopology().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SubBrep(System.Int32[],RMA.OpenNURBS.OnBrep)">
            <summary>Copy a subset of this brep.</summary>
            <param name="sub_fi">
[in] array of face indices in this brep to copy. (If any values in sub_fi[]
are out of range or if sub_fi[] contains duplicates, this function will return null.)
</param>
            <param name="sub_brep">
[in] if this pointer is not null, then the subbrep will be created in this class.
</param>
            <returns>
If the input is valid, a pointer to the subbrep is returned.
If the input is not valid, null is returned.  The faces in
in the subbrep's m_F array are in the same
order as they were specified in sub_fi[].
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.GetConnectedComponents(RMA.OpenNURBS.OnBrep[]@,System.Boolean)">
            <summary>
If this brep has two or more connected components,
then duplicates of the connected components are appended to the components[] array.
</summary>
            <param name="components">[in] connected components are appended to this array.</param>
            <param name="bDuplicateMeshes">[in] if true, any meshes on this brep are copied to the output breps.</param>
            <returns>
Number of connected components appended to components[] or
zero if this brep has only one connected component.
See Also: ON_Brep::GetConnectedComponents
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.LabelConnectedComponents">
            <summary>
Set m_vertex_user.i, m_edge_user.i, m_face_user.i, m_loop_user.i, and m_trim_user.i
values values to distinguish connected components.
</summary>
            <returns>number of connected components</returns>
            <remarks>
For each face in the ith component, sets m_face_user.i to i&gt;0.
Chases through trim lists of face edges to find adjacent faces.
Numbering starts at 1. Does NOT check for vertex-vertex connections.
See Also: ON_Brep::GetConnectedComponents
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.LabelConnectedComponent(System.Int32,System.Int32)">
            <summary>
Set m_vertex_user.i, m_edge_user.i, m_face_user.i, m_loop_user.i,
and m_trim_user.i values of faces of component including
m_F[face_index] to label. Numbering starts at 1.
</summary>
            <param name="face_index">[in] index of face in component</param>
            <param name="label">[in] value for m_*_user.i</param>
            <remarks>
Chases through trim lists of face edges to find adjacent faces.
Does NOT check for vertex-vertex connections
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Delete3dCurve(System.Int32)">
            <summary>
These remove a topology piece from a b-rep but do not
rearrange the arrays that hold the brep objects.  The
deleted objects have their indices set to -1.  Deleting
an object that is connected to other objects will 
modify thos objects.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Delete2dCurve(System.Int32)">
            <summary>
These remove a topology piece from a b-rep but do not
rearrange the arrays that hold the brep objects.  The
deleted objects have their indices set to -1.  Deleting
an object that is connected to other objects will 
modify thos objects.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.DeleteSurface(System.Int32)">
            <summary>
These remove a topology piece from a b-rep but do not
rearrange the arrays that hold the brep objects.  The
deleted objects have their indices set to -1.  Deleting
an object that is connected to other objects will 
modify thos objects.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.DeleteFace(RMA.OpenNURBS.OnBrepFace@,System.Boolean)">
            <summary>
These remove a topology piece from a b-rep but do not
rearrange the arrays that hold the brep objects.  The
deleted objects have their indices set to -1.  Deleting
an object that is connected to other objects will 
modify thos objects.

pass true to delete edges and vertices used only by face
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.DeleteLoop(RMA.OpenNURBS.OnBrepLoop@,System.Boolean)">
            <summary>
These remove a topology piece from a b-rep but do not
rearrange the arrays that hold the brep objects.  The
deleted objects have their indices set to -1.  Deleting
an object that is connected to other objects will 
modify thos objects.

pass true to delete edges and vertices used only by trim
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.DeleteTrim(RMA.OpenNURBS.OnBrepTrim@,System.Boolean)">
            <summary>
These remove a topology piece from a b-rep but do not
rearrange the arrays that hold the brep objects.  The
deleted objects have their indices set to -1.  Deleting
an object that is connected to other objects will 
modify thos objects.

pass true to delete edges and vertices used only by trim
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.DeleteEdge(RMA.OpenNURBS.OnBrepEdge@,System.Boolean)">
            <summary>
These remove a topology piece from a b-rep but do not
rearrange the arrays that hold the brep objects.  The
deleted objects have their indices set to -1.  Deleting
an object that is connected to other objects will 
modify thos objects.

pass true to delete vertices used only by edge
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.DeleteVertex(RMA.OpenNURBS.OnBrepVertex@)">
            <summary>
These remove a topology piece from a b-rep but do not
rearrange the arrays that hold the brep objects.  The
deleted objects have their indices set to -1.  Deleting
an object that is connected to other objects will 
modify thos objects.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SplitBipolarFaces">
            <summary>
Splits surfaces with two singularities, like spheres, so the results have at most one singularity.
</summary>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SplitClosedFaces">
            <summary>Splits closed surfaces so they are not closed.</summary>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SplitClosedFaces(System.Int32)">
            <summary>Splits closed surfaces so they are not closed.</summary>
            <param name="min_degree">
[in] If the degree of the surface &lt; min_degree, the surface is not split.
In some cases, min_degree = 2 is useful to preserve piecewise linear surfaces.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SplitEdge(System.Int32,System.Double,RMA.OpenNURBS.IArraydouble)">
            <summary>
Expert user function. Splits an edge into two edges.
The input edge becomes the left portion and a new edge is created for the right portion.
</summary>
            <param name="edge_index">[in] index of edge in brep.m_E[]</param>
            <param name="edge_t">[in] 3d edge splitting parameter</param>
            <param name="trim_t">
[in] array of trim splitting parameters. trim_t[eti] is the parameter for
splitting the trim brep.m_T[edge.m_ti[eti]].
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SplitEdge(System.Int32,System.Double,RMA.OpenNURBS.IArraydouble,System.Int32)">
            <summary>
Expert user function. Splits an edge into two edges.
The input edge becomes the left portion and a new edge is created for the right portion.
</summary>
            <param name="edge_index">[in] index of edge in brep.m_E[]</param>
            <param name="edge_t">[in] 3d edge splitting parameter</param>
            <param name="trim_t">
[in] array of trim splitting parameters. trim_t[eti] is the parameter for
splitting the trim brep.m_T[edge.m_ti[eti]].
</param>
            <param name="vertex_index">
[in] if not -1, then this vertex will be used for the new vertex.
Otherwise a new vertex is created.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SplitEdge(System.Int32,System.Double,RMA.OpenNURBS.IArraydouble,System.Int32,System.Boolean)">
            <summary>
Expert user function. Splits an edge into two edges.
The input edge becomes the left portion and a new edge is created for the right portion.
</summary>
            <param name="edge_index">[in] index of edge in brep.m_E[]</param>
            <param name="edge_t">[in] 3d edge splitting parameter</param>
            <param name="trim_t">
[in] array of trim splitting parameters. trim_t[eti] is the parameter for
splitting the trim brep.m_T[edge.m_ti[eti]].
</param>
            <param name="vertex_index">
[in] if not -1, then this vertex will be used for the new vertex.
Otherwise a new vertex is created.
</param>
            <param name="bSetTrimBoxesAndFlags">
[in] if true, trim boxes and flags are set.
If false, the user is responsible for doing this.
Set to true if you are unsure what to use.
If you pass false, then need to call SetTrimBoundingBoxes(..,bLazy=true) so
that the trim iso flags and bounding info is correctly updated.
If you pass true, then the trim flags and bounding boxes get set inside of SplitEdge.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.GetEdgeParameter(System.Int32,System.Double,System.Double@)">
            <summary>
Given a trim and parameter on the 2d trim curve, get the corresponding parameter on the 3d edge curve.
</summary>
            <param name="trim_index">[in] index of trim in m_T array</param>
            <param name="trim_t">[in] parameter on 2d trim curve</param>
            <param name="edge_t">[out] parameter on 3d edge</param>
            <returns>
TRUE successful
FALSE failure - edge_t not set
See Also: TL_Brep::GetTrimParameter
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.GetTrimParameter(System.Int32,System.Double,System.Double@)">
            <summary>
Given a trim and parameter on the corresponding 3d edge, get the corresponding parameter on the 2d trim curve.
</summary>
            <param name="trim_index">[in] index of trim in m_T array</param>
            <param name="edge_t">[in] parameter on 3d edge</param>
            <param name="trim_t">[out] parameter on 2d trim curve</param>
            <returns>
TRUE successful
FALSE failure - trim_t not set
See Also: TL_Brep::GetEdgeParameter
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.GetTrimParameter(System.Int32,System.Double,System.Double@,System.Boolean)">
            <summary>
Given a trim and parameter on the corresponding 3d edge, get the corresponding parameter on the 2d trim curve.
</summary>
            <param name="trim_index">[in] index of trim in m_T array</param>
            <param name="edge_t">[in] parameter on 3d edge</param>
            <param name="trim_t">[out] parameter on 2d trim curve</param>
            <param name="bOkToBuildTrimPline">
[in] if TRUE and m_T[trim_index].m_pline[] does not have its edge parameters set,
then they are filled in. This is slow the first time, but greatly increases the
speed of GetTrimParameter and GetEdgeParameter on subsequent calls.
</param>
            <returns>
TRUE successful
FALSE failure - trim_t not set
See Also: TL_Brep::GetEdgeParameter
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.CombineContiguousEdges(System.Int32,System.Int32)">
            <summary>
Expert user function. Combines contiguous edges into a single edge.
The edges must share a common vertex, then angle between the edge
tangents are the common vertex must be less than or equal to angle_tolerance_radians,
and any associated trims must be contiguous in there respective boundaries.
</summary>
            <param name="edge_index0">[in]</param>
            <param name="edge_index1">[in]</param>
            <returns>Pointer to the new edge or NULL if the edges cannot be combined into a single edge.</returns>
            <remarks>
The input edges are deleted but are still in the brep's m_E[] arrays.
Use ON_Brep::Compact to remove the unused edges.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.CombineContiguousEdges(System.Int32,System.Int32,System.Double)">
            <summary>
Expert user function. Combines contiguous edges into a single edge.
The edges must share a common vertex, then angle between the edge
tangents are the common vertex must be less than or equal to angle_tolerance_radians,
and any associated trims must be contiguous in there respective boundaries.
</summary>
            <param name="edge_index0">[in]</param>
            <param name="edge_index1">[in]</param>
            <param name="angle_tolerance_radians">[in]</param>
            <returns>Pointer to the new edge or NULL if the edges cannot be combined into a single edge.</returns>
            <remarks>
The input edges are deleted but are still in the brep's m_E[] arrays.
Use ON_Brep::Compact to remove the unused edges.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.CombineCoincidentEdges(RMA.OpenNURBS.OnBrepEdge@,RMA.OpenNURBS.OnBrepEdge@)">
            <summary>
Expert user function. See Also: ON_Brep::JoinEdges
moves information to first edge and deletes second
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.CombineCoincidentVertices(RMA.OpenNURBS.OnBrepVertex@,RMA.OpenNURBS.OnBrepVertex@)">
            <summary>
Expert user function. See Also: ON_Brep::JoinEdges
moves information to first vertex and deletes second
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.JoinEdges(RMA.OpenNURBS.OnBrepEdge@,RMA.OpenNURBS.OnBrepEdge@,System.Double)">
            <summary>Join coincident edges.</summary>
            <param name="edge">
[in] this edge will survive the joining process and the vertices at
its ends will survive the joining process.
</param>
            <param name="other_edge">[in] this edge and the vertices at its ends will be removed.</param>
            <param name="join_tolerance">
[in] The distances between the ends of edge and other_edge must be at most
join_tolerance in order for the edges to be joined. The caller is responsible
for insuring that the 3d location of other_edge is within join_tolerance of edge.
</param>
            <returns>true if join is successful</returns>
            <example>
extrude an edge of a brep to make a new face
NOTE WELL:
THIS IS A SIMPLE EXAMPLE THAT IS NOT VERY EFFICIENT
Use ON_BrepExtrudeEdge if you really want to extrude an edge.
ON_Brep brep = ...;
edge = some valid edge in brep
const ON_BrepEdge&amp; edge = brep.m_E[...];
extrude edge to make a surface
ON_3dVector v = ...;
ON_SumSurface* new_surface = new ON_SumSurface();
new_surface-&gt;Create( edge, v );
ON_Brep new_brep;
new_brep.AddFace( Create( new_surface );
brep.
See Also: ON_Brep:CullUnusedEdges ON_Brep:CullUnusedVertices ON_Brep:CullUnused3dCurves
</example>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.JoinEdges(RMA.OpenNURBS.OnBrepEdge@,RMA.OpenNURBS.OnBrepEdge@,System.Double,System.Boolean)">
            <summary>Join coincident edges.</summary>
            <param name="edge">
[in] this edge will survive the joining process and the vertices at
its ends will survive the joining process.
</param>
            <param name="other_edge">[in] this edge and the vertices at its ends will be removed.</param>
            <param name="join_tolerance">
[in] The distances between the ends of edge and other_edge must be at most
join_tolerance in order for the edges to be joined. The caller is responsible
for insuring that the 3d location of other_edge is within join_tolerance of edge.
</param>
            <param name="bCheckFaceOrientaion">
[in] If true and edge and other_edge are boundary edges, then the orientation of
the face using other_edge is adjusted to match the orientation of the face using edge.
</param>
            <returns>true if join is successful</returns>
            <example>
extrude an edge of a brep to make a new face
NOTE WELL:
THIS IS A SIMPLE EXAMPLE THAT IS NOT VERY EFFICIENT
Use ON_BrepExtrudeEdge if you really want to extrude an edge.
ON_Brep brep = ...;
edge = some valid edge in brep
const ON_BrepEdge&amp; edge = brep.m_E[...];
extrude edge to make a surface
ON_3dVector v = ...;
ON_SumSurface* new_surface = new ON_SumSurface();
new_surface-&gt;Create( edge, v );
ON_Brep new_brep;
new_brep.AddFace( Create( new_surface );
brep.
See Also: ON_Brep:CullUnusedEdges ON_Brep:CullUnusedVertices ON_Brep:CullUnused3dCurves
</example>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.RebuildEdges(RMA.OpenNURBS.OnBrepFace@,System.Double,System.Boolean,System.Boolean)">
            <summary>
Rebuild the edges used by a face so they lie on the surface.
</summary>
            <param name="face">[in] face whose surface should be changed</param>
            <param name="tolerance">[in] tolerance for fitting 3d edge curves</param>
            <param name="bRebuildSharedEdges">
[in] if false and and edge is used by this face and a neighbor, then the edge will be skipped.
</param>
            <param name="bRebuildVertices">[in] if true, vertex locations are updated to lie on the surface.</param>
            <remarks>See Also: ON_Brep::RebuildEdges</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SortFaceLoops(RMA.OpenNURBS.OnBrepFace@)">
            <summary>
Sort the face.m_li[] array by loop type (outer, inner, slit, crvonsrf, ptonsrf)
</summary>
            <param name="face">[in/out] face whose m_li[] array should be sorted.</param>
            <returns>
true success
false failure - no loops or loops with unset loop.m_type
See Also: ON_Brep::ComputeLoopType ON_Brep::LoopDirection
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.LoopDirection(RMA.OpenNURBS.IOnBrepLoop)">
            <summary>
LoopDirection() examines the 2d trimming curve geometry that defines
the loop and returns
 +1    the loop is a counter-clockwise loop.
 -1    the loop is a clockwise loop.
  0    the loop is not a continuous closed loop.
Since LoopDirection() calculates its result based on the 2d trimming
curve geometry, it can be use to set ON_BrepLoop::m_type to outer/inner
when translating from data definition where this distinction is murky.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.FlipLoop(RMA.OpenNURBS.OnBrepLoop@)">
            <summary>
Reverses orientation of trimming loop. 
This function is intended to be used by brep experts and does
does NOT modify ON_BrepLoop::m_type.  You should make sure 
ON_BrepLoop::m_type jibes with the loop's direction.  (Outer loops
should be counter-clockwise and inner loops should be clockwise.)
You can use ON_Brep::LoopDirection() to determine the direction of
a loop.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.FlipFace(RMA.OpenNURBS.OnBrepFace@)">
            <summary>
reverses orientation of a face by toggling ON_BrepFace::m_bRev
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Flip">
            <summary>
Reverses entire brep orientation of all faces by toggling 
value of all face's ON_BrepFace::m_bRev flag.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetEdgeDomain(System.Int32,RMA.OpenNURBS.IOnInterval)">
            <summary>
Change the domain of an edge.  This changes only the
parameterization of the 3d edge curve; the locus of the 
3d edge curve is not changed.
</summary>
            <param name="edge_index">index of edge in m_E[] array</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimDomain(System.Int32,RMA.OpenNURBS.IOnInterval)">
            <summary>
Change the domain of a trim's 2d curve.  This changes only the
parameterization of the 2d trimming curve; the locus of the 
2d trimming curve is not changed.
</summary>
            <param name="trim_index">index of trim in m_T[] array</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.FlipReversedSurfaces">
            <summary>
Clears all ON_BrepFace.m_bRev flags by ON_BrepFace::Transpose
on each face with a true m_bRev.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.LoopIsSurfaceBoundary(System.Int32)">
            <summary>
returns true if the loop's trims all run along the edge's of the underlying surface's
parameter space.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.FaceIsSurface(System.Int32)">
returns true if the face has a single outer boundary and that boundary runs
along the edges of the underlying surface. In this case the geometry of the surface
is the same as the geometry of the face. If FaceIsSurface() is true, then
m_S[m_F[face_index].m_si] is the surface. The flag m_F[face_index].m_bRev records
the correspondence between the surface's natural parametric orientation and the
orientation of face in the b-rep.
</member>
        <member name="M:RMA.OpenNURBS.OnBrep.IsSurface">
            <summary>
returns true if the b-rep has a single face
and that face is geometrically the same
as the underlying surface.  I.e., the face
has trivial trimming.  In this case, the
surface is m_S[0].
The flag m_F[0].m_bRev records
the correspondence between the surface's
natural parametric orientation and the
orientation of the b-rep.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.IsPointInside(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Boolean)">
            <summary>
Determine if P is inside Brep.  This question only makes sense
when the brep is a closed manifold.  This function does not
not check for closed or manifold, so result is not valid in
those cases.  Intersects a line through P with brep, finds
the intersection point Q closest to P, and looks at face 
normal at Q.  If the point Q is on an edge or the intersection
is not transverse at Q, then another line is used.
</summary>
            <param name="P">[in] 3d point</param>
            <param name="tolerance">
[in] 3d distance tolerance used for intersection and determining strict inclusion.
</param>
            <param name="bStrictlyInside">
[in] If bStrictlInside is true, then this function will return false
if the distance from P is within tolerance of a brep face.
</param>
            <returns>True if P is in, false if not. See parameter bStrictlyIn.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.IsManifold">
            <summary>Test brep to see if it is an oriented manifold.</summary>
            <returns>
true brep is a manifold
false brep is not a manifold
</returns>
            <seealso>ON_Brep::IsSolid</seealso>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.IsManifold(System.Boolean@)">
            <summary>Test brep to see if it is an oriented manifold.</summary>
            <param name="pbIsOriented">
[in] if not null, *pbIsOriented is set to true if b-rep is an oriented
manifold and false if brep is not an oriented manifold.
</param>
            <returns>
true brep is a manifold
false brep is not a manifold
</returns>
            <seealso>ON_Brep::IsSolid</seealso>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.IsManifold(System.Boolean@,System.Boolean@)">
            <summary>Test brep to see if it is an oriented manifold.</summary>
            <param name="pbIsOriented">
[in] if not null, *pbIsOriented is set to true if b-rep is an oriented
manifold and false if brep is not an oriented manifold.
</param>
            <param name="pbHasBoundary">
[in] if not null, *pbHasBoundary is set to true if b-rep has a boundary edge
and false if brep does not have a boundary edge.
</param>
            <returns>
true brep is a manifold
false brep is not a manifold
</returns>
            <seealso>ON_Brep::IsSolid</seealso>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.IsSolid">
            <summary>
Test brep to see if it is a solid. (A "solid" is a closed oriented manifold.)
</summary>
            <returns>
true brep is a solid fals brep is not a solid
See Also: ON_Brep::SolidOrientation ON_Brep::IsManifold
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SolidOrientation">
            <summary>Determine orientation of a brep.</summary>
            <returns>
+2 brep is a solid but orientation cannot be computed
+1 brep is a solid with outward facing normals
-1 brep is a solid with inward facing normals
0 brep is not a solid
</returns>
            <remarks>
The base class implementation returns 2 or 0. This function is 
overridden in the Rhino SDK and returns +1, -1, or 0.
See Also: ON_Brep::IsSolid
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Loop2dCurve(RMA.OpenNURBS.IOnBrepLoop)">
            <summary>Get a 3d curve that traces the entire loop</summary>
            <param name="loop">[in] loop whose 2d curve should be duplicated</param>
            <returns>A pointer to a 2d ON_Curve. The caller must delete this curve.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Loop3dCurve(RMA.OpenNURBS.IOnBrepLoop,RMA.OpenNURBS.OnCurve[]@)">
            <summary>Get a list of 3d curves that trace the non-seam edge portions of an entire loop</summary>
            <param name="loop">[in] loop whose 3d curve should be duplicated</param>
            <param name="curve_list">[out] 3d curves are appended to this list</param>
            <returns>Number of curves appended to curve_list.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Loop3dCurve(RMA.OpenNURBS.IOnBrepLoop,RMA.OpenNURBS.OnCurve[]@,System.Boolean)">
            <summary>Get a list of 3d curves that trace the non-seam edge portions of an entire loop</summary>
            <param name="loop">[in] loop whose 3d curve should be duplicated</param>
            <param name="curve_list">[out] 3d curves are appended to this list</param>
            <param name="bRevCurveIfFaceRevIsTrue">
[in] If false, the returned 3d curves have an orientation compatible with
the 2d curve returned by Loop2dCurve().
If true and the m_bRev flag of the loop's face is true,
then the returned curves are reversed.
</param>
            <returns>Number of curves appended to curve_list.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Loop3dCurve(RMA.OpenNURBS.IOnBrepLoop)">
            <summary>Get a single 3d curve that traces the entire loop</summary>
            <param name="loop">[in] loop whose 3d curve should be duplicated</param>
            <returns>A pointer to a 3d ON_Curve. The caller must delete this curve.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Loop3dCurve(RMA.OpenNURBS.IOnBrepLoop,System.Boolean)">
            <summary>Get a single 3d curve that traces the entire loop</summary>
            <param name="loop">[in] loop whose 3d curve should be duplicated</param>
            <param name="bRevCurveIfFaceRevIsTrue">
[in] If false, the returned 3d curve has an orientation compatible with the
2d curve returned by Loop2dCurve().
If true and the m_bRev flag of the loop's face is true,
then the returned curve is reversed.
</param>
            <returns>A pointer to a 3d ON_Curve. The caller must delete this curve.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.TrimCurveUseCount(System.Int32)">
            <summary>Determine how many brep trims reference m_C2[c2_index].</summary>
            <param name="c2_index">[in] index of the 2d curve in m_C2[] array</param>
            <returns>Number of brep trims that reference the 2d curve.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.TrimCurveUseCount(System.Int32,System.Int32)">
            <summary>Determine how many brep trims reference m_C2[c2_index].</summary>
            <param name="c2_index">[in] index of the 2d curve in m_C2[] array</param>
            <param name="max_count">
[in] counting stops if max_count &gt; 0 and at least max_count trims use the 2d curve.
</param>
            <returns>Number of brep trims that reference the 2d curve.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.EdgeCurveUseCount(System.Int32)">
            <summary>Determine how many brep edges reference m_C3[c3_index].</summary>
            <param name="c3_index">[in] index of the 3d curve in m_C3[] array</param>
            <returns>Number of brep edges that reference the 3d curve.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.EdgeCurveUseCount(System.Int32,System.Int32)">
            <summary>Determine how many brep edges reference m_C3[c3_index].</summary>
            <param name="c3_index">[in] index of the 3d curve in m_C3[] array</param>
            <param name="max_count">
[in] counting stops if max_count &gt; 0 and at least max_count edges use the 3d curve.
</param>
            <returns>Number of brep edges that reference the 3d curve.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SurfaceUseCount(System.Int32)">
            <summary>Determine how many brep faces reference m_S[surface_index].</summary>
            <param name="surface_index">[in] index of the surface in m_S[] array</param>
            <returns>Number of brep faces that reference the surface.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SurfaceUseCount(System.Int32,System.Int32)">
            <summary>Determine how many brep faces reference m_S[surface_index].</summary>
            <param name="surface_index">[in] index of the surface in m_S[] array</param>
            <param name="max_count">[in] counting stops if max_count &gt; 0 and at least max_count faces use the surface.</param>
            <returns>Number of brep faces that reference the surface.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTolerancesBoxesAndFlags">
            <summary>Set tolerances and flags in a brep</summary>
            <remarks>
See Also:
ON_Brep::SetVertexTolerance ON_Brep::SetEdgeTolerance ON_Brep::SetTrimTolerance ON_Brep::SetTrimTypeFlags ON_Brep::SetTrimIsoFlags ON_Brep::ComputeLoopType ON_Brep::SetTrimBoundingBox ON_Brep::SetTrimBoundingBoxes
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTolerancesBoxesAndFlags(System.Boolean)">
            <summary>Set tolerances and flags in a brep</summary>
            <param name="bLazy">[in] if true, only flags and tolerances that are not set will be calculated.</param>
            <remarks>
See Also:
ON_Brep::SetVertexTolerance ON_Brep::SetEdgeTolerance ON_Brep::SetTrimTolerance ON_Brep::SetTrimTypeFlags ON_Brep::SetTrimIsoFlags ON_Brep::ComputeLoopType ON_Brep::SetTrimBoundingBox ON_Brep::SetTrimBoundingBoxes
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTolerancesBoxesAndFlags(System.Boolean,System.Boolean)">
            <summary>Set tolerances and flags in a brep</summary>
            <param name="bLazy">[in] if true, only flags and tolerances that are not set will be calculated.</param>
            <param name="bSetVertexTolerances">[in] true to compute vertex.m_tolerance values</param>
            <remarks>
See Also:
ON_Brep::SetVertexTolerance ON_Brep::SetEdgeTolerance ON_Brep::SetTrimTolerance ON_Brep::SetTrimTypeFlags ON_Brep::SetTrimIsoFlags ON_Brep::ComputeLoopType ON_Brep::SetTrimBoundingBox ON_Brep::SetTrimBoundingBoxes
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTolerancesBoxesAndFlags(System.Boolean,System.Boolean,System.Boolean)">
            <summary>Set tolerances and flags in a brep</summary>
            <param name="bLazy">[in] if true, only flags and tolerances that are not set will be calculated.</param>
            <param name="bSetVertexTolerances">[in] true to compute vertex.m_tolerance values</param>
            <param name="bSetEdgeTolerances">[in] true to compute edge.m_tolerance values</param>
            <remarks>
See Also:
ON_Brep::SetVertexTolerance ON_Brep::SetEdgeTolerance ON_Brep::SetTrimTolerance ON_Brep::SetTrimTypeFlags ON_Brep::SetTrimIsoFlags ON_Brep::ComputeLoopType ON_Brep::SetTrimBoundingBox ON_Brep::SetTrimBoundingBoxes
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTolerancesBoxesAndFlags(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Set tolerances and flags in a brep</summary>
            <param name="bLazy">[in] if true, only flags and tolerances that are not set will be calculated.</param>
            <param name="bSetVertexTolerances">[in] true to compute vertex.m_tolerance values</param>
            <param name="bSetEdgeTolerances">[in] true to compute edge.m_tolerance values</param>
            <param name="bSetTrimTolerances">[in] true to compute trim.m_tolerance[0,1] values</param>
            <remarks>
See Also:
ON_Brep::SetVertexTolerance ON_Brep::SetEdgeTolerance ON_Brep::SetTrimTolerance ON_Brep::SetTrimTypeFlags ON_Brep::SetTrimIsoFlags ON_Brep::ComputeLoopType ON_Brep::SetTrimBoundingBox ON_Brep::SetTrimBoundingBoxes
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTolerancesBoxesAndFlags(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Set tolerances and flags in a brep</summary>
            <param name="bLazy">[in] if true, only flags and tolerances that are not set will be calculated.</param>
            <param name="bSetVertexTolerances">[in] true to compute vertex.m_tolerance values</param>
            <param name="bSetEdgeTolerances">[in] true to compute edge.m_tolerance values</param>
            <param name="bSetTrimTolerances">[in] true to compute trim.m_tolerance[0,1] values</param>
            <param name="bSetTrimIsoFlags">[in] true to compute trim.m_iso values</param>
            <remarks>
See Also:
ON_Brep::SetVertexTolerance ON_Brep::SetEdgeTolerance ON_Brep::SetTrimTolerance ON_Brep::SetTrimTypeFlags ON_Brep::SetTrimIsoFlags ON_Brep::ComputeLoopType ON_Brep::SetTrimBoundingBox ON_Brep::SetTrimBoundingBoxes
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTolerancesBoxesAndFlags(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Set tolerances and flags in a brep</summary>
            <param name="bLazy">[in] if true, only flags and tolerances that are not set will be calculated.</param>
            <param name="bSetVertexTolerances">[in] true to compute vertex.m_tolerance values</param>
            <param name="bSetEdgeTolerances">[in] true to compute edge.m_tolerance values</param>
            <param name="bSetTrimTolerances">[in] true to compute trim.m_tolerance[0,1] values</param>
            <param name="bSetTrimIsoFlags">[in] true to compute trim.m_iso values</param>
            <param name="bSetTrimTypeFlags">[in] true to compute trim.m_type values</param>
            <remarks>
See Also:
ON_Brep::SetVertexTolerance ON_Brep::SetEdgeTolerance ON_Brep::SetTrimTolerance ON_Brep::SetTrimTypeFlags ON_Brep::SetTrimIsoFlags ON_Brep::ComputeLoopType ON_Brep::SetTrimBoundingBox ON_Brep::SetTrimBoundingBoxes
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTolerancesBoxesAndFlags(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Set tolerances and flags in a brep</summary>
            <param name="bLazy">[in] if true, only flags and tolerances that are not set will be calculated.</param>
            <param name="bSetVertexTolerances">[in] true to compute vertex.m_tolerance values</param>
            <param name="bSetEdgeTolerances">[in] true to compute edge.m_tolerance values</param>
            <param name="bSetTrimTolerances">[in] true to compute trim.m_tolerance[0,1] values</param>
            <param name="bSetTrimIsoFlags">[in] true to compute trim.m_iso values</param>
            <param name="bSetTrimTypeFlags">[in] true to compute trim.m_type values</param>
            <param name="bSetLoopTypeFlags">[in] true to compute loop.m_type values</param>
            <remarks>
See Also:
ON_Brep::SetVertexTolerance ON_Brep::SetEdgeTolerance ON_Brep::SetTrimTolerance ON_Brep::SetTrimTypeFlags ON_Brep::SetTrimIsoFlags ON_Brep::ComputeLoopType ON_Brep::SetTrimBoundingBox ON_Brep::SetTrimBoundingBoxes
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTolerancesBoxesAndFlags(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Set tolerances and flags in a brep</summary>
            <param name="bLazy">[in] if true, only flags and tolerances that are not set will be calculated.</param>
            <param name="bSetVertexTolerances">[in] true to compute vertex.m_tolerance values</param>
            <param name="bSetEdgeTolerances">[in] true to compute edge.m_tolerance values</param>
            <param name="bSetTrimTolerances">[in] true to compute trim.m_tolerance[0,1] values</param>
            <param name="bSetTrimIsoFlags">[in] true to compute trim.m_iso values</param>
            <param name="bSetTrimTypeFlags">[in] true to compute trim.m_type values</param>
            <param name="bSetLoopTypeFlags">[in] true to compute loop.m_type values</param>
            <param name="bSetTrimBoxes">[in] true to compute trim.m_pbox values</param>
            <remarks>
See Also:
ON_Brep::SetVertexTolerance ON_Brep::SetEdgeTolerance ON_Brep::SetTrimTolerance ON_Brep::SetTrimTypeFlags ON_Brep::SetTrimIsoFlags ON_Brep::ComputeLoopType ON_Brep::SetTrimBoundingBox ON_Brep::SetTrimBoundingBoxes
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimBoundingBoxes">
            <summary>
Set the loop and trim parameter space bounding boxes for every loop and trim in the brep.
</summary>
            <returns>true if all the loop and trim parameter space bounding boxes are valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimBoundingBoxes(System.Boolean)">
            <summary>
Set the loop and trim parameter space bounding boxes for every loop and trim in the brep.
</summary>
            <param name="bLazy">
[in] if true and trim trim.m_pbox is valid, then that trim.m_pbox is not recalculated.
</param>
            <returns>true if all the loop and trim parameter space bounding boxes are valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimBoundingBoxes(RMA.OpenNURBS.OnBrepFace@)">
            <summary>
Set the loop and trim parameter space bounding boxes for every loop and trim in the face
</summary>
            <param name="face">[in]</param>
            <returns>true if all the face's loop and trim parameter space bounding boxes are valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimBoundingBoxes(RMA.OpenNURBS.OnBrepFace@,System.Boolean)">
            <summary>
Set the loop and trim parameter space bounding boxes for every loop and trim in the face
</summary>
            <param name="face">[in]</param>
            <param name="bLazy">[in] if true and trim trim.m_pbox is valid, then that trim.m_pbox is not recalculated.</param>
            <returns>true if all the face's loop and trim parameter space bounding boxes are valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimBoundingBoxes(RMA.OpenNURBS.OnBrepLoop@)">
            <summary>Set the loop parameter space bounding box (loop.m_pbox).</summary>
            <param name="loop">[in]</param>
            <returns>true if loop ends up with a valid bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimBoundingBoxes(RMA.OpenNURBS.OnBrepLoop@,System.Boolean)">
            <summary>Set the loop parameter space bounding box (loop.m_pbox).</summary>
            <param name="loop">[in]</param>
            <param name="bLazy">
[in] if true and loop trim trim.m_pbox is valid, then that trim.m_pbox is not recalculated.
</param>
            <returns>true if loop ends up with a valid bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimBoundingBox(RMA.OpenNURBS.OnBrepTrim@)">
            <summary>Set the trim parameter space bounding box (trim.m_pbox).</summary>
            <param name="trim">[in]</param>
            <returns>true if trim ends up with a valid bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimBoundingBox(RMA.OpenNURBS.OnBrepTrim@,System.Boolean)">
            <summary>Set the trim parameter space bounding box (trim.m_pbox).</summary>
            <param name="trim">[in]</param>
            <param name="bLazy">[in] if true and trim.m_pbox is valid, then the box is not set.</param>
            <returns>true if trim ends up with a valid bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetEdgeTolerances">
            <summary>Set the brep's edge tolerances.</summary>
            <returns>
true if successful.
See Also:
ON_Brep::SetVertexTolerance
ON_Brep::SetTrimTolerance
ON_Brep::SetEdgeTolerance
ON_Brep::SetVertexTolerances
ON_Brep::SetTrimTolerances
ON_Brep::SetEdgeTolerances
ON_Brep::SetTolerancesAndFlags
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetEdgeTolerances(System.Boolean)">
            <summary>Set the brep's edge tolerances.</summary>
            <param name="bLazy">
[in] if true, only edge tolerances with the value ON_UNSET_VALUE will be set.
If false, the edge tolerance is recomputed from the geometry in the brep.
</param>
            <returns>
true if successful.
See Also:
ON_Brep::SetVertexTolerance
ON_Brep::SetTrimTolerance
ON_Brep::SetEdgeTolerance
ON_Brep::SetVertexTolerances
ON_Brep::SetTrimTolerances
ON_Brep::SetEdgeTolerances
ON_Brep::SetTolerancesAndFlags
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimTolerances">
            <summary>Set the brep's trim tolerances.</summary>
            <returns>
true if successful.
See Also:
ON_Brep::SetVertexTolerance
ON_Brep::SetTrimTolerance
ON_Brep::SetEdgeTolerance
ON_Brep::SetVertexTolerances
ON_Brep::SetTrimTolerances
ON_Brep::SetEdgeTolerances
ON_Brep::SetTolerancesAndFlags
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimTolerances(System.Boolean)">
            <summary>Set the brep's trim tolerances.</summary>
            <param name="bLazy">
[in] if true, only trim tolerances with the value ON_UNSET_VALUE will be set.
If false, the trim tolerance is recomputed from the geometry in the brep.
</param>
            <returns>
true if successful.
See Also:
ON_Brep::SetVertexTolerance
ON_Brep::SetTrimTolerance
ON_Brep::SetEdgeTolerance
ON_Brep::SetVertexTolerances
ON_Brep::SetTrimTolerances
ON_Brep::SetEdgeTolerances
ON_Brep::SetTolerancesAndFlags
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetVertexTolerances">
            <summary>Set the brep's vertex tolerances.</summary>
            <returns>
true if successful.
See Also:
ON_Brep::SetVertexTolerance
ON_Brep::SetTrimTolerance
ON_Brep::SetEdgeTolerance
ON_Brep::SetVertexTolerances
ON_Brep::SetTrimTolerances
ON_Brep::SetEdgeTolerances
ON_Brep::SetTolerancesAndFlags
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetVertexTolerances(System.Boolean)">
            <summary>Set the brep's vertex tolerances.</summary>
            <param name="bLazy">
[in] if true, only vertex tolerances with the value ON_UNSET_VALUE will be set.
If false, the vertex tolerance is recomputed from the geometry in the brep.
</param>
            <returns>
true if successful.
See Also:
ON_Brep::SetVertexTolerance
ON_Brep::SetTrimTolerance
ON_Brep::SetEdgeTolerance
ON_Brep::SetVertexTolerances
ON_Brep::SetTrimTolerances
ON_Brep::SetEdgeTolerances
ON_Brep::SetTolerancesAndFlags
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetEdgeTolerance(RMA.OpenNURBS.OnBrepEdge@)">
            <summary>
These set the various tolerances.  The optional BOOL argument
is called bLazy.  If bLazy is false, the tolerance is recomputed
from its definition.  If bLazy is true, the tolerance is computed
only if its current value is negative.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetEdgeTolerance(RMA.OpenNURBS.OnBrepEdge@,System.Boolean)">
            <summary>
These set the various tolerances.  The optional BOOL argument
is called bLazy.  If bLazy is false, the tolerance is recomputed
from its definition.  If bLazy is true, the tolerance is computed
only if its current value is negative.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimTolerance(RMA.OpenNURBS.OnBrepTrim@)">
            <summary>
These set the various tolerances.  The optional BOOL argument
is called bLazy.  If bLazy is false, the tolerance is recomputed
from its definition.  If bLazy is true, the tolerance is computed
only if its current value is negative.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimTolerance(RMA.OpenNURBS.OnBrepTrim@,System.Boolean)">
            <summary>
These set the various tolerances.  The optional BOOL argument
is called bLazy.  If bLazy is false, the tolerance is recomputed
from its definition.  If bLazy is true, the tolerance is computed
only if its current value is negative.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetVertexTolerance(RMA.OpenNURBS.OnBrepVertex@)">
            <summary>
These set the various tolerances.  The optional BOOL argument
is called bLazy.  If bLazy is false, the tolerance is recomputed
from its definition.  If bLazy is true, the tolerance is computed
only if its current value is negative.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetVertexTolerance(RMA.OpenNURBS.OnBrepVertex@,System.Boolean)">
            <summary>
These set the various tolerances.  The optional BOOL argument
is called bLazy.  If bLazy is false, the tolerance is recomputed
from its definition.  If bLazy is true, the tolerance is computed
only if its current value is negative.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.ComputeLoopType(RMA.OpenNURBS.IOnBrepLoop)">
            <summary>
This function examines the 2d parameter space curves and returns
the loop's type based on their orientation.  Use this function for
debugging loop orientation problems.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.GetTrim3dEnd(System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>
GetTrim3dEnd() evaluates the 3d surface at the end of the
parameter space (2d) trim curve.
</summary>
            <param name="trim_index">index of ON_BrepTrim in m_T[] array</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.GetTrim3dStart(System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>
GetTrim3dStart() evaluates the 3d surface at the start of the
parameter space (2d) trim curve.
</summary>
            <param name="trim_index">index of ON_BrepTrim in m_T[] array</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.GetTrim2dEnd(System.Int32,RMA.OpenNURBS.On2dPoint@)">
            <summary>
GetTrim2dEnd() evaluates end of the
parameter space (2d) trim curve.
</summary>
            <param name="trim_index">index of ON_BrepTrim in m_T[] array</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.GetTrim2dStart(System.Int32,RMA.OpenNURBS.On2dPoint@)">
            <summary>
GetTrim2dStart() evaluates the start of the
parameter space (2d) trim curve.
</summary>
            <param name="trim_index">index of ON_BrepTrim in m_T[] array</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimTypeFlags(RMA.OpenNURBS.OnBrepTrim@)">
            <summary>
This function can be used to set the ON_BrepTrim::m_type
flag.  If the optional bLazy argument is true, then only
trims with m_type = unknown are set.
See Also: ON_BrepSetFlagsAndTolerances
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimTypeFlags(RMA.OpenNURBS.OnBrepTrim@,System.Boolean)">
            <summary>
This function can be used to set the ON_BrepTrim::m_type
flag.  If the optional bLazy argument is true, then only
trims with m_type = unknown are set.
See Also: ON_BrepSetFlagsAndTolerances
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimTypeFlags(RMA.OpenNURBS.OnBrepLoop@)">
            <summary>
This function can be used to set the ON_BrepTrim::m_type
flag.  If the optional bLazy argument is true, then only
trims with m_type = unknown are set.
See Also: ON_BrepSetFlagsAndTolerances
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimTypeFlags(RMA.OpenNURBS.OnBrepLoop@,System.Boolean)">
            <summary>
This function can be used to set the ON_BrepTrim::m_type
flag.  If the optional bLazy argument is true, then only
trims with m_type = unknown are set.
See Also: ON_BrepSetFlagsAndTolerances
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimTypeFlags(RMA.OpenNURBS.OnBrepFace@)">
            <summary>
This function can be used to set the ON_BrepTrim::m_type
flag.  If the optional bLazy argument is true, then only
trims with m_type = unknown are set.
See Also: ON_BrepSetFlagsAndTolerances
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimTypeFlags(RMA.OpenNURBS.OnBrepFace@,System.Boolean)">
            <summary>
This function can be used to set the ON_BrepTrim::m_type
flag.  If the optional bLazy argument is true, then only
trims with m_type = unknown are set.
See Also: ON_BrepSetFlagsAndTolerances
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimTypeFlags">
            <summary>
This function can be used to set the ON_BrepTrim::m_type
flag.  If the optional bLazy argument is true, then only
trims with m_type = unknown are set.
See Also: ON_BrepSetFlagsAndTolerances

sets all trim iso flags
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimTypeFlags(System.Boolean)">
            <summary>
This function can be used to set the ON_BrepTrim::m_type
flag.  If the optional bLazy argument is true, then only
trims with m_type = unknown are set.
See Also: ON_BrepSetFlagsAndTolerances

sets all trim iso flags
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.TrimType(RMA.OpenNURBS.IOnBrepTrim)">
            <summary>
Calculate the type (singular, mated, boundary, etc.) of an ON_BrepTrim object.
</summary>
            <param name="trim">[in]</param>
            <returns>Type of trim.</returns>
            <remarks>
The trim must be connected to a valid loop. See Also: ON_Brep::SetTrimTypeFlags
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.TrimType(RMA.OpenNURBS.IOnBrepTrim,System.Boolean)">
            <summary>
Calculate the type (singular, mated, boundary, etc.) of an ON_BrepTrim object.
</summary>
            <param name="trim">[in]</param>
            <param name="bLazy">
[in] if true and trim.m_type is set to something other than ON_BrepTrim::unknown,
then no calculation is performed and the value of trim.m_type is returned.
If false, the value of trim.m_type is ignored and is caluculated.
</param>
            <returns>Type of trim.</returns>
            <remarks>
The trim must be connected to a valid loop. See Also: ON_Brep::SetTrimTypeFlags
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimIsoFlags(RMA.OpenNURBS.OnBrepTrim@)">
            <summary>
This function can be used to set the ON_BrepTrim::m_iso
flag. It is intended to be used when creating a ON_Brep from
a definition that does not include compatible parameter space
type information.
See Also: ON_BrepSetFlagsAndTolerances
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimIsoFlags(RMA.OpenNURBS.OnBrepLoop@)">
            <summary>
This function can be used to set the ON_BrepTrim::m_iso
flag. It is intended to be used when creating a ON_Brep from
a definition that does not include compatible parameter space
type information.
See Also: ON_BrepSetFlagsAndTolerances
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimIsoFlags(RMA.OpenNURBS.OnBrepFace@)">
            <summary>
This function can be used to set the ON_BrepTrim::m_iso
flag. It is intended to be used when creating a ON_Brep from
a definition that does not include compatible parameter space
type information.
See Also: ON_BrepSetFlagsAndTolerances
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimIsoFlags">
            <summary>
This function can be used to set the ON_BrepTrim::m_iso
flag. It is intended to be used when creating a ON_Brep from
a definition that does not include compatible parameter space
type information.
See Also: ON_BrepSetFlagsAndTolerances

sets all trim iso flags
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetVertices">
            <summary>
This function can be used to compute vertex information for a
b-rep when everything but the m_V array is properly filled in.
It is intended to be used when creating a ON_Brep from a 
definition that does not include explicit vertex information.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Append(RMA.OpenNURBS.IOnBrep)">
            <summary>
appends a copy of brep to this and updates
indices of appended brep parts.  Duplicates are not removed.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewCurveOnFace(RMA.OpenNURBS.OnBrepFace@,RMA.OpenNURBS.OnBrepEdge@)">
            <summary>Add a new curve on face to the brep.</summary>
            <param name="face">[in] face that curve lies on</param>
            <param name="edge">[in] 3d edge associated with this curve on surface</param>
            <returns>new trim that represents the curve on surface</returns>
            <remarks>You should set the trim's ON_BrepTrim::m_tolerance and ON_BrepTrim::m_iso values.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewCurveOnFace(RMA.OpenNURBS.OnBrepFace@,RMA.OpenNURBS.OnBrepEdge@,System.Boolean)">
            <summary>Add a new curve on face to the brep.</summary>
            <param name="face">[in] face that curve lies on</param>
            <param name="edge">[in] 3d edge associated with this curve on surface</param>
            <param name="bRev3d">[in] true if the 3d edge and the 2d parameter space curve have opposite directions.</param>
            <returns>new trim that represents the curve on surface</returns>
            <remarks>You should set the trim's ON_BrepTrim::m_tolerance and ON_BrepTrim::m_iso values.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewCurveOnFace(RMA.OpenNURBS.OnBrepFace@,RMA.OpenNURBS.OnBrepEdge@,System.Boolean,System.Int32)">
            <summary>Add a new curve on face to the brep.</summary>
            <param name="face">[in] face that curve lies on</param>
            <param name="edge">[in] 3d edge associated with this curve on surface</param>
            <param name="bRev3d">[in] true if the 3d edge and the 2d parameter space curve have opposite directions.</param>
            <param name="c2i">[in] index of 2d curve in face's parameter space</param>
            <returns>new trim that represents the curve on surface</returns>
            <remarks>You should set the trim's ON_BrepTrim::m_tolerance and ON_BrepTrim::m_iso values.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewPointOnFace(RMA.OpenNURBS.OnBrepFace@,System.Double,System.Double)">
            <summary>Adds a new point on face to the brep.</summary>
            <param name="face">[in] face that vertex lies on</param>
            <param name="s">[in] surface parameters</param>
            <param name="t">[in] surface parameters</param>
            <returns>new vertex that represents the point on face.</returns>
            <remarks>
If a vertex is a point on a face, then brep.m_E[m_ei] will be an edge with no 3d curve.
This edge will have a single trim with type ON_BrepTrim::ptonsrf. There will be a loop
containing this single trim.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewSingularTrim(RMA.OpenNURBS.IOnBrepVertex,RMA.OpenNURBS.OnBrepLoop@,RMA.OpenNURBS.IOnSurface.ISO)">
            <summary>Add a new singular trim to the brep.</summary>
            <param name="vertex">[in] vertex along collapsed surface edge</param>
            <param name="loop">[in] trim is appended to this loop</param>
            <param name="iso">[in] one of ON_Surface::S_iso, ON_Surface::E_iso, ON_Surface::N_iso, or ON_Surface::W_iso.</param>
            <returns>
new trim
See Also: ON_Brep::NewTrim
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewSingularTrim(RMA.OpenNURBS.IOnBrepVertex,RMA.OpenNURBS.OnBrepLoop@,RMA.OpenNURBS.IOnSurface.ISO,System.Int32)">
            <summary>Add a new singular trim to the brep.</summary>
            <param name="vertex">[in] vertex along collapsed surface edge</param>
            <param name="loop">[in] trim is appended to this loop</param>
            <param name="iso">[in] one of ON_Surface::S_iso, ON_Surface::E_iso, ON_Surface::N_iso, or ON_Surface::W_iso.</param>
            <param name="c2i">[in] index of 2d trimming curve</param>
            <returns>
new trim
See Also: ON_Brep::NewTrim
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewTrim(RMA.OpenNURBS.OnBrepEdge@,System.Boolean,RMA.OpenNURBS.OnBrepLoop@)">
            <summary>Add a new trim that will be part of an inner, outer, or slit loop to the brep.</summary>
            <param name="edge">[in] 3d edge associated with this trim</param>
            <param name="bRev3d">[in] ON_BrepTrim::m_bRev3d value. true if the edge and trim have opposite directions.</param>
            <param name="loop">[in] trim is appended to this loop</param>
            <returns>new trim</returns>
            <example>
int c2i = brep-&gt;AddTrimCurve( p2dCurve );
ON_BrepTrim&amp; trim = brep-&gt;NewTrim( edge, bRev3d, loop, c2i );
trim.m_tolerance[0] = ...;
trim.m_tolerance[1] = ...;
</example>
            <remarks>
You should set the trim's ON_BrepTrim::m_tolerance values. If c2i is -1,
you must set the trim's ON_BrepTrim::m_iso values.
This version of NewTrim sets the trim.m_type value. If the input edge or loop 
are not currently valid, then you may need to adjust the trim.m_type value.
If you want to add a singular trim, use ON_Brep::NewSingularTrim.
If you want to add a crvonsrf trim, use ON_Brep::NewCurveOnFace.
If you want to add a ptonsrf trim, use ON_Brep::NewPointOnFace.
See Also:
ON_Brep::SetTrimTypeFlags
ON_Brep::SetTrimIsoFlags
ON_Brep::NewSingularTrim
ON_Brep::NewPointOnFace
ON_Brep::NewCurveOnFace
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewTrim(RMA.OpenNURBS.OnBrepEdge@,System.Boolean,RMA.OpenNURBS.OnBrepLoop@,System.Int32)">
            <summary>Add a new trim that will be part of an inner, outer, or slit loop to the brep.</summary>
            <param name="edge">[in] 3d edge associated with this trim</param>
            <param name="bRev3d">[in] ON_BrepTrim::m_bRev3d value. true if the edge and trim have opposite directions.</param>
            <param name="loop">[in] trim is appended to this loop</param>
            <param name="c2i">[in] index of 2d trimming curve</param>
            <returns>new trim</returns>
            <example>
int c2i = brep-&gt;AddTrimCurve( p2dCurve );
ON_BrepTrim&amp; trim = brep-&gt;NewTrim( edge, bRev3d, loop, c2i );
trim.m_tolerance[0] = ...;
trim.m_tolerance[1] = ...;
</example>
            <remarks>
You should set the trim's ON_BrepTrim::m_tolerance values. If c2i is -1,
you must set the trim's ON_BrepTrim::m_iso values.
This version of NewTrim sets the trim.m_type value. If the input edge or loop 
are not currently valid, then you may need to adjust the trim.m_type value.
If you want to add a singular trim, use ON_Brep::NewSingularTrim.
If you want to add a crvonsrf trim, use ON_Brep::NewCurveOnFace.
If you want to add a ptonsrf trim, use ON_Brep::NewPointOnFace.
See Also:
ON_Brep::SetTrimTypeFlags
ON_Brep::SetTrimIsoFlags
ON_Brep::NewSingularTrim
ON_Brep::NewPointOnFace
ON_Brep::NewCurveOnFace
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewTrim(RMA.OpenNURBS.OnBrepEdge@,System.Boolean)">
            <summary>
Add a new trim that will be part of an inner, outer, or slit loop to the brep.
</summary>
            <param name="edge">[in] 3d edge associated with this trim</param>
            <param name="bRev3d">[in] ON_BrepTrim::m_bRev3d value. true if the edge and trim have opposite directions.</param>
            <returns>new trim</returns>
            <example>
int c2i = brep-&gt;
AddTrimCurve( p2dCurve );
ON_BrepTrim&amp; trim = NewTrim( edge, bRev3d, c2i );
trim.m_li = ...;
trim.m_tolerance[0] = ...;
trim.m_tolerance[1] = ...;
trim.m_type = ...;
trim.m_iso = ...;
</example>
            <remarks>
You should set the trim's ON_BrepTrim::m_tolerance, ON_BrepTrim::m_type,
ON_BrepTrim::m_iso, and ON_BrepTrim::m_li values. In general, you should try
to use the ON_BrepTrim::NewTrim( edge, bRev3d, loop, c2i ) version of NewTrim.
If you want to add a singular trim, use ON_Brep::NewSingularTrim.
If you want to add a crvonsrf trim, use ON_Brep::NewCurveOnFace.
If you want to add a ptonsrf trim, use ON_Brep::NewPointOnFace.
See Also:
ON_Brep::SetTrimTypeFlags
ON_Brep::SetTrimIsoFlags 
ON_Brep::NewSingularTrim 
ON_Brep::NewPointOnFace
ON_Brep::NewCurveOnFace
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewTrim(RMA.OpenNURBS.OnBrepEdge@,System.Boolean,System.Int32)">
            <summary>
Add a new trim that will be part of an inner, outer, or slit loop to the brep.
</summary>
            <param name="edge">[in] 3d edge associated with this trim</param>
            <param name="bRev3d">[in] ON_BrepTrim::m_bRev3d value. true if the edge and trim have opposite directions.</param>
            <param name="c2i">[in] index of 2d trimming curve</param>
            <returns>new trim</returns>
            <example>
int c2i = brep-&gt;
AddTrimCurve( p2dCurve );
ON_BrepTrim&amp; trim = NewTrim( edge, bRev3d, c2i );
trim.m_li = ...;
trim.m_tolerance[0] = ...;
trim.m_tolerance[1] = ...;
trim.m_type = ...;
trim.m_iso = ...;
</example>
            <remarks>
You should set the trim's ON_BrepTrim::m_tolerance, ON_BrepTrim::m_type,
ON_BrepTrim::m_iso, and ON_BrepTrim::m_li values. In general, you should try
to use the ON_BrepTrim::NewTrim( edge, bRev3d, loop, c2i ) version of NewTrim.
If you want to add a singular trim, use ON_Brep::NewSingularTrim.
If you want to add a crvonsrf trim, use ON_Brep::NewCurveOnFace.
If you want to add a ptonsrf trim, use ON_Brep::NewPointOnFace.
See Also:
ON_Brep::SetTrimTypeFlags
ON_Brep::SetTrimIsoFlags 
ON_Brep::NewSingularTrim 
ON_Brep::NewPointOnFace
ON_Brep::NewCurveOnFace
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewTrim(System.Boolean,RMA.OpenNURBS.OnBrepLoop@)">
            <summary>
Add a new trim that will be part of an inner, outer, or slit loop to the brep.
</summary>
            <param name="bRev3d">[in] ON_BrepTrim::m_bRev3d value. true if the edge and trim have opposite directions.</param>
            <param name="loop">[in] trim is appended to this loop</param>
            <returns>new trim</returns>
            <example>
int c2i = brep-&gt;AddTrimCurve( p2dCurve );
ON_BrepTrim&amp; trim = NewTrim( edge, bRev3d, loop, c2i );
trim.m_ei = ...;
trim.m_tolerance[0] = ...;
trim.m_tolerance[1] = ...;
trim.m_type = ...;
trim.m_iso = ...; 
</example>
            <remarks>
You should set the trim's ON_BrepTrim::m_tolerance, ON_BrepTrim::m_type, ON_BrepTrim::m_iso,
and ON_BrepTrim::m_ei values. In general, you should try to use the
ON_BrepTrim::NewTrim( edge, bRev3d, loop, c2i ) version of NewTrim. If you want to add a singular
trim, use ON_Brep::NewSingularTrim. If you want to add a crvonsrf trim, use ON_Brep::NewCurveOnFace.
If you want to add a ptonsrf trim, use ON_Brep::NewPointOnFace.
See Also:
ON_Brep::SetTrimTypeFlags
ON_Brep::SetTrimIsoFlags
ON_Brep::NewSingularTrim
ON_Brep::NewPointOnFace
ON_Brep::NewCurveOnFace
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewTrim(System.Boolean,RMA.OpenNURBS.OnBrepLoop@,System.Int32)">
            <summary>
Add a new trim that will be part of an inner, outer, or slit loop to the brep.
</summary>
            <param name="bRev3d">[in] ON_BrepTrim::m_bRev3d value. true if the edge and trim have opposite directions.</param>
            <param name="loop">[in] trim is appended to this loop</param>
            <param name="c2i">[in] index of 2d trimming curve</param>
            <returns>new trim</returns>
            <example>
int c2i = brep-&gt;AddTrimCurve( p2dCurve );
ON_BrepTrim&amp; trim = NewTrim( edge, bRev3d, loop, c2i );
trim.m_ei = ...;
trim.m_tolerance[0] = ...;
trim.m_tolerance[1] = ...;
trim.m_type = ...;
trim.m_iso = ...; 
</example>
            <remarks>
You should set the trim's ON_BrepTrim::m_tolerance, ON_BrepTrim::m_type, ON_BrepTrim::m_iso,
and ON_BrepTrim::m_ei values. In general, you should try to use the
ON_BrepTrim::NewTrim( edge, bRev3d, loop, c2i ) version of NewTrim. If you want to add a singular
trim, use ON_Brep::NewSingularTrim. If you want to add a crvonsrf trim, use ON_Brep::NewCurveOnFace.
If you want to add a ptonsrf trim, use ON_Brep::NewPointOnFace.
See Also:
ON_Brep::SetTrimTypeFlags
ON_Brep::SetTrimIsoFlags
ON_Brep::NewSingularTrim
ON_Brep::NewPointOnFace
ON_Brep::NewCurveOnFace
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewTrim">
            <summary>
Add a new trim that will be part of an inner, outer, or slit loop to the brep.
</summary>
            <returns>new trim</returns>
            <example>
int c2i = brep-&gt;
AddTrimCurve( p2dCurve );
ON_BrepTrim&amp; trim = NewTrim( edge, bRev3d, loop, c2i );
trim.m_ei = ...;
trim.m_li = ...;
trim.m_tolerance[0] = ...;
trim.m_tolerance[1] = ...;
trim.m_type = ...;
trim.m_iso = ...;
</example>
            <remarks>
You should set the trim's ON_BrepTrim::m_tolerance, ON_BrepTrim::m_type,
ON_BrepTrim::m_iso, ON_BrepTrim::m_li, and ON_BrepTrim::m_ei values.
In general, you should try to use the ON_BrepTrim::NewTrim( edge, bRev3d, loop, c2i )
version of NewTrim. If you want to add a singular trim, use ON_Brep::NewSingularTrim.
If you want to add a crvonsrf trim, use ON_Brep::NewCurveOnFace. If you want to add
a ptonsrf trim, use ON_Brep::NewPointOnFace.
See Also:
ON_Brep::SetTrimTypeFlags
ON_Brep::SetTrimIsoFlags
ON_Brep::NewSingularTrim
ON_Brep::NewPointOnFace
ON_Brep::NewCurveOnFace
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewTrim(System.Int32)">
            <summary>
Add a new trim that will be part of an inner, outer, or slit loop to the brep.
</summary>
            <param name="c2i">[in] index of 2d trimming curve</param>
            <returns>new trim</returns>
            <example>
int c2i = brep-&gt;
AddTrimCurve( p2dCurve );
ON_BrepTrim&amp; trim = NewTrim( edge, bRev3d, loop, c2i );
trim.m_ei = ...;
trim.m_li = ...;
trim.m_tolerance[0] = ...;
trim.m_tolerance[1] = ...;
trim.m_type = ...;
trim.m_iso = ...;
</example>
            <remarks>
You should set the trim's ON_BrepTrim::m_tolerance, ON_BrepTrim::m_type,
ON_BrepTrim::m_iso, ON_BrepTrim::m_li, and ON_BrepTrim::m_ei values.
In general, you should try to use the ON_BrepTrim::NewTrim( edge, bRev3d, loop, c2i )
version of NewTrim. If you want to add a singular trim, use ON_Brep::NewSingularTrim.
If you want to add a crvonsrf trim, use ON_Brep::NewCurveOnFace. If you want to add
a ptonsrf trim, use ON_Brep::NewPointOnFace.
See Also:
ON_Brep::SetTrimTypeFlags
ON_Brep::SetTrimIsoFlags
ON_Brep::NewSingularTrim
ON_Brep::NewPointOnFace
ON_Brep::NewCurveOnFace
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewPlanarFaceLoop(System.Int32,RMA.OpenNURBS.IOnBrepLoop.TYPE,RMA.OpenNURBS.OnCurve[])">
            <summary>Add a planar trimming loop to a planar face.</summary>
            <param name="face_index">[in] index of planar face. The underlying suface must be an ON_PlaneSurface.</param>
            <param name="loop_type">
[in] type of loop to add. If loop_type is ON_BrepLoop::unknown, then the loop
direction is tested and the the new loops type will be set to ON_BrepLoop::outer
or ON_BrepLoop::inner. If the loop_type is ON_BrepLoop::outer, then the direction
of the new loop is tested and flipped if it is clockwise. If the loop_type is
ON_BrepLoop::inner, then the direction of the new loop is tested and flipped if
it is counter-clockwise.
</param>
            <param name="boundary">
[in] a list of 3d curves that form a simple (no self intersections) closed curve.
These curves define the 3d edge geometry and should be near the planar surface.
</param>
            <returns>true if successful. The new loop will be brep.m_L.Last().</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewPlanarFaceLoop(System.Int32,RMA.OpenNURBS.IOnBrepLoop.TYPE,RMA.OpenNURBS.OnCurve[],System.Boolean)">
            <summary>Add a planar trimming loop to a planar face.</summary>
            <param name="face_index">[in] index of planar face. The underlying suface must be an ON_PlaneSurface.</param>
            <param name="loop_type">
[in] type of loop to add. If loop_type is ON_BrepLoop::unknown, then the loop
direction is tested and the the new loops type will be set to ON_BrepLoop::outer
or ON_BrepLoop::inner. If the loop_type is ON_BrepLoop::outer, then the direction
of the new loop is tested and flipped if it is clockwise. If the loop_type is
ON_BrepLoop::inner, then the direction of the new loop is tested and flipped if
it is counter-clockwise.
</param>
            <param name="boundary">
[in] a list of 3d curves that form a simple (no self intersections) closed curve.
These curves define the 3d edge geometry and should be near the planar surface.
</param>
            <param name="bDuplicateCurves">
[in] If true, then duplicates of the curves in the boundary array are added to the brep.
If false, the curves in the boundary array are added to the brep and will be deleted
by ON_Brep::~ON_Brep.
</param>
            <returns>true if successful. The new loop will be brep.m_L.Last().</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewOuterLoop(System.Int32,System.Int32[],System.Int32[],System.Int32[])">
            <summary>
Add a new face to brep. This version is for expert users.
</summary>
            <param name="face_index">
[in] index of face that will get a new outer loop running around the sides of the
face's underlying surface.
</param>
            <param name="vid">
[in/out] four vertex indices that specify the vertices at the (sw,se,nw,ne) corners.
If the input value of a vertex index is -1, then the vertex will be created.
</param>
            <param name="eid">
[in/out] four edge indices that specify the edges for the (south,east,north,west) sides.
If the input value of an edge index is -1, then the edge will be created.
</param>
            <param name="bRev3d">
[in/out] four values of the trim m_bRev3d flags of the (south,east,north,west) sides.
</param>
            <returns>Pointer to the new loop or NULL if input is not valid.</returns>
            <remarks>
Adding a new loop may grow the dynamic m_L array. When this happens pointers and
references to memory in the previous m_L[] array may become invalid. Use face
indices if this is an issue.
See Also: ON_Brep::NewFace
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewOuterLoop(System.Int32)">
            <summary>
Create a new outer boundary loop that runs along the sides of the face's surface.
All the necessary trims, edges, and vertices are created and added to the brep.
</summary>
            <param name="face_index">
[in] index of face that needs an outer boundary that runs along the sides of its surface.
</param>
            <returns>New outer boundary loop that is complete.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewLoop(RMA.OpenNURBS.IOnBrepLoop.TYPE,RMA.OpenNURBS.OnBrepFace@)">
            <summary>
Create a new boundary loop on a face. After you get this ON_BrepLoop, you
still need to create the vertices, edges, and trims that define the loop.
</summary>
            <returns>New loop that needs to be filled in.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewLoop(RMA.OpenNURBS.IOnBrepLoop.TYPE)">
            <summary>
Create a new outer boundary loop that runs along the edges of the underlying surface.
</summary>
            <returns>New outer boundary loop.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewConeFace(RMA.OpenNURBS.IOnBrepVertex,RMA.OpenNURBS.IOnBrepEdge,System.Boolean)">
            <summary>
Add a new face to the brep whose surface geometry is a ruled cone with the edge as
the base and the vertex as the apex point.
</summary>
            <param name="vertex">
[in] The apex of the cone will be at this vertex. The north side of the surface's
parameter space will be a singular point at the vertex.
</param>
            <param name="edge">[in] The south side of the face's surface will run along this edge.</param>
            <param name="bRevEdge">
[in] true if the new face's outer boundary orientation along the edge is
opposite the orientation of edge.
</param>
            <returns>A pointer to the new face or a NULL if the new face could not be created.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewRuledFace(RMA.OpenNURBS.IOnBrepEdge,System.Boolean,RMA.OpenNURBS.IOnBrepEdge,System.Boolean)">
            <summary>
Add a new face to the brep whose surface geometry is a ruled surface between two edges.
</summary>
            <param name="edgeA">[in] The south side of the face's surface will run along edgeA.</param>
            <param name="bRevEdgeA">
[in] true if the new face's outer boundary orientation along edgeA is opposite the orientation of edgeA.
</param>
            <param name="edgeB">[in] The north side of the face's surface will run along edgeA.</param>
            <param name="bRevEdgeB">
[in] true if the new face's outer boundary orientation along edgeB is opposite the orientation of edgeB.
</param>
            <returns>A pointer to the new face or a NULL if the new face could not be created.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewFace(RMA.OpenNURBS.OnSurface,System.Int32[],System.Int32[],System.Boolean[])">
            <summary>Add a new face to brep. This version is for expert users.</summary>
            <param name="pSurface">
[in] the returned face will have an outer loop that goes around the edges of the surface.
</param>
            <param name="vid">
[in/out] four vertex indices that specify the vertices at the (sw,se,nw,ne) corners.
If the input value of a vertex index is -1, then the vertex will be created.
</param>
            <param name="eid">
[in/out] four edge indices that specify the edges for the (south,east,north,west) sides.
If the input value of an edge index is -1, then the edge will be created.
</param>
            <param name="bRev3d">
[in/out] four values of the trim m_bRev3d flags of the (south,east,north,west) sides.
</param>
            <returns>Pointer to the new face or NULL if input is not valid.</returns>
            <remarks>
Adding a new face may grow the dynamic m_F array. When this happens pointers
and references to memory in the previous m_F[] array may become invalid.
Use face indices if this is an issue.
Example: See ON_BrepBox and ON_BrepSphere source code.
See Also: ON_Brep::AddSurface ON_Brep::AddFace( int si ) ON_Brep::Create( ON_Surface*&amp; )
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewFace(RMA.OpenNURBS.IOnSurface)">
            <summary>
Add a new face to a brep. This creates a complete face with new vertices
at the surface corners, new edges along the surface boundary, etc. The
loop of the returned face has four trims that correspond to the south,
east, north, and west side of the surface in that order. If you use this 
version of NewFace to add an exiting brep, then you are responsible for
using a tool like ON_Brep::JoinEdges() to hook the new face to its neighbors.
</summary>
            <param name="surface">[in] surface is copied.</param>
            <returns>Pointer to new face.</returns>
            <remarks>
Adding a new face may grow the dynamic arrays used to store vertices, edges,
faces, loops, and trims. When these dyamic arrays are grown, any pointers
and references to memory in the previous arrays may become invalid.
Use indices if this is an issue.
See Also: ON_Brep::JoinEdges ON_Brep::AddSurface
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewFace">
            <summary>
Add a new face to a brep. An incomplete face is added. 
The caller must create and fill in the loops used by the face.
</summary>
            <returns>Reference to new face.</returns>
            <remarks>
Adding a new face may grow the dynamic m_F array. When this happens
pointers and references to memory in the previous m_F[] array may
become invalid. Use face indices if this is an issue.
Example: See ON_BrepBox and ON_BrepSphere source code.
See Also: ON_Brep::AddSurface
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewFace(System.Int32)">
            <summary>
Add a new face to a brep. An incomplete face is added. 
The caller must create and fill in the loops used by the face.
</summary>
            <param name="si">[in] index of surface in brep's m_S[] array</param>
            <returns>Reference to new face.</returns>
            <remarks>
Adding a new face may grow the dynamic m_F array. When this happens
pointers and references to memory in the previous m_F[] array may
become invalid. Use face indices if this is an issue.
Example: See ON_BrepBox and ON_BrepSphere source code.
See Also: ON_Brep::AddSurface
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewEdge(RMA.OpenNURBS.OnBrepVertex@,RMA.OpenNURBS.OnBrepVertex@)">
            <summary>
These add a new topology piece to the b-rep and return a 
reference that is intended to be used for initialization.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewEdge(RMA.OpenNURBS.OnBrepVertex@,RMA.OpenNURBS.OnBrepVertex@,System.Int32)">
            <summary>
These add a new topology piece to the b-rep and return a 
reference that is intended to be used for initialization.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewEdge(RMA.OpenNURBS.OnBrepVertex@,RMA.OpenNURBS.OnBrepVertex@,System.Int32,RMA.OpenNURBS.IOnInterval)">
            <summary>
These add a new topology piece to the b-rep and return a 
reference that is intended to be used for initialization.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewEdge(RMA.OpenNURBS.OnBrepVertex@,RMA.OpenNURBS.OnBrepVertex@,System.Int32,RMA.OpenNURBS.IOnInterval,System.Double)">
            <summary>
These add a new topology piece to the b-rep and return a 
reference that is intended to be used for initialization.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewEdge">
            <summary>
These add a new topology piece to the b-rep and return a 
reference that is intended to be used for initialization.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewEdge(System.Int32)">
            <summary>
These add a new topology piece to the b-rep and return a 
reference that is intended to be used for initialization.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewVertex(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
These add a new topology piece to the b-rep and return a 
reference that is intended to be used for initialization.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewVertex(RMA.OpenNURBS.IOn3dPoint,System.Double)">
            <summary>
These add a new topology piece to the b-rep and return a 
reference that is intended to be used for initialization.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewVertex">
            <summary>
These add a new topology piece to the b-rep and return a 
reference that is intended to be used for initialization.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimCurve(RMA.OpenNURBS.OnBrepTrim@,System.Int32)">
            <summary>Set 2d curve geometry used by a b-rep trim.</summary>
            <param name="trim">[in]</param>
            <param name="c2_index">[in] index of 2d curve in m_C2[] array</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimCurve(RMA.OpenNURBS.OnBrepTrim@,System.Int32,RMA.OpenNURBS.IOnInterval)">
            <summary>Set 2d curve geometry used by a b-rep trim.</summary>
            <param name="trim">[in]</param>
            <param name="c2_index">[in] index of 2d curve in m_C2[] array</param>
            <param name="sub_domain">
[in] if not NULL, sub_domain is an increasing
sub interval of m_C2[c2_index]-&gt;Domain().
</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetEdgeCurve(RMA.OpenNURBS.OnBrepEdge@,System.Int32)">
            <summary>Set 3d curve geometry used by a b-rep edge.</summary>
            <param name="edge">[in]</param>
            <param name="c3_index">[in] index of 3d curve in m_C3[] array</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetEdgeCurve(RMA.OpenNURBS.OnBrepEdge@,System.Int32,RMA.OpenNURBS.IOnInterval)">
            <summary>Set 3d curve geometry used by a b-rep edge.</summary>
            <param name="edge">[in]</param>
            <param name="c3_index">[in] index of 3d curve in m_C3[] array</param>
            <param name="sub_domain">
[in] if not NULL, sub_domain is an increasing
sub interval of m_C3[c3_index]-&gt;Domain().
</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.AddSurface(RMA.OpenNURBS.OnSurface)">
            <summary>
These add a new geometry piece to the b-rep and return the
index that should be used to reference the geometry.
-1 is returned if the input is not acceptable.
~ON_Brep() will delete the geometry.
</summary>
            <param name="arg1">3d surface used by ON_BrepFace</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.AddEdgeCurve(RMA.OpenNURBS.OnCurve)">
            <summary>
These add a new geometry piece to the b-rep and return the
index that should be used to reference the geometry.
-1 is returned if the input is not acceptable.
~ON_Brep() will delete the geometry.
</summary>
            <param name="arg1">3d curve used by ON_BrepEdge</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.AddTrimCurve(RMA.OpenNURBS.OnCurve)">
            <summary>
These add a new geometry piece to the b-rep and return the
index that should be used to reference the geometry.
-1 is returned if the input is not acceptable.
~ON_Brep() will delete the geometry.
</summary>
            <param name="arg1">2d curve used by ON_BrepTrim</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SplitKinkyEdge(System.Int32)">
            <summary>Split the edge into G1 pieces.</summary>
            <param name="edge_index">[in] Index of the edge to test and split.</param>
            <returns>True if successful.</returns>
            <remarks>
This function leaves deleted stuff in the brep. Call ON_Brep::Compact() to remove deleted stuff.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SplitKinkyEdge(System.Int32,System.Double)">
            <summary>Split the edge into G1 pieces.</summary>
            <param name="edge_index">[in] Index of the edge to test and split.</param>
            <param name="kink_tol_radians">[in] kink tolerance</param>
            <returns>True if successful.</returns>
            <remarks>
This function leaves deleted stuff in the brep. Call ON_Brep::Compact() to remove deleted stuff.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SplitKinkyFace(System.Int32)">
            <summary>Split the face into G1 pieces.</summary>
            <param name="face_index">[in] Index of the face to test and split.</param>
            <returns>True if successful.</returns>
            <remarks>
This function leaves deleted stuff in the brep. Call ON_Brep::Compact() to remove deleted stuff.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SplitKinkyFace(System.Int32,System.Double)">
            <summary>Split the face into G1 pieces.</summary>
            <param name="face_index">[in] Index of the face to test and split.</param>
            <param name="kink_tol_radians">[in] kink tolerance</param>
            <returns>True if successful.</returns>
            <remarks>
This function leaves deleted stuff in the brep. Call ON_Brep::Compact() to remove deleted stuff.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SplitKinkyFaces">
            <summary>Split any faces with creases into G1 pieces.</summary>
            <returns>True if successful.</returns>
            <remarks>
If you need to detect when splitting occured, comare the before and after values of m_F.Count().
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SplitKinkyFaces(System.Double)">
            <summary>Split any faces with creases into G1 pieces.</summary>
            <param name="kink_tol_radians">[in] kink tolerance</param>
            <returns>True if successful.</returns>
            <remarks>
If you need to detect when splitting occured, comare the before and after values of m_F.Count().
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SplitKinkyFaces(System.Double,System.Boolean)">
            <summary>Split any faces with creases into G1 pieces.</summary>
            <param name="kink_tol_radians">[in] kink tolerance</param>
            <param name="bCompactIfNeeded">
[in] If true and splitting is performed,
ON_Brep::Compact() will be called to clean up the unsued parts.
</param>
            <returns>True if successful.</returns>
            <remarks>
If you need to detect when splitting occured, comare the before and after values of m_F.Count().
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.RebuildTrimsForV2(RMA.OpenNURBS.OnBrepFace@,RMA.OpenNURBS.IOnNurbsSurface)">
            <summary>
No support is available for this function. Expert user function
used by MakeValidForV2 to convert trim curves from one surface
to its NURBS form. After calling this function, you need to change
the face's surface to nurbs_surface.
</summary>
            <param name="face">
[in] face whose underlying surface has a parameterization that
is different from its NURBS form.
</param>
            <param name="nurbs_surface">[in] NURBS form of the face's underlying surface</param>
            <remarks>
Don't call this function unless you know exactly what you are doing. No support is available.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.MakeValidForV2">
            <summary>
Change brep so it is valid for saving in V2 3DM archives.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.IsValidForV2">
            <summary>
Tests brep to see if it is valid for 
saving in V2 3DM archives.
</summary>
            <returns>true if brep is valid for V2 3DM archives.</returns>
            <remarks>V2 breps could not have dangling curves.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.IsValidTolerancesAndFlags">
            <summary>
Expert user function that tests the brep to see if its tolerances and flags are valid.
The values of brep.IsValidTopology() and brep.IsValidGeometry() must be true before
brep.IsValidTolerancesAndFlags() can be safely called.
</summary>
            <returns>
true brep tolerance and flags are valid
false brep tolerance and flags are not valid
</returns>
            <remarks>
ON_Brep::IsValidTopology and ON_Brep::IsValidGeometry must be true before
you can safely call ON_Brep::IsValidTolerancesAndFlags.
See Also: ON_Brep::IsValid ON_Brep::IsValidTopology ON_Brep::IsValidGeometry
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.IsValidTolerancesAndFlags(RMA.OpenNURBS.OnTextLog)">
            <summary>
Expert user function that tests the brep to see if its tolerances and flags are valid.
The values of brep.IsValidTopology() and brep.IsValidGeometry() must be true before
brep.IsValidTolerancesAndFlags() can be safely called.
</summary>
            <param name="text_log">
[in] if the brep tolerance or flags are not valid and text_log is not NULL,
then a brief english description of the problem is appended to the log.
The information appended to text_log is suitable for low-level debugging
purposes by programmers and is not intended to be useful as a high level
user interface tool.
</param>
            <returns>
true brep tolerance and flags are valid
false brep tolerance and flags are not valid
</returns>
            <remarks>
ON_Brep::IsValidTopology and ON_Brep::IsValidGeometry must be true before
you can safely call ON_Brep::IsValidTolerancesAndFlags.
See Also: ON_Brep::IsValid ON_Brep::IsValidTopology ON_Brep::IsValidGeometry
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.IsValidGeometry">
            <summary>
Expert user function that tests the brep to see if its geometry information is valid.
The value of brep.IsValidTopology() must be true before brep.IsValidGeometry() can
be safely called.
</summary>
            <returns>
true brep geometry is valid
false brep geometry is not valid
</returns>
            <remarks>
ON_Brep::IsValidTopology must be true before you can safely
call ON_Brep::IsValidGeometry.
See Also: ON_Brep::IsValid ON_Brep::IsValidTopology ON_Brep::IsValidTolerancesAndFlags
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.IsValidGeometry(RMA.OpenNURBS.OnTextLog)">
            <summary>
Expert user function that tests the brep to see if its geometry information is valid.
The value of brep.IsValidTopology() must be true before brep.IsValidGeometry() can
be safely called.
</summary>
            <param name="text_log">
[in] if the brep geometry is not valid and text_log is not NULL,
then a brief english description of the problem is appended to the log.
The information appended to text_log is suitable for low-level debugging
purposes by programmers and is not intended to be useful as a high level
user interface tool.
</param>
            <returns>
true brep geometry is valid
false brep geometry is not valid
</returns>
            <remarks>
ON_Brep::IsValidTopology must be true before you can safely
call ON_Brep::IsValidGeometry.
See Also: ON_Brep::IsValid ON_Brep::IsValidTopology ON_Brep::IsValidTolerancesAndFlags
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.IsValidTopology">
            <summary>Tests the brep to see if its topology information is valid.</summary>
            <returns>
true brep topology is valid
false brep topology is not valid
</returns>
            <remarks>
ON_Brep::IsValidTopology can be called at any time.
See Also:
ON_Brep::IsValid
ON_Brep::IsValidGeometry
ON_Brep::IsValidTolerancesAndFlags
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.IsValidTopology(RMA.OpenNURBS.OnTextLog)">
            <summary>Tests the brep to see if its topology information is valid.</summary>
            <param name="text_log">
[in] if the brep topology is not valid and text_log is not NULL,
then a brief english description of the problem is appended to the log.
The information appended to text_log is suitable for low-level
debugging purposes by programmers and is not intended to be useful
as a high level user interface tool.
</param>
            <returns>
true brep topology is valid
false brep topology is not valid
</returns>
            <remarks>
ON_Brep::IsValidTopology can be called at any time.
See Also:
ON_Brep::IsValid
ON_Brep::IsValidGeometry
ON_Brep::IsValidTolerancesAndFlags
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Create(RMA.OpenNURBS.OnSurface)">
            <summary>
Create a brep from a surface. The resulting surface has an outer boundary made
from four trims. The trims are ordered so that they run along the south, east,
north, and then west side of the surface's parameter space.
</summary>
            <param name="pSurface">
[in] pointer to a surface. The brep will manage this pointer and delete it in ~ON_Brep.
</param>
            <returns>
true successful
false brep cannot be created from this surface.
</returns>
            <remarks>
The surface class must be created with new so that the delete in ~ON_Brep will not cause a crash.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@)">
            <summary>Calculate volume mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean)">
            <summary>Calculate volume mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, volume, and volume centroid.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, volume, and volume centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, volume, and volume centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Calculate volume mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, volume, and volume centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <param name="base_point">
[in] If the brep is closed, then pass ON_UNSET_VALUE.
This parameter is for expert users who are computing a volume whose
boundary is defined by several non-closed breps, surfaces, and meshes.
When computing the volume, volume centroid, or volume first moments
of a volume whose boundary is defined by several breps, surfaces, and
meshes, pass the same base_point to each call to VolumeMassProperties.
When computing the volume second moments or volume product moments of
a volume whose boundary is defined by several breps, surfaces, and meshes,
you MUST pass the entire volume's centroid as the base_point and the
input mp parameter must contain the results of a previous call to
VolumeMassProperties(mp,true,true,false,false,base_point).
In particular, in this case, you need to make two sets of calls; use first
set to calculate the volume centroid and the second set calculate the second
moments and product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RMA.OpenNURBS.IOn3dPoint,System.Double)">
            <summary>Calculate volume mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, volume, and volume centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <param name="base_point">
[in] If the brep is closed, then pass ON_UNSET_VALUE.
This parameter is for expert users who are computing a volume whose
boundary is defined by several non-closed breps, surfaces, and meshes.
When computing the volume, volume centroid, or volume first moments
of a volume whose boundary is defined by several breps, surfaces, and
meshes, pass the same base_point to each call to VolumeMassProperties.
When computing the volume second moments or volume product moments of
a volume whose boundary is defined by several breps, surfaces, and meshes,
you MUST pass the entire volume's centroid as the base_point and the
input mp parameter must contain the results of a previous call to
VolumeMassProperties(mp,true,true,false,false,base_point).
In particular, in this case, you need to make two sets of calls; use first
set to calculate the volume centroid and the second set calculate the second
moments and product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double)">
            <summary>Calculate volume mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, volume, and volume centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <param name="base_point">
[in] If the brep is closed, then pass ON_UNSET_VALUE.
This parameter is for expert users who are computing a volume whose
boundary is defined by several non-closed breps, surfaces, and meshes.
When computing the volume, volume centroid, or volume first moments
of a volume whose boundary is defined by several breps, surfaces, and
meshes, pass the same base_point to each call to VolumeMassProperties.
When computing the volume second moments or volume product moments of
a volume whose boundary is defined by several breps, surfaces, and meshes,
you MUST pass the entire volume's centroid as the base_point and the
input mp parameter must contain the results of a previous call to
VolumeMassProperties(mp,true,true,false,false,base_point).
In particular, in this case, you need to make two sets of calls; use first
set to calculate the volume centroid and the second set calculate the second
moments and product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@)">
            <summary>Calculate area mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean)">
            <summary>Calculate area mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">
[in] true to calculate area first moments, area and area centroid.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">
[in] true to calculate area first moments, area and area centroid.
</param>
            <param name="bSecondMoments">
[in] true to calculate area second moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">
[in] true to calculate area first moments, area and area centroid.
</param>
            <param name="bSecondMoments">
[in] true to calculate area second moments.
</param>
            <param name="bProductMoments">
[in] true to calculate area product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double)">
            <summary>Calculate area mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">
[in] true to calculate area first moments, area and area centroid.
</param>
            <param name="bSecondMoments">
[in] true to calculate area second moments.
</param>
            <param name="bProductMoments">
[in] true to calculate area product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double,System.Double)">
            <summary>Calculate area mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">
[in] true to calculate area first moments, area and area centroid.
</param>
            <param name="bSecondMoments">
[in] true to calculate area second moments.
</param>
            <param name="bProductMoments">
[in] true to calculate area product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.GetMesh(RMA.OpenNURBS.IOn.mesh_type,RMA.OpenNURBS.IOnMesh[]@)">
            <summary>Get cached meshes used to render and analyze brep.</summary>
            <param name="mesh_type">[in] type of mesh to get</param>
            <param name="meshes">
[out] meshes are appended to this array.
The ON_Brep owns these meshes so the cannot be modified.
</param>
            <returns>
Number of meshes added to array. (Same as m_F.Count())
See Also:
ON_Brep::DestroyMesh
ON_BrepFace::DestroyMesh
ON_BrepFace::Mesh
ON_BrepFace::SetMesh
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.DestroyMesh(RMA.OpenNURBS.IOn.mesh_type)">
            <summary>Destroy meshes used to render and analyze brep.</summary>
            <param name="mesh_type">[in] type of mesh to destroy</param>
            <remarks>
See Also: ON_Brep::GetMesh ON_BrepFace::DestroyMesh ON_BrepFace::Mesh ON_BrepFace::SetMesh
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.DestroyMesh(RMA.OpenNURBS.IOn.mesh_type,System.Boolean)">
            <summary>Destroy meshes used to render and analyze brep.</summary>
            <param name="mesh_type">[in] type of mesh to destroy</param>
            <param name="bDeleteMesh">
[in] if true, cached meshes are deleted.
If false, pointers to cached meshes are just set to NULL.
</param>
            <remarks>
See Also: ON_Brep::GetMesh ON_BrepFace::DestroyMesh ON_BrepFace::Mesh ON_BrepFace::SetMesh
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.CreateMesh(RMA.OpenNURBS.IOnMeshParameters,RMA.OpenNURBS.OnMesh[]@)">
            <summary>
Calculates polygon mesh approximation of the brep and appends
one mesh for each face to the mesh_list[] array
</summary>
            <param name="mp">[in] meshing parameters</param>
            <param name="mesh_list">[out] meshes are appended to this array.</param>
            <returns>Number of meshes appended to mesh_list[] array.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.EmergencyDestroy">
            <summary>
call if memory pool used by b-rep members becomes invalid
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Destroy">
            <summary>returns Brep to state it has after default construction</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.IsDuplicate(RMA.OpenNURBS.IOnBrep)">
            <summary>See if this and other are same brep geometry.</summary>
            <param name="other">[in] other brep</param>
            <returns>true if breps are the same</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.IsDuplicate(RMA.OpenNURBS.IOnBrep,System.Double)">
            <summary>See if this and other are same brep geometry.</summary>
            <param name="other">[in] other brep</param>
            <param name="tolerance">[in] tolerance to use when comparing control points.</param>
            <returns>true if breps are the same</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrep.m_F">
            <value>
faces
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrep.m_L">
            <value>
loops
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrep.m_T">
            <value>
trims
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrep.m_E">
            <value>
edges
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrep.m_V">
            <value>
vertices
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrep.m_S">
            <value>
Pointers to parametric surfaces (used by faces)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrep.m_C3">
            <value>
Pointers to 3d curves (used by edges).
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrep.m_C2">
            <value>
Pointers to parameter space trimming curves (used by trims)
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.Face(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary> Get face from face index or component index.</summary>
            <param name="face_index">[in] either an index into m_F[] or a component index of type brep_face.</param>
            <returns>
If the index is a valid face index or a valid face component index,
then a pointer to the ON_BrepFace is returned. Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepFace&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.Face(System.Int32)">
            <summary> Get face from face index or component index.</summary>
            <param name="face_index">[in] either an index into m_F[] or a component index of type brep_face.</param>
            <returns>
If the index is a valid face index or a valid face component index,
then a pointer to the ON_BrepFace is returned. Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepFace&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.Loop(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get loop from loop index or component index.</summary>
            <param name="loop_index">[in] either an index into m_L[] or a component index of type brep_loop.</param>
            <returns>
If the index is a valid loop index or a valid loop component index,
then a pointer to the ON_BrepLoop is returned. Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepLoop&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.Loop(System.Int32)">
            <summary>Get loop from loop index or component index.</summary>
            <param name="loop_index">[in] either an index into m_L[] or a component index of type brep_loop.</param>
            <returns>
If the index is a valid loop index or a valid loop component index,
then a pointer to the ON_BrepLoop is returned. Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepLoop&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.Trim(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get trim from trim index or component index.</summary>
            <param name="trim_index">[in] either an index into m_T[] or a component index of type brep_trim.</param>
            <returns>
If the index is a valid trim index or a valid trim component index,
then a pointer to the ON_BrepTrim is returned. Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepTrim&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.Trim(System.Int32)">
            <summary>Get trim from trim index or component index.</summary>
            <param name="trim_index">[in] either an index into m_T[] or a component index of type brep_trim.</param>
            <returns>
If the index is a valid trim index or a valid trim component index,
then a pointer to the ON_BrepTrim is returned. Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepTrim&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.Edge(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get trim from edge index or component index.</summary>
            <param name="edge_index">[in] either an index into m_E[] or a component index of type brep_edge.</param>
            <returns>
If the index is a valid edge index or a valid edge component index,
then a pointer to the ON_BrepEdge is returned.
Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepEdge&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.Edge(System.Int32)">
            <summary>Get trim from edge index or component index.</summary>
            <param name="edge_index">[in] either an index into m_E[] or a component index of type brep_edge.</param>
            <returns>
If the index is a valid edge index or a valid edge component index,
then a pointer to the ON_BrepEdge is returned.
Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepEdge&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.Vertex(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get vertex from trim index or component index</summary>
            <param name="vertex_index">[in] either an index into m_V[] or a component index of type brep_vertex.</param>
            <returns>
If the index is a valid vertex index or a valid vertex component index,
then a pointer to the ON_BrepVertex is returned. Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepVertex&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.Vertex(System.Int32)">
            <summary>Get vertex from trim index or component index</summary>
            <param name="vertex_index">[in] either an index into m_V[] or a component index of type brep_vertex.</param>
            <returns>
If the index is a valid vertex index or a valid vertex component index,
then a pointer to the ON_BrepVertex is returned. Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepVertex&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.BrepComponent(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get a brep component from its index.</summary>
            <param name="component_index">[in]</param>
            <returns>
A const pointer to the component. Do not delete the returned object.
It points to an object managed by this brep.
</returns>
            <remarks>
See Also:
ON_Brep::Face
ON_Brep::Edge
ON_Brep::Loop
ON_Brep::Trim 
ON_Brep::Vertex
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.NextEdge(System.Int32,System.Int32)">
            <summary>
This is a simple tool for getting running through the edges that begin and end at a vertex.
</summary>
            <param name="current_edge_index">[in]</param>
            <param name="endi">[in] 0 = use the edge start vertex, 1 = use the edge end vertex</param>
            <returns>
edge index of the next edge or -1 if there is only one edge that begins or ends at the vertex.
</returns>
            <remarks>
This is a tool that simplifies searching through the ON_BrepVertex.m_ei[] array.
The edges are in no particular order.
See Also: ON_Brep::NextEdge
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.NextEdge(System.Int32,System.Int32,System.Int32@)">
            <summary>
This is a simple tool for getting running through the edges that begin and end at a vertex.
</summary>
            <param name="current_edge_index">[in]</param>
            <param name="endi">[in] 0 = use the edge start vertex, 1 = use the edge end vertex</param>
            <param name="next_endi">
[out] 0 if next edge begins at the vertex, 1 if next edge ends at the vertex
</param>
            <returns>
edge index of the next edge or -1 if there is only one edge that begins or ends at the vertex.
</returns>
            <remarks>
This is a tool that simplifies searching through the ON_BrepVertex.m_ei[] array.
The edges are in no particular order.
See Also: ON_Brep::NextEdge
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.PrevEdge(System.Int32,System.Int32)">
            <summary>
This is a simple tool for getting running through the edges that begin and end at a vertex.
</summary>
            <param name="current_edge_index">[in]</param>
            <param name="endi">[in] 0 = use the edge start vertex, 1 = use the edge end vertex</param>
            <returns>
edge index of the previous edge or -1 if there is only one edge that begins or ends at the vertex.
</returns>
            <remarks>
This is a tool that simplifies searching through the ON_BrepVertex.m_ei[] array.
The edges are in no particular order.
See Also: ON_Brep::NextEdge
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.PrevEdge(System.Int32,System.Int32,System.Int32@)">
            <summary>
This is a simple tool for getting running through the edges that begin and end at a vertex.
</summary>
            <param name="current_edge_index">[in]</param>
            <param name="endi">[in] 0 = use the edge start vertex, 1 = use the edge end vertex</param>
            <param name="prev_endi">
[out] 0 if previous edge begins at the vertex, 1 if previous edge ends at the vertex
</param>
            <returns>
edge index of the previous edge or -1 if there is only one edge that begins or ends at the vertex.
</returns>
            <remarks>
This is a tool that simplifies searching through the ON_BrepVertex.m_ei[] array.
The edges are in no particular order.
See Also: ON_Brep::NextEdge
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.NextTrim(System.Int32)">
            <summary>
for moving around loops - returns trim index of next trim in loop
</summary>
            <param name="index">index of current trim (m_trim_index)</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.PrevTrim(System.Int32)">
            <summary>
for moving around loops - returns trim index of prev trim in loop
</summary>
            <param name="index">index of current trim (m_trim_index)</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.DuplicateFaces(System.Int32[],System.Boolean)">
            <summary>Duplicate a a subset of a brep</summary>
            <param name="face_index">[in] array of face indices</param>
            <param name="bDuplicateMeshes">[in] if true, any attached meshes are duplicated</param>
            <returns>A brep made by duplicating the faces listed in the face_index[] array.</returns>
            <remarks>
The m_vertex_user.i, m_edge_user.i, m_face_user.i, m_loop_user.i,
and m_trim_user.i values of the returned brep are are set to the 
indices of the objects they duplicate.
See Also:
ON_Brep::DuplicateFace
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.DuplicateFace(System.Int32,System.Boolean)">
            <summary>Duplicate a single brep face.</summary>
            <param name="face_index">[in] index of face to duplicate</param>
            <param name="bDuplicateMeshes">[in] if true, any attached meshes are duplicated</param>
            <returns>Single face brep.</returns>
            <remarks>
The m_vertex_user.i, m_edge_user.i, m_face_user.i, m_loop_user.i,
and m_trim_user.i values of the returned brep are are set to the 
indices of the objects they duplicate.
See Also:
ON_Brep::DeleteFace, ON_Brep::ExtractFace
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.RegionTopology">
            <summary>
Get region topology information:
In order to keep the ON_Brep class efficient, rarely used
region topology information is not maintained.  If you 
require this information, call RegionTopology().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.SubBrep(System.Int32[],RMA.OpenNURBS.OnBrep)">
            <summary>Copy a subset of this brep.</summary>
            <param name="sub_fi">
[in] array of face indices in this brep to copy. (If any values in sub_fi[]
are out of range or if sub_fi[] contains duplicates, this function will return null.)
</param>
            <param name="sub_brep">
[in] if this pointer is not null, then the subbrep will be created in this class.
</param>
            <returns>
If the input is valid, a pointer to the subbrep is returned.
If the input is not valid, null is returned.  The faces in
in the subbrep's m_F array are in the same
order as they were specified in sub_fi[].
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.GetConnectedComponents(RMA.OpenNURBS.OnBrep[]@,System.Boolean)">
            <summary>
If this brep has two or more connected components,
then duplicates of the connected components are appended to the components[] array.
</summary>
            <param name="components">[in] connected components are appended to this array.</param>
            <param name="bDuplicateMeshes">[in] if true, any meshes on this brep are copied to the output breps.</param>
            <returns>
Number of connected components appended to components[] or
zero if this brep has only one connected component.
See Also: ON_Brep::GetConnectedComponents
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.GetEdgeParameter(System.Int32,System.Double,System.Double@)">
            <summary>
Given a trim and parameter on the 2d trim curve, get the corresponding parameter on the 3d edge curve.
</summary>
            <param name="trim_index">[in] index of trim in m_T array</param>
            <param name="trim_t">[in] parameter on 2d trim curve</param>
            <param name="edge_t">[out] parameter on 3d edge</param>
            <returns>
TRUE successful
FALSE failure - edge_t not set
See Also: TL_Brep::GetTrimParameter
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.GetTrimParameter(System.Int32,System.Double,System.Double@)">
            <summary>
Given a trim and parameter on the corresponding 3d edge, get the corresponding parameter on the 2d trim curve.
</summary>
            <param name="trim_index">[in] index of trim in m_T array</param>
            <param name="edge_t">[in] parameter on 3d edge</param>
            <param name="trim_t">[out] parameter on 2d trim curve</param>
            <returns>
TRUE successful
FALSE failure - trim_t not set
See Also: TL_Brep::GetEdgeParameter
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.GetTrimParameter(System.Int32,System.Double,System.Double@,System.Boolean)">
            <summary>
Given a trim and parameter on the corresponding 3d edge, get the corresponding parameter on the 2d trim curve.
</summary>
            <param name="trim_index">[in] index of trim in m_T array</param>
            <param name="edge_t">[in] parameter on 3d edge</param>
            <param name="trim_t">[out] parameter on 2d trim curve</param>
            <param name="bOkToBuildTrimPline">
[in] if TRUE and m_T[trim_index].m_pline[] does not have its edge parameters set,
then they are filled in. This is slow the first time, but greatly increases the
speed of GetTrimParameter and GetEdgeParameter on subsequent calls.
</param>
            <returns>
TRUE successful
FALSE failure - trim_t not set
See Also: TL_Brep::GetEdgeParameter
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.SortFaceLoops(RMA.OpenNURBS.OnBrepFace@)">
            <summary>
Sort the face.m_li[] array by loop type (outer, inner, slit, crvonsrf, ptonsrf)
</summary>
            <param name="face">[in/out] face whose m_li[] array should be sorted.</param>
            <returns>
true success
false failure - no loops or loops with unset loop.m_type
See Also: ON_Brep::ComputeLoopType ON_Brep::LoopDirection
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.LoopDirection(RMA.OpenNURBS.IOnBrepLoop)">
            <summary>
LoopDirection() examines the 2d trimming curve geometry that defines
the loop and returns
 +1    the loop is a counter-clockwise loop.
 -1    the loop is a clockwise loop.
  0    the loop is not a continuous closed loop.
Since LoopDirection() calculates its result based on the 2d trimming
curve geometry, it can be use to set ON_BrepLoop::m_type to outer/inner
when translating from data definition where this distinction is murky.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.LoopIsSurfaceBoundary(System.Int32)">
            <summary>
returns true if the loop's trims all run along the edge's of the underlying surface's
parameter space.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.FaceIsSurface(System.Int32)">
            <summary>
returns true if the face has a single outer boundary and that boundary runs
along the edges of the underlying surface. In this case the geometry of the surface
is the same as the geometry of the face. If FaceIsSurface() is true, then
m_S[m_F[face_index].m_si] is the surface. The flag m_F[face_index].m_bRev records
the correspondence between the surface's natural parametric orientation and the
orientation of face in the b-rep.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.IsSurface">
            <summary>
returns true if the b-rep has a single face
and that face is geometrically the same
as the underlying surface.  I.e., the face
has trivial trimming.  In this case, the
surface is m_S[0].
The flag m_F[0].m_bRev records
the correspondence between the surface's
natural parametric orientation and the
orientation of the b-rep.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.IsPointInside(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Boolean)">
            <summary>
Determine if P is inside Brep.  This question only makes sense
when the brep is a closed manifold.  This function does not
not check for closed or manifold, so result is not valid in
those cases.  Intersects a line through P with brep, finds
the intersection point Q closest to P, and looks at face 
normal at Q.  If the point Q is on an edge or the intersection
is not transverse at Q, then another line is used.
</summary>
            <param name="P">[in] 3d point</param>
            <param name="tolerance">
[in] 3d distance tolerance used for intersection and determining strict inclusion.
</param>
            <param name="bStrictlyInside">
[in] If bStrictlInside is true, then this function will return false
if the distance from P is within tolerance of a brep face.
</param>
            <returns>True if P is in, false if not. See parameter bStrictlyIn.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.IsManifold">
            <summary>Test brep to see if it is an oriented manifold.</summary>
            <returns>
true brep is a manifold
false brep is not a manifold
</returns>
            <seealso>ON_Brep::IsSolid</seealso>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.IsManifold(System.Boolean@)">
            <summary>Test brep to see if it is an oriented manifold.</summary>
            <param name="pbIsOriented">
[in] if not null, *pbIsOriented is set to true if b-rep is an oriented
manifold and false if brep is not an oriented manifold.
</param>
            <returns>
true brep is a manifold
false brep is not a manifold
</returns>
            <seealso>ON_Brep::IsSolid</seealso>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.IsManifold(System.Boolean@,System.Boolean@)">
            <summary>Test brep to see if it is an oriented manifold.</summary>
            <param name="pbIsOriented">
[in] if not null, *pbIsOriented is set to true if b-rep is an oriented
manifold and false if brep is not an oriented manifold.
</param>
            <param name="pbHasBoundary">
[in] if not null, *pbHasBoundary is set to true if b-rep has a boundary edge
and false if brep does not have a boundary edge.
</param>
            <returns>
true brep is a manifold
false brep is not a manifold
</returns>
            <seealso>ON_Brep::IsSolid</seealso>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.IsSolid">
            <summary>
Test brep to see if it is a solid. (A "solid" is a closed oriented manifold.)
</summary>
            <returns>
true brep is a solid fals brep is not a solid
See Also: ON_Brep::SolidOrientation ON_Brep::IsManifold
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.SolidOrientation">
            <summary>Determine orientation of a brep.</summary>
            <returns>
+2 brep is a solid but orientation cannot be computed
+1 brep is a solid with outward facing normals
-1 brep is a solid with inward facing normals
0 brep is not a solid
</returns>
            <remarks>
The base class implementation returns 2 or 0. This function is 
overridden in the Rhino SDK and returns +1, -1, or 0.
See Also: ON_Brep::IsSolid
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.Loop2dCurve(RMA.OpenNURBS.IOnBrepLoop)">
            <summary>Get a 3d curve that traces the entire loop</summary>
            <param name="loop">[in] loop whose 2d curve should be duplicated</param>
            <returns>A pointer to a 2d ON_Curve. The caller must delete this curve.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.Loop3dCurve(RMA.OpenNURBS.IOnBrepLoop,RMA.OpenNURBS.OnCurve[]@)">
            <summary>Get a list of 3d curves that trace the non-seam edge portions of an entire loop</summary>
            <param name="loop">[in] loop whose 3d curve should be duplicated</param>
            <param name="curve_list">[out] 3d curves are appended to this list</param>
            <returns>Number of curves appended to curve_list.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.Loop3dCurve(RMA.OpenNURBS.IOnBrepLoop,RMA.OpenNURBS.OnCurve[]@,System.Boolean)">
            <summary>Get a list of 3d curves that trace the non-seam edge portions of an entire loop</summary>
            <param name="loop">[in] loop whose 3d curve should be duplicated</param>
            <param name="curve_list">[out] 3d curves are appended to this list</param>
            <param name="bRevCurveIfFaceRevIsTrue">
[in] If false, the returned 3d curves have an orientation compatible with
the 2d curve returned by Loop2dCurve().
If true and the m_bRev flag of the loop's face is true,
then the returned curves are reversed.
</param>
            <returns>Number of curves appended to curve_list.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.Loop3dCurve(RMA.OpenNURBS.IOnBrepLoop)">
            <summary>Get a single 3d curve that traces the entire loop</summary>
            <param name="loop">[in] loop whose 3d curve should be duplicated</param>
            <returns>A pointer to a 3d ON_Curve. The caller must delete this curve.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.Loop3dCurve(RMA.OpenNURBS.IOnBrepLoop,System.Boolean)">
            <summary>Get a single 3d curve that traces the entire loop</summary>
            <param name="loop">[in] loop whose 3d curve should be duplicated</param>
            <param name="bRevCurveIfFaceRevIsTrue">
[in] If false, the returned 3d curve has an orientation compatible with the
2d curve returned by Loop2dCurve().
If true and the m_bRev flag of the loop's face is true,
then the returned curve is reversed.
</param>
            <returns>A pointer to a 3d ON_Curve. The caller must delete this curve.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.TrimCurveUseCount(System.Int32)">
            <summary>Determine how many brep trims reference m_C2[c2_index].</summary>
            <param name="c2_index">[in] index of the 2d curve in m_C2[] array</param>
            <returns>Number of brep trims that reference the 2d curve.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.TrimCurveUseCount(System.Int32,System.Int32)">
            <summary>Determine how many brep trims reference m_C2[c2_index].</summary>
            <param name="c2_index">[in] index of the 2d curve in m_C2[] array</param>
            <param name="max_count">
[in] counting stops if max_count &gt; 0 and at least max_count trims use the 2d curve.
</param>
            <returns>Number of brep trims that reference the 2d curve.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.EdgeCurveUseCount(System.Int32)">
            <summary>Determine how many brep edges reference m_C3[c3_index].</summary>
            <param name="c3_index">[in] index of the 3d curve in m_C3[] array</param>
            <returns>Number of brep edges that reference the 3d curve.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.EdgeCurveUseCount(System.Int32,System.Int32)">
            <summary>Determine how many brep edges reference m_C3[c3_index].</summary>
            <param name="c3_index">[in] index of the 3d curve in m_C3[] array</param>
            <param name="max_count">
[in] counting stops if max_count &gt; 0 and at least max_count edges use the 3d curve.
</param>
            <returns>Number of brep edges that reference the 3d curve.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.SurfaceUseCount(System.Int32)">
            <summary>Determine how many brep faces reference m_S[surface_index].</summary>
            <param name="surface_index">[in] index of the surface in m_S[] array</param>
            <returns>Number of brep faces that reference the surface.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.SurfaceUseCount(System.Int32,System.Int32)">
            <summary>Determine how many brep faces reference m_S[surface_index].</summary>
            <param name="surface_index">[in] index of the surface in m_S[] array</param>
            <param name="max_count">[in] counting stops if max_count &gt; 0 and at least max_count faces use the surface.</param>
            <returns>Number of brep faces that reference the surface.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.SetEdgeTolerance(RMA.OpenNURBS.OnBrepEdge@)">
            <summary>
These set the various tolerances.  The optional BOOL argument
is called bLazy.  If bLazy is false, the tolerance is recomputed
from its definition.  If bLazy is true, the tolerance is computed
only if its current value is negative.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.SetEdgeTolerance(RMA.OpenNURBS.OnBrepEdge@,System.Boolean)">
            <summary>
These set the various tolerances.  The optional BOOL argument
is called bLazy.  If bLazy is false, the tolerance is recomputed
from its definition.  If bLazy is true, the tolerance is computed
only if its current value is negative.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.SetTrimTolerance(RMA.OpenNURBS.OnBrepTrim@)">
            <summary>
These set the various tolerances.  The optional BOOL argument
is called bLazy.  If bLazy is false, the tolerance is recomputed
from its definition.  If bLazy is true, the tolerance is computed
only if its current value is negative.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.SetTrimTolerance(RMA.OpenNURBS.OnBrepTrim@,System.Boolean)">
            <summary>
These set the various tolerances.  The optional BOOL argument
is called bLazy.  If bLazy is false, the tolerance is recomputed
from its definition.  If bLazy is true, the tolerance is computed
only if its current value is negative.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.SetVertexTolerance(RMA.OpenNURBS.OnBrepVertex@)">
            <summary>
These set the various tolerances.  The optional BOOL argument
is called bLazy.  If bLazy is false, the tolerance is recomputed
from its definition.  If bLazy is true, the tolerance is computed
only if its current value is negative.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.SetVertexTolerance(RMA.OpenNURBS.OnBrepVertex@,System.Boolean)">
            <summary>
These set the various tolerances.  The optional BOOL argument
is called bLazy.  If bLazy is false, the tolerance is recomputed
from its definition.  If bLazy is true, the tolerance is computed
only if its current value is negative.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.ComputeLoopType(RMA.OpenNURBS.IOnBrepLoop)">
            <summary>
This function examines the 2d parameter space curves and returns
the loop's type based on their orientation.  Use this function for
debugging loop orientation problems.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.GetTrim3dEnd(System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>
GetTrim3dEnd() evaluates the 3d surface at the end of the
parameter space (2d) trim curve.
</summary>
            <param name="trim_index">index of ON_BrepTrim in m_T[] array</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.GetTrim3dStart(System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>
GetTrim3dStart() evaluates the 3d surface at the start of the
parameter space (2d) trim curve.
</summary>
            <param name="trim_index">index of ON_BrepTrim in m_T[] array</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.GetTrim2dEnd(System.Int32,RMA.OpenNURBS.On2dPoint@)">
            <summary>
GetTrim2dEnd() evaluates end of the
parameter space (2d) trim curve.
</summary>
            <param name="trim_index">index of ON_BrepTrim in m_T[] array</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.GetTrim2dStart(System.Int32,RMA.OpenNURBS.On2dPoint@)">
            <summary>
GetTrim2dStart() evaluates the start of the
parameter space (2d) trim curve.
</summary>
            <param name="trim_index">index of ON_BrepTrim in m_T[] array</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.TrimType(RMA.OpenNURBS.IOnBrepTrim)">
            <summary>
Calculate the type (singular, mated, boundary, etc.) of an ON_BrepTrim object.
</summary>
            <param name="trim">[in]</param>
            <returns>Type of trim.</returns>
            <remarks>
The trim must be connected to a valid loop. See Also: ON_Brep::SetTrimTypeFlags
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.TrimType(RMA.OpenNURBS.IOnBrepTrim,System.Boolean)">
            <summary>
Calculate the type (singular, mated, boundary, etc.) of an ON_BrepTrim object.
</summary>
            <param name="trim">[in]</param>
            <param name="bLazy">
[in] if true and trim.m_type is set to something other than ON_BrepTrim::unknown,
then no calculation is performed and the value of trim.m_type is returned.
If false, the value of trim.m_type is ignored and is caluculated.
</param>
            <returns>Type of trim.</returns>
            <remarks>
The trim must be connected to a valid loop. See Also: ON_Brep::SetTrimTypeFlags
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.IsValidForV2">
            <summary>
Tests brep to see if it is valid for 
saving in V2 3DM archives.
</summary>
            <returns>true if brep is valid for V2 3DM archives.</returns>
            <remarks>V2 breps could not have dangling curves.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.IsValidTolerancesAndFlags">
            <summary>
Expert user function that tests the brep to see if its tolerances and flags are valid.
The values of brep.IsValidTopology() and brep.IsValidGeometry() must be true before
brep.IsValidTolerancesAndFlags() can be safely called.
</summary>
            <returns>
true brep tolerance and flags are valid
false brep tolerance and flags are not valid
</returns>
            <remarks>
ON_Brep::IsValidTopology and ON_Brep::IsValidGeometry must be true before
you can safely call ON_Brep::IsValidTolerancesAndFlags.
See Also: ON_Brep::IsValid ON_Brep::IsValidTopology ON_Brep::IsValidGeometry
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.IsValidTolerancesAndFlags(RMA.OpenNURBS.OnTextLog)">
            <summary>
Expert user function that tests the brep to see if its tolerances and flags are valid.
The values of brep.IsValidTopology() and brep.IsValidGeometry() must be true before
brep.IsValidTolerancesAndFlags() can be safely called.
</summary>
            <param name="text_log">
[in] if the brep tolerance or flags are not valid and text_log is not NULL,
then a brief english description of the problem is appended to the log.
The information appended to text_log is suitable for low-level debugging
purposes by programmers and is not intended to be useful as a high level
user interface tool.
</param>
            <returns>
true brep tolerance and flags are valid
false brep tolerance and flags are not valid
</returns>
            <remarks>
ON_Brep::IsValidTopology and ON_Brep::IsValidGeometry must be true before
you can safely call ON_Brep::IsValidTolerancesAndFlags.
See Also: ON_Brep::IsValid ON_Brep::IsValidTopology ON_Brep::IsValidGeometry
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.IsValidGeometry">
            <summary>
Expert user function that tests the brep to see if its geometry information is valid.
The value of brep.IsValidTopology() must be true before brep.IsValidGeometry() can
be safely called.
</summary>
            <returns>
true brep geometry is valid
false brep geometry is not valid
</returns>
            <remarks>
ON_Brep::IsValidTopology must be true before you can safely
call ON_Brep::IsValidGeometry.
See Also: ON_Brep::IsValid ON_Brep::IsValidTopology ON_Brep::IsValidTolerancesAndFlags
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.IsValidGeometry(RMA.OpenNURBS.OnTextLog)">
            <summary>
Expert user function that tests the brep to see if its geometry information is valid.
The value of brep.IsValidTopology() must be true before brep.IsValidGeometry() can
be safely called.
</summary>
            <param name="text_log">
[in] if the brep geometry is not valid and text_log is not NULL,
then a brief english description of the problem is appended to the log.
The information appended to text_log is suitable for low-level debugging
purposes by programmers and is not intended to be useful as a high level
user interface tool.
</param>
            <returns>
true brep geometry is valid
false brep geometry is not valid
</returns>
            <remarks>
ON_Brep::IsValidTopology must be true before you can safely
call ON_Brep::IsValidGeometry.
See Also: ON_Brep::IsValid ON_Brep::IsValidTopology ON_Brep::IsValidTolerancesAndFlags
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.IsValidTopology">
            <summary>Tests the brep to see if its topology information is valid.</summary>
            <returns>
true brep topology is valid
false brep topology is not valid
</returns>
            <remarks>
ON_Brep::IsValidTopology can be called at any time.
See Also:
ON_Brep::IsValid
ON_Brep::IsValidGeometry
ON_Brep::IsValidTolerancesAndFlags
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.IsValidTopology(RMA.OpenNURBS.OnTextLog)">
            <summary>Tests the brep to see if its topology information is valid.</summary>
            <param name="text_log">
[in] if the brep topology is not valid and text_log is not NULL,
then a brief english description of the problem is appended to the log.
The information appended to text_log is suitable for low-level
debugging purposes by programmers and is not intended to be useful
as a high level user interface tool.
</param>
            <returns>
true brep topology is valid
false brep topology is not valid
</returns>
            <remarks>
ON_Brep::IsValidTopology can be called at any time.
See Also:
ON_Brep::IsValid
ON_Brep::IsValidGeometry
ON_Brep::IsValidTolerancesAndFlags
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@)">
            <summary>Calculate volume mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean)">
            <summary>Calculate volume mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, volume, and volume centroid.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, volume, and volume centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, volume, and volume centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Calculate volume mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, volume, and volume centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <param name="base_point">
[in] If the brep is closed, then pass ON_UNSET_VALUE.
This parameter is for expert users who are computing a volume whose
boundary is defined by several non-closed breps, surfaces, and meshes.
When computing the volume, volume centroid, or volume first moments
of a volume whose boundary is defined by several breps, surfaces, and
meshes, pass the same base_point to each call to VolumeMassProperties.
When computing the volume second moments or volume product moments of
a volume whose boundary is defined by several breps, surfaces, and meshes,
you MUST pass the entire volume's centroid as the base_point and the
input mp parameter must contain the results of a previous call to
VolumeMassProperties(mp,true,true,false,false,base_point).
In particular, in this case, you need to make two sets of calls; use first
set to calculate the volume centroid and the second set calculate the second
moments and product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RMA.OpenNURBS.IOn3dPoint,System.Double)">
            <summary>Calculate volume mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, volume, and volume centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <param name="base_point">
[in] If the brep is closed, then pass ON_UNSET_VALUE.
This parameter is for expert users who are computing a volume whose
boundary is defined by several non-closed breps, surfaces, and meshes.
When computing the volume, volume centroid, or volume first moments
of a volume whose boundary is defined by several breps, surfaces, and
meshes, pass the same base_point to each call to VolumeMassProperties.
When computing the volume second moments or volume product moments of
a volume whose boundary is defined by several breps, surfaces, and meshes,
you MUST pass the entire volume's centroid as the base_point and the
input mp parameter must contain the results of a previous call to
VolumeMassProperties(mp,true,true,false,false,base_point).
In particular, in this case, you need to make two sets of calls; use first
set to calculate the volume centroid and the second set calculate the second
moments and product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double)">
            <summary>Calculate volume mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, volume, and volume centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <param name="base_point">
[in] If the brep is closed, then pass ON_UNSET_VALUE.
This parameter is for expert users who are computing a volume whose
boundary is defined by several non-closed breps, surfaces, and meshes.
When computing the volume, volume centroid, or volume first moments
of a volume whose boundary is defined by several breps, surfaces, and
meshes, pass the same base_point to each call to VolumeMassProperties.
When computing the volume second moments or volume product moments of
a volume whose boundary is defined by several breps, surfaces, and meshes,
you MUST pass the entire volume's centroid as the base_point and the
input mp parameter must contain the results of a previous call to
VolumeMassProperties(mp,true,true,false,false,base_point).
In particular, in this case, you need to make two sets of calls; use first
set to calculate the volume centroid and the second set calculate the second
moments and product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@)">
            <summary>Calculate area mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean)">
            <summary>Calculate area mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">
[in] true to calculate area first moments, area and area centroid.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">
[in] true to calculate area first moments, area and area centroid.
</param>
            <param name="bSecondMoments">
[in] true to calculate area second moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">
[in] true to calculate area first moments, area and area centroid.
</param>
            <param name="bSecondMoments">
[in] true to calculate area second moments.
</param>
            <param name="bProductMoments">
[in] true to calculate area product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double)">
            <summary>Calculate area mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">
[in] true to calculate area first moments, area and area centroid.
</param>
            <param name="bSecondMoments">
[in] true to calculate area second moments.
</param>
            <param name="bProductMoments">
[in] true to calculate area product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double,System.Double)">
            <summary>Calculate area mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">
[in] true to calculate area first moments, area and area centroid.
</param>
            <param name="bSecondMoments">
[in] true to calculate area second moments.
</param>
            <param name="bProductMoments">
[in] true to calculate area product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.GetMesh(RMA.OpenNURBS.IOn.mesh_type,RMA.OpenNURBS.IOnMesh[]@)">
            <summary>Get cached meshes used to render and analyze brep.</summary>
            <param name="mesh_type">[in] type of mesh to get</param>
            <param name="meshes">
[out] meshes are appended to this array.
The ON_Brep owns these meshes so the cannot be modified.
</param>
            <returns>
Number of meshes added to array. (Same as m_F.Count())
See Also:
ON_Brep::DestroyMesh
ON_BrepFace::DestroyMesh
ON_BrepFace::Mesh
ON_BrepFace::SetMesh
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.CreateMesh(RMA.OpenNURBS.IOnMeshParameters,RMA.OpenNURBS.OnMesh[]@)">
            <summary>
Calculates polygon mesh approximation of the brep and appends
one mesh for each face to the mesh_list[] array
</summary>
            <param name="mp">[in] meshing parameters</param>
            <param name="mesh_list">[out] meshes are appended to this array.</param>
            <returns>Number of meshes appended to mesh_list[] array.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.IsDuplicate(RMA.OpenNURBS.IOnBrep)">
            <summary>See if this and other are same brep geometry.</summary>
            <param name="other">[in] other brep</param>
            <returns>true if breps are the same</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.IsDuplicate(RMA.OpenNURBS.IOnBrep,System.Double)">
            <summary>See if this and other are same brep geometry.</summary>
            <param name="other">[in] other brep</param>
            <param name="tolerance">[in] tolerance to use when comparing control points.</param>
            <returns>true if breps are the same</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrep.m_F">
            <value>
faces
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrep.m_L">
            <value>
loops
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrep.m_T">
            <value>
trims
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrep.m_E">
            <value>
edges
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrep.m_V">
            <value>
vertices
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrep.m_S">
            <value>
Pointers to parametric surfaces (used by faces)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrep.m_C3">
            <value>
Pointers to 3d curves (used by edges).
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrep.m_C2">
            <value>
Pointers to parameter space trimming curves (used by trims)
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepRegion.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RMA.OpenNURBS.On3dPoint,System.Double,System.Double)">
            <summary>Calculate volume mass properties of the region.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <param name="base_point">
[in] If the brep is closed, then pass ON_UNSET_VALUE.

This parameter is for expert users who are computing a volume whose boundary is
defined by several non-closed breps, surfaces, and meshes.

When computing the volume, volume centroid, or volume first moments of a volume
whose boundary is defined by several breps, surfaces, and meshes, pass the same 
base_point to each call to VolumeMassProperties.  

When computing the volume second moments or volume product moments of a volume
whose boundary is defined by several breps, surfaces, and meshes, you MUST pass
the entire volume's centroid as the base_point and the input mp parameter must
contain the results of a previous call to VolumeMassProperties(mp,true,true,false,false,base_point).
In particular, in this case, you need to make two sets of calls; use first set
to calculate the volume centroid and the second set calculate the second moments
and product moments.
</param>
            <param name="rel_tol">default = 1.0e-6</param>
            <param name="abs_tol">default = 1.0e-6</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepRegion.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double,System.Double)">
            <summary>Calculate area mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <param name="bProductMoments">[in] true to calculate area product moments.</param>
            <param name="rel_tol">default = 1.0e-6</param>
            <param name="abs_tol">default = 1.0e-6</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepRegion.RegionBoundaryBrep(RMA.OpenNURBS.OnBrep)">
            <summary>
Get the boundary of a region as a brep object.  
If the region is finite, the boundary will be a closed manifold brep.
The boundary may have more than one connected component.
</summary>
            <param name="brep">[in] if not NULL, the brep form is put into this brep.</param>
            <returns>the region boundary as a brep or NULL if the calculation fails</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepRegion.m_type">
            <value>0 = infinte, 1 = bounded</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepRegion.m_fsi">
            <value>indices of face sides</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepRegion.BoundingBox">
            <returns>Region bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepRegion.IsFinite">
            <returns>True if the region is finite.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepRegion.FaceSide(System.Int32)">
            <param name="fsi">[in] index into the region's m_fsi[] array.</param>
            <returns>
The face side in rtop.m_FS[m_fsi[rsi]], where rtop is the ON_BrepRegionTopology
class this region belongs to.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepRegion.RegionTopology">
            <returns>Region topology this region belongs to.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepRegion.Brep">
            <returns>Brep this region belongs to.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepRegion.m_region_index">
            <value>index of region in ON_BrepRegionTopology.m_R[] array</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepRegion.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RMA.OpenNURBS.On3dPoint,System.Double,System.Double)">
            <summary>Calculate volume mass properties of the region.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <param name="base_point">
[in] If the brep is closed, then pass ON_UNSET_VALUE.

This parameter is for expert users who are computing a volume whose boundary is
defined by several non-closed breps, surfaces, and meshes.

When computing the volume, volume centroid, or volume first moments of a volume
whose boundary is defined by several breps, surfaces, and meshes, pass the same 
base_point to each call to VolumeMassProperties.  

When computing the volume second moments or volume product moments of a volume
whose boundary is defined by several breps, surfaces, and meshes, you MUST pass
the entire volume's centroid as the base_point and the input mp parameter must
contain the results of a previous call to VolumeMassProperties(mp,true,true,false,false,base_point).
In particular, in this case, you need to make two sets of calls; use first set
to calculate the volume centroid and the second set calculate the second moments
and product moments.
</param>
            <param name="rel_tol">default = 1.0e-6</param>
            <param name="abs_tol">default = 1.0e-6</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepRegion.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double,System.Double)">
            <summary>Calculate area mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <param name="bProductMoments">[in] true to calculate area product moments.</param>
            <param name="rel_tol">default = 1.0e-6</param>
            <param name="abs_tol">default = 1.0e-6</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepRegion.RegionBoundaryBrep(RMA.OpenNURBS.OnBrep)">
            <summary>
Get the boundary of a region as a brep object.  
If the region is finite, the boundary will be a closed manifold brep.
The boundary may have more than one connected component.
</summary>
            <param name="brep">[in] if not NULL, the brep form is put into this brep.</param>
            <returns>the region boundary as a brep or NULL if the calculation fails</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepRegion.m_type">
            <value>0 = infinte, 1 = bounded</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepRegion.m_fsi">
            <value>indices of face sides</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepRegion.BoundingBox">
            <returns>Region bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepRegion.IsFinite">
            <returns>True if the region is finite.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepRegion.FaceSide(System.Int32)">
            <param name="rfsi">[in] index into the region's m_fsi[] array.</param>
            <returns>
The face side in rtop.m_FS[m_fsi[rsi]], where rtop is the ON_BrepRegionTopology
class this region belongs to.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepRegion.RegionTopology">
            <returns>Region topology this region belongs to.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepRegion.Brep">
            <returns>Brep this region belongs to.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepRegion.m_region_index">
            <value>index of region in ON_BrepRegionTopology.m_R[] array</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepFaceSide.m_srf_dir">
            <value>
 1 ON_BrepFace's surface normal points into region
-1 ON_BrepFace's surface normal points out of region
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepFaceSide.m_fi">
            <value>face index</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepFaceSide.m_ri">
            <value>
region index
m_ri = -1 indicates this faceside overlaps another faceside.
Generally this is a flaw in an ON_Brep
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFaceSide.SurfaceNormalDirection">
            <returns>
+1: underlying geometric surface normal points into region.
-1: underlying geometric surface normal points out of region.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFaceSide.Face">
            <returns>Faces this side belongs to.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFaceSide.Region">
            <returns>Region the face side belongs to</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFaceSide.RegionTopology">
            <returns>Region topology this face side belongs to.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFaceSide.Brep">
            <returns>Brep this face side belongs to.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepFaceSide.m_faceside_index">
            <value>index of face side in ON_BrepRegionTopology.m_FS[] array</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepFaceSide.m_srf_dir">
            <value>
 1 ON_BrepFace's surface normal points into region
-1 ON_BrepFace's surface normal points out of region
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepFaceSide.m_fi">
            <value>face index</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepFaceSide.m_ri">
            <value>
region index
m_ri = -1 indicates this faceside overlaps another faceside.
Generally this is a flaw in an ON_Brep
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepFaceSide.SurfaceNormalDirection">
            <returns>
+1: underlying geometric surface normal points into region.
-1: underlying geometric surface normal points out of region.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepFaceSide.Face">
            <returns>Faces this side belongs to.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepFaceSide.Region">
            <returns>Region the face side belongs to</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepFaceSide.RegionTopology">
            <returns>Region topology this face side belongs to.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepFaceSide.Brep">
            <returns>Brep this face side belongs to.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepFaceSide.m_faceside_index">
            <value>index of face side in ON_BrepRegionTopology.m_FS[] array</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFace.SurfaceOf">
            <summary>
Returns: Pointer to the surface geometry used by the face.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFace.SurfaceIndexOf">
            <summary>
Returns: brep.m_S[] surface index of the 3d surface geometry used by this face or -1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFace.ChangeSurface(System.Int32)">
            <summary>
Expert user tool that replaces the 3d surface geometry use by the face.
</summary>
            <param name="si">[in] brep surface index of new surface</param>
            <returns>True if successful.</returns>
            <example>
ON_Surface* pSurface = ...;
int si = brep.AddSurface(pSurface);
face.ChangeSurface(si);
</example>
            <remarks>
If the face had a surface and new surface has a different shape,
then you probably want to call something like ON_Brep::RebuildEdges()
to move the 3d edge curves so they will lie on the new surface.
This doesn't delete the old surface; call ON_Brep::CullUnusedSurfaces()
or ON_Brep::Compact to remove unused surfaces.
See Also: ON_Brep::RebuildEdges ON_Brep::CullUnusedSurfaces
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFace.TransformTrim(RMA.OpenNURBS.IOnXform)">
            <summary>
Expert user tool that tranforms all the parameter space (2d) trimming curves on this face.
Only 2d curve geometry is changed. The caller is responsible for reversing loops,
toggle m_bRev, flags, etc.
</summary>
            <param name="xform">[in] Transformation applied to 2d curve geometry.</param>
            <returns>True if successful. If false is returned, the brep may be invalid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFace.DestroyMesh(RMA.OpenNURBS.IOn.mesh_type)">
            <summary>
Destroy meshes used to render and analyze surface and polysrf objects.
</summary>
            <param name="mesh_type">[in] type of mesh to destroy</param>
            <remarks>
See Also:
CRhinoObject::GetMeshes
CRhinoObject::MeshCount
CRhinoObject::IsMeshable
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFace.DestroyMesh(RMA.OpenNURBS.IOn.mesh_type,System.Boolean)">
            <summary>
Destroy meshes used to render and analyze surface and polysrf objects.
</summary>
            <param name="mesh_type">[in] type of mesh to destroy</param>
            <param name="bDeleteMesh">
[in] if true, cached mesh is deleted.
If false, pointer to cached mesh is just set to NULL.
</param>
            <remarks>
See Also:
CRhinoObject::GetMeshes
CRhinoObject::MeshCount
CRhinoObject::IsMeshable
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFace.SetMesh(RMA.OpenNURBS.IOn.mesh_type,RMA.OpenNURBS.OnMesh)">
            <summary>If true is returne, then ~ON_BrepFace will delete mesh.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFace.SetDomain(RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>
Change the domain of a face
This changes the parameterization of the face's surface and transforms
the u and v coordinates of all the face's parameter space trimming
curves.  The locus of the face is not changed.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFace.SetDomain(System.Int32,System.Double,System.Double)">
            <summary>
This is an override of the virtual ON_Surface::SetDomain function.
</summary>
            <param name="dir">[in] 0 = set "u" domain, 1 = set "v" domain.</param>
            <param name="t0">[in]</param>
            <param name="t1">[in] t0 &lt; t1 The new domain is the interval (t0,t1)</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFace.ClearBoundingBox">
            <summary>
virtual ON_Geometry::ClearBoundingBox() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFace.ComponentIndex">
            <summary>
virtual ON_Geometry::ComponentIndex() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFace.FaceSide(System.Int32)">
            <param name="dir">
1: side with underlying surface normal pointing into the topology region
-1: side with underlying surface normal pointing out of the topology region
</param>
            <returns>
Brep region topology face side. If the region topology has not be created by calling
ON_Brep::RegionToplogy(), then NULL is returned.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFace.OuterLoop">
            <returns>Outer boundary loop for this face.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFace.LoopCount">
            <returns>Number of loops in this face.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFace.Loop(System.Int32)">
            <param name="fli">[in] index into the face's m_li[] array.</param>
            <returns>The loop brep.m_L[face.m_li[fli]];</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFace.Brep">
            <summary>
Returns: Brep that the face belongs to.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepFace.m_face_uuid">
            <value>
Persistent id for this face.  Default is ON_nil_uuid.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepFace.m_face_material_channel">
            <value>
m_face_material_channel provides a way to have individual
brep faces use a rendering material that is different
from the rendering material used by the parent brep.
If m_face_material_channel is zero 
channel and m_face_material_channel.m_j is the back face
materal. The default is (0,0) which indicates the face
should use the parent brep's material.
If "mat" is the brep's rendering material and
0 &lt; m_material_channel.m_i &lt; mat.m_material_channel.Count(),
then this face should use the material with id
mat.m_material_channel[face.m_material_channel.m_i-1].m_id.
If m_material_channel.m_i or the id is invalid in any way,
then the default should be used.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepFace.m_bRev">
            <value>
true if face orientation is opposite of natural surface orientation
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepFace.m_si">
            <value>
index of surface in b-rep m_S[] array
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepFace.m_li">
            <value>
loop indices (outer loop is m_li[0])
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepFace.m_face_index">
            <value>
index of face in ON_Brep.m_F[] array
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepFace.SurfaceOf">
            <summary>
Returns: Pointer to the surface geometry used by the face.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepFace.SurfaceIndexOf">
            <summary>
Returns: brep.m_S[] surface index of the 3d surface geometry used by this face or -1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepFace.ComponentIndex">
            <summary>
virtual ON_Geometry::ComponentIndex() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepFace.FaceSide(System.Int32)">
            <param name="dir">
1: side with underlying surface normal pointing into the topology region
-1: side with underlying surface normal pointing out of the topology region
</param>
            <returns>
Brep region topology face side. If the region topology has not be created by calling
ON_Brep::RegionToplogy(), then NULL is returned.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepFace.OuterLoop">
            <returns>Outer boundary loop for this face.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepFace.LoopCount">
            <returns>Number of loops in this face.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepFace.Loop(System.Int32)">
            <param name="fli">[in] index into the face's m_li[] array.</param>
            <returns>The loop brep.m_L[face.m_li[fli]];</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepFace.Brep">
            <summary>Brep that the face belongs to.</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepFace.m_face_uuid">
            <value>
Persistent id for this face.  Default is ON_nil_uuid.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepFace.m_face_material_channel">
            <value>
m_face_material_channel provides a way to have individual
brep faces use a rendering material that is different
from the rendering material used by the parent brep.
If m_face_material_channel is zero 
channel and m_face_material_channel.m_j is the back face
materal. The default is (0,0) which indicates the face
should use the parent brep's material.
If "mat" is the brep's rendering material and
0 &lt; m_material_channel.m_i &lt; mat.m_material_channel.Count(),
then this face should use the material with id
mat.m_material_channel[face.m_material_channel.m_i-1].m_id.
If m_material_channel.m_i or the id is invalid in any way,
then the default should be used.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepFace.m_bRev">
            <value>
true if face orientation is opposite of natural surface orientation
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepFace.m_si">
            <value>
index of surface in b-rep m_S[] array
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepFace.m_li">
            <value>
loop indices (outer loop is m_li[0])
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepFace.m_face_index">
            <value>
index of face in ON_Brep.m_F[] array
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepLoop.TransformTrim(RMA.OpenNURBS.IOnXform)">
            <summary>
Expert user tool that tranforms all the parameter space (2d) trimming curves in this loop.
Only 2d curve geometry is changed. The caller is responsible for reversing loops, toggle m_bRev, flags, etc.
</summary>
            <param name="xform">[in] Transformation applied to 2d curve geometry.</param>
            <returns>True if successful. If false is returned, the brep may be invalid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepLoop.SurfaceOf">
            <summary>
Returns: Pointer to the surface geometry used by the loop.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepLoop.SurfaceIndexOf">
            <summary>
Returns: brep.m_S[] surface index of the 3d surface geometry used by this loop or -1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepLoop.IndexOfTrim(RMA.OpenNURBS.IOnBrepTrim)">
            <returns>
Returns the index i such that loop.m_ti[i] = trim.m_trim_index.
Returns -1 if the trim is not in this loop
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepLoop.#ctor(System.Int32)">
            <summary>
loop index
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepLoop.TrimCount">
            <summary>
Returns: Number of trims in this loop.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepLoop.Trim(System.Int32)">
            <param name="lti">[in] index into the loop's m_ti[] array.</param>
            <returns>The trim brep.m_T[loop.m_ti[lti]];</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepLoop.Face">
            <summary>
Brep face this loop belongs to.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepLoop.Brep">
            <summary>
Brep that the loop belongs to.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepLoop.m_pbox">
            <value>
parameter space trimming loop bounding box
runtime information - not saved
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepLoop.m_fi">
            <value>
index of face that uses this loop
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepLoop.m_ti">
            <value>
trim indices
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepLoop.m_loop_index">
            <value>
index of loop in ON_Brep.m_L[] array
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepLoop.SurfaceOf">
            <summary>
Returns: Pointer to the surface geometry used by the loop.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepLoop.SurfaceIndexOf">
            <summary>
Returns: brep.m_S[] surface index of the 3d surface geometry used by this loop or -1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepLoop.IndexOfTrim(RMA.OpenNURBS.IOnBrepTrim)">
            <returns>
Returns the index i such that loop.m_ti[i] = trim.m_trim_index.
Returns -1 if the trim is not in this loop
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepLoop.TrimCount">
            <summary>
Returns: Number of trims in this loop.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepLoop.Trim(System.Int32)">
            <param name="lti">[in] index into the loop's m_ti[] array.</param>
            <returns>The trim brep.m_T[loop.m_ti[lti]];</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepLoop.Face">
            <summary>
Brep face this loop belongs to.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepLoop.Brep">
            <summary>
Brep that the loop belongs to.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepLoop.m_pbox">
            <value>
parameter space trimming loop bounding box
runtime information - not saved
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepLoop.m_fi">
            <value>
index of face that uses this loop
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepLoop.m_ti">
            <value>
trim indices
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepLoop.m_loop_index">
            <value>
index of loop in ON_Brep.m_L[] array
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.TransformTrim(RMA.OpenNURBS.IOnXform)">
            <summary>
Expert user tool that tranforms all the parameter space (2d) trimming curves in this loop.
Only 2d curve geometry is changed. The caller is responsible for reversing loops, toggle
m_bRev, flags, etc.
</summary>
            <param name="xform">[in] Transformation applied to 2d curve geometry.</param>
            <returns>True if successful. If false is returned, the brep may be invalid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.IsSeam">
            <summary>
Returns: True if the trim satisfies these four criteria.
1) is part of a loop
2) is connected to a 3d edge
3) one other trim from the same loop is connected to the edge
4) the 2d trim curve for this trim lies along the side of 
  the face's parameter space and the 2d curve for the other
  trim lies on the opposite side of the face's parameter space.
</summary>
            <remarks>
In order for IsSeam() to work correctly, the m_type and m_iso
fields must be set correctly.  In V4 SR1, this function will
be removed and ON_BrepTrim::slit will be added as a type.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.IsSlit">
            <summary>
Returns: True if the trim satisfies these four criteria.
1) is part of a loop
2) is connected to a 3d edge
3) one other trim from the same loop is connected to the edge
4) The 2d trim curve for the other trim is the reverse of the 2d trim curve for this trim.
</summary>
            <remarks>
In order for IsSlit() to work correctly, the m_type and m_iso
fields must be set correctly.  In V4 SR1, this function will
be removed and ON_BrepTrim::slit will be added as a type.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.FaceIndexOf">
            <summary>
Returns: brep.m_F[] face index of the face used by this trim or -1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.SurfaceIndexOf">
            <summary>
Returns: brep.m_S[] surface index of the 3d surface geometry used by this trim or -1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.EdgeCurveIndexOf">
            <summary>
Returns: brep.m_C3[] 3d curve index of the 3d curve geometry used by this trim or -1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.TrimCurveIndexOf">
            <summary>
Returns: brep.m_C2[] 2d curve index of the 2d curve geometry used by this trim or -1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.SurfaceOf">
            <summary>
Returns: 3d surface geometry used by this trim or NULL
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.EdgeCurveOf">
            <summary>
Returns: 3d curve geometry used by this trim or NULL.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.TrimCurveOf">
            <summary>
Returns: 2d curve geometry used by this trim or NULL
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.AttachToEdge(System.Int32,System.Boolean)">
            <summary>Expert user function. Attaches a trim to an edge.</summary>
            <param name="edge_index">[in] index of an edge.</param>
            <param name="bRev3d">[in] value for trim's m_bRev3d field.</param>
            <remarks>
If the trim is attached to an edge (m_ei&gt;=0), then the trim is
removed from the edge and the edge's m_ti[] list.
The trim's tolerance values are not changed.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.RemoveFromEdge(System.Boolean,System.Boolean)">
            <summary>
Expert user function. Removes a trim from an edge.
</summary>
            <param name="bRemoveFromStartVertex">
[in] if true, the trim is removed from its start vertex by setting m_vi[0] to -1.
</param>
            <param name="bRemoveFromEndVertex">
[in] if true, the trim is removed from its start vertex by setting m_vi[1] to -1.
</param>
            <remarks>
If the trim is attached to an edge (m_ei&gt;=0),
then the trim is removed from the edge and the edge's m_ti[] list.
The trim's m_bRev3d and tolerance values are not changed.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.ChangeTrimCurve(System.Int32)">
            <summary>
Expert user tool that replaces the 2d curve geometry of a trim
</summary>
            <param name="c2i">[in] brep 2d curve index of new curve</param>
            <returns>True if successful.</returns>
            <example>
ON_Curve* pCurve = ...;
int c2i = brep.AddTrimCurve(pCurve);
trim.ChangeTrimCurve(c2i);
</example>
            <remarks>Sets m_c2i, calls SetProxyCurve, cleans runtime caches, and updates m_pbox.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.SetEndPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Force the curve to end at a specified point.</summary>
            <param name="end_point">[in]</param>
            <returns>TRUE if successful.</returns>
            <remarks>
Some end points cannot be moved. Be sure to check return code.
See Also:
ON_Curve::SetStartPoint
ON_Curve::PointAtStart
ON_Curve::PointAtEnd
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.SetStartPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Force the curve to start at a specified point.</summary>
            <param name="start_point">[in]</param>
            <returns>TRUE if successful.</returns>
            <remarks>
Some end points cannot be moved. Be sure to check return code.
See Also:
ON_Curve::SetEndPoint
ON_Curve::PointAtStart
ON_Curve::PointAtEnd
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.ComponentIndex">
            <summary>
virtual ON_Geometry::ComponentIndex() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.Vertex(System.Int32)">
            <param name="tvi">[in] 0 or 1</param>
            <returns>Brep vertex at specified end of the trim.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.Edge">
            <summary>
Brep edge this trim uses for belongs to. This will be NULL for singular trims.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.Face">
            <summary>
Brep face this trim belongs to.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.Loop">
            <summary>
Brep loop that this trim belongs to.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.Brep">
            <summary>
Brep that this trim belongs to.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.#ctor(System.Int32)">
            <summary>
In general, you should not directly create ON_BrepTrim classes.
Use ON_Brep::NewTrim instead.
</summary>
            <param name="arg1">trim index</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.#ctor">
            <summary>
In general, you should not directly create ON_BrepTrim classes.
Use ON_Brep::NewTrim instead.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepTrim.m_pbox">
            <value>
Runtime parameter space trimming curve bounding box.
This information is not saved in 3DM archives.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepTrim.m_pline">
            <value>
Runtime polyline approximation of trimming curve.
This information is not saved in 3DM archives.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepTrim.m_tolerance(System.Int32)">
            <value>
The values in m_tolerance[] record the accuracy of
the parameter space trimming curves.
</value>
            <remarks>
m_tolerance[0] = accuracy of parameter space curve in first ( "u" ) parameter

m_tolerance[1] = accuracy of parameter space curve in second ( "v" ) parameter

A value of ON_UNSET_VALUE indicates that the tolerance should be computed.
If the value &gt;= 0.0, then the tolerance is set. If the value is 
ON_UNSET_VALUE, then the tolerance needs to be computed.

If the trim is not singular, then the trim must have an edge. If P is a
3d point on the edge curve and surface(u,v) = Q is the point on the 
surface that is closest to P, then there must be a parameter t in
the interval [m_t[0], m_t[1]] such that

|u - curve2d(t)[0]| &lt;= m_tolerance[0]
and 
|v - curve2d(t)[1]| &lt;= m_tolerance[1]

If P is the 3d point for the vertex brep.m_V[m_vi[k]] and (uk,vk) is the
corresponding end of the trim's parameter space curve, then there must be a surface
parameter (u,v) such that:
  *  the distance from the 3d point surface(u,v) to P
     is &lt;= brep.m_V[m_vi[k]].m_tolerance,
  *  |u-uk| &lt;= m_tolerance[0].
  *  |v-vk| &lt;= m_tolerance[1].
</remarks>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepTrim.m_li">
            <value>
index of loop that uses this trim
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepTrim.m_bRev3d">
            <value>
true if the 2d trim and 3d edge have opposite orientations.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepTrim.m_vi(System.Int32)">
            <value>
Indices of start/end vertices.  Trims along singular
sides and trims that correspond to closed 3d edges
have m_vi[0] = m_vi[1].  Note that singular trims
and trims on the closed edge of a closed surface can
have an open 2d trimming curve and still have 
m_vi[0] = m_vi[1].
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepTrim.m_ei">
            <value>
index of 3d edge (-1 if ON_BrepTrim is singular)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepTrim.m_c2i">
            <value>
index of the 2d parameter space trimming curve
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepTrim.m_trim_index">
            <value>
index of trim in ON_Brep.m_T[] array
</value>
        </member>
        <member name="T:RMA.OpenNURBS.OnBrepTrim">
            <summary>
Brep trim information is stored in ON_BrepTrim classes.
ON_Brep.m_T[] is an array of all the trim in the brep.

An ON_BrepTrim is derived from ON_CurveProxy so the the
trim can supply easy to use evaluation tools via 
the ON_Curve virtual member functions.

Note well that the domains and orientations of the curve
m_C2[trim.m_c2i] and the trin as a curve may not
agree.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepTrim.IsSeam">
            <summary>
Returns: True if the trim satisfies these four criteria.
1) is part of a loop
2) is connected to a 3d edge
3) one other trim from the same loop is connected to the edge
4) the 2d trim curve for this trim lies along the side of 
  the face's parameter space and the 2d curve for the other
  trim lies on the opposite side of the face's parameter space.
</summary>
            <remarks>
In order for IsSeam() to work correctly, the m_type and m_iso
fields must be set correctly.  In V4 SR1, this function will
be removed and ON_BrepTrim::slit will be added as a type.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepTrim.IsSlit">
            <summary>
Returns: True if the trim satisfies these four criteria.
1) is part of a loop
2) is connected to a 3d edge
3) one other trim from the same loop is connected to the edge
4) The 2d trim curve for the other trim is the reverse of the 2d trim curve for this trim.
</summary>
            <remarks>
In order for IsSlit() to work correctly, the m_type and m_iso
fields must be set correctly.  In V4 SR1, this function will
be removed and ON_BrepTrim::slit will be added as a type.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepTrim.FaceIndexOf">
            <summary>
Returns: brep.m_F[] face index of the face used by this trim or -1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepTrim.SurfaceIndexOf">
            <summary>
Returns: brep.m_S[] surface index of the 3d surface geometry used by this trim or -1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepTrim.EdgeCurveIndexOf">
            <summary>
Returns: brep.m_C3[] 3d curve index of the 3d curve geometry used by this trim or -1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepTrim.TrimCurveIndexOf">
            <summary>
Returns: brep.m_C2[] 2d curve index of the 2d curve geometry used by this trim or -1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepTrim.SurfaceOf">
            <summary>
Returns: 3d surface geometry used by this trim or NULL
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepTrim.EdgeCurveOf">
            <summary>
Returns: 3d curve geometry used by this trim or NULL.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepTrim.TrimCurveOf">
            <summary>
Returns: 2d curve geometry used by this trim or NULL
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepTrim.ComponentIndex">
            <summary>
virtual ON_Geometry::ComponentIndex() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepTrim.Vertex(System.Int32)">
            <param name="tvi">[in] 0 or 1</param>
            <returns>Brep vertex at specified end of the trim.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepTrim.Edge">
            <summary>
Brep edge this trim uses or belongs to. This will be NULL for singular trims.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepTrim.Face">
            <summary>
Brep face this trim belongs to.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepTrim.Loop">
            <summary>
Brep loop that this trim belongs to.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepTrim.Brep">
            <summary>
Brep that this trim belongs to.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepTrim.m_pbox">
            <value>
Runtime parameter space trimming curve bounding box.
This information is not saved in 3DM archives.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepTrim.m_pline">
            <value>
Runtime polyline approximation of trimming curve.
This information is not saved in 3DM archives.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepTrim.m_tolerance(System.Int32)">
            <value>
The values in m_tolerance[] record the accuracy of
the parameter space trimming curves.
</value>
            <remarks>
m_tolerance[0] = accuracy of parameter space curve in first ( "u" ) parameter

m_tolerance[1] = accuracy of parameter space curve in second ( "v" ) parameter

A value of ON_UNSET_VALUE indicates that the tolerance should be computed.
If the value &gt;= 0.0, then the tolerance is set. If the value is 
ON_UNSET_VALUE, then the tolerance needs to be computed.

If the trim is not singular, then the trim must have an edge. If P is a
3d point on the edge curve and surface(u,v) = Q is the point on the 
surface that is closest to P, then there must be a parameter t in
the interval [m_t[0], m_t[1]] such that

|u - curve2d(t)[0]| &lt;= m_tolerance[0]
and 
|v - curve2d(t)[1]| &lt;= m_tolerance[1]

If P is the 3d point for the vertex brep.m_V[m_vi[k]] and (uk,vk) is the
corresponding end of the trim's parameter space curve, then there must be a surface
parameter (u,v) such that:
  *  the distance from the 3d point surface(u,v) to P
     is &lt;= brep.m_V[m_vi[k]].m_tolerance,
  *  |u-uk| &lt;= m_tolerance[0].
  *  |v-vk| &lt;= m_tolerance[1].
</remarks>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepTrim.m_li">
            <value>
index of loop that uses this trim
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepTrim.m_bRev3d">
            <value>
true if the 2d trim and 3d edge have opposite orientations.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepTrim.m_vi(System.Int32)">
            <value>
Indices of start/end vertices.  Trims along singular
sides and trims that correspond to closed 3d edges
have m_vi[0] = m_vi[1].  Note that singular trims
and trims on the closed edge of a closed surface can
have an open 2d trimming curve and still have 
m_vi[0] = m_vi[1].
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepTrim.m_ei">
            <value>
index of 3d edge (-1 if ON_BrepTrim is singular)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepTrim.m_c2i">
            <value>
index of the 2d parameter space trimming curve
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepTrim.m_trim_index">
            <value>
index of trim in ON_Brep.m_T[] array
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnBrepTrim">
            <summary>
Brep trim information is stored in ON_BrepTrim classes.
ON_Brep.m_T[] is an array of all the trim in the brep.

An ON_BrepTrim is derived from ON_CurveProxy so the the
trim can supply easy to use evaluation tools via 
the ON_Curve virtual member functions.

Note well that the domains and orientations of the curve
m_C2[trim.m_c2i] and the trin as a curve may not
agree.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepEdge.ChangeEdgeCurve(System.Int32)">
            <summary>Expert user tool that replaces the 3d curve geometry of an edge</summary>
            <param name="c3i">[in] brep 3d curve index of new curve</param>
            <returns>True if successful.</returns>
            <example>
ON_Curve* pCurve = ...;
int c3i = brep.AddEdgeCurve(pCurve);
edge.ChangeEdgeCurve(c3i);
</example>
            <remarks>Sets m_c3i, calls SetProxyCurve, cleans runtime caches.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepEdge.EdgeCurveOf">
            <summary>
Returns: 3d curve geometry used by this edge or NULL.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepEdge.EdgeCurveIndexOf">
            <summary>
Returns: brep.m_C3[] index of the 3d curve geometry used by this edge or -1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepEdge.IsSmoothManifoldEdge">
            <summary>
For a manifold, non-boundary edge, decides whether or not the two surfaces on either side meet smoothly.
</summary>
            <returns>
true if edge is manifold, has exactly 2 trims, and surface normals on
either side agree to within angle_tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepEdge.IsSmoothManifoldEdge(System.Double)">
            <summary>
For a manifold, non-boundary edge, decides whether or not the two surfaces on either side meet smoothly.
</summary>
            <param name="angle_tolerance">[in] used to decide if surface normals on either side are parallel.</param>
            <returns>
true if edge is manifold, has exactly 2 trims, and surface normals on
either side agree to within angle_tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepEdge.SetEndPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Force the curve to end at a specified point.</summary>
            <param name="end_point">[in]</param>
            <returns>TRUE if successful.</returns>
            <remarks>Some end points cannot be moved. Be sure to check return code.
See Also: ON_Curve::SetStartPoint ON_Curve::PointAtStart ON_Curve::PointAtEnd
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepEdge.SetStartPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Force the curve to start at a specified point.</summary>
            <param name="start_point">[in]</param>
            <returns>TRUE if successful.</returns>
            <remarks>
Some end points cannot be moved. Be sure to check return code.
See Also: ON_Curve::SetEndPoint ON_Curve::PointAtStart ON_Curve::PointAtEnd
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepEdge.ComponentIndex">
            <summary>
virtual ON_Geometry::ComponentIndex() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepEdge.Vertex(System.Int32)">
            <param name="evi">[in] 0 or 1</param>
            <returns>Brep vertex at specified end of the edge.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepEdge.TrimCount">
            <summary>
Number of trims attached to this edge.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepEdge.Trim(System.Int32)">
            <param name="eti">[in] index into the edge's m_ti[] array.</param>
            <returns>The trim brep.m_T[edge.m_ti[eti]];</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepEdge.Brep">
            <summary>
Brep this edge belongs to.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepEdge.#ctor(System.Int32)">
            <summary>
In general, you should not directly create ON_BrepEdge classes.
Use ON_Brep::NewVertex instead.
</summary>
            <param name="arg1">edge index</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepEdge.#ctor">
            <summary>
In general, you should not directly create ON_BrepEdge classes.
Use ON_Brep::NewVertex instead.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepEdge.m_tolerance">
            <value>
accuracy of edge curve (&gt;=0.0 or ON_UNSET_VALUE)
A value of ON_UNSET_VALUE indicates that the
tolerance should be computed.
The maximum distance from the edge's 3d curve
to any surface of a face that has this edge as
a portion of its boundary must be &lt;= this
tolerance.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepEdge.m_ti">
            <value>
indices of starting/ending vertex
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepEdge.m_vi(System.Int32)">
            <value>
indices of starting/ending vertex
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepEdge.m_edge_index">
            <value>
index of edge in ON_Brep.m_E[] array
</value>
        </member>
        <member name="T:RMA.OpenNURBS.OnBrepEdge">
            <summary>
Brep edge information is stored in ON_BrepEdge classes.
ON_Brep.m_E[] is an array of all the edges in the brep.

An ON_BrepEdge is derived from ON_CurveProxy so the the
edge can supply easy to use evaluation tools via 
the ON_Curve virtual member functions.

Note well that the domains and orientations of the curve
m_C3[edge.m_c3i] and the edge as a curve may not
agree.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepEdge.EdgeCurveOf">
            <summary>
Returns: 3d curve geometry used by this edge or NULL.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepEdge.EdgeCurveIndexOf">
            <summary>
Returns: brep.m_C3[] index of the 3d curve geometry used by this edge or -1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepEdge.IsSmoothManifoldEdge">
            <summary>
For a manifold, non-boundary edge, decides whether or not the two surfaces on either side meet smoothly.
</summary>
            <returns>
true if edge is manifold, has exactly 2 trims, and surface normals on
either side agree to within angle_tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepEdge.IsSmoothManifoldEdge(System.Double)">
            <summary>
For a manifold, non-boundary edge, decides whether or not the two surfaces on either side meet smoothly.
</summary>
            <param name="angle_tolerance">[in] used to decide if surface normals on either side are parallel.</param>
            <returns>
true if edge is manifold, has exactly 2 trims, and surface normals on
either side agree to within angle_tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepEdge.ComponentIndex">
            <summary>
virtual ON_Geometry::ComponentIndex() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepEdge.Vertex(System.Int32)">
            <param name="evi">[in] 0 or 1</param>
            <returns>Brep vertex at specified end of the edge.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepEdge.TrimCount">
            <summary>
Number of trims attached to this edge.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepEdge.Trim(System.Int32)">
            <param name="eti">[in] index into the edge's m_ti[] array.</param>
            <returns>The trim brep.m_T[edge.m_ti[eti]];</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepEdge.Brep">
            <summary>
Brep this edge belongs to.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepEdge.m_tolerance">
            <value>
accuracy of edge curve (&gt;=0.0 or ON_UNSET_VALUE)
A value of ON_UNSET_VALUE indicates that the
tolerance should be computed.
The maximum distance from the edge's 3d curve
to any surface of a face that has this edge as
a portion of its boundary must be &lt;= this
tolerance.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepEdge.m_ti">
            <value>
indices of starting/ending vertex
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepEdge.m_vi(System.Int32)">
            <value>
indices of starting/ending vertex
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepEdge.m_edge_index">
            <value>
index of edge in ON_Brep.m_E[] array
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnBrepEdge">
            <summary>
Brep edge information is stored in ON_BrepEdge classes.
ON_Brep.m_E[] is an array of all the edges in the brep.

An ON_BrepEdge is derived from ON_CurveProxy so the the
edge can supply easy to use evaluation tools via 
the ON_Curve virtual member functions.

Note well that the domains and orientations of the curve
m_C3[edge.m_c3i] and the edge as a curve may not
agree.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepVertex.#ctor(System.Int32)">
            <summary>
In general, you should not directly create ON_BrepVertex classes.
Use ON_Brep::NewVertex instead.
</summary>
            <param name="arg1">vertex index</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepVertex.EdgeCount">
            <summary>
number of edges that begin or end at this vertex.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepVertex.Tolerance">
            <returns>value of ON_BrepVertex::m_tolerance</returns>
            <remarks>Use ON_Brep::SetVertexTolerance( ON_BrepVertex&amp; ) to set tolerances.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepVertex.Point">
            <summary>
Vertex location.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepVertex.SetPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Set vertex location.</summary>
            <param name="point">[in] 3d vertex location</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepVertex.ComponentIndex">
            <summary>
virtual ON_Geometry::ComponentIndex() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepVertex.#ctor">
            <summary>
In general, you should not directly create ON_BrepVertex classes.
Use ON_Brep::NewVertex instead.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepVertex.m_tolerance">
            <value>
accuracy of vertex point (&gt;=0.0 or ON_UNSET_VALUE)
A value of ON_UNSET_VALUE indicates that the
tolerance should be computed.
A value of 0.0 indicates that the distance
from the vertex to any applicable edge or trim
end is &lt;=  ON_ZERO_TOLERANCE
If an edge begins or ends at this vertex,
then the distance from the vertex's 
3d point to the appropriate end of the
edge's 3d curve must be &lt;= this tolerance.
If a trim begins or ends at this vertex,
then the distance from the vertex's 3d point
to the 3d point on the surface obtained by
evaluating the surface at the appropriate
end of the trimming curve must be &lt;= this
tolerance.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepVertex.m_ei">
            <value>
indices of edges starting/ending at this vertex

For closed edges, edge.m_vi[0] = edge.m_vi[1] and 
edge.m_edge_index appears twice in the m_ei[] array.
The first occurance of edge.m_edge_index in m_ei[]
is for the closed edge starting the vertex.
The second occurance of edge,m_edge_index in m_ei[]
is for the closed edge ending at the vertex.
C.f. ON_Brep::Next/PrevEdge().
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepVertex.m_vertex_index">
            <value>
index of the vertex in the ON_Brep.m_V[] array
</value>
        </member>
        <member name="T:RMA.OpenNURBS.OnBrepVertex">
            <summary>
Brep vertex information is stored in ON_BrepVertex classes.
ON_Brep.m_V[] is an array of all the vertices in the brep.

If a vertex is a point on a face, then brep.m_E[m_ei]
will be an edge with no 3d curve.  This edge will have
a single trim with type ON_BrepTrim::ptonsrf.  There
will be a loop containing this single trim.
Use ON_Brep::NewPointOnFace() to create vertices that are
points on faces. 
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepVertex.EdgeCount">
            <summary>
number of edges that begin or end at this vertex.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepVertex.Tolerance">
            <returns>value of ON_BrepVertex::m_tolerance</returns>
            <remarks>Use ON_Brep::SetVertexTolerance( ON_BrepVertex&amp; ) to set tolerances.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepVertex.Point">
            <summary>
Vertex location.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepVertex.ComponentIndex">
            <summary>
virtual ON_Geometry::ComponentIndex() override
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepVertex.m_tolerance">
            <value>
accuracy of vertex point (&gt;=0.0 or ON_UNSET_VALUE)
A value of ON_UNSET_VALUE indicates that the
tolerance should be computed.
A value of 0.0 indicates that the distance
from the vertex to any applicable edge or trim
end is &lt;=  ON_ZERO_TOLERANCE
If an edge begins or ends at this vertex,
then the distance from the vertex's 
3d point to the appropriate end of the
edge's 3d curve must be &lt;= this tolerance.
If a trim begins or ends at this vertex,
then the distance from the vertex's 3d point
to the 3d point on the surface obtained by
evaluating the surface at the appropriate
end of the trimming curve must be &lt;= this
tolerance.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepVertex.m_ei">
            <value>
indices of edges starting/ending at this vertex

For closed edges, edge.m_vi[0] = edge.m_vi[1] and 
edge.m_edge_index appears twice in the m_ei[] array.
The first occurance of edge.m_edge_index in m_ei[]
is for the closed edge starting the vertex.
The second occurance of edge,m_edge_index in m_ei[]
is for the closed edge ending at the vertex.
C.f. ON_Brep::Next/PrevEdge().
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepVertex.m_vertex_index">
            <value>
index of the vertex in the ON_Brep.m_V[] array
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnBrepVertex">
            <summary>
Brep vertex information is stored in ON_BrepVertex classes.
ON_Brep.m_V[] is an array of all the vertices in the brep.

If a vertex is a point on a face, then brep.m_E[m_ei]
will be an edge with no 3d curve.  This edge will have
a single trim with type ON_BrepTrim::ptonsrf.  There
will be a loop containing this single trim.
Use ON_Brep::NewPointOnFace() to create vertices that are
points on faces. 
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepTrimPoint.e">
            <value>
corresponding edge curve parameter (ON_UNSET_VALUE if unknown)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepTrimPoint.t">
            <value>
corresponding trim curve parameter
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepTrimPoint.p">
            <value>
2d surface parameter space point
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepTrimPoint.e">
            <value>
corresponding edge curve parameter (ON_UNSET_VALUE if unknown)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepTrimPoint.t">
            <value>
corresponding trim curve parameter
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepTrimPoint.p">
            <value>
2d surface parameter space point
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnSumSurface.MakeDeformable">
            <summary>
virtual ON_Geometry::MakeDeformable() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSumSurface.IsDeformable">
            <summary>
virtual ON_Geometry::IsDeformable() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSumSurface.Create(RMA.OpenNURBS.OnCurve,RMA.OpenNURBS.OnCurve)">
            <summary>Extrude a curve to create a surface.</summary>
            <param name="pCurve">
[in] pointer to a curve. This pointer will be assigned to m_curve[0] and will be deleted by ~ON_SumSurface.
</param>
            <param name="pPathCurve">
[in] pointer to a path curve. This pointer will be assigned to m_curve[1] and will be deleted by ~ON_SumSurface.
</param>
            <returns>TRUE if a valid surface is created.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSumSurface.Create(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnCurve)">
            <summary>Extrude a curve along a path to create a surface.</summary>
            <param name="curve">[in] curve is copied.</param>
            <param name="path_curve">[in] path_curve is copied.</param>
            <returns>TRUE if a valid surface is created.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSumSurface.Create(RMA.OpenNURBS.OnCurve,RMA.OpenNURBS.IOn3dVector)">
            <summary>Extrude a curve to create a surface.</summary>
            <param name="pCurve">
[in] pointer to a curve. This pointer will be assigned to m_curve[0] and
will be deleted by ~ON_SumSurface.
</param>
            <param name="extrusion_vector">[in] extrusion vector (must be nonzero)</param>
            <returns>TRUE if a valid surface is created.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSumSurface.Create(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOn3dVector)">
            <summary>Extrude a curve to create a surface.</summary>
            <param name="curve">[in] curve is copied.</param>
            <param name="extrusion_vector">[in] extrusion vector (must be nonzero)</param>
            <returns>TRUE if a valid surface is created.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnSumSurface.m_bbox">
            <value>
lazy evaluation used in ON_SumSurface::BoundingBox()
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnSumSurface.m_curve(System.Int32)">
            <value>
for expert users
surface-PointAt(s,t) 
= m_curve[0]-&gt;PointAt(s) + m_curve[1]-&gt;PointAt(t) + m_basepoint;
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSumSurface.IsDeformable">
            <summary>
virtual ON_Geometry::IsDeformable() override
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnSumSurface.m_bbox">
            <value>
lazy evaluation used in ON_SumSurface::BoundingBox()
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnSumSurface.m_curve(System.Int32)">
            <value>
for expert users
surface-PointAt(s,t) 
= m_curve[0]-&gt;PointAt(s) + m_curve[1]-&gt;PointAt(t) + m_basepoint;
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnRevSurface.IsConical">
            <summary>Test a surface of revolution to see if it is a portion of a cone.</summary>
            <returns>TRUE if the surface of revolution is a portion of a cone.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnRevSurface.IsConical(RMA.OpenNURBS.OnCone)">
            <summary>Test a surface of revolution to see if it is a portion of a cone.</summary>
            <param name="cone">[out] if not NULL and TRUE is returned, the cone parameters are filled in.</param>
            <returns>TRUE if the surface of revolution is a portion of a cone.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnRevSurface.IsConical(RMA.OpenNURBS.OnCone,System.Double)">
            <summary>Test a surface of revolution to see if it is a portion of a cone.</summary>
            <param name="cone">[out] if not NULL and TRUE is returned, the cone parameters are filled in.</param>
            <param name="tolerance">[in] tolerance to use when checking</param>
            <returns>TRUE if the surface of revolution is a portion of a cone.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnRevSurface.IsCylindrical">
            <summary>Test a surface of revolution to see if it is a portion of a cylinder.</summary>
            <returns>TRUE if the surface of revolution is a portion of a cylinder.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnRevSurface.IsCylindrical(RMA.OpenNURBS.OnCylinder)">
            <summary>Test a surface of revolution to see if it is a portion of a cylinder.</summary>
            <param name="cylinder">[out] if not NULL and TRUE is returned, the cylinder parameters are filled in.</param>
            <returns>TRUE if the surface of revolution is a portion of a cylinder.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnRevSurface.IsCylindrical(RMA.OpenNURBS.OnCylinder,System.Double)">
            <summary>Test a surface of revolution to see if it is a portion of a cylinder.</summary>
            <param name="cylinder">[out] if not NULL and TRUE is returned, the cylinder parameters are filled in.</param>
            <param name="tolerance">[in] tolerance to use when checking</param>
            <returns>TRUE if the surface of revolution is a portion of a cylinder.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnRevSurface.IsSpherical">
            <summary>Test a surface of revolution to see if it is a portion of a sphere.</summary>
            <returns>TRUE if the surface of revolution is a portion of a sphere.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnRevSurface.IsSpherical(RMA.OpenNURBS.OnSphere)">
            <summary>Test a surface of revolution to see if it is a portion of a sphere.</summary>
            <param name="sphere">
[out] if not NULL and TRUE is returned, the sphere parameters are filled in.
</param>
            <returns>TRUE if the surface of revolution is a portion of a sphere.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnRevSurface.IsSpherical(RMA.OpenNURBS.OnSphere,System.Double)">
            <summary>Test a surface of revolution to see if it is a portion of a sphere.</summary>
            <param name="sphere">
[out] if not NULL and TRUE is returned, the sphere parameters are filled in.
</param>
            <param name="tolerance">[in] tolerance to use when checking</param>
            <returns>TRUE if the surface of revolution is a portion of a sphere.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnRevSurface.m_bbox">
            <value>
Bounding box of the surface of revolution.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnRevSurface.m_bTransposed">
            <value>
If FALSE, the "u" parameter is the angle parameter
and the "v" parameter is the curve parameter.  
If TRUE,  the "u" parameter is the curve parameter
and the "v" parameter is the angle parameter.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnRevSurface.m_t">
            <value>
The interval m_t specifies the parameterization for the
angular parameter; m_t must be an increasing interval.
The parameter m_t[0] corresonds to angle m_angle[0] and 
the parameter m_t[1] corresponds to angle m_angle[1].
Changing m_t and leaving m_angle unchanged will change the
parameterization but not change the locus of the surface.
Changing m_angle and leaving m_t unchanged, will change the
locus of the surface but not change the evaluation domain.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnRevSurface.m_angle">
            <value>
Start and end angles of revolution in radians. 
The interval m_angle must be increasing and satisfiy 
ON_ZERO_TOLERANCE &lt; m_angle.Length() &lt;= 2.0*ON_PI
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnRevSurface.m_axis">
            <value>
Axis of revolution.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnRevSurface.m_curve">
            <value>
Revolute curve.
If m_curve is not NULL, then ~ON_RevSurface() deletes m_curve.
</value>
        </member>
        <member name="T:RMA.OpenNURBS.OnRevSurface">
            <summary>surface of revolution</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnRevSurface.IsConical">
            <summary>Test a surface of revolution to see if it is a portion of a cone.</summary>
            <returns>TRUE if the surface of revolution is a portion of a cone.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnRevSurface.IsConical(RMA.OpenNURBS.OnCone)">
            <summary>Test a surface of revolution to see if it is a portion of a cone.</summary>
            <param name="cone">[out] if not NULL and TRUE is returned, the cone parameters are filled in.</param>
            <returns>TRUE if the surface of revolution is a portion of a cone.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnRevSurface.IsConical(RMA.OpenNURBS.OnCone,System.Double)">
            <summary>Test a surface of revolution to see if it is a portion of a cone.</summary>
            <param name="cone">[out] if not NULL and TRUE is returned, the cone parameters are filled in.</param>
            <param name="tolerance">[in] tolerance to use when checking</param>
            <returns>TRUE if the surface of revolution is a portion of a cone.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnRevSurface.IsCylindrical">
            <summary>Test a surface of revolution to see if it is a portion of a cylinder.</summary>
            <returns>TRUE if the surface of revolution is a portion of a cylinder.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnRevSurface.IsCylindrical(RMA.OpenNURBS.OnCylinder)">
            <summary>Test a surface of revolution to see if it is a portion of a cylinder.</summary>
            <param name="cylinder">[out] if not NULL and TRUE is returned, the cylinder parameters are filled in.</param>
            <returns>TRUE if the surface of revolution is a portion of a cylinder.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnRevSurface.IsCylindrical(RMA.OpenNURBS.OnCylinder,System.Double)">
            <summary>Test a surface of revolution to see if it is a portion of a cylinder.</summary>
            <param name="cylinder">[out] if not NULL and TRUE is returned, the cylinder parameters are filled in.</param>
            <param name="tolerance">[in] tolerance to use when checking</param>
            <returns>TRUE if the surface of revolution is a portion of a cylinder.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnRevSurface.IsSpherical">
            <summary>Test a surface of revolution to see if it is a portion of a sphere.</summary>
            <returns>TRUE if the surface of revolution is a portion of a sphere.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnRevSurface.IsSpherical(RMA.OpenNURBS.OnSphere)">
            <summary>Test a surface of revolution to see if it is a portion of a sphere.</summary>
            <param name="sphere">
[out] if not NULL and TRUE is returned, the sphere parameters are filled in.
</param>
            <returns>TRUE if the surface of revolution is a portion of a sphere.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnRevSurface.IsSpherical(RMA.OpenNURBS.OnSphere,System.Double)">
            <summary>
returns TRUE if successful
</summary>
            <summary>
returns TRUE if successful
</summary>
            <summary>Test a surface of revolution to see if it is a portion of a sphere.</summary>
            <param name="sphere">
[out] if not NULL and TRUE is returned, the sphere parameters are filled in.
</param>
            <param name="tolerance">[in] tolerance to use when checking</param>
            <returns>TRUE if the surface of revolution is a portion of a sphere.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnRevSurface.m_bbox">
            <value>
Bounding box of the surface of revolution.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnRevSurface.m_bTransposed">
            <value>
If FALSE, the "u" parameter is the angle parameter
and the "v" parameter is the curve parameter.  
If TRUE,  the "u" parameter is the curve parameter
and the "v" parameter is the angle parameter.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnRevSurface.m_t">
            <value>
The interval m_t specifies the parameterization for the
angular parameter; m_t must be an increasing interval.
The parameter m_t[0] corresonds to angle m_angle[0] and 
the parameter m_t[1] corresponds to angle m_angle[1].
Changing m_t and leaving m_angle unchanged will change the
parameterization but not change the locus of the surface.
Changing m_angle and leaving m_t unchanged, will change the
locus of the surface but not change the evaluation domain.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnRevSurface.m_angle">
            <value>
Start and end angles of revolution in radians. 
The interval m_angle must be increasing and satisfiy 
ON_ZERO_TOLERANCE &lt; m_angle.Length() &lt;= 2.0*ON_PI
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnRevSurface.m_axis">
            <value>
Axis of revolution.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnRevSurface.m_curve">
            <value>
Revolute curve.
If m_curve is not NULL, then ~ON_RevSurface() deletes m_curve.
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnRevSurface">
            <summary>surface of revolution</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlaneSurface.Extents(System.Int32)">
            <summary>Gets the extents of the rectangle.</summary>
            <param name="dir">
0 gets plane's x coordinate extents
1 gets plane's y coordinate extents
</param>
            <returns>
Increasing interval
See Also: ON_PlaneSurface::Domain
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlaneSurface.SetExtents(System.Int32,RMA.OpenNURBS.IOnInterval)">
            <summary>Sets the extents of then rectangle. Does not change the evaluation domain.</summary>
            <param name="dir">
0 sets plane's x coordinate extents
1 sets plane's y coordinate extents
</param>
            <param name="extents">[in] increasing interval</param>
            <returns>
True if successful.
See Also: ON_PlaneSurface::SetDomain
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlaneSurface.SetExtents(System.Int32,RMA.OpenNURBS.IOnInterval,System.Boolean)">
            <summary>Sets the extents of then rectangle. Does not change the evaluation domain.</summary>
            <param name="dir">
0 sets plane's x coordinate extents
1 sets plane's y coordinate extents
</param>
            <param name="extents">[in] increasing interval</param>
            <param name="bSynchDomain">
[in] if true, the corresponding evaluation interval domain is set
so that it matches the extents interval
</param>
            <returns>
True if successful.
See Also: ON_PlaneSurface::SetDomain
</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnPlaneSurface.m_plane">
            <value>
An ON_PlaneSurface is really a finite rectangle.
m_plane defines the plane and m_extents[] stores
the x and y intervals of the plane that define the
rectangle.  The m_domain[] intervals specify the
evaluation domain.  Changing the extents are domain
are INDEPENDENT of each other.  Use Domain() and
SetDomain() to control the evluation domain.  Use
Extents() and SetExtents() to control the rectangle
extents.
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlaneSurface.Extents(System.Int32)">
            <summary>Gets the extents of the rectangle.</summary>
            <param name="dir">
0 gets plane's x coordinate extents
1 gets plane's y coordinate extents
</param>
            <returns>
Increasing interval
See Also: ON_PlaneSurface::Domain
</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPlaneSurface.m_plane">
            <value>
An ON_PlaneSurface is really a finite rectangle.
m_plane defines the plane and m_extents[] stores
the x and y intervals of the plane that define the
rectangle.  The m_domain[] intervals specify the
evaluation domain.  Changing the extents are domain
are INDEPENDENT of each other.  Use Domain() and
SetDomain() to control the evluation domain.  Use
Extents() and SetExtents() to control the rectangle
extents.
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnMorphControl.MorphPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Evaluates the deformation. Used by ON_CageMorph::MorphPoint().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMorphControl.AddControlLocalizer(System.Double,System.Double)">
            <summary>Adds localizer with support near the controling NURBS object.</summary>
            <param name="support_distance">
[in] &gt;= 0
If the distance a point to the controls NURBS curve/surface/cage is less than
or equal to support_distance, then MorphPoint() deformation has 100% effect.
</param>
            <param name="falloff_distance">
[in] &gt; 0 
If the distance a point to the controls NURBS curve/surface/cage is more than
support_distance+falloff_distance, then MorphPoint() deformation does not move
the point. As the distance varies from support_distance to support_distance+falloff_distance
the deformation attenuates from 100% to 0%.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnMorphControl.CVCount">
            <summary>
Returns: Number of control points in the target NURBS object.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMorphControl.MakeNonRational">
            <summary>
Description: Makes the target NURBS object non-rational.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMorphControl.MakeRational">
            <summary>
Description: Makes the target NURBS object rational.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMorphControl.IsRational">
            <summary>
Returns: True if the target NURBS object is rational
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMorphControl.m_sporh_tolerance">
            <value>
ON_SpaceMorphOptions
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMorphControl.m_nurbs_curve0">
            <value>
The value of m_varient determines which nurbs object
controls the cage
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMorphControl.m_varient">
            <value>
1= curve, 2 = surface, 3 = cage
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMorphControl.MorphPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Evaluates the deformation. Used by ON_CageMorph::MorphPoint().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMorphControl.CVCount">
            <summary>
Returns: Number of control points in the target NURBS object.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMorphControl.IsRational">
            <summary>
Returns: True if the target NURBS object is rational
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMorphControl.m_sporh_tolerance">
            <value>
Rhino captive object ids
</value>
            <value>
Use ON_GetCageXform to set m_cage_xform.
Used to localize the deformation
</value>
            <value>
ON_SpaceMorphOptions
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMorphControl.m_nurbs_curve0">
            <value>
The value of m_varient determines which nurbs object
controls the cage
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMorphControl.m_varient">
            <value>
1= curve, 2 = surface, 3 = cage
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.ReserveCVCapacity(System.Int32)">
            <summary>
Description: cv_capacity - [in] number of doubles to reserve
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.IsSingular(System.Int32)">
            <summary>TRUE if surface side is collapsed to a point</summary>
            <param name="side">
side of parameter space to test
0 = south, 1 = east, 2 = north, 3 = west
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.IsPeriodic(System.Int32)">
            <summary>
TRUE if NURBS surface is periodic (degree &gt; 1,
periodic knot vector, last degree many CVs
are duplicates of first degree many CVs.)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.IsClosed(System.Int32)">
            <summary>
TRUE if NURBS surface is closed (either surface has
clamped end knots and euclidean location of start
CV = euclidean location of end CV, or surface is
periodic.)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.ZeroCVs">
            <summary>
zeros control vertices and, if rational, sets weights to 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.GetCV(System.Int32,System.Int32,System.Int32,RMA.OpenNURBS.On4dPoint@)">
            <summary>get a single control vertex</summary>
            <param name="arg4">gets homogeneous cv</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.GetCV(System.Int32,System.Int32,System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>get a single control vertex</summary>
            <param name="arg4">gets euclidean cv when NURBS is rational</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.SetCV(System.Int32,System.Int32,System.Int32,RMA.OpenNURBS.IOn4dPoint)">
            <summary>
set a single control vertex
value of control vertex
If NURBS is not rational, euclidean
location of homogeneous point will
be used.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.SetCV(System.Int32,System.Int32,System.Int32,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
set a single control vertex
If NURBS is rational, weight
will be set to 1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.SetWeight(System.Int32,System.Int32,System.Int32,System.Double)">
            <summary>
set value of control vertex weight
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.Weight(System.Int32,System.Int32,System.Int32)">
            <summary>
get value of control vertex weight
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.CVStyle">
            <summary>
Description: Expert user function to get a pointer to control vertex memory. If you are not an expert user, please use ON_NurbsCage::GetCV( ON_3dPoint&amp; ) or ON_NurbsCage::GetCV( ON_4dPoint&amp; ). Parameters: cv_index0 - [in] (0 &lt;= cv_index0 &lt; m_order[0]) cv_index1 - [in] (0 &lt;= cv_index1 &lt; m_order[1]) Returns: Pointer to control vertex. Remarks: If the Nurbs surface is rational, the format of the returned array is a homogeneos rational point with length m_dim+1. If the Nurbs surface is not rational, the format of the returned array is a nonrational euclidean point with length m_dim. See Also ON_NurbsCage::CVStyle ON_NurbsCage::GetCV ON_NurbsCage::Weight
</summary>
            <summary>Returns the style of control vertices in the m_cv array.</summary>
            <returns>
ON::not_rational         m_is_rat is FALSE
ON::homogeneous_rational m_is_rat is TRUE
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.KnotCount(System.Int32)">
            <summary>
total number of knots in knot vector
</summary>
            <param name="dir">0 = "u" domain, 1 = "v" domain, 2 = "w" domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.CVCount">
            <summary>
total number of control vertices
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.CVCount(System.Int32)">
            <summary>
number of control vertices
</summary>
            <param name="dir">0 = "u" domain, 1 = "v" domain, 2 = "w" domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.PointAt(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Evaluates bezer volume map. Parameters: rst - [in] Returns: Value of the nurbs volume map at (rst.x,rst.y,rst.z).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.PointAt(System.Double,System.Double,System.Double)">
            <summary>Evaluates bezer volume map.</summary>
            <returns>Value of the nurbs volume map at (r,s,t).</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.Domain(System.Int32)">
            <param name="dir">0 = "u" domain, 1 = "v" domain, 2 = "w" domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.EmergencyDestroy">
            <summary>
call if memory used by ON_NurbsCage becomes invalid
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.Create(RMA.OpenNURBS.IOnBoundingBox,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Create a Nurbs volume with corners defined by a bounding box.</summary>
            <param name="box_corners">
[in] 8 points that define corners of the volume

     7______________6
     |\             |
     | \            | 
     |  \ _____________
     |   4          |   5
     |   |          |   |
     |   |          |   |
     3---|----------2   |
     \   |          \   |
      \  |z          \  |
     y \ |            \ |
        \0_____________\1
                x
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.IsParallelogram(System.Double)">
            <summary>
True if the cage is a parallelogram within the tolerance. This means
the cage can be used as a starting point for cage deformations.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnNurbsCage.m_dim">
            <value>
NOTE: These members are left "public" so that expert users may efficiently
     create nurbs curves using the default constructor and borrow the
     knot and CV arrays from their native NURBS representation.
     No technical support will be provided for users who access these
     members directly.  If you can't get your stuff to work, then use
     the constructor with the arguments and the SetKnot() and SetCV()
     functions to fill in the arrays.
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCage.GrevilleAbcissa(System.Int32,System.Int32)">
            <param name="gindex">index (0 &lt;= index &lt; CVCount(dir)</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCage.IsSingular(System.Int32)">
            <summary>TRUE if surface side is collapsed to a point</summary>
            <param name="side">
side of parameter space to test
0 = south, 1 = east, 2 = north, 3 = west
</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCage.IsPeriodic(System.Int32)">
            <summary>
TRUE if NURBS surface is periodic (degree &gt; 1,
periodic knot vector, last degree many CVs
are duplicates of first degree many CVs.)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCage.IsClosed(System.Int32)">
            <summary>
TRUE if NURBS surface is closed (either surface has
clamped end knots and euclidean location of start
CV = euclidean location of end CV, or surface is
periodic.)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCage.GetCV(System.Int32,System.Int32,System.Int32,RMA.OpenNURBS.On4dPoint@)">
            <summary>get a single control vertex</summary>
            <param name="arg4">gets homogeneous cv</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCage.GetCV(System.Int32,System.Int32,System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>get a single control vertex</summary>
            <param name="arg4">gets euclidean cv when NURBS is rational</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCage.Weight(System.Int32,System.Int32,System.Int32)">
            <summary>
get value of control vertex weight
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCage.CVStyle">
            <summary>
Description: Expert user function to get a pointer to control vertex memory. If you are not an expert user, please use ON_NurbsCage::GetCV( ON_3dPoint&amp; ) or ON_NurbsCage::GetCV( ON_4dPoint&amp; ). Parameters: cv_index0 - [in] (0 &lt;= cv_index0 &lt; m_order[0]) cv_index1 - [in] (0 &lt;= cv_index1 &lt; m_order[1]) Returns: Pointer to control vertex. Remarks: If the Nurbs surface is rational, the format of the returned array is a homogeneos rational point with length m_dim+1. If the Nurbs surface is not rational, the format of the returned array is a nonrational euclidean point with length m_dim. See Also ON_NurbsCage::CVStyle ON_NurbsCage::GetCV ON_NurbsCage::Weight
</summary>
            <summary>Returns the style of control vertices in the m_cv array.</summary>
            <returns>
ON::not_rational         m_is_rat is FALSE
ON::homogeneous_rational m_is_rat is TRUE
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCage.KnotCount(System.Int32)">
            <summary>
total number of knots in knot vector
</summary>
            <param name="dir">0 = "u" domain, 1 = "v" domain, 2 = "w" domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCage.CVCount">
            <summary>
total number of control vertices
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCage.CVCount(System.Int32)">
            <summary>
number of control vertices
</summary>
            <param name="dir">0 = "u" domain, 1 = "v" domain, 2 = "w" domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCage.PointAt(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Evaluates bezer volume map. Parameters: rst - [in] Returns: Value of the nurbs volume map at (rst.x,rst.y,rst.z).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCage.PointAt(System.Double,System.Double,System.Double)">
            <summary>Evaluates bezer volume map.</summary>
            <returns>Value of the nurbs volume map at (r,s,t).</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCage.Domain(System.Int32)">
            <param name="dir">0 = "u" domain, 1 = "v" domain, 2 = "w" domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCage.IsParallelogram(System.Double)">
            <summary>
True if the cage is a parallelogram within the tolerance. This means
the cage can be used as a starting point for cage deformations.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnNurbsCage.m_dim">
            <value>
NOTE: These members are left "public" so that expert users may efficiently
     create nurbs curves using the default constructor and borrow the
     knot and CV arrays from their native NURBS representation.
     No technical support will be provided for users who access these
     members directly.  If you can't get your stuff to work, then use
     the constructor with the arguments and the SetKnot() and SetCV()
     functions to fill in the arrays.
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.#ctor(System.Int32,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32)">
            <param name="dimension">(&gt;= 1)</param>
            <param name="bIsRational">TRUE to make a rational NURBS</param>
            <param name="order0">(&gt;= 2)</param>
            <param name="order1">(&gt;= 2)</param>
            <param name="cv_count0">cv count0 (&gt;= order0)</param>
            <param name="cv_count1">cv count1 (&gt;= order1)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.ConvertSpanToBezier(System.Int32,System.Int32,RMA.OpenNURBS.OnBezierSurface@)">
            <summary>Convert a NURBS surface bispan into a bezier surface.</summary>
            <param name="span_index0">
[in] Specifies the "u" span and must satisfy
0 &lt;= span_index0 &lt;= m_cv_count[0]-m_order[0]
m_knot[0][span_index0+m_order[0]-2] &lt; m_knot[0][span_index0+m_order[0]-1]
</param>
            <param name="span_index1">
[in] Specifies the "v" span and must satisfy
0 &lt;= span_index1 &lt;= m_cv_count[1]-m_order[1]
m_knot[1][span_index1+m_order[1]-2] &lt; m_knot[1][span_index1+m_order[1]-1]
</param>
            <param name="bezier_surface">[out] bezier surface returned here</param>
            <returns>
TRUE if successful
FALSE if input is not valid
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.ReserveCVCapacity(System.Int32)">
            <summary>
returns FALSE if allocation fails
does not change m_order or m_cv_count
</summary>
            <param name="cv_array_capacity">minimum capacity of m_cv[] array</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.ReserveKnotCapacity(System.Int32,System.Int32)">
            <summary>
returns FALSE if allocation fails
does not change m_order or m_cv_count
</summary>
            <param name="dir">dir 0 = "s", 1 = "t"</param>
            <param name="knot_array_capacity">minimum capacity of m_knot[] array</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.TensorProduct(RMA.OpenNURBS.IOnNurbsCurve,RMA.OpenNURBS.IOnNurbsCurve,RMA.OpenNURBS.OnTensorProduct@)">
            <summary>
Creates a tensor product nurbs surface with srf(s,t) = T(A(s),B(t));
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.ChangeSurfaceSeam(System.Int32,System.Double)">
            <summary>
If the surface is closed in direction dir, then modify it so that
the seam is at parameter t in the dir direction.
</summary>
            <param name="dir">[in] must be 0 or 1</param>
            <param name="t">
[in] dir parameter of seam, must have Domain(dir).Includes(t).
The resulting surface domain in the dir direction will start at t.
</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.IncreaseDegree(System.Int32,System.Int32)">
            <param name="dir">dir 0 = "s", 1 = "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.InsertKnot(System.Int32,System.Double)">
            <param name="dir">dir 0 = "s", 1 = "t"</param>
            <param name="knot_value">value of knot</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.InsertKnot(System.Int32,System.Double,System.Int32)">
            <param name="dir">dir 0 = "s", 1 = "t"</param>
            <param name="knot_value">value of knot</param>
            <param name="knot_multiplicity">multiplicity of knot ( &gt;= 1 and &lt;= degree )</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.ClampEnd(System.Int32,System.Int32)">
            <param name="dir">dir 0 = "s", 1 = "t"</param>
            <param name="end">0 = clamp start, 1 = clamp end, 2 = clamp start and end</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.ZeroCVs">
            <summary>
zeros all CVs (any weights set to 1);
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.GetGrevilleAbcissae(System.Int32,System.Double[]@)">
            <summary>see ON_GetGrevilleAbcissa() for details</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.GrevilleAbcissa(System.Int32,System.Int32)">
            <param name="cv_index">0 &lt;= index &lt; CVCount(dir)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.SuperfluousKnot(System.Int32,System.Int32)">
            <param name="dir">dir 0 = "s", 1 = "t"</param>
            <param name="end">end to check: 0 = start, 1 = end, 2 = start and end</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.IsClamped(System.Int32)">
            <summary>determine if knot vector is clamped</summary>
            <param name="dir">dir 0 = "s", 1 = "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.IsClamped(System.Int32,System.Int32)">
            <summary>determine if knot vector is clamped</summary>
            <param name="dir">dir 0 = "s", 1 = "t"</param>
            <param name="end">end to check: 0 = start, 1 = end, 2 = start and end</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.MakePeriodicUniformKnotVector(System.Int32)">
            <summary>
Make knot vector a periodic uniform knot vector
based on the current values of m_order and m_cv_count.
Does not change values of control vertices.
</summary>
            <param name="dir">[in] 0 = u knots, 1 = v knots</param>
            <returns>TRUE if successful.</returns>
            <remarks>
Allocates m_knot[] if it is not big enough.
See Also:
ON_MakePeriodicUniformKnotVector
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.MakePeriodicUniformKnotVector(System.Int32,System.Double)">
            <summary>
Make knot vector a periodic uniform knot vector
based on the current values of m_order and m_cv_count.
Does not change values of control vertices.
</summary>
            <param name="dir">[in] 0 = u knots, 1 = v knots</param>
            <param name="delta">[in] (&gt;0.0) knot spacing.</param>
            <returns>TRUE if successful.</returns>
            <remarks>
Allocates m_knot[] if it is not big enough.
See Also:
ON_MakePeriodicUniformKnotVector
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.MakeClampedUniformKnotVector(System.Int32)">
            <summary>
Make knot vector a clamped uniform knot vector
based on the current values of m_order and m_cv_count.
Does not change values of control vertices.
</summary>
            <param name="dir">[in] 0 = u knots, 1 = v knots</param>
            <returns>TRUE if successful.</returns>
            <remarks>
Allocates m_knot[] if it is not big enough.
See Also:
ON_MakeClampedUniformKnotVector
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.MakeClampedUniformKnotVector(System.Int32,System.Double)">
            <summary>
knot[] array
</summary>
            <summary>
Make knot vector a clamped uniform knot vector
based on the current values of m_order and m_cv_count.
Does not change values of control vertices.
</summary>
            <param name="dir">[in] 0 = u knots, 1 = v knots</param>
            <param name="delta">[in] (&gt;0.0) knot spacing.</param>
            <returns>TRUE if successful.</returns>
            <remarks>
Allocates m_knot[] if it is not big enough.
See Also:
ON_MakeClampedUniformKnotVector
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.KnotMultiplicity(System.Int32,System.Int32)">
            <param name="dir">0 = "s", 1 = "t"</param>
            <param name="knot_index">( 0 to KnotCount - 1 )</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.Knot(System.Int32,System.Int32)">
            <param name="dir">0 = "s", 1 = "t"</param>
            <param name="knot_index">( 0 to KnotCount - 1 )</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.SetKnot(System.Int32,System.Int32,System.Double)">
            <param name="dir">0 = "s", 1 = "t"</param>
            <param name="knot_index">( 0 to KnotCount - 1 )</param>
            <param name="knot_value">value for knot</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.GetCV(System.Int32,System.Int32,RMA.OpenNURBS.On4dPoint@)">
            <summary>get a single control vertex</summary>
            <param name="i">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
            <param name="j">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
            <param name="cv">gets homogeneous cv</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.GetCV(System.Int32,System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>get a single control vertex</summary>
            <param name="i">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
            <param name="j">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
            <param name="cv">gets euclidean cv when NURBS is rational</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.SetCVColumn(System.Int32,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Sets CV( col_index, * )</summary>
            <param name="col_index">col_index &gt;= 0 and &lt; m_cv_count[0]</param>
            <param name="cv">
value of control vertex
If NURBS is rational, weight will be set to 1.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.SetCVRow(System.Int32,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Sets CV( *, row_index )</summary>
            <param name="row_index">row_index &gt;= 0 and &lt; m_cv_count[1]</param>
            <param name="cv">
value of control vertex
If NURBS is rational, weight will be set to 1.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.SetCV(System.Int32,System.Int32,RMA.OpenNURBS.IOn4dPoint)">
            <summary>set a single control vertex</summary>
            <param name="i">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
            <param name="j">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
            <param name="cv">value of control vertex</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.SetCV(System.Int32,System.Int32,RMA.OpenNURBS.IOn3dPoint)">
            <summary>set a single control vertex</summary>
            <param name="i">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
            <param name="j">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
            <param name="cv">
value of control vertex
If NURBS is rational, weight will be set to 1.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.SetWeight(System.Int32,System.Int32,System.Double)">
            <summary>set value of control vertex weight</summary>
            <param name="i">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
            <param name="j">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.Weight(System.Int32,System.Int32)">
            <summary>get value of control vertex weight</summary>
            <param name="i">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
            <param name="j">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.CVStyle">
            <summary>
Description: Expert user function to get a pointer to control vertex memory. If you are not an expert user, please use ON_NurbsSurface::GetCV( ON_3dPoint&amp; ) or ON_NurbsSurface::GetCV( ON_4dPoint&amp; ). Parameters: i - [in] (0 &lt;= i &lt; m_cv_count[0]) j - [in] (0 &lt;= j &lt; m_cv_count[1]) Returns: Pointer to control vertex. Remarks: If the NURBS surface is rational, the format of the returned array is a homogeneos rational point with length m_dim+1. If the NURBS surface is not rational, the format of the returned array is a nonrational euclidean point with length m_dim. See Also ON_NurbsSurface::CVStyle ON_NurbsSurface::GetCV ON_NurbsSurface::Weight
</summary>
            <summary>Returns the style of control vertices in the m_cv array.</summary>
            <returns>
ON::not_rational         m_is_rat is FALSE
ON::homogeneous_rational m_is_rat is TRUE
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.KnotCount(System.Int32)">
            <summary>
total number of knots in knot vector
</summary>
            <param name="dir">0 = "s", 1 = "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.CVCount">
            <summary>
total number of control vertices
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.CVCount(System.Int32)">
            <summary>number of control vertices</summary>
            <param name="dir">0 = "s", 1 = "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.Order(System.Int32)">
            <summary>order = degree + 1</summary>
            <param name="dir">0 = "s", 1 = "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.CVSize">
            <summary>
number of doubles per control vertex = IsRational() ? Dim()+1 : Dim()
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.IsRational">
            <summary>
TRUE if NURBS surface is rational
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.ControlPolygonLength(System.Int32)">
            <summary>Get the maximum length of a nurb surface's control polygon rows and/or columns</summary>
            <param name="dir">
[in] 0 to get "u" direction length, 1 to get "v" direction length
</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.IsMorphable">
            <summary>
virtual ON_Geometry override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.Morph(RMA.OpenNURBS.IOnSpaceMorph)">
            <summary>
virtual ON_Geometry override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.MakeDeformable">
            <summary>
virtual ON_Geometry::MakeDeformable() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.IsDeformable">
            <summary>
virtual ON_Geometry::IsDeformable() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.op_Implicit(RMA.OpenNURBS.IOnBezierSurface)~RMA.OpenNURBS.OnNurbsSurface">
            <summary>
Set NURBS surface equal to bezier surface with domain [0,1]x[0,1].
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.EmergencyDestroy">
            <summary>
call if memory used by this class becomes invalid
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.CollapseSide(System.Int32)">
            <summary>Collapse the side of a NURBS surface to a single point.</summary>
            <param name="side">
0 = south west,
1 = south east,
2 = north east,
3 = north west
</param>
            <returns>True if successful.</returns>
            <remarks>
If the surface is rational, the weights of the side control points must be set before calling CollapseSide.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.CollapseSide(System.Int32,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Collapse the side of a NURBS surface to a single point.</summary>
            <param name="side">
0 = south west,
1 = south east,
2 = north east,
3 = north west
</param>
            <param name="point">
[in] point to collapse to. If point is ON_unset_point, the current location of the start of the side is used.
</param>
            <returns>True if successful.</returns>
            <remarks>
If the surface is rational, the weights of the side control points must be set before calling CollapseSide.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.CreateConeSurface(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOnCurve)">
            <summary>Create a cone surface from a curve to a point.</summary>
            <param name="apex_point">[in]</param>
            <param name="curve">[in]</param>
            <returns>
0 failure
1 success - parameterization is exact
2 success - parameterization is not exact
</returns>
            <remarks>
The ruling parameter is the second surface parameter and it is in the interval [0,1].
The true cone surface has parameterization srf(s,t) = (1.0-t)*curve(s) + t*apex_point.
The returned NURBS surface has parameterization srf(s,t) = (1.0-t)*nurbs_curve(s) + t*apex_point,
where nurbs_curve is the NURBS form of curve. If the parameterization of nurbs_curve
does not match the parameterization of curve, then 2 is returned.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.CreateConeSurface(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnInterval)">
            <summary>Create a cone surface from a curve to a point.</summary>
            <param name="apex_point">[in]</param>
            <param name="curve">[in]</param>
            <param name="curve_domain">[in] if not NULL, then this is a subdomain of curve to use for the ruled surface.</param>
            <returns>
0 failure
1 success - parameterization is exact
2 success - parameterization is not exact
</returns>
            <remarks>
The ruling parameter is the second surface parameter and it is in the interval [0,1].
The true cone surface has parameterization srf(s,t) = (1.0-t)*curve(s) + t*apex_point.
The returned NURBS surface has parameterization srf(s,t) = (1.0-t)*nurbs_curve(s) + t*apex_point,
where nurbs_curve is the NURBS form of curve. If the parameterization of nurbs_curve
does not match the parameterization of curve, then 2 is returned.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.CreateRuledSurface(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnCurve)">
            <summary>Create a ruled surface from two curves.</summary>
            <param name="curveA">[in] (must have same NURBS form knots as curveB)</param>
            <param name="curveB">[in] (must have same NURBS form knots as curveA)</param>
            <returns>
0 failure
1 success - parameterization is exact
2 success - parameterization is not exact
</returns>
            <remarks>
The ruling parameter is the second surface parameter and it is in the interval [0,1].
The true ruled surface has parameterization srf(s,t) = (1.0-t)*curveA(s) + t*curveB(s).
The returned NURBS surface has parameterization srf(s,t) = (1.0-t)*nurbs_curveA(s) + t*nurbs_curveB(s),
where nurbs_curveX is the NURBS form of curveX. If the parameterization of nurbs_curveX
does not match the parameterization of curveX, then 2 is returned.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.CreateRuledSurface(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnInterval)">
            <summary>Create a ruled surface from two curves.</summary>
            <param name="curveA">[in] (must have same NURBS form knots as curveB)</param>
            <param name="curveB">[in] (must have same NURBS form knots as curveA)</param>
            <param name="curveA_domain">[in] if not NULL, then this is a subdomain of curveA to use for the ruled surface.</param>
            <returns>
0 failure
1 success - parameterization is exact
2 success - parameterization is not exact
</returns>
            <remarks>
The ruling parameter is the second surface parameter and it is in the interval [0,1].
The true ruled surface has parameterization srf(s,t) = (1.0-t)*curveA(s) + t*curveB(s).
The returned NURBS surface has parameterization srf(s,t) = (1.0-t)*nurbs_curveA(s) + t*nurbs_curveB(s),
where nurbs_curveX is the NURBS form of curveX. If the parameterization of nurbs_curveX
does not match the parameterization of curveX, then 2 is returned.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.CreateRuledSurface(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Create a ruled surface from two curves.</summary>
            <param name="curveA">[in] (must have same NURBS form knots as curveB)</param>
            <param name="curveB">[in] (must have same NURBS form knots as curveA)</param>
            <param name="curveA_domain">[in] if not NULL, then this is a subdomain of curveA to use for the ruled surface.</param>
            <param name="curveB_domain">[in] if not NULL, then this is a subdomain of curveA to use for the ruled surface.</param>
            <returns>
0 failure
1 success - parameterization is exact
2 success - parameterization is not exact
</returns>
            <remarks>
The ruling parameter is the second surface parameter and it is in the interval [0,1].
The true ruled surface has parameterization srf(s,t) = (1.0-t)*curveA(s) + t*curveB(s).
The returned NURBS surface has parameterization srf(s,t) = (1.0-t)*nurbs_curveA(s) + t*nurbs_curveB(s),
where nurbs_curveX is the NURBS form of curveX. If the parameterization of nurbs_curveX
does not match the parameterization of curveX, then 2 is returned.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.Create(System.Int32,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32)">
            <param name="dim">dimension (&gt;= 1)</param>
            <param name="is_rat">TRUE to make a rational NURBS</param>
            <param name="order0">order0 (&gt;= 2)</param>
            <param name="order1">order1 (&gt;= 2)</param>
            <param name="cv_count0">cv count0 (&gt;= order0)</param>
            <param name="cv_count1">cv count0 (&gt;= order1)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.Initialize">
            <summary>
zeros all fields
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.IsDuplicate(RMA.OpenNURBS.IOnNurbsSurface,System.Boolean)">
            <summary>See if this and other are same NURBS geometry.</summary>
            <param name="other">[in] other NURBS surface</param>
            <param name="bIgnoreParameterization">[in] if true, parameterization and orientaion are ignored.</param>
            <returns>true if curves are tne same.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.IsDuplicate(RMA.OpenNURBS.IOnNurbsSurface,System.Boolean,System.Double)">
            <summary>See if this and other are same NURBS geometry.</summary>
            <param name="other">[in] other NURBS surface</param>
            <param name="bIgnoreParameterization">[in] if true, parameterization and orientaion are ignored.</param>
            <param name="tolerance">[in] tolerance to use when comparing control points.</param>
            <returns>true if curves are tne same.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnNurbsSurface.m_cv_capacity">
            <value>
If m_cv_capacity &gt; 0, then m_cv[] is an array of at least m_cv_capacity doubles whose
memory is managed by the ON_NurbsSurface class using rhmalloc(), onrealloc(), and rhfree().
If m_cv_capacity is 0 and m_cv is not NULL, then m_cv[] is assumed to be big enough
for any requested operation and m_cv[] is not deleted by the destructor.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnNurbsSurface.m_cv_stride(System.Int32)">
            <value>
The pointer to start of "CV[i]" is m_cv + i*m_cv_stride.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnNurbsSurface.m_knot_capacity(System.Int32)">
            <value>
If m_knot_capacity &gt; 0, then m_knot[] is an array of at least m_knot_capacity
doubles whose memory is managed by the ON_NurbsSurface class using rhmalloc(),
onrealloc(), and rhfree().
If m_knot_capacity is 0 and m_knot is not NULL, then  m_knot[] is assumed to
be big enough for any requested operation and m_knot[] is not deleted by the
destructor.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnNurbsSurface.m_cv_count(System.Int32)">
            <value>
number of control vertices ( &gt;= order )
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnNurbsSurface.m_order(System.Int32)">
            <value>
order = degree+1 (&gt;=2)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnNurbsSurface.m_is_rat">
            <value>
1 for rational B-splines. (Control vertices use homogeneous form.)
0 for non-rational B-splines. (Control verticies do not have a weight coordinate.)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnNurbsSurface.m_dim">
            <value>
(&gt;=1)
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.ConvertSpanToBezier(System.Int32,System.Int32,RMA.OpenNURBS.OnBezierSurface@)">
            <summary>Convert a NURBS surface bispan into a bezier surface.</summary>
            <param name="span_index0">
[in] Specifies the "u" span and must satisfy
0 &lt;= span_index0 &lt;= m_cv_count[0]-m_order[0]
m_knot[0][span_index0+m_order[0]-2] &lt; m_knot[0][span_index0+m_order[0]-1]
</param>
            <param name="span_index1">
[in] Specifies the "v" span and must satisfy
0 &lt;= span_index1 &lt;= m_cv_count[1]-m_order[1]
m_knot[1][span_index1+m_order[1]-2] &lt; m_knot[1][span_index1+m_order[1]-1]
</param>
            <param name="bezier_surface">[out] bezier surface returned here</param>
            <returns>
TRUE if successful
FALSE if input is not valid
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.GetGrevilleAbcissae(System.Int32,System.Double[]@)">
            <summary>see ON_GetGrevilleAbcissa() for details</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.GrevilleAbcissa(System.Int32,System.Int32)">
            <param name="cv_index">0 &lt;= index &lt; CVCount(dir)</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.SuperfluousKnot(System.Int32,System.Int32)">
            <param name="dir">dir 0 = "s", 1 = "t"</param>
            <param name="end">end to check: 0 = start, 1 = end, 2 = start and end</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.IsClamped(System.Int32)">
            <summary>determine if knot vector is clamped</summary>
            <param name="dir">dir 0 = "s", 1 = "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.IsClamped(System.Int32,System.Int32)">
            <summary>
knot[] array
</summary>
            <summary>determine if knot vector is clamped</summary>
            <param name="dir">dir 0 = "s", 1 = "t"</param>
            <param name="end">end to check: 0 = start, 1 = end, 2 = start and end</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.KnotMultiplicity(System.Int32,System.Int32)">
            <param name="dir">0 = "s", 1 = "t"</param>
            <param name="knot_index">( 0 to KnotCount - 1 )</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.Knot(System.Int32,System.Int32)">
            <param name="dir">0 = "s", 1 = "t"</param>
            <param name="knot_index">( 0 to KnotCount - 1 )</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.GetCV(System.Int32,System.Int32,RMA.OpenNURBS.On4dPoint@)">
            <summary>get a single control vertex</summary>
            <param name="i">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
            <param name="j">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
            <param name="cv">gets homogeneous cv</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.GetCV(System.Int32,System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>get a single control vertex</summary>
            <param name="i">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
            <param name="j">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
            <param name="cv">gets euclidean cv when NURBS is rational</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.Weight(System.Int32,System.Int32)">
            <summary>get value of control vertex weight</summary>
            <param name="i">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
            <param name="j">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.CVStyle">
            <summary>
Description: Expert user function to get a pointer to control vertex memory. If you are not an expert user, please use ON_NurbsSurface::GetCV( ON_3dPoint&amp; ) or ON_NurbsSurface::GetCV( ON_4dPoint&amp; ). Parameters: i - [in] (0 &lt;= i &lt; m_cv_count[0]) j - [in] (0 &lt;= j &lt; m_cv_count[1]) Returns: Pointer to control vertex. Remarks: If the NURBS surface is rational, the format of the returned array is a homogeneos rational point with length m_dim+1. If the NURBS surface is not rational, the format of the returned array is a nonrational euclidean point with length m_dim. See Also ON_NurbsSurface::CVStyle ON_NurbsSurface::GetCV ON_NurbsSurface::Weight
</summary>
            <summary>Returns the style of control vertices in the m_cv array.</summary>
            <returns>
ON::not_rational         m_is_rat is FALSE
ON::homogeneous_rational m_is_rat is TRUE
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.KnotCount(System.Int32)">
            <summary>
total number of knots in knot vector
</summary>
            <param name="dir">0 = "s", 1 = "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.CVCount">
            <summary>
total number of control vertices
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.CVCount(System.Int32)">
            <summary>number of control vertices</summary>
            <param name="dir">0 = "s", 1 = "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.Order(System.Int32)">
            <summary>order = degree + 1</summary>
            <param name="dir">0 = "s", 1 = "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.CVSize">
            <summary>
number of doubles per control vertex = IsRational() ? Dim()+1 : Dim()
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.IsRational">
            <summary>
TRUE if NURBS surface is rational
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.ControlPolygonLength(System.Int32)">
            <summary>Get the maximum length of a nurb surface's control polygon rows and/or columns</summary>
            <param name="dir">
[in] 0 to get "u" direction length, 1 to get "v" direction length
</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.IsMorphable">
            <summary>
virtual ON_Geometry override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.IsDeformable">
            <summary>
virtual ON_Geometry::IsDeformable() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.IsDuplicate(RMA.OpenNURBS.IOnNurbsSurface,System.Boolean)">
            <summary>See if this and other are same NURBS geometry.</summary>
            <param name="other">[in] other NURBS surface</param>
            <param name="bIgnoreParameterization">[in] if true, parameterization and orientaion are ignored.</param>
            <returns>true if curves are tne same.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.IsDuplicate(RMA.OpenNURBS.IOnNurbsSurface,System.Boolean,System.Double)">
            <summary>See if this and other are same NURBS geometry.</summary>
            <param name="other">[in] other NURBS surface</param>
            <param name="bIgnoreParameterization">[in] if true, parameterization and orientaion are ignored.</param>
            <param name="tolerance">[in] tolerance to use when comparing control points.</param>
            <returns>true if curves are tne same.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnNurbsSurface.m_cv_capacity">
            <value>
If m_cv_capacity &gt; 0, then m_cv[] is an array of at least m_cv_capacity doubles whose
memory is managed by the ON_NurbsSurface class using rhmalloc(), onrealloc(), and rhfree().
If m_cv_capacity is 0 and m_cv is not NULL, then m_cv[] is assumed to be big enough
for any requested operation and m_cv[] is not deleted by the destructor.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnNurbsSurface.m_cv_stride(System.Int32)">
            <value>
The pointer to start of "CV[i]" is m_cv + i*m_cv_stride.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnNurbsSurface.m_knot_capacity(System.Int32)">
            <value>
If m_knot_capacity &gt; 0, then m_knot[] is an array of at least m_knot_capacity
doubles whose memory is managed by the ON_NurbsSurface class using rhmalloc(),
onrealloc(), and rhfree().
If m_knot_capacity is 0 and m_knot is not NULL, then  m_knot[] is assumed to
be big enough for any requested operation and m_knot[] is not deleted by the
destructor.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnNurbsSurface.m_cv_count(System.Int32)">
            <value>
number of control vertices ( &gt;= order )
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnNurbsSurface.m_order(System.Int32)">
            <value>
order = degree+1 (&gt;=2)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnNurbsSurface.m_is_rat">
            <value>
1 for rational B-splines. (Control vertices use homogeneous form.)
0 for non-rational B-splines. (Control verticies do not have a weight coordinate.)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnNurbsSurface.m_dim">
            <value>
(&gt;=1)
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnTensorProduct.DimensionC">
            <summary>dimension of range space</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTensorProduct.DimensionB">
            <summary>dimension of B space</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTensorProduct.DimensionA">
            <summary>dimension of A space</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnTensorProduct">
            <summary>Pure virtual tensor passed to ON_NurbsSurface::TensorProduct()</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTensorProduct.DimensionC">
            <summary>dimension of range space</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTensorProduct.DimensionB">
            <summary>dimension of B space</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTensorProduct.DimensionA">
            <summary>dimension of A space</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnTensorProduct">
            <summary>Pure virtual tensor passed to ON_NurbsSurface::TensorProduct()</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveOnSurface.SwapCoordinates(System.Int32,System.Int32)">
            <summary>
(optional - default uses Transform for 2d and 3d objects)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveOnSurface.op_Implicit(RMA.OpenNURBS.IOnCurveOnSurface)~RMA.OpenNURBS.OnCurveOnSurface">
            <summary>
Parameters: 
p2dCurve - [in] ~ON_CurveOnSurface() will delete this curve. Use an ON_CurveProxy if you don't want the original deleted. 
p3dCurve - [in] ~ON_CurveOnSurface() will delete this curve. Use an ON_CurveProxy if you don't want the original deleted.
pSurface - [in] ~ON_CurveOnSurface() will delete this surface. Use an ON_SurfaceProxy if you don't want the original deleted.
</summary>
            <summary>
no implementation
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.SegmentParameters">
            <summary>
Returns: Reference to m_t.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.SegmentCurves">
            <summary>
Returns: Reference to m_segment.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.ParameterSearch(System.Double,System.Int32@,System.Boolean)">
            <summary>
Lookup a parameter in the m_t array, optionally using a built in snap
tolerance to snap a parameter value to an element of m_t.
</summary>
            <param name="t">[in] parameter</param>
            <param name="index">
[out] index into m_t such that if the function returns true then
t is equal to, or is within tolerance of m_t[index].
if function returns false then the value of index is
t&lt;m_t[0] or m_t is empty   -1
m_t[i] &lt; t &lt; m_t[i+1]    i for 0&lt;=i&lt;=m_t.Count()-2
t&gt;m_t[ m_t.Count()-1]       m_t.Count()-1
</param>
            <param name="bEnableSnap">[in] if true use tolerance when comparing to m_t values</param>
            <returns>true if the t is exactly equal to, or within tolerance of (only if bEnableSnap==true) m_t[index].</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.RemoveNestingEx">
            <summary>
Removes the nested of polycurves. The result will have not have
an ON_PolyCurve as a segment but will have identical locus and
parameterization.
</summary>
            <returns>True if a nested polycurve was removed. False if no nested polycurves were found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.RemoveNesting">
            <summary>Same as RemoveNestingEx().</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.HarvestSegment(System.Int32)">
            <summary>
Use the HarvestSegment() function when you want to prevent a
segment from being destroyed by ~ON_PolyCurve().  HarvestSegment()
replaces the polycurve segment with a NULL.  Count() and parameter
information remains unchanged.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.Remove(System.Int32)">
            <summary>
delete specified segment and reduce count by 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.Remove">
            <summary>
delete last segment and reduce count by 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.AppendAndMatch(RMA.OpenNURBS.OnCurve)">
            <summary>
ON_Curve pointers added with Prepend(), Append(), PrependAndMatch(), AppendANdMatch(),and Insert()
are deleted by ~ON_PolyCurve(). Use ON_CurveProxy( ON_Curve*) if you want
the original curve segment to survive ~ON_PolyCurve().
PrependAndMatch() and AppendAndMatch() return FALSE if this-&gt;IsCLosed() or 
this-&gt;Count() &gt; 0 and curve is closed
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.PrependAndMatch(RMA.OpenNURBS.OnCurve)">
            <summary>
ON_Curve pointers added with Prepend(), Append(), PrependAndMatch(), AppendANdMatch(),and Insert()
are deleted by ~ON_PolyCurve(). Use ON_CurveProxy( ON_Curve*) if you want
the original curve segment to survive ~ON_PolyCurve().
PrependAndMatch() and AppendAndMatch() return FALSE if this-&gt;IsCLosed() or 
this-&gt;Count() &gt; 0 and curve is closed
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.Insert(System.Int32,RMA.OpenNURBS.OnCurve)">
            <summary>
ON_Curve pointers added with Prepend(), Append(), PrependAndMatch(), AppendANdMatch(),and Insert()
are deleted by ~ON_PolyCurve(). Use ON_CurveProxy( ON_Curve*) if you want
the original curve segment to survive ~ON_PolyCurve().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.Append(RMA.OpenNURBS.OnCurve)">
            <summary>
ON_Curve pointers added with Prepend(), Append(), PrependAndMatch(), AppendANdMatch(),and Insert()
are deleted by ~ON_PolyCurve(). Use ON_CurveProxy( ON_Curve*) if you want
the original curve segment to survive ~ON_PolyCurve().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.Prepend(RMA.OpenNURBS.OnCurve)">
            <summary>
ON_Curve pointers added with Prepend(), Append(), PrependAndMatch(), AppendANdMatch(),and Insert()
are deleted by ~ON_PolyCurve(). Use ON_CurveProxy( ON_Curve*) if you want
the original curve segment to survive ~ON_PolyCurve().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.Reserve(System.Int32)">
            <summary>
make sure capacity is at least the specified count
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.HasGap">
            <summary>
This is a quick way to see if the curve has gaps between the sub curve segments.
The test is fairly severe (ON_ComparePoint).
</summary>
            <returns>
0: The ends adjacent polycuve segments are coincident.
i &gt; 0: The end of polycuve segment (i-1) is not coincident with the start of polycurve segment i.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.LastSegmentCurve">
            <summary>
returns NULL if count = 0
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.FirstSegmentCurve">
            <summary>
returns NULL if count = 0
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.SegmentIndex(System.Double)">
            <summary>Find the segment used for evaluation at polycurve_parameter.</summary>
            <param name="polycurve_parameter">[in]</param>
            <returns>
index of the segment used for evaluation at polycurve_parameter.
If polycurve_parameter &lt; Domain.Min(), then 0 is returned.
If polycurve_parameter &gt; Domain.Max(), then Count()-1 is returned.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.SegmentDomain(System.Int32)">
            <summary>Returns the polycurve subdomain assigned to a segment curve.</summary>
            <param name="segment_index">[in] 0 based index (0 &lt;= segment_index &lt; Count() )</param>
            <returns>
The polycurve subdomain assigned to a segment curve.
Returns ([ON_UNSET_VALUE,ON_UNSET_VALUE) if segment_index &lt; 0 or segment_index &gt;= Count().
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.PolyCurveParameter(System.Int32,System.Double)">
            <summary>Converts a segment curve parameter to a polycurve parameter.</summary>
            <param name="segment_index">[in]</param>
            <param name="segmentcurve_parameter">[in]</param>
            <returns>
Polycurve evaluation parameter or ON_UNSET_VALUE if the polycurve
curve parameter cannot be computed.
See Also: ON_PolyCurve::SegmentCurveParameter
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.SegmentCurveParameter(System.Double)">
            <summary>Converts a polycurve parameter to a segment curve parameter.</summary>
            <param name="polycurve_parameter">[in]</param>
            <returns>
Segment curve evaluation parameter or ON_UNSET_VALUE if the
segment curve parameter cannot be computed.
See Also: ON_PolyCurve::PolyCurveParameter
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.SegmentCurve(System.Int32)">
            <summary>Returns a pointer to a segment curve.</summary>
            <param name="segment_index">[in] 0 based index (0 &lt;= segment_index &lt; Count() )</param>
            <returns>A pointer to the segment curve. Returns NULL if segment_index &lt; 0 or segment_index &gt;= Count().</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.Count">
            <summary>
number of segment curves
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.RemoveShortSegments(System.Double)">
            <summary>
Looks for segments that are shorter than tolerance that can be removed.
If bRemoveShortSegments is true, then the short segments are removed.
Does not change the domain, but it will change the relative parameterization.
</summary>
            <param name="tolerance">[in]</param>
            <returns>
True if removable short segments can were found.
False if no removable short segments can were found.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.RemoveShortSegments(System.Double,System.Boolean)">
            <summary>
Looks for segments that are shorter than tolerance that can be removed.
If bRemoveShortSegments is true, then the short segments are removed.
Does not change the domain, but it will change the relative parameterization.
</summary>
            <param name="tolerance">[in]</param>
            <param name="bRemoveShortSegments">[in] If true, then short segments are removed.</param>
            <returns>
True if removable short segments can were found.
False if no removable short segments can were found.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.IsMorphable">
            <summary>
virtual ON_Geometry override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.Morph(RMA.OpenNURBS.IOnSpaceMorph)">
            <summary>
virtual ON_Geometry override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.MakeDeformable">
            <summary>
virtual ON_Geometry::MakeDeformable() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.IsDeformable">
            <summary>
virtual ON_Geometry::IsDeformable() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.EmergencyDestroy">
            <summary>
call if memory used by ON_PolyCurve becomes invalid
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.#ctor(System.Int32)">
            <param name="capacity">initial capacity - use when a good estimate of the number of segments is known.</param>
        </member>
        <member name="T:RMA.OpenNURBS.OnPolyCurve">
            <summary>
An ON_PolyCurve is an ON_Curve represented by a sequence of 
contiguous ON_Curve segments. A valid polycurve is represented 
by an array m_segment of Count()&gt;=1 curve objects	and a strictly
increasing array m_t of Count()+1 parameter values.  The i-th 
curve segment,  when considered as part of the polycurve, is affinely 
reparamaterized from m_t[i] to m_t[i+1], i.e., m_segment[i].Domain()[0] 
is mapped to 	m_t[i] and m_segment[i].Domain()[1] is mapped to m_t[i+1]. 
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyCurve.SegmentParameters">
            <summary>
Returns: Reference to m_t.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyCurve.SegmentCurves">
            <summary>
Returns: Reference to m_segment.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyCurve.ParameterSearch(System.Double,System.Int32@,System.Boolean)">
            <summary>
Lookup a parameter in the m_t array, optionally using a built in snap
tolerance to snap a parameter value to an element of m_t.
</summary>
            <param name="t">[in] parameter</param>
            <param name="index">
[out] index into m_t such that if the function returns true then
t is equal to, or is within tolerance of m_t[index].
if function returns false then the value of index is
t&lt;m_t[0] or m_t is empty   -1
m_t[i] &lt; t &lt; m_t[i+1]    i for 0&lt;=i&lt;=m_t.Count()-2
t&gt;m_t[ m_t.Count()-1]       m_t.Count()-1
</param>
            <param name="bEnableSnap">[in] if true use tolerance when comparing to m_t values</param>
            <returns>true if the t is exactly equal to, or within tolerance of (only if bEnableSnap==true) m_t[index].</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyCurve.HasGap">
            <summary>
This is a quick way to see if the curve has gaps between the sub curve segments.
The test is fairly severe (ON_ComparePoint).
</summary>
            <returns>
0: The ends adjacent polycuve segments are coincident.
i &gt; 0: The end of polycuve segment (i-1) is not coincident with the start of polycurve segment i.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyCurve.LastSegmentCurve">
            <summary>
returns NULL if count = 0
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyCurve.FirstSegmentCurve">
            <summary>
returns NULL if count = 0
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyCurve.SegmentIndex(System.Double)">
            <summary>Find the segment used for evaluation at polycurve_parameter.</summary>
            <param name="polycurve_parameter">[in]</param>
            <returns>
index of the segment used for evaluation at polycurve_parameter.
If polycurve_parameter &lt; Domain.Min(), then 0 is returned.
If polycurve_parameter &gt; Domain.Max(), then Count()-1 is returned.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyCurve.SegmentDomain(System.Int32)">
            <summary>Returns the polycurve subdomain assigned to a segment curve.</summary>
            <param name="segment_index">[in] 0 based index (0 &lt;= segment_index &lt; Count() )</param>
            <returns>
The polycurve subdomain assigned to a segment curve.
Returns ([ON_UNSET_VALUE,ON_UNSET_VALUE) if segment_index &lt; 0 or segment_index &gt;= Count().
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyCurve.PolyCurveParameter(System.Int32,System.Double)">
            <summary>Converts a segment curve parameter to a polycurve parameter.</summary>
            <param name="segment_index">[in]</param>
            <param name="segmentcurve_parameter">[in]</param>
            <returns>
Polycurve evaluation parameter or ON_UNSET_VALUE if the polycurve
curve parameter cannot be computed.
See Also: ON_PolyCurve::SegmentCurveParameter
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyCurve.SegmentCurveParameter(System.Double)">
            <summary>Converts a polycurve parameter to a segment curve parameter.</summary>
            <param name="polycurve_parameter">[in]</param>
            <returns>
Segment curve evaluation parameter or ON_UNSET_VALUE if the
segment curve parameter cannot be computed.
See Also: ON_PolyCurve::PolyCurveParameter
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyCurve.SegmentCurve(System.Int32)">
            <summary>Returns a pointer to a segment curve.</summary>
            <param name="segment_index">[in] 0 based index (0 &lt;= segment_index &lt; Count() )</param>
            <returns>A pointer to the segment curve. Returns NULL if segment_index &lt; 0 or segment_index &gt;= Count().</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyCurve.Count">
            <summary>
number of segment curves
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyCurve.IsMorphable">
            <summary>
virtual ON_Geometry override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyCurve.IsDeformable">
            <summary>
virtual ON_Geometry::IsDeformable() override
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnPolyCurve">
            <summary>
An ON_PolyCurve is an ON_Curve represented by a sequence of 
contiguous ON_Curve segments. A valid polycurve is represented 
by an array m_segment of Count()&gt;=1 curve objects	and a strictly
increasing array m_t of Count()+1 parameter values.  The i-th 
curve segment,  when considered as part of the polycurve, is affinely 
reparamaterized from m_t[i] to m_t[i+1], i.e., m_segment[i].Domain()[0] 
is mapped to 	m_t[i] and m_segment[i].Domain()[1] is mapped to m_t[i+1]. 
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.#ctor(System.Int32,System.Boolean,System.Int32,System.Int32)">
            <summary>Create a NURBS curve with knot a cv memory allocated.</summary>
            <param name="dimension">[in] (&gt;= 1)</param>
            <param name="bIsRational">[in] TRUE to make a rational NURBS</param>
            <param name="order">[in] (&gt;= 2) The order=degree+1</param>
            <param name="cv_count">[in] (&gt;= order) number of control vertices</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.#ctor(RMA.OpenNURBS.IOnBezierCurve)">
            <summary>Create a NURBS curve equal to bezier with domain [0,1].</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.Reparameterize(System.Double)">
            <summary>
Use a linear fractional transformation to reparameterize the NURBS curve.  This does not change the curve's domain.
</summary>
            <param name="c">
[in] reparameterization constant (generally speaking, c should be &gt; 0). The control points and knots are adjusted so that 
output_nurbs(t) = input_nurbs(lambda(t)), where lambda(t) = c*t/( (c-1)*t + 1 ).
Note that lambda(0) = 0, lambda(1) = 1, lambda'(t) &gt; 0, lambda'(0) = c and lambda'(1) = 1/c.
</param>
            <returns>true if successful.</returns>
            <remarks>
The cv and knot values are values are changed so that output_nurbs(t) = input_nurbs(lambda(t)).
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.ChangeEndWeights(System.Double,System.Double)">
            <summary>
Use a combination of scaling and reparameterization to change the end weights to the specified values.
</summary>
            <param name="w0">[in] weight for first cv</param>
            <param name="w1">[in] weight for last cv</param>
            <returns>true if successful.</returns>
            <remarks>
The domain, eucleanean locations of the control points, and locus of the curve do not change, but the weights,
homogeneous cv values and internal knot values may change. If w0 and w1 are 1 and the curve is not rational,
the curve is not changed.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.MakePiecewiseBezier">
            <summary>
Clamps ends and adds knots so the NURBS curve has bezier spans (all distinct knots have multiplitity = degree).
</summary>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.MakePiecewiseBezier(System.Boolean)">
            <summary>
Clamps ends and adds knots so the NURBS curve has bezier spans (all distinct knots have multiplitity = degree).
</summary>
            <param name="bSetEndWeightsToOne">
[in] If true and the first or last weight is not one, then the first and last spans
are reparameterized so that the end weights are one.
</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.HasBezierSpans">
            <summary>
Returns TRUE if the NURBS curve has bezier spans 
(all distinct knots have multiplitity = degree)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.ConvertSpanToBezier(System.Int32,RMA.OpenNURBS.OnBezierCurve@)">
            <summary>
Converts a span of the NURBS curve into a bezier.  If the span is empty 
(m_knot[span_index+m_order-2] == m_knot[span_index+m_order-1]),
then FALSE is returned.
</summary>
            <param name="span_index">(0 &lt;= span_index &lt;= m_cv_count-m_order)</param>
            <param name="bezier">bezier returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.ControlPolygonLength">
            <summary>returns the length of the control polygon</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.ReserveKnotCapacity(System.Int32)">
            <summary>Tools for managing CV and knot memory</summary>
            <param name="arg1">number of doubles to reserve</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.ReserveCVCapacity(System.Int32)">
            <summary>Tools for managing CV and knot memory</summary>
            <param name="arg1">number of doubles to reserve</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.InsertKnot(System.Double,System.Int32)">
            <summary>Insert a knot and update cv locations.</summary>
            <param name="knot_value">[in] m_knot[order-2] &lt; knot_value &lt; m_knot[m_cv_count-1]</param>
            <param name="knot_multiplicity">[in] 1 to degree - includes multiplicity of existing knots.</param>
            <remarks>Does not change parameterization or locus of curve.</remarks>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.ClampEnd(System.Int32)">
            <summary>
Clamp end knots.  Does not modify control points.
</summary>
            <param name="end">[in] 0 = clamp start, 1 = clamp end, 2 = clamp start and end</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.ZeroCVs">
            <summary>
zeros control vertices and, if rational, sets weights to 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.GetGrevilleAbcissae(System.Double[]@)">
            <summary>see ON_GetGrevilleAbcissae() for details</summary>
            <param name="g">g[cv_count]</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.GrevilleAbcissa(System.Int32)">
            <param name="index">index (0 &lt;= index &lt; CVCount(dir)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.SuperfluousKnot(System.Int32)">
            <param name="end">0 = start, 1 = end</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.IsClamped">
            <summary>determine if knot vector is clamped</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.IsClamped(System.Int32)">
            <summary>determine if knot vector is clamped</summary>
            <param name="end">end to check: 0 = start, 1 = end, 2 = start and end</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.MakePeriodicUniformKnotVector">
            <summary>
Make knot vector a periodic uniform knot vector
based on the current values of m_order and m_cv_count.
Does not change values of control vertices.
</summary>
            <returns>TRUE if successful.</returns>
            <remarks>
Allocates m_knot[] if it is not big enough.
See Also: ON_MakePeriodicUniformKnotVector
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.MakePeriodicUniformKnotVector(System.Double)">
            <summary>
Make knot vector a periodic uniform knot vector
based on the current values of m_order and m_cv_count.
Does not change values of control vertices.
</summary>
            <param name="delta">[in] (&gt;0.0) knot spacing.</param>
            <returns>TRUE if successful.</returns>
            <remarks>
Allocates m_knot[] if it is not big enough.
See Also: ON_MakePeriodicUniformKnotVector
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.MakeClampedUniformKnotVector">
            <summary>
Make knot vector a clamped uniform knot vector
based on the current values of m_order and m_cv_count.
Does not change values of control vertices.
</summary>
            <returns>TRUE if successful.</returns>
            <remarks>
Allocates m_knot[] if it is not big enough.
See Also: ON_MakeClampedUniformKnotVector
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.MakeClampedUniformKnotVector(System.Double)">
            <summary>
Description:
 Get pointer to knot vector array.
Returns:
 pointer to knot vector array (m_knot).
See Also:
 ON_NurbsCurve::SetKnot, ON_NurbsCurve::Knot, 
 ON_NurbsCurve::InsertKnot
</summary>
            <summary>
Make knot vector a clamped uniform knot vector
based on the current values of m_order and m_cv_count.
Does not change values of control vertices.
</summary>
            <param name="delta">[in] (&gt;0.0) knot spacing.</param>
            <returns>TRUE if successful.</returns>
            <remarks>
Allocates m_knot[] if it is not big enough.
See Also: ON_MakeClampedUniformKnotVector
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.KnotMultiplicity(System.Int32)">
            <summary>Get knot multiplicity.</summary>
            <param name="knot_index">[in] 0 &lt;= knot_index &lt;= KnotCount()-1</param>
            <returns>
knot multiplicity = m_knot[knot_index]
See Also:
ON_NurbsCurve::SetKnot, ON_NurbsCurve::Knot, 
ON_NurbsCurve::InsertKnot
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.Knot(System.Int32)">
            <summary>Get knot value.</summary>
            <param name="knot_index">[in] 0 &lt;= knot_index &lt;= KnotCount()-1</param>
            <returns>
knot value = m_knot[knot_index]
See Also: ON_NurbsCurve::SetKnot, ON_NurbsCurve::KnotMultiplicity
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.SetKnot(System.Int32,System.Double)">
            <summary>Set knot value.</summary>
            <param name="knot_index">[in] 0 &lt;= knot_index &lt;= KnotCount()-1</param>
            <param name="knot_value">[in]</param>
            <remarks>m_knot[] must exist.  Use ReserveKnotCapacity to allocate m_knot[].</remarks>
            <returns>
TRUE if successful
See Also: ON_NurbsCurve::ReserveKnotCapacity
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.GetCV(System.Int32,RMA.OpenNURBS.On4dPoint@)">
            <summary>get a single control vertex</summary>
            <param name="cv_index">CV index ( &gt;= 0 and &lt; CVCount() )</param>
            <param name="vertex_value">gets homogeneous cv</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.GetCV(System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>get a single control vertex</summary>
            <param name="cv_index">CV index ( &gt;= 0 and &lt; CVCount() )</param>
            <param name="vertex_value">gets euclidean cv when NURBS is rational</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.GetCV(System.Int32,RMA.OpenNURBS.IOn.point_style,System.Double[]@)">
            <summary>get a single control vertex</summary>
            <param name="cv_index">CV index ( &gt;= 0 and &lt; CVCount() )</param>
            <param name="style">style to use for output point</param>
            <param name="arg3">array of length CVSize()</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.SetCV(System.Int32,RMA.OpenNURBS.IOn4dPoint)">
            <summary>set a single control vertex</summary>
            <param name="cv_index">CV index ( &gt;= 0 and &lt; CVCount() )</param>
            <param name="vertex_value">
value of control vertex
If NURBS is not rational, euclidean location of
homogeneous point will be used.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.SetCV(System.Int32,RMA.OpenNURBS.IOn3dPoint)">
            <summary>set a single control vertex</summary>
            <param name="cv_index">CV index ( &gt;= 0 and &lt; CVCount() )</param>
            <param name="vertex_value">
value of control vertex
If NURBS is rational, weight will be set to 1.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.SetWeight(System.Int32,System.Double)">
            <summary>
set value of control vertex weight
</summary>
            <param name="cv_index">CV index ( &gt;= 0 and &lt; CVCount() )</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.Weight(System.Int32)">
            <summary>
get value of control vertex weight
</summary>
            <param name="cv_index">CV index ( &gt;= 0 and &lt; CVCount() )</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.CVStyle">
            <summary>
Description: Expert user function to get a pointer to control vertex memory. If you are not an expert user, please use ON_NurbsCurve::GetCV( ON_3dPoint&amp; ) or ON_NurbsCurve::GetCV( ON_4dPoint&amp; ). Parameters: cv_index - [in] Returns: Pointer to control vertex. Remarks: If the NURBS curve is rational, the format of the returned array is a homogeneos rational point with length m_dim+1. If the NURBS curve is not rational, the format of the returned array is a nonrational euclidean point with length m_dim. See Also ON_NurbsCurve::CVStyle ON_NurbsCurve::GetCV ON_NurbsCurve::Weight
</summary>
            <summary>
Returns the style of control vertices in the m_cv array.
</summary>
            <returns>
ON::not_rational          m_is_rat is FALSE
ON::homogeneous_rational  m_is_rat is TRUE
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.KnotCount">
            <summary>
total number of knots in knot vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.CVCount">
            <summary>
number of control vertices
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.Order">
            <summary>
order = degree + 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.CVSize">
            <summary>
number of doubles per control vertex
= IsRational() ? Dim()+1 : Dim()
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.IsRational">
            <summary>
TRUE if NURBS curve is rational
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.RepairBadKnots">
            <summary>
Looks for problems caused by knots that are close together or
have mulitplicity &gt;= order. If bRepair is true, the problems
are fixed. Does not change the domain.
</summary>
            <returns>
True if bad knots were found and can be repaired.
See Also: ON_NurbsCurve::RemoveShortSegments
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.RepairBadKnots(System.Double)">
            <summary>
Looks for problems caused by knots that are close together or
have mulitplicity &gt;= order. If bRepair is true, the problems
are fixed. Does not change the domain.
</summary>
            <param name="knot_tolerance">[in] &gt;= 0 When in doubt, use zero.</param>
            <returns>
True if bad knots were found and can be repaired.
See Also: ON_NurbsCurve::RemoveShortSegments
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.RepairBadKnots(System.Double,System.Boolean)">
            <summary>
Looks for problems caused by knots that are close together or
have mulitplicity &gt;= order. If bRepair is true, the problems
are fixed. Does not change the domain.
</summary>
            <param name="knot_tolerance">[in] &gt;= 0 When in doubt, use zero.</param>
            <param name="bRepair">
[in] If true, then problems are repaired. Otherwise this function
looks for problems that can be repaired, but does not modify the curve.
</param>
            <returns>
True if bad knots were found and can be repaired.
See Also: ON_NurbsCurve::RemoveShortSegments
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.RemoveShortSegments(System.Double)">
            <summary>
Looks for segments that are shorter than tolerance that can be removed.
If bRemoveShortSegments is true, then the short segments are removed.
Does not change the domain, but it will change the relative parameterization.
</summary>
            <param name="tolerance">[in]</param>
            <returns>
True if removable short segments can were found.
False if no removable short segments can were found.
See Also: ON_NurbsCurve::RepairBadKnots
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.RemoveShortSegments(System.Double,System.Boolean)">
            <summary>
Looks for segments that are shorter than tolerance that can be removed.
If bRemoveShortSegments is true, then the short segments are removed.
Does not change the domain, but it will change the relative parameterization.
</summary>
            <param name="tolerance">[in]</param>
            <param name="bRemoveShortSegments">[in] If true, then short segments are removed.</param>
            <returns>
True if removable short segments can were found.
False if no removable short segments can were found.
See Also: ON_NurbsCurve::RepairBadKnots
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.IsMorphable">
            <summary>
virtual ON_Geometry override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.Morph(RMA.OpenNURBS.IOnSpaceMorph)">
            <summary>
virtual ON_Geometry override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.SwapCoordinates(System.Int32,System.Int32)">
            <summary>
virtual ON_Geometry::SwapCoordinates override.
Swaps control vertex coordinate values with indices i and j.
</summary>
            <param name="i">[in] coordinate index</param>
            <param name="j">[in] coordinate index</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.MakeDeformable">
            <summary>
virtual ON_Geometry::MakeDeformable() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.IsDeformable">
            <summary>
virtual ON_Geometry::IsDeformable() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>
virtual ON_Geometry::Transform override.
Transforms the NURBS curve.
</summary>
            <param name="xform">[in] transformation to apply to object.</param>
            <remarks>
When overriding this function, be sure to include a call
to ON_Object::TransformUserData() which takes care of 
transforming any ON_UserData that may be attached to 
the object.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.op_Implicit(RMA.OpenNURBS.IOnBezierCurve)~RMA.OpenNURBS.OnNurbsCurve">
            <summary>
Set NURBS curve equal to bezier with domain [0,1].
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.EmergencyDestroy">
            <summary>
Call if memory used by ON_NurbsCurve becomes invalid.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.Destroy">
            <summary>
Description:
 Deallocate knot and cv memory.  Zeros all fields.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.CreatePeriodicUniformNurbs(System.Int32,System.Int32,RMA.OpenNURBS.IOn3dPoint[])">
            <summary>Create a periodic uniform NURBS curve from a list of control points</summary>
            <param name="dimension">[in] 1, 2 or 3</param>
            <param name="order">[in] (&gt;=2) order=degree+1</param>
            <param name="points">
[in] (&gt;=max(3,order-1)) number of distinct control vertices
array of distinct control vertex locations.
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.CreatePeriodicUniformNurbs(System.Int32,System.Int32,RMA.OpenNURBS.IOn3dPoint[],System.Double)">
            <summary>Create a periodic uniform NURBS curve from a list of control points</summary>
            <param name="dimension">[in] 1, 2 or 3</param>
            <param name="order">[in] (&gt;=2) order=degree+1</param>
            <param name="points">
[in] (&gt;=max(3,order-1)) number of distinct control vertices
array of distinct control vertex locations.
</param>
            <param name="knot_delta">[in] (&gt;0.0) knot spacing</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.CreateClampedUniformNurbs(System.Int32,System.Int32,RMA.OpenNURBS.IOn3dPoint[])">
            <summary>Create a clamped uniform NURBS curve from a list of control points</summary>
            <param name="dimension">[in] 1, 2 or 3</param>
            <param name="order">[in] (&gt;=2) order=degree+1</param>
            <param name="points">
[in] (&gt;=order) number of control vertices
array of control vertex locations.
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.CreateClampedUniformNurbs(System.Int32,System.Int32,RMA.OpenNURBS.IOn3dPoint[],System.Double)">
            <summary>Create a clamped uniform NURBS curve from a list of control points</summary>
            <param name="dimension">[in] 1, 2 or 3</param>
            <param name="order">[in] (&gt;=2) order=degree+1</param>
            <param name="points">
[in] (&gt;=order) number of control vertices
array of control vertex locations.
</param>
            <param name="knot_delta">[in] (&gt;0.0) knot spacing</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.Create(System.Int32,System.Boolean,System.Int32,System.Int32)">
            <summary>Create a NURBS curve with knot a cv memory allocated.</summary>
            <param name="dimension">[in] (&gt;= 1)</param>
            <param name="bIsRational">[in] TRUE to make a rational NURBS</param>
            <param name="order">[in] (&gt;= 2) The order=degree+1</param>
            <param name="cv_count">[in] (&gt;= order) number of control vertices</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.Initialize">
            <summary>
Zeros all fields.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.IsDuplicate(RMA.OpenNURBS.IOnNurbsCurve,System.Boolean)">
            <summary>See if this and other are same NURBS geometry.</summary>
            <param name="other">[in] other NURBS curve</param>
            <param name="bIgnoreParameterization">[in] if true, parameterization and orientaion are ignored.</param>
            <returns>true if curves are the same.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.IsDuplicate(RMA.OpenNURBS.IOnNurbsCurve,System.Boolean,System.Double)">
            <summary>See if this and other are same NURBS geometry.</summary>
            <param name="other">[in] other NURBS curve</param>
            <param name="bIgnoreParameterization">[in] if true, parameterization and orientaion are ignored.</param>
            <param name="tolerance">[in] tolerance to use when comparing control points.</param>
            <returns>true if curves are the same.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnNurbsCurve.m_cv_capacity">
            <value>
If m_cv_capacity &gt; 0, then m_cv[] is an array
of at least m_cv_capacity doubles whose
memory is managed by the ON_NurbsCurve
class using rhmalloc(), onrealloc(), and rhfree().
If m_cv_capacity is 0 and m_cv is not
NULL, then m_cv[] is assumed to be big enough
for any requested operation and m_cv[] is not
deleted by the destructor.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnNurbsCurve.m_cv_stride">
            <value>
The pointer to start of "CV[i]" is m_cv + i*m_cv_stride.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnNurbsCurve.m_knot_capacity">
            <value>
If m_knot_capacity &gt; 0, then m_knot[] is an array of at least m_knot_capacity
doubles whose memory is managed by the ON_NurbsCurve class using rhmalloc(),
onrealloc(), and rhfree(). If m_knot_capacity is 0 and m_knot is not NULL, then
m_knot[] is assumed to be big enough for any requested operation and
m_knot[] is not deleted by the destructor.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnNurbsCurve.m_cv_count">
            <value>
number of control vertices ( &gt;= order )
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnNurbsCurve.m_order">
            <value>
order = degree+1 (&gt;=2)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnNurbsCurve.m_is_rat">
            <value>
1 for rational B-splines. (Rational control vertices use homogeneous form.)
0 for non-rational B-splines. (Control verticies do not have a weight coordinate.)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnNurbsCurve.m_dim">
            <value>
(&gt;=1)
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.HasBezierSpans">
            <summary>
Returns TRUE if the NURBS curve has bezier spans 
(all distinct knots have multiplitity = degree)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.ConvertSpanToBezier(System.Int32,RMA.OpenNURBS.OnBezierCurve@)">
            <summary>
Converts a span of the NURBS curve into a bezier.  If the span is empty 
(m_knot[span_index+m_order-2] == m_knot[span_index+m_order-1]),
then FALSE is returned.
</summary>
            <param name="span_index">(0 &lt;= span_index &lt;= m_cv_count-m_order)</param>
            <param name="bezier">bezier returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.ControlPolygonLength">
            <summary>returns the length of the control polygon</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.GetGrevilleAbcissae(System.Double[]@)">
            <summary>see ON_GetGrevilleAbcissae() for details</summary>
            <param name="g">g[cv_count]</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.GrevilleAbcissa(System.Int32)">
            <param name="index">index (0 &lt;= index &lt; CVCount(dir)</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.SuperfluousKnot(System.Int32)">
            <param name="end">0 = start, 1 = end</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.IsClamped">
            <summary>determine if knot vector is clamped</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.IsClamped(System.Int32)">
            <summary>determine if knot vector is clamped</summary>
            <param name="end">end to check: 0 = start, 1 = end, 2 = start and end</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.KnotMultiplicity(System.Int32)">
            <summary>Get knot multiplicity.</summary>
            <param name="knot_index">[in] 0 &lt;= knot_index &lt;= KnotCount()-1</param>
            <returns>
knot multiplicity = m_knot[knot_index]
See Also:
ON_NurbsCurve::SetKnot, ON_NurbsCurve::Knot, 
ON_NurbsCurve::InsertKnot
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.Knot(System.Int32)">
            <summary>Get knot value.</summary>
            <param name="knot_index">[in] 0 &lt;= knot_index &lt;= KnotCount()-1</param>
            <returns>
knot value = m_knot[knot_index]
See Also: ON_NurbsCurve::SetKnot, ON_NurbsCurve::KnotMultiplicity
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.GetCV(System.Int32,RMA.OpenNURBS.On4dPoint@)">
            <summary>get a single control vertex</summary>
            <param name="cv_index">CV index ( &gt;= 0 and &lt; CVCount() )</param>
            <param name="vertex_value">gets homogeneous cv</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.GetCV(System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>get a single control vertex</summary>
            <param name="cv_index">CV index ( &gt;= 0 and &lt; CVCount() )</param>
            <param name="vertex_value">gets euclidean cv when NURBS is rational</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.GetCV(System.Int32,RMA.OpenNURBS.IOn.point_style,System.Double[]@)">
            <summary>get a single control vertex</summary>
            <param name="cv_index">CV index ( &gt;= 0 and &lt; CVCount() )</param>
            <param name="style">style to use for output point</param>
            <param name="arg3">array of length CVSize()</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.Weight(System.Int32)">
            <summary>
get value of control vertex weight
</summary>
            <param name="cv_index">CV index ( &gt;= 0 and &lt; CVCount() )</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.CVStyle">
            <summary>
Description: Expert user function to get a pointer to control vertex memory. If you are not an expert user, please use ON_NurbsCurve::GetCV( ON_3dPoint&amp; ) or ON_NurbsCurve::GetCV( ON_4dPoint&amp; ). Parameters: cv_index - [in] Returns: Pointer to control vertex. Remarks: If the NURBS curve is rational, the format of the returned array is a homogeneos rational point with length m_dim+1. If the NURBS curve is not rational, the format of the returned array is a nonrational euclidean point with length m_dim. See Also ON_NurbsCurve::CVStyle ON_NurbsCurve::GetCV ON_NurbsCurve::Weight
</summary>
            <summary>
Returns the style of control vertices in the m_cv array.
</summary>
            <returns>
ON::not_rational          m_is_rat is FALSE
ON::homogeneous_rational  m_is_rat is TRUE
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.KnotCount">
            <summary>
total number of knots in knot vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.CVCount">
            <summary>
number of control vertices
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.Order">
            <summary>
order = degree + 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.CVSize">
            <summary>
number of doubles per control vertex
= IsRational() ? Dim()+1 : Dim()
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.IsRational">
            <summary>
TRUE if NURBS curve is rational
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.IsMorphable">
            <summary>
virtual ON_Geometry override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.IsDeformable">
            <summary>
virtual ON_Geometry::IsDeformable() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.IsDuplicate(RMA.OpenNURBS.IOnNurbsCurve,System.Boolean)">
            <summary>See if this and other are same NURBS geometry.</summary>
            <param name="other">[in] other NURBS curve</param>
            <param name="bIgnoreParameterization">[in] if true, parameterization and orientaion are ignored.</param>
            <returns>true if curves are the same.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.IsDuplicate(RMA.OpenNURBS.IOnNurbsCurve,System.Boolean,System.Double)">
            <summary>See if this and other are same NURBS geometry.</summary>
            <param name="other">[in] other NURBS curve</param>
            <param name="bIgnoreParameterization">[in] if true, parameterization and orientaion are ignored.</param>
            <param name="tolerance">[in] tolerance to use when comparing control points.</param>
            <returns>true if curves are the same.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnNurbsCurve.m_cv_capacity">
            <value>
If m_cv_capacity &gt; 0, then m_cv[] is an array
of at least m_cv_capacity doubles whose
memory is managed by the ON_NurbsCurve
class using rhmalloc(), onrealloc(), and rhfree().
If m_cv_capacity is 0 and m_cv is not
NULL, then m_cv[] is assumed to be big enough
for any requested operation and m_cv[] is not
deleted by the destructor.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnNurbsCurve.m_cv_stride">
            <value>
The pointer to start of "CV[i]" is m_cv + i*m_cv_stride.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnNurbsCurve.m_knot_capacity">
            <value>
If m_knot_capacity &gt; 0, then m_knot[] is an array of at least m_knot_capacity
doubles whose memory is managed by the ON_NurbsCurve class using rhmalloc(),
onrealloc(), and rhfree(). If m_knot_capacity is 0 and m_knot is not NULL, then
m_knot[] is assumed to be big enough for any requested operation and
m_knot[] is not deleted by the destructor.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnNurbsCurve.m_cv_count">
            <value>
number of control vertices ( &gt;= order )
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnNurbsCurve.m_order">
            <value>
order = degree+1 (&gt;=2)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnNurbsCurve.m_is_rat">
            <value>
1 for rational B-splines. (Rational control vertices use homogeneous form.)
0 for non-rational B-splines. (Control verticies do not have a weight coordinate.)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnNurbsCurve.m_dim">
            <value>
(&gt;=1)
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolylineCurve.PointCount">
            <summary>
number of points in polyline
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolylineCurve.ParameterSearch(System.Double,System.Int32@,System.Boolean)">
            <summary>
Lookup a parameter in the m_t array, optionally using a built in snap
tolerance to snap a parameter value to an element of m_t.
</summary>
            <param name="t">[in] parameter</param>
            <param name="index">
[out] index into m_t such that if function returns false then value of index is
-1                            t&lt;m_t[0] or m_t is empty
0&lt;=i&lt;=m_t.Count()-2     m_t[i] &lt; t &lt; m_t[i+1]
m_t.Count()-1                 t&gt;m_t[ m_t.Count()-1]
if the function returns true then t is equal to, or is closest to and within tolerance of m_t[index].
</param>
            <param name="bEnableSnap">[in] enable snapping</param>
            <returns>
true if the t is exactly equal to, or within tolerance of (only if bEnableSnap==true) m_t[index].
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolylineCurve.RemoveShortSegments(System.Double)">
            <summary>
Looks for segments that are shorter than tolerance that can be removed.
If bRemoveShortSegments is true, then the short segments are removed.
Does not change the domain, but it will change the relative parameterization.
</summary>
            <param name="tolerance">[in]</param>
            <returns>
True if removable short segments can were found.
False if no removable short segments can were found.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolylineCurve.RemoveShortSegments(System.Double,System.Boolean)">
            <summary>
Description: Looks for segments that are shorter than tolerance that can be removed. If bRemoveShortSegments is true, then the short segments are removed. Does not change the domain, but it will change the relative parameterization. Parameters: tolerance - [in] bRemoveShortSegments - [in] If true, then short segments are removed. Returns: True if removable short segments can were found. False if no removable short segments can were found.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolylineCurve.IsShort(System.Double)">
            <summary>Used to quickly find short curves.</summary>
            <param name="tolerance">[in] (&gt;=0)</param>
            <returns>True if the length of the curve is &lt;= tolerance.</returns>
            <remarks>Faster than calling Length() and testing the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolylineCurve.IsShort(System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Used to quickly find short curves.</summary>
            <param name="tolerance">[in] (&gt;=0)</param>
            <param name="sub_domain">
[in] If not NULL, the test is performed on the interval that is the
intersection of sub_domain with Domain().
</param>
            <returns>True if the length of the curve is &lt;= tolerance.</returns>
            <remarks>Faster than calling Length() and testing the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolylineCurve.IsMorphable">
            <summary>
virtual ON_Geometry override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolylineCurve.Morph(RMA.OpenNURBS.IOnSpaceMorph)">
            <summary>
virtual ON_Geometry override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolylineCurve.SwapCoordinates(System.Int32,System.Int32)">
            <summary>
virtual ON_Geometry::SwapCoordinates override.
Swaps control point coordinate values with indices i and j.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolylineCurve.MakeDeformable">
            <summary>
virtual ON_Geometry::MakeDeformable() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolylineCurve.IsDeformable">
            <summary>
virtual ON_Geometry::IsDeformable() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolylineCurve.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>virtual ON_Geometry::Transform override. Transforms the NURBS curve.</summary>
            <param name="xform">[in] transformation to apply to object.</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolylineCurve.EmergencyDestroy">
            <summary>
Description:
 Call if memory used by ON_PolylineCurve becomes invalid.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnPolylineCurve.m_dim">
            <value>
2 or 3 (2 so ON_PolylineCurve can be uses as a trimming curve)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnPolylineCurve.m_t">
            <value>
parameters
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolylineCurve.PointCount">
            <summary>
number of points in polyline
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolylineCurve.ParameterSearch(System.Double,System.Int32@,System.Boolean)">
            <summary>
Lookup a parameter in the m_t array, optionally using a built in snap
tolerance to snap a parameter value to an element of m_t.
</summary>
            <param name="t">[in] parameter</param>
            <param name="index">
[out] index into m_t such that if function returns false then value of index is
-1                            t&lt;m_t[0] or m_t is empty
0&lt;=i&lt;=m_t.Count()-2     m_t[i] &lt; t &lt; m_t[i+1]
m_t.Count()-1                 t&gt;m_t[ m_t.Count()-1]
if the function returns true then t is equal to, or is closest to and within tolerance of m_t[index].
</param>
            <param name="bEnableSnap">[in] enable snapping</param>
            <returns>
true if the t is exactly equal to, or within tolerance of (only if bEnableSnap==true) m_t[index].
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolylineCurve.IsShort(System.Double)">
            <summary>Used to quickly find short curves.</summary>
            <param name="tolerance">[in] (&gt;=0)</param>
            <returns>True if the length of the curve is &lt;= tolerance.</returns>
            <remarks>Faster than calling Length() and testing the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolylineCurve.IsShort(System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Used to quickly find short curves.</summary>
            <param name="tolerance">[in] (&gt;=0)</param>
            <param name="sub_domain">
[in] If not NULL, the test is performed on the interval that is the
intersection of sub_domain with Domain().
</param>
            <returns>True if the length of the curve is &lt;= tolerance.</returns>
            <remarks>Faster than calling Length() and testing the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolylineCurve.IsMorphable">
            <summary>
virtual ON_Geometry override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolylineCurve.IsDeformable">
            <summary>
virtual ON_Geometry::IsDeformable() override
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPolylineCurve.m_dim">
            <value>
2 or 3 (2 so ON_PolylineCurve can be uses as a trimming curve)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPolylineCurve.m_t">
            <value>
parameters
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnArcCurve.#ctor(RMA.OpenNURBS.IOnArc)">
            <summary>Create an arc curve with domain (0,arc.Length()).</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArcCurve.#ctor(RMA.OpenNURBS.IOnArc,System.Double,System.Double)">
            <summary>Create an arc curve with domain (t0,t1)</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArcCurve.#ctor(RMA.OpenNURBS.IOnCircle)">
            <summary>
Creates a curve that is a complete circle with 
domain (0,circle.Length()).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArcCurve.#ctor(RMA.OpenNURBS.IOnCircle,System.Double,System.Double)">
            <summary>Creates a curve that is a complete circle with domain (t0,t1).</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArcCurve.AngleDegrees">
            <summary>
The arc's subtended angle in degrees.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArcCurve.AngleRadians">
            <summary>
The arc's subtended angle in radians.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArcCurve.Radius">
            <summary>The arc's radius.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArcCurve.IsCircle">
            <summary>
Returns true if this arc curve is a complete circle.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArcCurve.IsShort(System.Double)">
            <summary>Used to quickly find short curves.</summary>
            <param name="tolerance">[in] (&gt;=0)</param>
            <returns>True if the length of the curve is &lt;= tolerance.</returns>
            <remarks>Faster than calling Length() and testing the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnArcCurve.IsShort(System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Used to quickly find short curves.</summary>
            <param name="tolerance">[in] (&gt;=0)</param>
            <param name="sub_domain">
[in] If not NULL, the test is performed on the interval
that is the intersection of sub_domain with Domain().
</param>
            <returns>True if the length of the curve is &lt;= tolerance.</returns>
            <remarks>Faster than calling Length() and testing the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnArcCurve.op_Implicit(RMA.OpenNURBS.IOnCircle)~RMA.OpenNURBS.OnArcCurve">
            <summary />
        </member>
        <member name="M:RMA.OpenNURBS.OnArcCurve.op_Implicit(RMA.OpenNURBS.IOnArc)~RMA.OpenNURBS.OnArcCurve">
            <summary>
Create an arc curve with domain (0,arc.Length()).
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnArcCurve.m_dim">
            <value>
The dimension of a arc curve can be 2 or 3.
(2 so ON_ArcCurve can be used as a trimming curve)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnArcCurve.m_t">
            <value>
evaluation domain (always increasing)
( m_t[i] corresponds to m_arc.m_angle[i] )
</value>
        </member>
        <member name="T:RMA.OpenNURBS.OnArcCurve">
            <summary>
ON_ArcCurve is used to represent arcs and circles.
ON_ArcCurve.IsCircle() returns true if the curve
is a complete circle.

Details:
ON_ArcCurve is a subcurve of a circle, with a 
constant speed parameterization. The parameterization is
an affine linear reparameterzation of the underlying arc
m_arc onto the domain m_t.

A valid ON_ArcCurve has Radius()&gt;0 and  0&lt;AngleRadians()&lt;=2*PI
and a strictly increasing Domain(). 
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArcCurve.AngleDegrees">
            <summary>
The arc's subtended angle in degrees.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArcCurve.AngleRadians">
            <summary>
The arc's subtended angle in radians.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArcCurve.Radius">
            <summary>The arc's radius.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArcCurve.IsCircle">
            <summary>
Returns true if this arc curve is a complete circle.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArcCurve.IsShort(System.Double)">
            <summary>Used to quickly find short curves.</summary>
            <param name="tolerance">[in] (&gt;=0)</param>
            <returns>True if the length of the curve is &lt;= tolerance.</returns>
            <remarks>Faster than calling Length() and testing the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArcCurve.IsShort(System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Used to quickly find short curves.</summary>
            <param name="tolerance">[in] (&gt;=0)</param>
            <param name="sub_domain">
[in] If not NULL, the test is performed on the interval
that is the intersection of sub_domain with Domain().
</param>
            <returns>True if the length of the curve is &lt;= tolerance.</returns>
            <remarks>Faster than calling Length() and testing the result.</remarks>
        </member>
        <member name="P:RMA.OpenNURBS.IOnArcCurve.m_dim">
            <value>
The dimension of a arc curve can be 2 or 3.
(2 so ON_ArcCurve can be used as a trimming curve)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnArcCurve.m_t">
            <value>
evaluation domain (always increasing)
(2 so ON_ArcCurve can be used as a trimming curve)
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnArcCurve">
            <summary>
ON_ArcCurve is used to represent arcs and circles.
ON_ArcCurve.IsCircle() returns true if the curve
is a complete circle.

Details:
ON_ArcCurve is a subcurve of a circle, with a 
constant speed parameterization. The parameterization is
an affine linear reparameterzation of the underlying arc
m_arc onto the domain m_t.

A valid ON_ArcCurve has Radius()&gt;0 and  0&lt;AngleRadians()&lt;=2*PI
and a strictly increasing Domain(). 
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLineCurve.IsShort(System.Double)">
            <summary>Used to quickly find short curves.</summary>
            <param name="tolerance">[in] (&gt;=0)</param>
            <returns>True if the length of the curve is &lt;= tolerance.</returns>
            <remarks>Faster than calling Length() and testing the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnLineCurve.IsShort(System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Used to quickly find short curves.</summary>
            <param name="tolerance">[in] (&gt;=0)</param>
            <param name="sub_domain">
[in] If not NULL, the test is performed on the interval that is the intersection of sub_domain with Domain().
</param>
            <returns>True if the length of the curve is &lt;= tolerance.</returns>
            <remarks>Faster than calling Length() and testing the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnLineCurve.IsMorphable">
            <summary>
virtual ON_Geometry override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLineCurve.Morph(RMA.OpenNURBS.IOnSpaceMorph)">
            <summary>
virtual ON_Geometry override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLineCurve.SwapCoordinates(System.Int32,System.Int32)">
            <summary>arg1 and arg2 are indices of coords to swap</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLineCurve.MakeDeformable">
            <summary>
virtual ON_Geometry::MakeDeformable() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLineCurve.IsDeformable">
            <summary>
virtual ON_Geometry::IsDeformable() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLineCurve.#ctor(RMA.OpenNURBS.IOnLine,System.Double,System.Double)">
            <summary>t0 and t1 are the line domain</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLineCurve.#ctor(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
creates a 3d line curve
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLineCurve.#ctor(RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOn2dPoint)">
            <summary>
creates a 2d line curve
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnLineCurve.m_dim">
            <value>
2 or 3 (2 so ON_LineCurve can be uses as a trimming curve)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnLineCurve.m_t">
            <value>
domain
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLineCurve.IsShort(System.Double)">
            <summary>Used to quickly find short curves.</summary>
            <param name="tolerance">[in] (&gt;=0)</param>
            <returns>True if the length of the curve is &lt;= tolerance.</returns>
            <remarks>Faster than calling Length() and testing the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLineCurve.IsShort(System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Used to quickly find short curves.</summary>
            <param name="tolerance">[in] (&gt;=0)</param>
            <param name="sub_domain">
[in] If not NULL, the test is performed on the interval that is the intersection of sub_domain with Domain().
</param>
            <returns>True if the length of the curve is &lt;= tolerance.</returns>
            <remarks>Faster than calling Length() and testing the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLineCurve.IsMorphable">
            <summary>
virtual ON_Geometry override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLineCurve.IsDeformable">
            <summary>
virtual ON_Geometry::IsDeformable() override
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLineCurve.m_dim">
            <value>
2 or 3 (2 so ON_LineCurve can be uses as a trimming curve)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLineCurve.m_t">
            <value>
domain
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointGrid.#ctor(System.Int32,System.Int32)">
            <param name="point_count0">point count0 (&gt;=1)</param>
            <param name="point_count1">point count1 (&gt;=1)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointGrid.Transpose">
            <summary>
transpose grid points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointGrid.Reverse(System.Int32)">
            <summary>reverse grid order</summary>
            <param name="dir">0 = "s", 1 = "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointGrid.GetPoint(System.Int32,System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>
get a single control vertex
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointGrid.SetPoint(System.Int32,System.Int32,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
set a single point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointGrid.PointArrayStride(System.Int32)">
            <summary>
point stride in grid direction
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointGrid.PointCount">
            <summary>
total number of points in grid
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointGrid.PointCount(System.Int32)">
            <summary>number of points in grid direction</summary>
            <param name="dir">0 = "s", 1 = "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointGrid.EmergencyDestroy">
            <summary>
call if memory used by point grid becomes invalid
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointGrid.Create(System.Int32,System.Int32)">
            <param name="point_count0">point count0 (&gt;=1)</param>
            <param name="point_count1">point count1 (&gt;=1)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointGrid.Initialize">
            <summary>
zeros all fields
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPointGrid.GetPoint(System.Int32,System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>
get a single control vertex
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPointGrid.PointArrayStride(System.Int32)">
            <summary>
point stride in grid direction
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPointGrid.PointCount">
            <summary>
total number of points in grid
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPointGrid.PointCount(System.Int32)">
            <summary>number of points in grid direction</summary>
            <param name="dir">0 = "s", 1 = "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshFaceRef.MeshTopologyFace">
            <summary>
Returns: The mesh topology face associated with this mesh face reference.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshFaceRef.MeshFace">
            <summary>
Returns: The mesh face associated with this mesh face reference.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshFaceRef.MeshTopology">
            <summary>
Returns: The mesh topology associated with this mesh face reference or NULL if it doesn't exist.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshFaceRef.m_mesh_fi">
            <value>m_mesh-&gt;m_F[] and m_mesh-&gt;m_top.m_tope[] index.</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshFaceRef.m_mesh">
            <value>parent mesh</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshFaceRef.MeshTopologyFace">
            <summary>
Returns: The mesh topology face associated with this mesh face reference.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshFaceRef.MeshFace">
            <summary>
Returns: The mesh face associated with this mesh face reference.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshFaceRef.MeshTopology">
            <summary>
Returns: The mesh topology associated with this mesh face reference or NULL if it doesn't exist.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshFaceRef.m_mesh_fi">
            <value>m_mesh-&gt;m_F[] and m_mesh-&gt;m_top.m_tope[] index.</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshFaceRef.m_mesh">
            <value>parent mesh</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshEdgeRef.MeshTopologyEdge">
            <summary>
Returns: The mesh topology edge associated with this mesh edge reference.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshEdgeRef.Line">
            <summary>
The 3d location of the mesh edge. Returns ON_UNSET_POINT,ON_UNSET_POINT, is this ON_MeshEdgeRef is not valid.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshEdgeRef.MeshTopology">
            <summary>
The mesh topology associated with this mesh edge reference or NULL if it doesn't exist.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshEdgeRef.m_top_ei">
            <value>m_mesh-&gt;m_top.m_tope[] index</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshEdgeRef.m_mesh">
            <value>parent mesh</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshEdgeRef.MeshTopologyEdge">
            <summary>
Returns: The mesh topology edge associated with this mesh edge reference.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshEdgeRef.Line">
            <summary>
The 3d location of the mesh edge. Returns ON_UNSET_POINT,ON_UNSET_POINT, is this ON_MeshEdgeRef is not valid.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshEdgeRef.MeshTopology">
            <summary>
The mesh topology associated with this mesh edge reference or NULL if it doesn't exist.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshEdgeRef.m_top_ei">
            <value>m_mesh-&gt;m_top.m_tope[] index</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshEdgeRef.m_mesh">
            <value>parent mesh</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshVertexRef.MeshTopologyVertex">
            <summary>
Returns: The mesh topology vertex associated with this mesh vertex reference.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshVertexRef.Point">
            <summary>
The 3d location of the mesh vertex.
Returns ON_UNSET_POINT is this ON_MeshVertexRef is not valid.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshVertexRef.MeshTopology">
            <summary>
The mesh topology associated with this mesh vertex reference
or NULL if it doesn't exist.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshVertexRef.m_top_vi">
            <value>
m_mesh-&gt;m_top.m_topv[] index
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshVertexRef.m_mesh_vi">
            <value>
m_mesh-&gt;m_V[] index
(can be -1 when m_top_vi references a shared vertex location)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshVertexRef.m_mesh">
            <value>parent mesh</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshVertexRef.MeshTopologyVertex">
            <summary>
Returns: The mesh topology vertex associated with this mesh vertex reference.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshVertexRef.Point">
            <summary>
The 3d location of the mesh vertex.
Returns ON_UNSET_POINT is this ON_MeshVertexRef is not valid.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshVertexRef.MeshTopology">
            <summary>
The mesh topology associated with this mesh vertex reference
or NULL if it doesn't exist.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshVertexRef.m_top_vi">
            <value>
m_mesh-&gt;m_top.m_topv[] index
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshVertexRef.m_mesh_vi">
            <value>
m_mesh-&gt;m_V[] index
(can be -1 when m_top_vi references a shared vertex location)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshVertexRef.m_mesh">
            <value>parent mesh</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.HasPackedTextureRegion">
            <returns>
True if the m_srf_scale[] values are positive and
the m_packed_tex_domain[] intervals are set to values
that describe a proper subrectangle of (0,1)x(0,1).
True does not necessarily mean the current values in
m_T[] are packed texture coordinates.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.CreatePartition(System.Int32,System.Int32)">
            <summary>
Some rendering engines work best when processing small batches of
triangles.  CreatePartition() sorts the vertices and faces 
so that they can be processed in small batches.
</summary>
            <param name="arg1">maximum number of vertices in a partition</param>
            <param name="arg2">maximum number of triangles in a partition</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.DestroyTopology">
            <summary>
If you modify the mesh in any way that may change its topology,
then call DestroyTopology().  Specifically if you add or remove
vertices or face, change vertex locations, or change the face m_vi[]
values, then you must call DestroyTopology().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.Topology">
            <summary>
In order to keep the mesh facet definition simple and make the mesh
definition easily used in common rendering application, if two facets
share a vertex location but have different normals, curvatures, 
textures, etc., at that common vertex location, then the vertex is
duplicated.  When the topology of the mesh needs to be known,
use Topology() to get a class that provides complete topological
information about the mesh.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.FaceIsHidden(System.Int32)">
            <summary>
Returns true if the mesh face is hidden. This is a runtime setting
that is not saved in 3dm files.
</summary>
            <param name="meshfi">[in] mesh face index.</param>
            <returns>True if mesh face is hidden.</returns>
            <remarks>A face is hidden if, and only if, at least one of its vertices is hidden.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.VertexIsHidden(System.Int32)">
            <summary>
Returns true if the mesh vertex is hidden. This is a runtime setting
that is not saved in 3dm files.
</summary>
            <param name="meshvi">[in] mesh vertex index.</param>
            <returns>True if mesh vertex is hidden.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.SetVertexHiddenFlag(System.Int32,System.Boolean)">
            <summary>
Returns: If the mesh has some hidden vertices, then an array of length VertexCount() is returned and the i-th element is true if the i-th vertex is hidden. If no vertices are hidden, NULL is returned.
</summary>
            <summary>Set the runtime vertex hidden flag.</summary>
            <param name="meshvi">[in] mesh vertex index</param>
            <param name="bHidden">[in] true to hide vertex</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.DestroyHiddenVertexArray">
            <summary>
Destroys the m_H[] array and sets m_hidden_count=0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.DeleteFace(System.Int32)">
            <summary>Removes a face from a mesh and does not alter the geometry of the remaining mesh.</summary>
            <param name="meshfi">[in] index of face in ON_Mesh.m_F[] array</param>
            <remarks>
This function calls DestroyTopology() and DestroyPartition().
The caller is responsible for calling Compact() if that step is required.
</remarks>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.SwapEdge(System.Int32)">
            <summary>If the edge is shared by two triangular face, then the edge is "swapped". </summary>
            <param name="topei">[in] index of edge in MeshTopology().m_tope[] array</param>
            <returns>
true if successful
See Also: ON_Mesh::IsSwappableEdge
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.IsSwappableEdge(System.Int32)">
            <summary>Tests a mesh edge to see if it is valid as input to ON_Mesh::SwapMeshEdge.</summary>
            <param name="topei">[in] index of edge in MeshTopology().m_tope[] array</param>
            <returns>
true if edge can be swapped by ON_Mesh::SwapMeshEdge.
See Also: ON_Mesh::SwapEdge
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.CollapseEdge(System.Int32)">
            <summary>Replace a mesh edge with a vertex at its center and update adjacent faces as needed.</summary>
            <param name="topei">[in] index of edge in MeshTopology().m_tope[] array</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@)">
            <summary>Calculate volume mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean)">
            <summary>Calculate volume mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Calculate volume mass properties of the mesh.</summary>
            <param name="base_point">
[in] When computing the volume mass properties of a solid volume defined by several meshes,
pass the same base_point to each call to VolumeMassProperties() and add the answers.
When computing the volume mass properties of a solid defined by a single mesh, the center
of the bounding box is a good choice for base_point. If the mesh is closed, you can pass
ON_UNSET_POINT and the center of the bounding box will be used.
</param>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <param name="base_point">
[in] If the surface is closed, then pass ON_UNSET_VALUE. This parameter is for
expert users who are computing a volume whose boundary is defined by several
non-closed breps, surfaces, and meshes. When computing the volume, volume centroid,
or volume first moments of a volume whose boundary is defined by several breps, surfaces,
and meshes, pass the same base_point to each call to VolumeMassProperties. When
computing the volume second moments or volume product moments of a volume whose
boundary is defined by several breps, surfaces, and meshes, you MUST pass the entire
volume's centroid as the base_point and the input mp parameter must contain the
results of a previous call to VolumeMassProperties(mp,true,true,false,false,base_point).
In particular, in this case, you need to make two sets of calls; use first set to calculate
the volume centroid and the second set calculate the second moments and product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.VolumeCentroid">
            <summary>Compute volume centroid of the mesh.</summary>
            <returns>Location of the volume centroid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.VolumeCentroid(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Compute volume centroid of the mesh.</summary>
            <param name="base_point">
[in] When computing the centroid of a solid volume defined by several meshes,
pass the same base_point to each call to GetVolumeCentroid() and add the answers.
When computing the centroid of a solid defined by a single mesh, the center of
the bounding box is a good choice for base_point.
</param>
            <returns>Location of the volume centroid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.VolumeCentroid(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>Compute volume centroid of the mesh.</summary>
            <param name="base_point">
[in] When computing the centroid of a solid volume defined by several meshes,
pass the same base_point to each call to GetVolumeCentroid() and add the answers.
When computing the centroid of a solid defined by a single mesh, the center of
the bounding box is a good choice for base_point.
</param>
            <param name="volume">[out] it not NULL, Volume of the mesh</param>
            <returns>Location of the volume centroid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.Volume">
            <summary>Compute volume of the mesh.</summary>
            <returns>volume of the mesh.</returns>
            <example>
Assume a solid is enclosed by 3 meshes, mesh1, mesh2, and mesh3.
The volume of the solid can be computed as follows.
ON_Mesh mesh1=..., mesh2=..., mesh3=...;
use the center of the solid's bounding box as a common base point.
ON_BoundingBox bbox = mesh1.BoundingBox();
mesh2.GetBoundingBox(bbox,TRUE);
mesh3.GetBoundingBox(bbox,TRUE);
ON_3dPoint base_point = bbox.Center()
double vol1_err, vol2_err, vol3_err;
double vol1 = mesh1.Volume(base_point,&amp;vol1_err);
double vol2 = mesh2.Volume(base_point,&amp;vol2_err);
double vol3 = mesh3.Volume(base_point,&amp;vol3_err);
double volume = vol1 + vol2 + vol3;
double error_estimate = vol1_err + vol2_err + vol3_err;
printf("mesh volumd = %g (+/- %g)\n",volume,error_estimate);
</example>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.Volume(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Compute volume of the mesh.</summary>
            <param name="base_point">
[in] optional base point When computing the volume of solid defined
by several meshes, pass the same base_point to each call to volume.
When computing the volume of a solid defined by a single mesh,
the center of the bounding box is a good choice for base_point.
</param>
            <returns>volume of the mesh.</returns>
            <example>
Assume a solid is enclosed by 3 meshes, mesh1, mesh2, and mesh3.
The volume of the solid can be computed as follows.
ON_Mesh mesh1=..., mesh2=..., mesh3=...;
use the center of the solid's bounding box as a common base point.
ON_BoundingBox bbox = mesh1.BoundingBox();
mesh2.GetBoundingBox(bbox,TRUE);
mesh3.GetBoundingBox(bbox,TRUE);
ON_3dPoint base_point = bbox.Center()
double vol1_err, vol2_err, vol3_err;
double vol1 = mesh1.Volume(base_point,&amp;vol1_err);
double vol2 = mesh2.Volume(base_point,&amp;vol2_err);
double vol3 = mesh3.Volume(base_point,&amp;vol3_err);
double volume = vol1 + vol2 + vol3;
double error_estimate = vol1_err + vol2_err + vol3_err;
printf("mesh volumd = %g (+/- %g)\n",volume,error_estimate);
</example>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.Volume(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>Compute volume of the mesh.</summary>
            <param name="base_point">
[in] optional base point When computing the volume of solid defined
by several meshes, pass the same base_point to each call to volume.
When computing the volume of a solid defined by a single mesh,
the center of the bounding box is a good choice for base_point.
</param>
            <param name="error_estimate">
[out] if not NULL, an upper bound on the error in the volume calculation is returned.
</param>
            <returns>volume of the mesh.</returns>
            <example>
Assume a solid is enclosed by 3 meshes, mesh1, mesh2, and mesh3.
The volume of the solid can be computed as follows.
ON_Mesh mesh1=..., mesh2=..., mesh3=...;
use the center of the solid's bounding box as a common base point.
ON_BoundingBox bbox = mesh1.BoundingBox();
mesh2.GetBoundingBox(bbox,TRUE);
mesh3.GetBoundingBox(bbox,TRUE);
ON_3dPoint base_point = bbox.Center()
double vol1_err, vol2_err, vol3_err;
double vol1 = mesh1.Volume(base_point,&amp;vol1_err);
double vol2 = mesh2.Volume(base_point,&amp;vol2_err);
double vol3 = mesh3.Volume(base_point,&amp;vol3_err);
double volume = vol1 + vol2 + vol3;
double error_estimate = vol1_err + vol2_err + vol3_err;
printf("mesh volumd = %g (+/- %g)\n",volume,error_estimate);
</example>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@)">
            <summary>Calculate area mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean)">
            <summary>Calculate area mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <param name="bProductMoments">[in] true to calculate area product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.AreaCentroid">
            <summary>Compute area centroid of the mesh.</summary>
            <returns>
Location of area centroid.
See Also: ON_Mesh::AreaMassProperties
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.AreaCentroid(System.Double@)">
            <summary>Compute area centroid of the mesh.</summary>
            <param name="area">[out] it not NULL, area of the mesh</param>
            <returns>
Location of area centroid.
See Also: ON_Mesh::AreaMassProperties
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.Area">
            <summary>Compute area of the mesh.</summary>
            <example>
ON_Mesh mesh = ...;
double area, error_estimate;
area = mesh.Area(&amp;error_estimate);
printf("mesh area = %g (+/- %g)\n",area,error_estimate);
</example>
            <returns>Area of the mesh.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.Area(System.Double@)">
            <summary>
Description: Appends a list of mesh edges that begin or end at the specified vertices to the edges[] array. Parameters: vcount - [in] number of vertices vertex_index - [in] array of vertex indices bNoDuplicates - [in] If true, then only one edges[] is added for each edge, the first vertex index will alwasy be less than the second, and the returned elements are sorted in dictionary order. If false and an edge is shared by multiple faces, then there will be an edges[] element added for each face and the order of the vertex indicies will indicate the orientation of the edge with respect to the face. No sorting is performed in this case. edges - [out] Edges that begin or end at one of the specified vertices are appended to this array. Each ON_2dex records the start and end vertex index. Returns: Number of ON_2dex values appended to the edges[] array.
</summary>
            <summary>
Description: Appends a list of mesh edges to the edges[] array. Parameters: edges - [out] Each edges[] element is a pair of vertex indices. There is at least one face in the mesh with an edge running between the indicies. Returns: Number of ON_2dex values appended to the edges[] array.
</summary>
            <summary>Compute area of the mesh.</summary>
            <param name="error_estimate">
[out] if not NULL, an upper bound on the error in the area calculation is returned.
</param>
            <example>
ON_Mesh mesh = ...;
double area, error_estimate;
area = mesh.Area(&amp;error_estimate);
printf("mesh area = %g (+/- %g)\n",area,error_estimate);
</example>
            <returns>Area of the mesh.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.IsManifold(System.Boolean)">
            <summary>Determine if the mesh is a manifold.</summary>
            <param name="bTopologicalTest">[in] If true, the query treats coincident vertices as the same.</param>
            <returns>True if every mesh "edge" has at most two adjacent faces.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.IsManifold(System.Boolean,System.Boolean@)">
            <summary>Determine if the mesh is a manifold.</summary>
            <param name="bTopologicalTest">[in] If true, the query treats coincident vertices as the same.</param>
            <param name="pbIsOriented">
[out] If the input pointer is not NULL, then the returned value of
pbIsOriented will be true if the mesh is a manifold and adjacent
faces have compatible face normals.
</param>
            <returns>True if every mesh "edge" has at most two adjacent faces.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.IsManifold(System.Boolean,System.Boolean@,System.Boolean@)">
            <summary>Determine if the mesh is a manifold.</summary>
            <param name="bTopologicalTest">[in] If true, the query treats coincident vertices as the same.</param>
            <param name="pbIsOriented">
[out] If the input pointer is not NULL, then the returned value of
pbIsOriented will be true if the mesh is a manifold and adjacent
faces have compatible face normals.
</param>
            <param name="pbHasBoundary">
[out] If the input pointer is not NULL, then the returned value of
pbHasBoundary will be true if the mesh is a manifold and there is
at least one "edge" with no adjacent faces have compatible
face normals.
</param>
            <returns>True if every mesh "edge" has at most two adjacent faces.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.IsClosed">
            <summary>
Returns: True if every mesh "edge" has two or more faces.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.SetClosed(System.Int32)">
            <summary>
indices of appended mesh parts
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.Append(RMA.OpenNURBS.IOnMesh)">
            <summary>
appends a copy of mesh to this and updates indices of appended mesh parts
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.CombineIdenticalVertices">
            <summary>Combines identical vertices.</summary>
            <returns>
True if the mesh is changed, in which case the returned
mesh will have fewer vertices than the input mesh.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.CombineIdenticalVertices(System.Boolean)">
            <summary>Combines identical vertices.</summary>
            <param name="bIgnoreVertexNormals">
[in] If true, then vertex normals are ignored when comparing vertices.
</param>
            <returns>
True if the mesh is changed, in which case the returned
mesh will have fewer vertices than the input mesh.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.CombineIdenticalVertices(System.Boolean,System.Boolean)">
            <summary>Combines identical vertices.</summary>
            <param name="bIgnoreVertexNormals">
[in] If true, then vertex normals are ignored when comparing vertices.
</param>
            <param name="bIgnoreTextureCoordinates">
[in] If true, then vertex texture coordinates, colors, and
principal curvatures are ignored when comparing vertices.
</param>
            <returns>
True if the mesh is changed, in which case the returned
mesh will have fewer vertices than the input mesh.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.CombineCoincidentVertices(RMA.OpenNURBS.IOn3fVector,System.Double)">
            <summary>
finds all coincident vertices and merges them if break angle is small enough
</summary>
            <param name="tolerance">coordinate tols for considering vertices to be coincident</param>
            <param name="cos_normal_angle">
cosine normal angle tolerance in radians
if vertices are coincident, then they are combined
if NormalA o NormalB &gt;= this value
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.EvaluateMeshGeometry(RMA.OpenNURBS.IOnSurface)">
            <summary>
evaluate surface at tcoords to set mesh geometry
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.SetTextureCoordinates(RMA.OpenNURBS.IOnTextureMapping)">
            <summary>Use a texture mapping function to set the m_T[] values.</summary>
            <param name="mapping">[in]</param>
            <returns>
True if successful.
See Also: ON_TextureMapping::GetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.SetTextureCoordinates(RMA.OpenNURBS.IOnTextureMapping,RMA.OpenNURBS.IOnXform)">
            <summary>Use a texture mapping function to set the m_T[] values.</summary>
            <param name="mapping">[in]</param>
            <param name="mesh_xform">
[in] If not NULL, the mapping calculation is performed as if 
the mesh were transformed by mesh_xform; the location of the
mesh is not changed.
</param>
            <returns>
True if successful.
See Also: ON_TextureMapping::GetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.SetTextureCoordinates(RMA.OpenNURBS.IOnTextureMapping,RMA.OpenNURBS.IOnXform,System.Boolean)">
            <summary>Use a texture mapping function to set the m_T[] values.</summary>
            <param name="mapping">[in]</param>
            <param name="mesh_xform">
[in] If not NULL, the mapping calculation is performed as if 
the mesh were transformed by mesh_xform; the location of the
mesh is not changed.
</param>
            <param name="bLazy">
[in] If true and the m_T[] values were set using the same mapping
parameters, then no calculation is performed.
</param>
            <returns>
True if successful.
See Also: ON_TextureMapping::GetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.ReverseTextureCoordinates(System.Int32)">
            <summary>
Reverse one coordinate direction of the texture coordinates, within texture domain m_tex_domain
</summary>
            <param name="dir">
[in]
dir=0  first texture coordinate is reversed
dir=1 second texture coordinate is reversed
</param>
            <returns>true on success</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.TransposeTextureCoordinates">
            <summary>Transposes the texture coordinates</summary>
            <returns>true on success</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.NormalizeTextureCoordinates">
            <summary>
Scales textures so the texture domains are [0,1] and
eliminates any texture rotations.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.ComputeVertexNormals">
            <summary>
uses face normals to cook up a vertex normal
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.Compact">
            <summary>
Removes any unreferenced objects from arrays, reindexes as needed,
and shrinks arrays to minimum required size.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.CullUnusedVertices">
            <summary>
returns number of culled vertices
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.CullDegenerateFaces">
            <summary>
returns number of degenerate faces
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.ComputeFaceNormal(System.Int32)">
            <summary>
computes face normal of indexed face
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.ComputeFaceNormals">
            <summary>
compute face normals for all faces
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.ConvertTrianglesToQuads(System.Double,System.Double)">
            <summary>Joins adjacent triangles into quads if the resulting quad is nice.</summary>
            <param name="angle_tol_radians">
[in] Used to compare adjacent triangles' face normals.
For two triangles to be considered, the angle between their
face normals has to be &lt;= angle_tol_radians.
When in doubt use ON_PI/90.0 (2 degrees).
</param>
            <param name="min_diagonal_length_ratio">
[in] ( &lt;= 1.0) For two triangles to be considered the ratio
of the resulting quad's diagonals (length of the shortest
diagonal)/(length of longest diagonal). has to be &gt;= min_diagonal_length_ratio.
When in doubt us .875.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.ConvertQuadsToTriangles">
            <summary>
Splits all quads along the short diagonal.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.FlipFaceOrientation">
            <summary>
reverses face orientation (does nothing to normals)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.FlipFaceNormals">
            <summary>
reverses face normals
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.FlipVertexNormals">
            <summary>
reverses vertex normals
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.Flip">
            <summary>
reverses face orientations and flips vertex and face normals
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.InvalidateBoundingBoxes">
            <summary>
Invalidates all cached bounding box information.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.InvalidateCurvatureStats">
            <summary>
Call if defining geometry is changed by directly manipulating the m_T[] array.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.InvalidateTextureCoordinateBoundingBox">
            <summary>
Call if defining geometry is changed by directly manipulating the m_T[] array.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.InvalidateVertexNormalBoundingBox">
            <summary>
Call if defining geometry is changed by directly manipulating the m_N[] array.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.InvalidateVertexBoundingBox">
            <summary>
Call if defining geometry is changed by directly manipulating the m_V[] array.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.GetCurvatureStats(RMA.OpenNURBS.IOn.curvature_style,RMA.OpenNURBS.OnMeshCurvatureStats@)">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.HiddenVertexCount">
            <summary>
Returns: Number of vertices that are hidden.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.HasVertexNormals">
            <summary>
normals at vertices
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.TriangleCount">
            <summary>
number of faces that are triangles
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.QuadCount">
            <summary>
number of faces that are quads
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.MeshComponent(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <param name="ci">
[in] a component index with type mesh_vertex, meshtop_vertex, meshtop_edge, or mesh_face.
</param>
            <returns>
A pointer to an ON_MeshVertexRef, ON_MeshEdgeRef, or ON_MeshFaceRef.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.FaceRef(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get a face reference from a mesh face index.</summary>
            <param name="ci">[in] component index with type mesh_face.</param>
            <returns>a reference to the face</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.EdgeRef(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get an edge reference from a mesh topology edge index.</summary>
            <param name="ci">[in] component index with type meshtop_edge</param>
            <returns>a reference to the edge</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.VertexRef(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get a vertex reference to a mesh vertex index.</summary>
            <param name="ci">[in] component index with type mesh_vertex or meshtop_vertex.</param>
            <returns>a reference to the vertex</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.DestroyTree">
            <summary>
members will soon become invalid for reasons 
beyond your control. EmergencyDestroy() zeros
anything that could possibly cause
~ON_Mesh() to crash.  Calling
EmergencyDestroy() under normal conditions 
will result in ~ON_Mesh() leaking
memory.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.EmergencyDestroy">
            <summary>
Call only when memory used by this class's members will soon become invalid for reasons 
beyond your control. EmergencyDestroy() zeros anything that could possibly cause ~ON_Mesh()
to crash. Calling EmergencyDestroy() under normal conditions will result in ~ON_Mesh() leaking
memory.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMesh.m_parent">
            <value>
runtime parent geometry (use ...::Cast() to get it)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMesh.m_hidden_count">
            <value>
number of vertices that are hidden = number of true values in m_H[] array.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMesh.m_H">
            <value>
OPTIONAL vertex visibility.
If m_H.Count() = m_V.Count(), then
m_H[vi] is true if the vertex m_V[vi] 
is hidden.  Otherwise, all vertices are visible.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMesh.m_C">
            <value>
OPTIONAL vertex color
Either m_C[] has zero count or it has the same
count as m_V[], in which case m_C[j] reports
the color assigned to m_V[j].
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMesh.m_Ctag">
            <value>
OPTIONAL tag for values in m_C[]
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMesh.m_K">
            <value>
OPTIONAL surface curvatures
Either m_K[] has zero count or it has the same
count as m_V[], in which case m_K[j] reports
the surface curvatures at m_V[j].
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMesh.m_TC">
            <value>
RUNTIME ONLY
 This array is used to cache texture coordinates used by
 rendering applications that require 1d texture coordinates,
 3d texture coordinates, or multiple sets of texture 
 coordinates (e.g. blended textures with different mappings).
 Users are responsible for verifying
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMesh.m_T">
            <value>
OPTIONAL texture coordinates for each vertex
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMesh.m_Ttag">
            <value>
OPTIONAL tag for values in m_T[]
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMesh.m_FN">
            <value>
OPTIONAL face unit normals
Either m_FN[] has zero count or it has the same
count as m_F[], in which case m_FN[j] reports
the unit normal for the facet m_F[j].
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMesh.m_N">
            <value>
OPTIONAL vertex unit normals
Either m_N[] has zero count or it has the same
count as m_V[], in which case m_N[j] reports
the unit normal at m_V[j].
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMesh.m_F">
            <value>
facets (triangle or quad)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMesh.m_V">
            <value>
vertex locations
In a case where adjacent facets share a vertex
location but have distinct normals or texture
coordinates at that location, the vertex must
be duplicated.
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.HasPackedTextureRegion">
            <returns>
True if the m_srf_scale[] values are positive and
the m_packed_tex_domain[] intervals are set to values
that describe a proper subrectangle of (0,1)x(0,1).
True does not necessarily mean the current values in
m_T[] are packed texture coordinates.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.Topology">
            <summary>
In order to keep the mesh facet definition simple and make the mesh
definition easily used in common rendering application, if two facets
share a vertex location but have different normals, curvatures, 
textures, etc., at that common vertex location, then the vertex is
duplicated.  When the topology of the mesh needs to be known,
use Topology() to get a class that provides complete topological
information about the mesh.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.FaceIsHidden(System.Int32)">
            <summary>
Returns true if the mesh face is hidden. This is a runtime setting
that is not saved in 3dm files.
</summary>
            <param name="meshfi">[in] mesh face index.</param>
            <returns>True if mesh face is hidden.</returns>
            <remarks>A face is hidden if, and only if, at least one of its vertices is hidden.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.VertexIsHidden(System.Int32)">
            <summary>
Returns: If the mesh has some hidden vertices, then an array of length VertexCount() is returned and the i-th element is true if the i-th vertex is hidden. If no vertices are hidden, NULL is returned.
</summary>
            <summary>
Returns true if the mesh vertex is hidden. This is a runtime setting
that is not saved in 3dm files.
</summary>
            <param name="meshvi">[in] mesh vertex index.</param>
            <returns>True if mesh vertex is hidden.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@)">
            <summary>Calculate volume mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean)">
            <summary>Calculate volume mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Calculate volume mass properties of the mesh.</summary>
            <param name="base_point">
[in] When computing the volume mass properties of a solid volume defined by several meshes,
pass the same base_point to each call to VolumeMassProperties() and add the answers.
When computing the volume mass properties of a solid defined by a single mesh, the center
of the bounding box is a good choice for base_point. If the mesh is closed, you can pass
ON_UNSET_POINT and the center of the bounding box will be used.
</param>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <param name="base_point">
[in] If the surface is closed, then pass ON_UNSET_VALUE. This parameter is for
expert users who are computing a volume whose boundary is defined by several
non-closed breps, surfaces, and meshes. When computing the volume, volume centroid,
or volume first moments of a volume whose boundary is defined by several breps, surfaces,
and meshes, pass the same base_point to each call to VolumeMassProperties. When
computing the volume second moments or volume product moments of a volume whose
boundary is defined by several breps, surfaces, and meshes, you MUST pass the entire
volume's centroid as the base_point and the input mp parameter must contain the
results of a previous call to VolumeMassProperties(mp,true,true,false,false,base_point).
In particular, in this case, you need to make two sets of calls; use first set to calculate
the volume centroid and the second set calculate the second moments and product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.VolumeCentroid">
            <summary>Compute volume centroid of the mesh.</summary>
            <returns>Location of the volume centroid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.VolumeCentroid(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Compute volume centroid of the mesh.</summary>
            <param name="base_point">
[in] When computing the centroid of a solid volume defined by several meshes,
pass the same base_point to each call to GetVolumeCentroid() and add the answers.
When computing the centroid of a solid defined by a single mesh, the center of
the bounding box is a good choice for base_point.
</param>
            <returns>Location of the volume centroid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.VolumeCentroid(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>Compute volume centroid of the mesh.</summary>
            <param name="base_point">
[in] When computing the centroid of a solid volume defined by several meshes,
pass the same base_point to each call to GetVolumeCentroid() and add the answers.
When computing the centroid of a solid defined by a single mesh, the center of
the bounding box is a good choice for base_point.
</param>
            <param name="volume">[out] it not NULL, Volume of the mesh</param>
            <returns>Location of the volume centroid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.Volume">
            <summary>Compute volume of the mesh.</summary>
            <returns>volume of the mesh.</returns>
            <example>
Assume a solid is enclosed by 3 meshes, mesh1, mesh2, and mesh3.
The volume of the solid can be computed as follows.
ON_Mesh mesh1=..., mesh2=..., mesh3=...;
use the center of the solid's bounding box as a common base point.
ON_BoundingBox bbox = mesh1.BoundingBox();
mesh2.GetBoundingBox(bbox,TRUE);
mesh3.GetBoundingBox(bbox,TRUE);
ON_3dPoint base_point = bbox.Center()
double vol1_err, vol2_err, vol3_err;
double vol1 = mesh1.Volume(base_point,&amp;vol1_err);
double vol2 = mesh2.Volume(base_point,&amp;vol2_err);
double vol3 = mesh3.Volume(base_point,&amp;vol3_err);
double volume = vol1 + vol2 + vol3;
double error_estimate = vol1_err + vol2_err + vol3_err;
printf("mesh volumd = %g (+/- %g)\n",volume,error_estimate);
</example>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.Volume(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Compute volume of the mesh.</summary>
            <param name="base_point">
[in] optional base point When computing the volume of solid defined
by several meshes, pass the same base_point to each call to volume.
When computing the volume of a solid defined by a single mesh,
the center of the bounding box is a good choice for base_point.
</param>
            <returns>volume of the mesh.</returns>
            <example>
Assume a solid is enclosed by 3 meshes, mesh1, mesh2, and mesh3.
The volume of the solid can be computed as follows.
ON_Mesh mesh1=..., mesh2=..., mesh3=...;
use the center of the solid's bounding box as a common base point.
ON_BoundingBox bbox = mesh1.BoundingBox();
mesh2.GetBoundingBox(bbox,TRUE);
mesh3.GetBoundingBox(bbox,TRUE);
ON_3dPoint base_point = bbox.Center()
double vol1_err, vol2_err, vol3_err;
double vol1 = mesh1.Volume(base_point,&amp;vol1_err);
double vol2 = mesh2.Volume(base_point,&amp;vol2_err);
double vol3 = mesh3.Volume(base_point,&amp;vol3_err);
double volume = vol1 + vol2 + vol3;
double error_estimate = vol1_err + vol2_err + vol3_err;
printf("mesh volumd = %g (+/- %g)\n",volume,error_estimate);
</example>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.Volume(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>Compute volume of the mesh.</summary>
            <param name="base_point">
[in] optional base point When computing the volume of solid defined
by several meshes, pass the same base_point to each call to volume.
When computing the volume of a solid defined by a single mesh,
the center of the bounding box is a good choice for base_point.
</param>
            <param name="error_estimate">
[out] if not NULL, an upper bound on the error in the volume calculation is returned.
</param>
            <returns>volume of the mesh.</returns>
            <example>
Assume a solid is enclosed by 3 meshes, mesh1, mesh2, and mesh3.
The volume of the solid can be computed as follows.
ON_Mesh mesh1=..., mesh2=..., mesh3=...;
use the center of the solid's bounding box as a common base point.
ON_BoundingBox bbox = mesh1.BoundingBox();
mesh2.GetBoundingBox(bbox,TRUE);
mesh3.GetBoundingBox(bbox,TRUE);
ON_3dPoint base_point = bbox.Center()
double vol1_err, vol2_err, vol3_err;
double vol1 = mesh1.Volume(base_point,&amp;vol1_err);
double vol2 = mesh2.Volume(base_point,&amp;vol2_err);
double vol3 = mesh3.Volume(base_point,&amp;vol3_err);
double volume = vol1 + vol2 + vol3;
double error_estimate = vol1_err + vol2_err + vol3_err;
printf("mesh volumd = %g (+/- %g)\n",volume,error_estimate);
</example>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@)">
            <summary>Calculate area mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean)">
            <summary>Calculate area mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <param name="bProductMoments">[in] true to calculate area product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.AreaCentroid">
            <summary>Compute area centroid of the mesh.</summary>
            <returns>
Location of area centroid.
See Also: ON_Mesh::AreaMassProperties
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.AreaCentroid(System.Double@)">
            <summary>Compute area centroid of the mesh.</summary>
            <param name="area">[out] it not NULL, area of the mesh</param>
            <returns>
Location of area centroid.
See Also: ON_Mesh::AreaMassProperties
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.Area">
            <summary>Compute area of the mesh.</summary>
            <example>
ON_Mesh mesh = ...;
double area, error_estimate;
area = mesh.Area(&amp;error_estimate);
printf("mesh area = %g (+/- %g)\n",area,error_estimate);
</example>
            <returns>Area of the mesh.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.Area(System.Double@)">
            <summary>
Description: Appends a list of mesh edges to the edges[] array. Parameters: edges - [out] Each edges[] element is a pair of vertex indices. There is at least one face in the mesh with an edge running between the indicies. Returns: Number of ON_2dex values appended to the edges[] array.
</summary>
            <summary>Compute area of the mesh.</summary>
            <param name="error_estimate">
[out] if not NULL, an upper bound on the error in the area calculation is returned.
</param>
            <example>
ON_Mesh mesh = ...;
double area, error_estimate;
area = mesh.Area(&amp;error_estimate);
printf("mesh area = %g (+/- %g)\n",area,error_estimate);
</example>
            <returns>Area of the mesh.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.IsManifold(System.Boolean)">
            <summary>Determine if the mesh is a manifold.</summary>
            <param name="bTopologicalTest">[in] If true, the query treats coincident vertices as the same.</param>
            <returns>True if every mesh "edge" has at most two adjacent faces.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.IsManifold(System.Boolean,System.Boolean@)">
            <summary>Determine if the mesh is a manifold.</summary>
            <param name="bTopologicalTest">[in] If true, the query treats coincident vertices as the same.</param>
            <param name="pbIsOriented">
[out] If the input pointer is not NULL, then the returned value of
pbIsOriented will be true if the mesh is a manifold and adjacent
faces have compatible face normals.
</param>
            <returns>True if every mesh "edge" has at most two adjacent faces.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.IsManifold(System.Boolean,System.Boolean@,System.Boolean@)">
            <summary>Determine if the mesh is a manifold.</summary>
            <param name="bTopologicalTest">[in] If true, the query treats coincident vertices as the same.</param>
            <param name="pbIsOriented">
[out] If the input pointer is not NULL, then the returned value of
pbIsOriented will be true if the mesh is a manifold and adjacent
faces have compatible face normals.
</param>
            <param name="pbHasBoundary">
[out] If the input pointer is not NULL, then the returned value of
pbHasBoundary will be true if the mesh is a manifold and there is
at least one "edge" with no adjacent faces have compatible
face normals.
</param>
            <returns>True if every mesh "edge" has at most two adjacent faces.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.IsClosed">
            <summary>
Returns: True if every mesh "edge" has two or more faces.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.GetCurvatureStats(RMA.OpenNURBS.IOn.curvature_style,RMA.OpenNURBS.OnMeshCurvatureStats@)">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.HiddenVertexCount">
            <summary>
Returns: Number of vertices that are hidden.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.HasVertexNormals">
            <summary>
normals at vertices
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.TriangleCount">
            <summary>
number of faces that are triangles
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.QuadCount">
            <summary>
number of faces that are quads
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.MeshComponent(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <param name="ci">
[in] a component index with type mesh_vertex, meshtop_vertex, meshtop_edge, or mesh_face.
</param>
            <returns>
A pointer to an ON_MeshVertexRef, ON_MeshEdgeRef, or ON_MeshFaceRef.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.FaceRef(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get a face reference from a mesh face index.</summary>
            <param name="ci">[in] component index with type mesh_face.</param>
            <returns>a reference to the face</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.EdgeRef(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get an edge reference from a mesh topology edge index.</summary>
            <param name="ci">[in] component index with type meshtop_edge</param>
            <returns>a reference to the edge</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.VertexRef(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>
members will soon become invalid for reasons 
beyond your control. EmergencyDestroy() zeros
anything that could possibly cause
~ON_Mesh() to crash.  Calling
EmergencyDestroy() under normal conditions 
will result in ~ON_Mesh() leaking
memory.
</summary>
            <summary>Get a vertex reference to a mesh vertex index.</summary>
            <param name="ci">[in] component index with type mesh_vertex or meshtop_vertex.</param>
            <returns>a reference to the vertex</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMesh.m_parent">
            <value>
runtime parent geometry (use ...::Cast() to get it)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMesh.m_hidden_count">
            <value>
number of vertices that are hidden = number of true values in m_H[] array.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMesh.m_H">
            <value>
OPTIONAL vertex visibility.
If m_H.Count() = m_V.Count(), then
m_H[vi] is true if the vertex m_V[vi] 
is hidden.  Otherwise, all vertices are visible.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMesh.m_C">
            <value>
OPTIONAL vertex color
Either m_C[] has zero count or it has the same
count as m_V[], in which case m_C[j] reports
the color assigned to m_V[j].
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMesh.m_Ctag">
            <value>
OPTIONAL tag for values in m_C[]
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMesh.m_K">
            <value>
OPTIONAL surface curvatures
Either m_K[] has zero count or it has the same
count as m_V[], in which case m_K[j] reports
the surface curvatures at m_V[j].
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMesh.m_TC">
            <value>
RUNTIME ONLY
 This array is used to cache texture coordinates used by
 rendering applications that require 1d texture coordinates,
 3d texture coordinates, or multiple sets of texture 
 coordinates (e.g. blended textures with different mappings).
 Users are responsible for verifying
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMesh.m_T">
            <value>
OPTIONAL texture coordinates for each vertex
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMesh.m_Ttag">
            <value>
OPTIONAL tag for values in m_T[]
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMesh.m_FN">
            <value>
OPTIONAL face unit normals
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMesh.m_N">
            <value>
OPTIONAL vertex unit normals
Either m_N[] has zero count or it has the same
count as m_V[], in which case m_N[j] reports
the unit normal at m_V[j].
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMesh.m_F">
            <value>
facets (triangle or quad)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMesh.m_V">
            <value>
vertex locations
In a case where adjacent facets share a vertex
location but have distinct normals or texture
coordinates at that location, the vertex must
be duplicated.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnTextureCoordinates.m_T">
            <value>
texture coordinates
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnTextureCoordinates.m_dim">
            <value>
1, 2, or 3
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTextureCoordinates.m_T">
            <value>
texture coordinates
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTextureCoordinates.m_dim">
            <value>
1, 2, or 3
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnMappingTag.IsDefaultSurfaceParameterMapping">
            <returns>
True if the mapping tag is for a mapping with type ON_TextureMapping::srfp_mapping
with m_uvw = identity.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMappingTag.IsSet">
            <returns>True if the mapping tag is set.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMappingTag.SetDefaultSurfaceParameterMappingTag">
            <summary>Sets the tag to the value the meshes have that come out of ON_Brep::CreateMesh().</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMappingTag.m_mapping_crc">
            <value>
ON_TextureMapping::MappingCRC()
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMappingTag.m_mapping_id">
            <value>
ON_TextureMapping::m_mapping_id
</value>
        </member>
        <member name="T:RMA.OpenNURBS.OnMappingTag">
            <summary>
Identifies the mapping used to create the texture 
coordinates and records transformations applied 
to the mesh after the texture coordinates were
calculated.  If the texture mapping does not
change when the mesh is transformed, then set 
m_mesh_xform to zero so that compares will work right.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMappingTag.IsDefaultSurfaceParameterMapping">
            <returns>
True if the mapping tag is for a mapping with type ON_TextureMapping::srfp_mapping
with m_uvw = identity.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMappingTag.IsSet">
            <returns>True if the mapping tag is set.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMappingTag.m_mapping_crc">
            <value>
ON_TextureMapping::MappingCRC()
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMappingTag.m_mapping_id">
            <value>
ON_TextureMapping::m_mapping_id
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnMappingTag">
            <summary>
Identifies the mapping used to create the texture 
coordinates and records transformations applied 
to the mesh after the texture coordinates were
calculated.  If the texture mapping does not
change when the mesh is transformed, then set 
m_mesh_xform to zero so that compares will work right.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshPartition.m_part">
            <value>
Partition i uses vertices m_V[j] where 
  m_part[i].vi[0] &lt;= j &lt; m_part[i].vi[1] 
and uses faces m_F[k] where
  m_part[i].fi[0] &lt;= k &lt; m_part[i].fi[1]
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshPartition.m_partition_max_triangle_count">
            <value>
maximum number of triangles in a partition (quads count as 2 triangles)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshPartition.m_partition_max_vertex_count">
            <value>
maximum number of vertices in a partition
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshPartition.m_part">
            <value>
Partition i uses vertices m_V[j] where 
  m_part[i].vi[0] &lt;= j &lt; m_part[i].vi[1] 
and uses faces m_F[k] where
  m_part[i].fi[0] &lt;= k &lt; m_part[i].fi[1]
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshPartition.m_partition_max_triangle_count">
            <value>
maximum number of triangles in a partition (quads count as 2 triangles)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshPartition.m_partition_max_vertex_count">
            <value>
maximum number of vertices in a partition
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopology.TopFaceIsHidden(System.Int32)">
            <summary>Returns true if the topological face is hidden.</summary>
            <param name="topfi">[in] mesh topology face index.</param>
            <returns>True if mesh topology face is hidden.</returns>
            <remarks>The mesh topology face is hidden if and only if any of its mesh topology edges are hidden.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopology.TopEdgeIsHidden(System.Int32)">
            <summary>Returns true if the topological edge is hidden.</summary>
            <param name="topei">[in] mesh topology edge index.</param>
            <returns>True if mesh topology edge is hidden.</returns>
            <remarks>The mesh topology edge is hidden if and only if either of its mesh topology vertices is hidden.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopology.TopVertexIsHidden(System.Int32)">
            <summary>Returns true if the topological vertex is hidden.</summary>
            <param name="topvi">[in] mesh topology vertex index.</param>
            <returns>True if mesh topology vertex is hidden.</returns>
            <remarks>
The mesh topology vertex is hidden if and only if all the ON_Mesh vertices it represents is hidden.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopology.SortVertexEdges">
            <summary>
Sort the m_topei[] list of every mesh topology vertex so that the edges
are in radial order. The "const" is a white lie to make this
function easier to call.
</summary>
            <remarks>
Same as for ( int topvi = 0; topvi &lt; m_topv.Count(); topvi++ ) SortVertexEdges(topvi);
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopology.SortVertexEdges(System.Int32)">
            <summary>
Sort the m_topei[] list of a mesh topology vertex so that the edges are
in radial order. The "const" is a white lie to make this function
easier to call.
</summary>
            <param name="topvi">[in] index of vertex in m_topv[] array.</param>
            <remarks>
A nonmanifold edge is treated as a boundary edge with respect to sorting.
If any boundary or nonmanifold edges end at the vertex, then the first edge
will be a boundary or nonmanifold edge.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopology.GetTopFaceVertices(System.Int32,System.Int32[])">
            <summary>
returns ON_MeshTopology vertex topology index of a face
corner.  The face is triangle iv TopFaceVertex(2) = TopFaceVertex(3)
</summary>
            <param name="arg1">ON_MeshTopology face topology index (= ON_Mesh face index)</param>
            <param name="arg2">ON_MeshTopology vertex indices returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopology.TopEdge(System.Int32,System.Int32)">
            <summary>
returns index of edge that connects topological vertices
returns -1 if no edge is found.
arg1 and arg2 are ON_MeshTopology vertex topology indices
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopology.TopEdgeLine(System.Int32)">
            <summary>Get the 3d line along an edge.</summary>
            <param name="tope_index">[in]</param>
            <returns>Line along edge. If input is not valid, the line.from and to are ON_UNSET_POINT</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopology.TopVertexPoint(System.Int32)">
            <summary>Get the 3d point location of a vertex.</summary>
            <param name="topv_index">[in]</param>
            <returns>Location of vertex.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopology.FaceRef(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get a face reference from a mesh face index.</summary>
            <param name="ci">[in] component index with type mesh_face.</param>
            <returns>a reference to the face.</returns>
            <remarks>
The OM_Mesh.m_F[] and ON_MeshTopology.m_topf[] arrays are parallel arrays;
corresponding faces have identical indices.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopology.EdgeRef(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get an edge reference.</summary>
            <param name="ci">[in] component index with type meshtop_edge.</param>
            <returns>a reference to the edge</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopology.VertexRef(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get a vertex reference to a mesh vertex index.</summary>
            <param name="ci">[in] component index with type mesh_vertex or meshtop_vertex.</param>
            <returns>a reference to the vertex</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopology.TopFaceCount">
            <summary>number of topoligical faces (same as m_mesh.FaceCount())</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopology.TopEdgeCount">
            <summary>number of topoligical edges</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopology.TopVertexCount">
            <summary>number of topoligical vertices (&lt;= m_mesh.VertexCount())</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopology.#ctor">
            <summary>
double ON_SurfaceCurvature::NormalCurvature(const ON_3dVector&amp; tangent) const
{
double c = tangent*e1;
double s = tangent*e2;
return k1*c*c + k2*s*s;
}
double ON_SurfaceCurvature::NormalSectionCurvature( const ON_3dVector&amp; section_normal, const ON_3dVector&amp; surface_normal ) const
{
ON_3dVector tangent = ON_CrossProduct( section_normal, surface_normal );
if ( fabs(tangent.x) &lt;= ON_SQRT_EPSILON &amp;&amp; fabs(tangent.y) &lt;= ON_SQRT_EPSILON &amp;&amp; fabs(tangent.z) &lt;= ON_SQRT_EPSILON )
  tangent.Zero();
else
  tangent.Unitize();
return NormalCurvature(tangent);
}
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshTopology.m_topf">
            <value>
Array of topological mesh faces.  The topological face
m_topf[fi] corresponds to the mesh face ON_Mesh.m_F[fi].
See the comments in the definition of ON_MeshTopologyFace
for details. To get the indices of the mesh topology 
vertices at the face corners use 
topvi = m_topv_map[m_mesh.m_F[fi].vi[n]]
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshTopology.m_tope">
            <value>
Array of topological mesh edges.  See the comments in the definition
of ON_MeshTopologyEdge for details.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshTopology.m_topv">
            <value>
Array of topological mesh vertices.  See the comments in the definition
of ON_MeshTopologyVertex for details.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshTopology.m_topv_map">
            <value>
m_topv_map[] has length m_mesh.VertexCount() and 
m_topv[m_topv_map[vi]] is the topological mesh vertex that is assocated
the with the mesh vertex m_mesh.m_V[vi].
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshTopology.m_mesh">
            <value>The parent ON_Mesh geometry used to compute this mesh topology.</value>
        </member>
        <member name="T:RMA.OpenNURBS.OnMeshTopology">
            <summary>
A mesh topology class is always associated with an ON_Mesh
and can be retrieved by calling ON_Mesh::Topology()
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopology.TopFaceIsHidden(System.Int32)">
            <summary>Returns true if the topological face is hidden.</summary>
            <param name="topfi">[in] mesh topology face index.</param>
            <returns>True if mesh topology face is hidden.</returns>
            <remarks>The mesh topology face is hidden if and only if any of its mesh topology edges are hidden.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopology.TopEdgeIsHidden(System.Int32)">
            <summary>Returns true if the topological edge is hidden.</summary>
            <param name="topei">[in] mesh topology edge index.</param>
            <returns>True if mesh topology edge is hidden.</returns>
            <remarks>The mesh topology edge is hidden if and only if either of its mesh topology vertices is hidden.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopology.TopVertexIsHidden(System.Int32)">
            <summary>Returns true if the topological vertex is hidden.</summary>
            <param name="topvi">[in] mesh topology vertex index.</param>
            <returns>True if mesh topology vertex is hidden.</returns>
            <remarks>
The mesh topology vertex is hidden if and only if all the ON_Mesh vertices it represents is hidden.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopology.SortVertexEdges">
            <summary>
Sort the m_topei[] list of every mesh topology vertex so that the edges
are in radial order. The "const" is a white lie to make this
function easier to call.
</summary>
            <remarks>
Same as for ( int topvi = 0; topvi &lt; m_topv.Count(); topvi++ ) SortVertexEdges(topvi);
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopology.SortVertexEdges(System.Int32)">
            <summary>
Sort the m_topei[] list of a mesh topology vertex so that the edges are
in radial order. The "const" is a white lie to make this function
easier to call.
</summary>
            <param name="topvi">[in] index of vertex in m_topv[] array.</param>
            <remarks>
A nonmanifold edge is treated as a boundary edge with respect to sorting.
If any boundary or nonmanifold edges end at the vertex, then the first edge
will be a boundary or nonmanifold edge.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopology.GetTopFaceVertices(System.Int32,System.Int32[])">
            <summary>
returns ON_MeshTopology vertex topology index of a face
corner.  The face is triangle iv TopFaceVertex(2) = TopFaceVertex(3)
</summary>
            <param name="arg1">ON_MeshTopology face topology index (= ON_Mesh face index)</param>
            <param name="arg2">ON_MeshTopology vertex indices returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopology.TopEdge(System.Int32,System.Int32)">
            <summary>
returns index of edge that connects topological vertices
returns -1 if no edge is found.
arg1 and arg2 are ON_MeshTopology vertex topology indices
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopology.TopEdgeLine(System.Int32)">
            <summary>Get the 3d line along an edge.</summary>
            <param name="tope_index">[in]</param>
            <returns>Line along edge. If input is not valid, the line.from and to are ON_UNSET_POINT</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopology.TopVertexPoint(System.Int32)">
            <summary>Get the 3d point location of a vertex.</summary>
            <param name="topv_index">[in]</param>
            <returns>Location of vertex.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopology.FaceRef(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get a face reference from a mesh face index.</summary>
            <param name="ci">[in] component index with type mesh_face.</param>
            <returns>a reference to the face.</returns>
            <remarks>
The OM_Mesh.m_F[] and ON_MeshTopology.m_topf[] arrays are parallel arrays;
corresponding faces have identical indices.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopology.EdgeRef(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get an edge reference.</summary>
            <param name="ci">[in] component index with type meshtop_edge.</param>
            <returns>a reference to the edge</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopology.VertexRef(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get a vertex reference to a mesh vertex index.</summary>
            <param name="ci">[in] component index with type mesh_vertex or meshtop_vertex.</param>
            <returns>a reference to the vertex</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopology.TopFaceCount">
            <summary>number of topoligical faces (same as m_mesh.FaceCount())</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopology.TopEdgeCount">
            <summary>number of topoligical edges</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopology.TopVertexCount">
            <summary>number of topoligical vertices (&lt;= m_mesh.VertexCount())</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshTopology.m_topf">
            <value>
Array of topological mesh faces.  The topological face
m_topf[fi] corresponds to the mesh face ON_Mesh.m_F[fi].
See the comments in the definition of ON_MeshTopologyFace
for details. To get the indices of the mesh topology 
vertices at the face corners use 
topvi = m_topv_map[m_mesh.m_F[fi].vi[n]]
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshTopology.m_tope">
            <value>
Array of topological mesh edges.  See the comments in the definition
of ON_MeshTopologyEdge for details.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshTopology.m_topv">
            <value>
Array of topological mesh vertices.  See the comments in the definition
of ON_MeshTopologyVertex for details.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshTopology.m_topv_map">
            <value>
m_topv_map[] has length m_mesh.VertexCount() and 
m_topv[m_topv_map[vi]] is the topological mesh vertex that is assocated
the with the mesh vertex m_mesh.m_V[vi].
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshTopology.m_mesh">
            <value>The parent ON_Mesh geometry used to compute this mesh topology.</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnMeshTopology">
            <summary>
A mesh topology class is always associated with an ON_Mesh
and can be retrieved by calling ON_Mesh::Topology()
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshFace.IsValid(System.Int32)">
            <param name="arg1">number of vertices in mesh</param>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshFace.vi(System.Int32)">
            <value>
vertex index - vi[2]==vi[3] for tirangles
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshFace.IsValid(System.Int32)">
            <param name="arg1">number of vertices in mesh</param>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshFace.vi(System.Int32)">
            <value>
vertex index - vi[2]==vi[3] for tirangles
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshCurvatureStats.m_adev">
            <value>
average deviation of "finite" values
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshCurvatureStats.m_average">
            <value>
average of "finite" values
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshCurvatureStats.m_mode">
            <value>
mode of "finite" values
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshCurvatureStats.m_count">
            <value>
count of "finite" values
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshCurvatureStats.m_count_infinite">
            <value>
number of "infinte" values
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshCurvatureStats.m_infinity">
            <value>
curvature values &gt;= this are considered infinite
and not used to compute the m_average or m_adev
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshCurvatureStats.m_adev">
            <value>
average deviation of "finite" values
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshCurvatureStats.m_average">
            <value>
average of "finite" values
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshCurvatureStats.m_mode">
            <value>
mode of "finite" values
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshCurvatureStats.m_count">
            <value>
count of "finite" values
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshCurvatureStats.m_count_infinite">
            <value>
number of "infinte" values
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshCurvatureStats.m_infinity">
            <value>
curvature values &gt;= this are considered infinite
and not used to compute the m_average or m_adev
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshParameters.Compare(RMA.OpenNURBS.IOnMeshParameters)">
            <summary>
Compare() ignores weld and curvature settings
Ignores m_min_tolerance setting.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshParameters.DefaultAnalysisMeshParameters">
            <summary>
Sets the meshing parameters to create the default analysis mesh.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshParameters.SmoothAndSlowerMeshParameters">
            <summary>
Sets the meshing parameters to create "smooth and slower" render meshes.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshParameters.JaggedAndFasterMeshParameters">
            <summary>
Sets the meshing parameters to create "jagged and faster" render meshes.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshParameters.Set(System.Double)">
            <summary>Tool for provding a simple slider interface.</summary>
            <param name="density">
[in] 0.0 &lt;= density &lt;= 1.0
0 quickly creates coarse meshes.
1 creates accurate meshes but takes lots of time.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshParameters.Set(System.Double,System.Double)">
            <summary>Tool for provding a simple slider interface.</summary>
            <param name="density">
[in] 0.0 &lt;= density &lt;= 1.0
0 quickly creates coarse meshes.
1 creates accurate meshes but takes lots of time.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshParameters.op_Equality(RMA.OpenNURBS.OnMeshParameters,RMA.OpenNURBS.IOnMesh)">
            <summary>
compares with mesh's mesh parameters
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_face_type">
            <value>
0 = mixed triangle and quads
1 = all triangles
2 = all quads
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_refine_angle">
            <value>
(in radians) maximum angle in radians between
surface normal evaluated at adjacent vertices.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_grid_amplification">
            <value>
If you want fewer quads, set m_grid_amplification
to a value &lt; 1.  If you want more quads,
set m_grid_amplification to a value &gt; 1.
default = 1 and values &lt;= 0 are treated as 1.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_grid_angle">
            <value>
(in radians) maximum angle between surface normal
evaluated at adjacent vertices. 0.0 is treated as pi.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_grid_max_count">
            <value>
desired masimum number of quads in initial grid
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_grid_min_count">
            <value>
minimum number of quads in initial grid
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_grid_aspect_ratio">
            <value>
desired aspect ratio of quads in grid
0.0 = any aspect ratio is acceptable
values &gt;0 and &lt; sqrt(2) are treated as sqrt(2)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_max_edge_length">
            <value>
edges longer than m_max_edge_length will be split even when
they meet all other meshing requirements
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_min_edge_length">
            <value>
edges shorter than m_min_edge_length will not be split even
if the do not meet other meshing requirements
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_min_tolerance">
            <value>
then the maximum distance from the center of an edge to the surface will
be &lt;= T, where T is the larger of (m_min_tolerance,d*m_relative_tolerance), 
where d is an esimate of the size of the object being meshed.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_relative_tolerance">
            <value>
If 0 &lt; m_relative_tolerance &lt; 1,
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_tolerance">
            <value>
maximum distance from center of edge to surface
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_texture_range">
            <value>
1: normalized
  each face has a normalized texture range [0,1]x[0,1].
2: packed normalized (default)
  each face in a polysurface is assigned a texture range that is a subrectangle 
  of [0,1]x[0,1].  The subrectangles are mutually disjoint and packed into
  [0,1]x[0,1] in a way that minimizes distortion and maximizes the coverage
  of [0,1]x[0,1].  (This texture style is suitable for creating texture maps 
  with popular 3D painting programs.)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_bJaggedSeams">
            <value>
FALSE - (default) edges of meshes of joined b-rep faces match with no gaps or
       "T" joints.
TRUE  - faces in b-reps are meshed independently. This is faster but results
       in gaps and "T" joints along seams between faces.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_bRefine">
            <value>
FALSE - skip stage 2
TRUE  - (default) do stage 2
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_bSimplePlanes">
            <value>
FALSE - (default) planar surfaces are meshed using the controls below.
TRUE  - planar surfaces are meshed using minimal number of triangles and
       aspect/edge controls are ignored.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_bComputeCurvature">
            <value>
FALSE - (default) - ON_Mesh::m_K[] not computed
TRUE  - ON_Mesh::m_K[] computed
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_bCustomSettings">
            <value>
FALSE - if these settings were used to create a mesh and the app settings don't match,
</value>
        </member>
        <member name="T:RMA.OpenNURBS.OnMeshParameters">
            <summary>
surface meshing parameters
Meshing happens in two stages.  The first stage creates a
rectangular grid.  The second stage refines the grid until
the mesh meets all meshing requirements.  The third stage
combines coincident vertices if the resulting mesh is a composite.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshParameters.Compare(RMA.OpenNURBS.IOnMeshParameters)">
            <summary>
Compare() ignores weld and curvature settings
Ignores m_min_tolerance setting.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_face_type">
            <value>
0 = mixed triangle and quads
1 = all triangles
2 = all quads
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_refine_angle">
            <value>
(in radians) maximum angle in radians between
surface normal evaluated at adjacent vertices.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_grid_amplification">
            <value>
If you want fewer quads, set m_grid_amplification
to a value &lt; 1.  If you want more quads,
set m_grid_amplification to a value &gt; 1.
default = 1 and values &lt;= 0 are treated as 1.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_grid_angle">
            <value>
(in radians) maximum angle between surface normal
evaluated at adjacent vertices. 0.0 is treated as pi.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_grid_max_count">
            <value>
desired masimum number of quads in initial grid
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_grid_min_count">
            <value>
minimum number of quads in initial grid
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_grid_aspect_ratio">
            <value>
desired aspect ratio of quads in grid
0.0 = any aspect ratio is acceptable
values &gt;0 and &lt; sqrt(2) are treated as sqrt(2)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_max_edge_length">
            <value>
edges longer than m_max_edge_length will be split even when
they meet all other meshing requirements
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_min_edge_length">
            <value>
edges shorter than m_min_edge_length will not be split even
if the do not meet other meshing requirements
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_min_tolerance">
            <value>
then the maximum distance from the center of an edge to the surface will
be &lt;= T, where T is the larger of (m_min_tolerance,d*m_relative_tolerance), 
where d is an esimate of the size of the object being meshed.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_relative_tolerance">
            <value>
If 0 &lt; m_relative_tolerance &lt; 1,
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_tolerance">
            <value>
maximum distance from center of edge to surface
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_texture_range">
            <value>
1: normalized
  each face has a normalized texture range [0,1]x[0,1].
2: packed normalized (default)
  each face in a polysurface is assigned a texture range that is a subrectangle 
  of [0,1]x[0,1].  The subrectangles are mutually disjoint and packed into
  [0,1]x[0,1] in a way that minimizes distortion and maximizes the coverage
  of [0,1]x[0,1].  (This texture style is suitable for creating texture maps 
  with popular 3D painting programs.)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_bJaggedSeams">
            <value>
FALSE - (default) edges of meshes of joined b-rep faces match with no gaps or
       "T" joints.
TRUE  - faces in b-reps are meshed independently. This is faster but results
       in gaps and "T" joints along seams between faces.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_bRefine">
            <value>
FALSE - skip stage 2
TRUE  - (default) do stage 2
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_bSimplePlanes">
            <value>
FALSE - (default) planar surfaces are meshed using the controls below.
TRUE  - planar surfaces are meshed using minimal number of triangles and
       aspect/edge controls are ignored.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_bComputeCurvature">
            <value>
FALSE - (default) - ON_Mesh::m_K[] not computed
TRUE  - ON_Mesh::m_K[] computed
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_bCustomSettings">
            <value>
FALSE - if these settings were used to create a mesh and the app settings don't match,
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnMeshParameters">
            <summary>
surface meshing parameters
Meshing happens in two stages.  The first stage creates a
rectangular grid.  The second stage refines the grid until
the mesh meets all meshing requirements.  The third stage
combines coincident vertices if the resulting mesh is a composite.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshPart.triangle_count">
            <value>
tris + 2*quads &gt;= fi[1] - fi[0]
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshPart.vertex_count">
            <value>
= vi[1] - vi[0];
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshPart.fi(System.Int32)">
            <value>
subinterval of mesh m_F[] array
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshPart.vi(System.Int32)">
            <value>
subinterval of mesh m_V[] array
</value>
        </member>
        <member name="T:RMA.OpenNURBS.OnMeshPart">
            <summary>
Faces with indices fi[0] &lt;= i &lt; fi[1] only reference
vertices with indices vi[0] &lt;= j &lt;= vi[1].
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshPart.triangle_count">
            <value>
tris + 2*quads &gt;= fi[1] - fi[0]
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshPart.vertex_count">
            <value>
= vi[1] - vi[0];
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshPart.fi(System.Int32)">
            <value>
subinterval of mesh m_F[] array
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshPart.vi(System.Int32)">
            <value>
subinterval of mesh m_V[] array
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnMeshPart">
            <summary>
Faces with indices fi[0] &lt;= i &lt; fi[1] only reference
vertices with indices vi[0] &lt;= j &lt;= vi[1].
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopologyFace.IsValid">
            <summary>
A topological mesh face is valid if m_topei[0], m_topei[1],
and m_topei[2] are mutually distinct, and m_topei[3] is either
equal to m_topei[2] or mutually distinct from the first three
indices.
</summary>
            <returns>True if face is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopologyFace.IsQuad">
            <summary>
A topological mesh face is a valid quad if m_topei[0], m_topei[1],
m_topei[2], and m_topei[3] are distinct edges.
</summary>
            <returns>True if face is a quad.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopologyFace.IsTriangle">
            <summary>
A topological mesh face is a valid triangle if m_topei[0],
m_topei[1], m_topei[2] are distinct edges and m_topei[3]=m_topei[2].
</summary>
            <returns>True if face is a triangle.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshTopologyFace.m_reve(System.Int32)">
            <value>
If m_reve[i] is 0, then the orientation of the edge matches the
orientation of the face. If m_reve[i] is 1, then the orientation
of the edge is opposite that of the face.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshTopologyFace.m_topei(System.Int32)">
            <value>
m_topei[] = indices of the topological edges that bound the face.
If m_topei[2] = m_topei[3], then the face is a triangle, otherwise the face is a quad.
NOTE WELL:
The topological edge with index m_topei[k] ENDS at the vertex corresponding to ON_MeshFace.vi[k].
So, ...
If the face is a quad, (ON_MeshFace.vi[2]!=ON_MeshFace.vi[3]),
the topological edge with index m_topei[0] STARTS at
ON_MeshFace.vi[3] and ENDS at ON_MeshFace.vi[0],
the topological edge with index m_topei[1] STARTS at
ON_MeshFace.vi[0] and ENDS at ON_MeshFace.vi[1],
the topological edge with index m_topei[2] STARTS at
ON_MeshFace.vi[1] and ENDS at ON_MeshFace.vi[2],
and the topological edge with index m_topei[3] STARTS at
ON_MeshFace.vi[0] and ENDS at ON_MeshFace.vi[1],

If the face is a triangle, (ON_MeshFace.vi[2]==ON_MeshFace.vi[3]),
the topological edge with index m_topei[0] STARTS at
ON_MeshFace.vi[2] and ENDS at ON_MeshFace.vi[0],
the topological edge with index m_topei[1] STARTS at
ON_MeshFace.vi[0] and ENDS at ON_MeshFace.vi[1],
the topological edge with index m_topei[2] STARTS at
ON_MeshFace.vi[1] and ENDS at ON_MeshFace.vi[2].
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopologyFace.IsValid">
            <summary>
A topological mesh face is valid if m_topei[0], m_topei[1],
and m_topei[2] are mutually distinct, and m_topei[3] is either
equal to m_topei[2] or mutually distinct from the first three
indices.
</summary>
            <returns>True if face is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopologyFace.IsQuad">
            <summary>
A topological mesh face is a valid quad if m_topei[0], m_topei[1],
m_topei[2], and m_topei[3] are distinct edges.
</summary>
            <returns>True if face is a quad.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopologyFace.IsTriangle">
            <summary>
A topological mesh face is a valid triangle if m_topei[0],
m_topei[1], m_topei[2] are distinct edges and m_topei[3]=m_topei[2].
</summary>
            <returns>True if face is a triangle.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshTopologyFace.m_reve(System.Int32)">
            <value>
If m_reve[i] is 0, then the orientation of the edge matches the
orientation of the face. If m_reve[i] is 1, then the orientation
of the edge is opposite that of the face.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshTopologyFace.m_topei(System.Int32)">
            <value>
m_topei[] = indices of the topological edges that bound the face.
If m_topei[2] = m_topei[3], then the face is a triangle, otherwise the face is a quad.
NOTE WELL:
The topological edge with index m_topei[k] ENDS at the vertex corresponding to ON_MeshFace.vi[k].
So, ...
If the face is a quad, (ON_MeshFace.vi[2]!=ON_MeshFace.vi[3]),
the topological edge with index m_topei[0] STARTS at
ON_MeshFace.vi[3] and ENDS at ON_MeshFace.vi[0],
the topological edge with index m_topei[1] STARTS at
ON_MeshFace.vi[0] and ENDS at ON_MeshFace.vi[1],
the topological edge with index m_topei[2] STARTS at
ON_MeshFace.vi[1] and ENDS at ON_MeshFace.vi[2],
and the topological edge with index m_topei[3] STARTS at
ON_MeshFace.vi[0] and ENDS at ON_MeshFace.vi[1],

If the face is a triangle, (ON_MeshFace.vi[2]==ON_MeshFace.vi[3]),
the topological edge with index m_topei[0] STARTS at
ON_MeshFace.vi[2] and ENDS at ON_MeshFace.vi[0],
the topological edge with index m_topei[1] STARTS at
ON_MeshFace.vi[0] and ENDS at ON_MeshFace.vi[1],
the topological edge with index m_topei[2] STARTS at
ON_MeshFace.vi[1] and ENDS at ON_MeshFace.vi[2].
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshTopologyEdge.m_topfi">
            <value>
indices of topological faces use this topological edge
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshTopologyEdge.m_topfi">
            <value>
indices of topological face use this topological edge
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshTopologyVertex.m_vi">
            <value>
indices of ON_Mesh vertices that correspond to this topological vertex
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshTopologyVertex.m_v_count">
            <value>
m_v_count = number of ON_Mesh vertices that correspond to 
this topological vertex.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshTopologyVertex.m_topei">
            <value>
indices of topological edges that begin or end at this vertex
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshTopologyVertex.m_tope_count">
            <value>
m_tope_count = number of topological edges that begin or 
end at this topological vertex.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshTopologyVertex.m_vi">
            <value>
indices of ON_Mesh vertices that correspond to this topological vertex
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshTopologyVertex.m_v_count">
            <value>
m_v_count = number of ON_Mesh vertices that correspond to 
this topological vertex.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshTopologyVertex.m_topei">
            <value>
indices of topological edges that begin or end at this vertex
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshTopologyVertex.m_tope_count">
            <value>
m_tope_count = number of topological edges that begin or 
end at this topological vertex.
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveProxy.ThisCurveParameter(System.Double)">
            <summary>
Parameters: real_curve_parameter - [in] m_real_curve parameter Returns: Corresponding parameter for "this" curve
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveProxy.RealCurveParameter(System.Double)">
            <summary>
Parameters: t - [in] parameter for "this" curve Returns: Corresponding parameter in m_real_curve's domain.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveProxy.ProxyCurveIsReversed">
            <summary>
Returns: True if "this" as a curve is reversed from the "real" curve geometry.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveProxy.ProxyCurveDomain">
            <summary>
Returns: Sub interval of the "real" curve's domain that "this" uses. This interval is not necessarily the same as "this" curve's domain. Remarks: This function is poorly named. It does NOT get the proxy curve's domain. It does get the evaluation interval of the "real" curve for which "this" is a proxy.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveProxy.SetProxyCurveDomain(RMA.OpenNURBS.IOnInterval)">
            <summary>
Description: Sets portion of the "real" curve that this proxy represents. Does NOT change the domain of "this" curve. Parameters: proxy_curve_subdomain - [in] increasing sub interval of ProxyCurve()-&gt;Domain(). This interval defines the portion the curve geometry that "this" proxy uses. Remarks: This function is poorly named. It does NOT set the proxy curve's domain. It does set the interval of the "real" curve for which "this" is a proxy.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveProxy.ProxyCurve">
            <summary>
Returns: "Real" curve geometry that "this" is a proxy for.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurveProxy.ThisCurveParameter(System.Double)">
            <summary>
Parameters: real_curve_parameter - [in] m_real_curve parameter Returns: Corresponding parameter for "this" curve
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurveProxy.RealCurveParameter(System.Double)">
            <summary>
Parameters: t - [in] parameter for "this" curve Returns: Corresponding parameter in m_real_curve's domain.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurveProxy.ProxyCurveIsReversed">
            <summary>
Returns: True if "this" as a curve is reversed from the "real" curve geometry.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurveProxy.ProxyCurveDomain">
            <summary>
Returns: Sub interval of the "real" curve's domain that "this" uses. This interval is not necessarily the same as "this" curve's domain. Remarks: This function is poorly named. It does NOT get the proxy curve's domain. It does get the evaluation interval of the "real" curve for which "this" is a proxy.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurveProxy.ProxyCurve">
            <summary>
Returns: "Real" curve geometry that "this" is a proxy for.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointCloud.#ctor(System.Int32)">
            <param name="initial_capacity">initial point array capacity</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointCloud.PointIsHidden(System.Int32)">
            <summary>
Returns true if the point is hidden. This is a runtime setting that is not saved in 3dm files.
</summary>
            <param name="point_index">[in]</param>
            <returns>True if the point is hidden.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointCloud.SetHiddenPointFlag(System.Int32,System.Boolean)">
            <summary>
Returns: If the point cloud has some hidden points, then an array of length PointCount() is returned and the i-th element is true if the i-th vertex is hidden. If no ponts are hidden, NULL is returned.
</summary>
            <summary>Set the runtime hidden point flag.</summary>
            <param name="point_index">[in] point vertex index</param>
            <param name="bHidden">[in] true to hide vertex</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointCloud.DestroyHiddenPointArray">
            <summary>
Destroys the m_H[] array and sets m_hidden_count=0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointCloud.HiddenPointCount">
            <summary>
Returns: Number of points that are hidden.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointCloud.HasPointColors">
            <summary>
Returns: True if m_C.Count() == m_P.Count().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointCloud.HasPointNormals">
            <summary>
Returns: True if m_N.Count() == m_P.Count().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointCloud.HasPlane">
            <summary>
TRUE if set is height field above a plane
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointCloud.IsOrdered">
            <summary>
TRUE if set is ordered stream
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointCloud.SetOrdered(System.Boolean)">
            <summary>
TRUE if set is ordered stream
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointCloud.InvalidateBoundingBox">
            <summary>
call if you change values of points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointCloud.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Int32@)">
            <summary>Get the index of the point in the point cloud that is closest to P.</summary>
            <param name="P">[in]</param>
            <param name="closest_point_index">[out]</param>
            <returns>
True if a point is found; in which case *closest_point_index is the index of the point.
False if no point is found or the input is not valid.
See Also: ON_GetClosestPointInPointList
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointCloud.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Int32@,System.Double)">
            <summary>Get the index of the point in the point cloud that is closest to P.</summary>
            <param name="P">[in]</param>
            <param name="closest_point_index">[out]</param>
            <param name="maximum_distance">
[in] optional distance constraint. If maximum_distance &gt; 0, then only
points Q with |P-Q| &lt;= maximum_distance are tested.
</param>
            <returns>
True if a point is found; in which case *closest_point_index is the index of the point.
False if no point is found or the input is not valid.
See Also: ON_GetClosestPointInPointList
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointCloud.EmergencyDestroy">
            <summary>
Call when the memory pool used the point cloud's arrays is no longer in existence.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointCloud.Point(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get a point cloud point from an ON_COMPONENT_INDEX.</summary>
            <param name="ci">
[in] a component index with m_typ set to ON_COMPONENT_INDEX::pointcloud_point
and 0 &lt;= m_index and m_index &lt; m_P.Count().
</param>
            <returns>Point at [ci.m_index] or ON_UNSET_POINT if ci is not valid.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnPointCloud.m_flags">
            <value>
bit 1 is set if ordered
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnPointCloud.m_hidden_count">
            <value>
m_hidden_count = number of true values in the m_H[] array.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnPointCloud.m_H">
            <value>
Implementation - RUNTIME point visibility - not saved in 3dm files.
If m_H.Count() = m_P.Count(), then m_H[j] is true if the point m_P[j] 
is hidden.  Otherwise, all points are visible.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnPointCloud.m_C">
            <value>
Implementation - OPTIONAL point color
Either m_C[] has zero count or it has the same count as m_P[], in which case m_P[j] reports
the color assigned to m_P[j].
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnPointCloud.m_N">
            <value>
Implementation - OPTIONAL point normal
Either m_N[] has zero count or it has the same count as m_P[], in which case m_N[j] reports
the color assigned to m_P[j].
</value>
        </member>
        <member name="T:RMA.OpenNURBS.OnPointCloud">
            <summary>unordered set of points</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPointCloud.PointIsHidden(System.Int32)">
            <summary>
Returns: If the point cloud has some hidden points, then an array of length PointCount() is returned and the i-th element is true if the i-th vertex is hidden. If no ponts are hidden, NULL is returned.
</summary>
            <summary>
Returns true if the point is hidden. This is a runtime setting that is not saved in 3dm files.
</summary>
            <param name="point_index">[in]</param>
            <returns>True if the point is hidden.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPointCloud.HiddenPointCount">
            <summary>
Returns: Number of points that are hidden.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPointCloud.HasPointColors">
            <summary>
Returns: True if m_C.Count() == m_P.Count().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPointCloud.HasPointNormals">
            <summary>
Returns: True if m_N.Count() == m_P.Count().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPointCloud.HasPlane">
            <summary>
TRUE if set is height field above a plane
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPointCloud.IsOrdered">
            <summary>
TRUE if set is ordered stream
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPointCloud.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Int32@)">
            <summary>Get the index of the point in the point cloud that is closest to P.</summary>
            <param name="P">[in]</param>
            <param name="closest_point_index">[out]</param>
            <returns>
True if a point is found; in which case *closest_point_index is the index of the point.
False if no point is found or the input is not valid.
See Also: ON_GetClosestPointInPointList
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPointCloud.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Int32@,System.Double)">
            <summary>Get the index of the point in the point cloud that is closest to P.</summary>
            <param name="P">[in]</param>
            <param name="closest_point_index">[out]</param>
            <param name="maximum_distance">
[in] optional distance constraint. If maximum_distance &gt; 0, then only
points Q with |P-Q| &lt;= maximum_distance are tested.
</param>
            <returns>
True if a point is found; in which case *closest_point_index is the index of the point.
False if no point is found or the input is not valid.
See Also: ON_GetClosestPointInPointList
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPointCloud.Point(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get a point cloud point from an ON_COMPONENT_INDEX.</summary>
            <param name="ci">
[in] a component index with m_typ set to ON_COMPONENT_INDEX::pointcloud_point
and 0 &lt;= m_index and m_index &lt; m_P.Count().
</param>
            <returns>Point at [ci.m_index] or ON_UNSET_POINT if ci is not valid.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPointCloud.m_flags">
            <value>
bit 1 is set if ordered
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPointCloud.m_hidden_count">
            <value>
m_hidden_count = number of true values in the m_H[] array.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPointCloud.m_H">
            <value>
Implementation - RUNTIME point visibility - not saved in 3dm files.
If m_H.Count() = m_P.Count(), then m_H[j] is true if the point m_P[j] 
is hidden.  Otherwise, all points are visible.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPointCloud.m_C">
            <value>
Implementation - OPTIONAL point color
Either m_C[] has zero count or it has the same count as m_P[], in which case m_P[j] reports
the color assigned to m_P[j].
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPointCloud.m_N">
            <value>
Implementation - OPTIONAL point normal
Either m_N[] has zero count or it has the same count as m_P[], in which case m_N[j] reports
the color assigned to m_P[j].
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnPointCloud">
            <summary>unordered set of points</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnPoint">
            <summary>
NOTE:  ON_3dPoint is much more efficient than ON_Point.
      Use ON_Point when you need a polymorphic 3d point
      that is derived from ON_Geometry or ON_Object.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnPoint">
            <summary>
NOTE:  ON_3dPoint is much more efficient than ON_Point.
      Use ON_Point when you need a polymorphic 3d point
      that is derived from ON_Geometry or ON_Object.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLight.ShadowIntensity">
            <summary>
0.0 = does not cast any shadows
1.0 = casts black shadows
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLight.SetShadowIntensity(System.Double)">
            <summary>
0.0 = does not cast any shadows
1.0 = casts black shadows
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLight.HotSpot">
            <summary>
The hot spot setting runs from 0.0 to 1.0 and is used to
provides a linear interface for controling the focus or 
concentration of a spotlight.
A hot spot setting of 0.0 corresponds to a spot exponent of 128.
A hot spot setting of 1.0 corresponds to a spot exponent of 0.0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLight.SetHotSpot(System.Double)">
            <summary>
The hot spot setting runs from 0.0 to 1.0 and is used to
provides a linear interface for controling the focus or 
concentration of a spotlight.
A hot spot setting of 0.0 corresponds to a spot exponent of 128.
A hot spot setting of 1.0 corresponds to a spot exponent of 0.0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLight.SpotExponent">
            <summary>
The spot exponent varies from 0.0 to 128.0 and provides
an exponential interface for controling the focus or 
concentration of a spotlight (like the 
OpenGL GL_SPOT_EXPONENT parameter).  The spot exponent
and hot spot parameters are linked; changing one will
change the other.
A hot spot setting of 0.0 corresponds to a spot exponent of 128.
A hot spot setting of 1.0 corresponds to a spot exponent of 0.0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLight.SetSpotExponent(System.Double)">
            <summary>
The spot exponent varies from 0.0 to 128.0 and provides
an exponential interface for controling the focus or 
concentration of a spotlight (like the 
OpenGL GL_SPOT_EXPONENT parameter).  The spot exponent
and hot spot parameters are linked; changing one will
change the other.
A hot spot setting of 0.0 corresponds to a spot exponent of 128.
A hot spot setting of 1.0 corresponds to a spot exponent of 0.0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLight.SetSpotAngleDegrees(System.Double)">
            <summary>angle = 0 to 90 degrees</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLight.Attenuation(System.Double)">
            <summary>
computes 1/(a[0] + d*a[1] + d^2*a[2]) where d = argument
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLight.Intensity">
            <summary>
0.0 = 0%  1.0 = 100%
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLight.GetLightXform(RMA.OpenNURBS.IOnViewport,RMA.OpenNURBS.IOn.coordinate_system,RMA.OpenNURBS.OnXform@)">
            <summary>
A light's location and direction can be defined with respect to world,
camera, or view coordinates. GetLightXform gets the transformation from the
light's intrinsic coordinate system to the destination coordinate system 
specified by dest_cs.
</summary>
            <param name="vp">[in] viewport where light is being used</param>
            <param name="dest_cs">[in] destination coordinate system</param>
            <param name="xform">[out] transformation from the light's intrinsic coordinate system to cs.</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLight.CoordinateSystem">
            <summary>
determined by style
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLight.Enable">
            <summary>turn light on</summary>
            <returns>previous state</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLight.Enable(System.Boolean)">
            <summary>turn light on/off</summary>
            <returns>previous state</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLight.Default">
            <summary>
make default light
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnLight.m_shadow_intensity">
            <value>
0.0 = no shadow casting, 1.0 = full shadow casting
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnLight.m_attenuation">
            <value>
each entry &gt;= 0.0
att = 1/(a[0] + d*a[1] + d^2*a[2])
where d = distance to light
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnLight.m_hotspot">
            <value>
0.0 to 1.0 (See SetHotSpot() for details)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnLight.m_spot_exponent">
            <value>
0.0 to 128.0
0.0 = uniform
128.0 = high focus
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnLight.m_spot_angle">
            <value>
0.0 to 90.0
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnLight.m_watts">
            <value>
ignored if 0
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnLight.m_intensity">
            <value>
0.0 = 0%, 1.0 = 100%
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnLight.m_width">
            <value>
only for rectangular lights
corners of rectangular lights are m_location, m_location+m_length,
m_location+m_width, m_location+m_width+m_length
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnLight.m_length">
            <value>
only for linear and rectangular lights
ends of linear lights are m_location and m_location+m_length
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnLight.m_location">
            <value>
ignored for "directional" and "ambient" lights
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnLight.m_direction">
            <value>
ignored for "point" and "ambient" lights
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnLight.m_style">
            <value>
style of light
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnLight.m_bOn">
            <value>
TRUE if light is on
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLight.ShadowIntensity">
            <summary>
0.0 = does not cast any shadows
1.0 = casts black shadows
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLight.HotSpot">
            <summary>
The hot spot setting runs from 0.0 to 1.0 and is used to
provides a linear interface for controling the focus or 
concentration of a spotlight.
A hot spot setting of 0.0 corresponds to a spot exponent of 128.
A hot spot setting of 1.0 corresponds to a spot exponent of 0.0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLight.SpotExponent">
            <summary>
The spot exponent varies from 0.0 to 128.0 and provides
an exponential interface for controling the focus or 
concentration of a spotlight (like the 
OpenGL GL_SPOT_EXPONENT parameter).  The spot exponent
and hot spot parameters are linked; changing one will
change the other.
A hot spot setting of 0.0 corresponds to a spot exponent of 128.
A hot spot setting of 1.0 corresponds to a spot exponent of 0.0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLight.Attenuation(System.Double)">
            <summary>
computes 1/(a[0] + d*a[1] + d^2*a[2]) where d = argument
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLight.Intensity">
            <summary>
0.0 = 0%  1.0 = 100%
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLight.GetLightXform(RMA.OpenNURBS.IOnViewport,RMA.OpenNURBS.IOn.coordinate_system,RMA.OpenNURBS.OnXform@)">
            <summary>
A light's location and direction can be defined with respect to world,
camera, or view coordinates. GetLightXform gets the transformation from the
light's intrinsic coordinate system to the destination coordinate system 
specified by dest_cs.
</summary>
            <param name="vp">[in] viewport where light is being used</param>
            <param name="dest_cs">[in] destination coordinate system</param>
            <param name="xform">[out] transformation from the light's intrinsic coordinate system to cs.</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLight.CoordinateSystem">
            <summary>
determined by style
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLight.m_shadow_intensity">
            <value>
0.0 = no shadow casting, 1.0 = full shadow casting
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLight.m_attenuation">
            <value>
each entry &gt;= 0.0
att = 1/(a[0] + d*a[1] + d^2*a[2])
where d = distance to light
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLight.m_hotspot">
            <value>
0.0 to 1.0 (See SetHotSpot() for details)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLight.m_spot_exponent">
            <value>
0.0 to 128.0
0.0 = uniform
128.0 = high focus
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLight.m_spot_angle">
            <value>
0.0 to 90.0
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLight.m_watts">
            <value>
ignored if 0
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLight.m_intensity">
            <value>
0.0 = 0%, 1.0 = 100%
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLight.m_width">
            <value>
only for rectangular lights
corners of rectangular lights are m_location, m_location+m_length,
m_location+m_width, m_location+m_width+m_length
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLight.m_length">
            <value>
only for linear and rectangular lights
ends of linear lights are m_location and m_location+m_length
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLight.m_location">
            <value>
ignored for "directional" and "ambient" lights
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLight.m_direction">
            <value>
ignored for "point" and "ambient" lights
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLight.m_style">
            <value>
style of light
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLight.m_bOn">
            <value>
TRUE if light is on
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnFont.AscentRatio">
            <summary>
Returns the ratio of the height of a typical upper case letter to the height of a whole character cell.
</summary>
            <returns>ratio of Windows Font Height / m_HeightOfH</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnFont.HeightOfLinefeed">
            <summary>
Height of a linefeed when the font is drawn with m_logfont.
lfHeight = ON_Font::normal_font_height.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnFont.HeightOfI">
            <summary>
Height of the 'I' character when the font is drawn with m_logfont.
lfHeight = ON_Font::normal_font_height.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnFont.LinefeedRatio">
            <summary>
Returns: The ratio (height of linefeed)/(height of I).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnFont.IsSymbolFontFaceName(System.String)">
            <summary>True if the font's character set should be SYMBOL_CHARSET</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnFont.m_font_index">
            <value>
font index in Rhino font table
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnFont.m_linefeed_ratio">
            <value>
defaults to static s_linefeed_ratio.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnFont.m_font_italic">
            <value>
Same as m_logfont.lfItalic
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnFont.m_font_weight">
            <value>
Same as m_logfont.lfWeight
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnFont.m_font_name">
            <value>
Name of this font in the Rhino UI
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnFont.m_metrics_char">
            <value>
ASCII code of character to used to get runtime "default" glyph
metrics. (Currently an "I").
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnFont.m_default_linefeed_ratio">
            <value>Ratio of linefeed to character height (1.6)</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnFont.AscentRatio">
            <summary>
Returns the ratio of the height of a typical upper case letter to the height of a whole character cell.
</summary>
            <returns>ratio of Windows Font Height / m_HeightOfH</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnFont.HeightOfLinefeed">
            <summary>
Height of a linefeed when the font is drawn with m_logfont.
lfHeight = ON_Font::normal_font_height.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnFont.HeightOfI">
            <summary>
Height of the 'I' character when the font is drawn with m_logfont.
lfHeight = ON_Font::normal_font_height.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnFont.LinefeedRatio">
            <summary>
Returns: The ratio (height of linefeed)/(height of I).
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnFont.m_font_index">
            <value>
font index in Rhino font table
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnFont.m_linefeed_ratio">
            <value>
defaults to static s_linefeed_ratio.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnFont.m_font_italic">
            <value>
Same as m_logfont.lfItalic
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnFont.m_font_weight">
            <value>
Same as m_logfont.lfWeight
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnFont.m_font_name">
            <value>
Name of this font in the Rhino UI
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinetype.Segments">
            <summary>
Expert user function to get access to the segment array for rapid calculations.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinetype.Segment(System.Int32)">
            <summary>
Returns a copy of the segment at index
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinetype.SetSegment(System.Int32,System.Double,RMA.OpenNURBS.IOnLinetypeSegment.eSegType)">
            <summary>
Sets the length and type of the segment at index
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinetype.SetSegment(System.Int32,RMA.OpenNURBS.IOnLinetypeSegment)">
            <summary>
Sets the segment at index to match segment
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinetype.RemoveSegment(System.Int32)">
            <summary>Removes a segment in the linetype.</summary>
            <param name="index">[in] Zero based index of the segment to remove.</param>
            <returns>True if the segment index was removed.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinetype.AppendSegment(RMA.OpenNURBS.IOnLinetypeSegment)">
            <summary>Adds a segment to the pattern</summary>
            <returns>Index of the added segment.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinetype.SegmentCount">
            <summary>
Returns the number of segments in the pattern
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinetype.PatternLength">
            <summary>
Returns the total length of one repeat of the pattern
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinetype.SetLinetypeIndex(System.Int32)">
            <summary>
Index of each linetype This index is used by geometry objects to reference a specific linetype
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinetype.SetLinetypeName(System.String)">
            <summary>
Unique name for each linetype
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinetype.Default">
            <summary>
Sets index = -1 and emptys name and segment list.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinetype.#ctor">
            <summary>
Sets index = -1.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnLinetype.m_linetype_id">
            <value>
Set by Rhino - unique id of this linetype
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLinetype.Segments">
            <summary>
Expert user function to get access to the segment array for rapid calculations.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLinetype.Segment(System.Int32)">
            <summary>
Returns a copy of the segment at index
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLinetype.SegmentCount">
            <summary>
Returns the number of segments in the pattern
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLinetype.PatternLength">
            <summary>
Returns the total length of one repeat of the pattern
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLinetype.m_linetype_id">
            <value>
Set by Rhino - unique id of this linetype
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnLayer.SetPlotWeight(System.Double)">
            <summary>Set the weight of the plotting pen.</summary>
            <param name="plot_weight_mm">
[in] Set the thickness of the plotting pen in millimeters. Any value &lt;= 0.0 is treated as 0.0.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnLayer.PlotWeight">
            <summary>Get the weight of the plotting pen.</summary>
            <returns>
Thickness of the plotting pen in millimeters. A thickness of 0.0
indicates the "default" pen weight should be used.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLayer.SetIgesLevel(System.Int32)">
            <summary>
IGES level for this layer
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLayer.SetLayerIndex(System.Int32)">
            <summary>
index of this layer;
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLayer.RenderMaterialIndex">
            <summary>
Index of render material for objects on this layer that have
MaterialSource() == ON::material_from_layer.
A material index of -1 indicates no material has been assigned
and the material created by the default ON_Material constructor
should be used.
</summary>
            <returns>
index of layer's rendering material
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLayer.SetRenderMaterialIndex(System.Int32)">
            <summary>
Index of render material for objects on this layer that have
MaterialSource() == ON::material_from_layer.
A material index of -1 indicates no material has been assigned
and the material created by the default ON_Material constructor
should be used.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLayer.IsVisibleAndLocked">
            <returns>
Value of (IsVisible() &amp;&amp; !IsLocked()).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLayer.IsVisibleAndNotLocked">
            <returns>
Value of (IsVisible() &amp;&amp; !IsLocked()).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLayer.SetLocked(System.Boolean)">
            <summary>Controls layer locked</summary>
            <param name="bLocked">[in] True to lock layer False to unlock layer</param>
            <remarks>See Also: ON_Layer::IsLocked</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnLayer.IsLocked">
            <returns>
true if objects on layer are locked.
See Also: ON_Layer::SetLocked
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLayer.SetVisible(System.Boolean)">
            <summary>Controls layer visibility</summary>
            <param name="bVisible">[in] true to make layer visible, false to make layer invisible</param>
            <remarks>See Also: ON_Layer::IsVisible</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnLayer.IsVisible">
            <returns>
true if objects on layer are visible.
See Also: ON_Layer::SetVisible
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLayer.SetLinetypeIndex(System.Int32)">
            <summary>
layer linetype
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLayer.SetPlotColor(RMA.OpenNURBS.IOnColor)">
            <summary>
plotting color
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLayer.SetColor(RMA.OpenNURBS.IOnColor)">
            <summary>
layer display color
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnLayer.m_bExpanded">
            <value>
If true, when the layer table is displayed in
a tree control then the list of child layers is
shown in the control.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnLayer.m_bLocked">
            <value>
If true, objects on this layer cannot be modified.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnLayer.m_bVisible">
            <value>
If true, objects on this layer are visible.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnLayer.m_plot_weight_mm">
            <value>
thickness of plot pen in mm
 =0.0 means use the default width
 &lt;0.0 means don't plot (visible for screen display, but does not show on plot)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnLayer.m_plot_color">
            <value>
plotting color
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnLayer.m_color">
            <value>
layer color
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnLayer.m_linetype_index">
            <value>
index of linetype
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnLayer.m_material_index">
            <value>
Rendering material:
 If you want something simple and fast, set 
 m_material_index to the index of your rendering material 
 and ignore m_rendering_attributes.
 If you are developing a fancy plug-in renderer, and a user is
 assigning one of your fabulous rendering materials to this
 layer, then add rendering material information to the
Developers:
 As soon as m_rendering_attributes.m_materials[] is not empty,
 rendering material queries slow down.  Do not populate
 m_rendering_attributes.m_materials[] when setting 
 m_material_index will take care of your needs.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnLayer.m_iges_level">
            <value>
IGES level number if this layer was made during IGES import
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnLayer.m_parent_layer_id">
            <value>
Layers are origanized in a hierarchical structure (like file folders).
If a layer is in a parent layer, then m_parent_layer_id is the id of 
the parent layer.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnLayer.m_layer_index">
            <value>
index of this layer
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLayer.PlotWeight">
            <summary>Get the weight of the plotting pen.</summary>
            <returns>
Thickness of the plotting pen in millimeters. A thickness of 0.0
indicates the "default" pen weight should be used.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLayer.RenderMaterialIndex">
            <summary>
Index of render material for objects on this layer that have
MaterialSource() == ON::material_from_layer.
A material index of -1 indicates no material has been assigned
and the material created by the default ON_Material constructor
should be used.
</summary>
            <returns>
index of layer's rendering material
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLayer.IsVisibleAndLocked">
            <returns>
Value of (IsVisible() &amp;&amp; IsLocked()).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLayer.IsVisibleAndNotLocked">
            <returns>
Value of (IsVisible() &amp;&amp; !IsLocked()).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLayer.IsLocked">
            <returns>
true if objects on layer are locked.
See Also: ON_Layer::SetLocked
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLayer.IsVisible">
            <returns>
true if objects on layer are visible.
See Also: ON_Layer::SetVisible
</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLayer.m_bExpanded">
            <value>
If true, when the layer table is displayed in
a tree control then the list of child layers is
shown in the control.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLayer.m_bLocked">
            <value>
If true, objects on this layer cannot be modified.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLayer.m_bVisible">
            <value>
If true, objects on this layer are visible.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLayer.m_plot_weight_mm">
            <value>
thickness of plot pen in mm
 =0.0 means use the default width
 &lt;0.0 means don't plot (visible for screen display, but does not show on plot)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLayer.m_plot_color">
            <value>
plotting color
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLayer.m_color">
            <value>
layer color
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLayer.m_linetype_index">
            <value>
index of linetype
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLayer.m_material_index">
            <value>
Rendering material:
 If you want something simple and fast, set 
 m_material_index to the index of your rendering material 
 and ignore m_rendering_attributes.
 If you are developing a fancy plug-in renderer, and a user is
 assigning one of your fabulous rendering materials to this
 layer, then add rendering material information to the
Developers:
 As soon as m_rendering_attributes.m_materials[] is not empty,
 rendering material queries slow down.  Do not populate
 m_rendering_attributes.m_materials[] when setting 
 m_material_index will take care of your needs.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLayer.m_iges_level">
            <value>
IGES level number if this layer was made during IGES import
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLayer.m_parent_layer_id">
            <value>
Layers are origanized in a hierarchical structure (like file folders).
If a layer is in a parent layer, then m_parent_layer_id is the id of 
the parent layer.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLayer.m_layer_index">
            <value>
index of this layer
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnMaterial.DeleteTexture(System.String,RMA.OpenNURBS.IOnTexture.TYPE)">
            <summary>Deletes all texures with matching filenames and types.</summary>
            <param name="filename">[in] If NULL, then any filename matches.</param>
            <param name="type">[in] If ON_Texture::no_texture_type, then any texture type matches.</param>
            <returns>Number of textures deleted.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMaterial.AddTexture(System.String,RMA.OpenNURBS.IOnTexture.TYPE)">
            <summary>
If there is a texture with a matching type, that texture's filename
is modified, otherwise a new texture is added.
</summary>
            <param name="filename">[in] new filename</param>
            <param name="type">[in]</param>
            <returns>Index of the added texture in the m_textures[] array.</returns>
            <remarks>
This is intended to be a quick and simple way to add textures to the material.
If you need to do something different, then just work on the m_textures[] array.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMaterial.AddTexture(RMA.OpenNURBS.IOnTexture)">
            <summary>
If there is already a texture with the same file name and type,
then that texture is modified, otherwise a new texture is added.
If tx has user data, the user data is copied to the m_textures[] element.
</summary>
            <param name="tx">[in]</param>
            <returns>Index of the added texture in the m_textures[] array.</returns>
            <remarks>
This is intended to be a quick and simple way to add textures to the material.
If you need to do something different, then just work on the m_textures[] array.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMaterial.FindTexture(System.String,RMA.OpenNURBS.IOnTexture.TYPE)">
            <summary>
Searches for a texure with matching filename and type. If more than one
texture matches, the first match is returned.
</summary>
            <param name="filename">[in] If NULL, then any filename matches.</param>
            <param name="type">[in] If ON_Texture::no_texture_type, then any texture type matches.</param>
            <example>
Iterate through all the the bitmap textures on a material.
ON_Material&amp; mat = ...;
int ti = -1;
int bitmap_texture_count = 0;
for(;;) {
 ti = mat.FindTexture( NULL, ON_Texture::bitmap_texture, ti );
 if ( ti &lt; 0 ) {
   // no more bitmap textures
   break;
 }
 // we have a bitmap texture
 bitmap_texture_count++;
 const ON_Texture&amp; bitmap_texture = mat.m_textures[ti];
 ...
}
</example>
            <returns>
&gt;=0 m_textures[] index of matching texture
-1 if no match is found.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMaterial.FindTexture(System.String,RMA.OpenNURBS.IOnTexture.TYPE,System.Int32)">
            <summary>
Searches for a texure with matching filename and type. If more than one
texture matches, the first match is returned.
</summary>
            <param name="filename">[in] If NULL, then any filename matches.</param>
            <param name="type">[in] If ON_Texture::no_texture_type, then any texture type matches.</param>
            <param name="i0">
[in] If i0 is &lt; 0, the search begins at m_textures[0],
if i0 &gt;= m_textures.Count(), -1 is returnd,
otherwise, the search begins at m_textures[i0+1].
</param>
            <example>
Iterate through all the the bitmap textures on a material.
ON_Material&amp; mat = ...;
int ti = -1;
int bitmap_texture_count = 0;
for(;;) {
 ti = mat.FindTexture( NULL, ON_Texture::bitmap_texture, ti );
 if ( ti &lt; 0 ) {
   // no more bitmap textures
   break;
 }
 // we have a bitmap texture
 bitmap_texture_count++;
 const ON_Texture&amp; bitmap_texture = mat.m_textures[ti];
 ...
}
</example>
            <returns>
&gt;=0 m_textures[] index of matching texture
-1 if no match is found.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMaterial.FindTexture(System.Guid)">
            <summary>
Searches for a texure with matching texture_id. If more than one
texture matches, the first match is returned.
</summary>
            <param name="texture_id">[in]</param>
            <returns>
&gt;=0 m_textures[] index of matching texture 
-1 if no match is found.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMaterial.SetTransparency(System.Double)">
            <summary>
0.0 = opaque, 1.0 = transparent
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMaterial.Transparency">
            <summary>
Transparency values are in range 0.0 = opaque to 1.0 = transparent
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMaterial.SetShine(System.Double)">
            <summary>
0 to ON_Material::MaxShine()
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMaterial.Shine">
            <summary>
Shine values are in range 0.0 to ON_Material::MaxShine()
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMaterial.Compare(RMA.OpenNURBS.IOnMaterial)">
            <summary>ignores m_material_index</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMaterial.op_Inequality(RMA.OpenNURBS.OnMaterial,RMA.OpenNURBS.IOnMaterial)">
            <summary>
ignores m_material_index
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMaterial.op_Equality(RMA.OpenNURBS.OnMaterial,RMA.OpenNURBS.IOnMaterial)">
            <summary>
ignores m_material_index
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMaterial.#ctor">
            <summary>
Default grey color
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMaterial.MaxShine">
            <summary>
maximum value of shine exponent
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMaterial.m_plugin_id">
            <value>
ID of the last plug-in to modify this material
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMaterial.m_material_channel">
            <value>
Used to provide per face material support. The parent object reference a basic material. 
When a brep face or mesh facet wants to use a material besides the base material, it
specifies a channelSupports material channel. The default material channel is 0 and that
indicates the base material. A channel of n &gt; 0 means that face used the material
with id m_material_channel[n-1]. If (n-1) &gt;= m_material_channel.Count(), then the base
material is used. The value of m_material_channel[n].m_id is persistent. The value of
m_material_channel[n].m_i is a runtime index in the CRhinoDoc::m_material_table[]. If
CRhinoDoc::m_material_table[m_i].m_uuid != m_id, then m_id is assumed to be correct.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMaterial.im_material_channel">
            <value>
Used to provide per face material support. The parent object reference a basic material. 
When a brep face or mesh facet wants to use a material besides the base material, it
specifies a channelSupports material channel. The default material channel is 0 and that
indicates the base material. A channel of n &gt; 0 means that face used the material
with id m_material_channel[n-1]. If (n-1) &gt;= m_material_channel.Count(), then the base
material is used. The value of m_material_channel[n].m_id is persistent. The value of
m_material_channel[n].m_i is a runtime index in the CRhinoDoc::m_material_table[]. If
CRhinoDoc::m_material_table[m_i].m_uuid != m_id, then m_id is assumed to be correct.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMaterial.m_bShared">
            <value>
True means this material can be shared. When an object that uses this material is copied,
the new object will share the material. False means this material is not shared.
When an object that uses this material is duplicated.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMaterial.m_transparency">
            <value>
0.0 = opaque to 1.0 = transparent (1.0-alpha)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMaterial.m_shine">
            <value>
0.0 = none to GetMaxShine()=maximum
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMaterial.m_reflectivity">
            <value>
0.0 = none, 1.0 = 100%
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMaterial.m_index_of_refraction">
            <value>
generally &gt;= 1.0 (speed of light in vacum)/(speed of light in material)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMaterial.m_material_name">
            <value>
For user comfort - duplicates permitted
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMaterial.m_material_index">
            <value>
Runtime material table index. This value is constant
for each runtim instance of Rhino, but can change
each time a model is loaded or saved.  Once a material
is in the CRhinoDoc material table, its id and index
never change in that instance of Rhino.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMaterial.m_material_id">
            <value>
The only reliable and persistent way to reference 
materials is by the material_id.
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMaterial.FindTexture(System.String,RMA.OpenNURBS.IOnTexture.TYPE)">
            <summary>
Searches for a texure with matching filename and type. If more than one
texture matches, the first match is returned.
</summary>
            <param name="filename">[in] If NULL, then any filename matches.</param>
            <param name="type">[in] If ON_Texture::no_texture_type, then any texture type matches.</param>
            <example>
Iterate through all the the bitmap textures on a material.
ON_Material&amp; mat = ...;
int ti = -1;
int bitmap_texture_count = 0;
for(;;) {
 ti = mat.FindTexture( NULL, ON_Texture::bitmap_texture, ti );
 if ( ti &lt; 0 ) {
   // no more bitmap textures
   break;
 }
 // we have a bitmap texture
 bitmap_texture_count++;
 const ON_Texture&amp; bitmap_texture = mat.m_textures[ti];
 ...
}
</example>
            <returns>
&gt;=0 m_textures[] index of matching texture
-1 if no match is found.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMaterial.FindTexture(System.String,RMA.OpenNURBS.IOnTexture.TYPE,System.Int32)">
            <summary>
Searches for a texure with matching filename and type. If more than one
texture matches, the first match is returned.
</summary>
            <param name="filename">[in] If NULL, then any filename matches.</param>
            <param name="type">[in] If ON_Texture::no_texture_type, then any texture type matches.</param>
            <param name="i0">
[in] If i0 is &lt; 0, the search begins at m_textures[0],
if i0 &gt;= m_textures.Count(), -1 is returnd,
otherwise, the search begins at m_textures[i0+1].
</param>
            <example>
Iterate through all the the bitmap textures on a material.
ON_Material&amp; mat = ...;
int ti = -1;
int bitmap_texture_count = 0;
for(;;) {
 ti = mat.FindTexture( NULL, ON_Texture::bitmap_texture, ti );
 if ( ti &lt; 0 ) {
   // no more bitmap textures
   break;
 }
 // we have a bitmap texture
 bitmap_texture_count++;
 const ON_Texture&amp; bitmap_texture = mat.m_textures[ti];
 ...
}
</example>
            <returns>
&gt;=0 m_textures[] index of matching texture
-1 if no match is found.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMaterial.FindTexture(System.Guid)">
            <summary>
Searches for a texure with matching texture_id. If more than one
texture matches, the first match is returned.
</summary>
            <param name="texture_id">[in]</param>
            <returns>
&gt;=0 m_textures[] index of matching texture 
-1 if no match is found.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMaterial.Transparency">
            <summary>
Transparency values are in range 0.0 = opaque to 1.0 = transparent
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMaterial.Shine">
            <summary>
Shine values are in range 0.0 to ON_Material::MaxShine()
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMaterial.Compare(RMA.OpenNURBS.IOnMaterial)">
            <summary>ignores m_material_index</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMaterial.m_plugin_id">
            <value>
ID of the last plug-in to modify this material
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMaterial.m_material_channel">
            <value>
Used to provide per face material support. The parent object reference a basic material. 
When a brep face or mesh facet wants to use a material besides the base material, it
specifies a channelSupports material channel. The default material channel is 0 and that
indicates the base material. A channel of n &gt; 0 means that face used the material
with id m_material_channel[n-1]. If (n-1) &gt;= m_material_channel.Count(), then the base
material is used. The value of m_material_channel[n].m_id is persistent. The value of
m_material_channel[n].m_i is a runtime index in the CRhinoDoc::m_material_table[]. If
CRhinoDoc::m_material_table[m_i].m_uuid != m_id, then m_id is assumed to be correct.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMaterial.m_bShared">
            <value>
True means this material can be shared. When an object that uses this material is copied,
the new object will share the material. False means this material is not shared.
When an object that uses this material is duplicated.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMaterial.m_transparency">
            <value>
0.0 = opaque to 1.0 = transparent (1.0-alpha)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMaterial.m_shine">
            <value>
0.0 = none to GetMaxShine()=maximum
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMaterial.m_reflectivity">
            <value>
0.0 = none, 1.0 = 100%
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMaterial.m_index_of_refraction">
            <value>
generally &gt;= 1.0 (speed of light in vacum)/(speed of light in material)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMaterial.m_material_name">
            <value>
For user comfort - duplicates permitted
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMaterial.m_material_index">
            <value>
Runtime material table index. This value is constant
for each runtim instance of Rhino, but can change
each time a model is loaded or saved.  Once a material
is in the CRhinoDoc material table, its id and index
never change in that instance of Rhino.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMaterial.m_material_id">
            <value>
The only reliable and persistent way to reference 
materials is by the material_id.
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnTexture.IsTiled(System.Int32,System.Double@,System.Double@)">
            <summary>Examines the m_uvw matrix and harvests tiling constants.</summary>
            <param name="dir">[in] 0 = reverse "u", 1 = reverse "v", 2 = reverse "w".</param>
            <param name="count">[out] number of tiles</param>
            <param name="offset">[out] offset of the tile</param>
            <returns>True if if the m_uvw matrix had entries that were compatible with tiling.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTexture.TileTextureCoordinate(System.Int32,System.Double,System.Double)">
            <summary>Tiles the specified texture coordinates.</summary>
            <param name="dir">[in] 0 = reverse "u", 1 = reverse "v", 2 = reverse "w".</param>
            <param name="count">[in] number of tiles (can be negative)</param>
            <param name="offset">[in] offset of the tile (can be any number)</param>
            <remarks>Modifes m_uvw so that the specified texture coordinate is tiled.</remarks>
            <returns>True if input is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTexture.SwapTextureCoordinate(System.Int32,System.Int32)">
            <summary>Swaps the specified texture coordinates.</summary>
            <param name="i">[in]</param>
            <param name="j">[in] (0 &lt;= i, j &lt;= 3 and i != j)</param>
            <remarks>Modifes m_uvw so that the specified texture coordinates are swapped.</remarks>
            <returns>True if input is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTexture.ReverseTextureCoordinate(System.Int32)">
            <summary>Reverses the texture in the specified direction.</summary>
            <param name="dir">[in] 0 = reverse "u", 1 = reverse "v", 2 = reverse "w".</param>
            <remarks>Modifes m_uvw so that the spedified direction transforms the texture coordinate t to 1-t.</remarks>
            <returns>True if input is valid.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnTexture.m_runtime_ptr_id">
            <value>
Applications use the m_runtime_ptr_id and m_runtime_ptr fields
to cached runtime bitmaps. If either the id or the pointer
are non-zero, then you cannot use them.  If you hang something
on the pointer, then set the id to something unique to
prevent others from messing with it.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnTexture.m_blend_order">
            <value>
If an ON_Material m_textures[] array has more than
one texture, the textures are blended, and the textures
have different m_blend_order values, the the texture 
with the smaller m_blend_order is first.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnTexture.m_blend_constant_A">
            <value>
If the m_mode is blend_texture, then m_blend_A[]
and m_blend_RGB[] determine the blending function.
new alpha  = m_blend_constant_A 
           + m_blend_A[0]*(current alpha)
           + m_blend_A[1]*(texture alpha)
           + m_blend_A[2]*min(current alpha,texture alpha)
           + m_blend_A[3]*max(current alpha,texture alpha)
new rgb    = m_blend_constant_RGB 
           + m_blend_RGB[0]*(current RGB)
           + m_blend_RGB[1]*(texture RGB)
           + m_blend_RGB[2]*min(current RGB,texture RGB)
           + m_blend_RGB[3]*max(current RGB,texture RGB)
Results are clamped to handle underflow or overflow.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnTexture.m_bump_scale">
            <value>
If the m_type is bump_texture, the height of the
bump is m_bump_scale.ParameterAt(value), where
value is in the HSV sense and normalized 
(black=0, white=1).  The interval can be 
decreasing.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnTexture.m_transparency_texture_id">
            <value>
This field is used for textures with type
bitmap_texture that reference bitmap files that do
not have an alpha channel and is used to set
runtime alpha values.  It needs to be parsed when the
texture is loaded and can be ignored at runtime.
If m_transparency_id is not nil, it is the id of another
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnTexture.m_transparent_color">
            <value>
This field is used for textures with type
bitmap_texture that reference bitmap files that do
not have an alpha channel and is used to set
runtime alpha values.  It needs to be parsed when the
texture is loaded and can be ignored at runtime.
If ON_UNSET_COLOR != m_transparent_color, then 
a pixel in the bitmap file with a matching RGB
value is assigned the alpha value (ON_Color::Alpha)
in m_transparent_color. The intended use is 
for non-rectangular decals defined by RGB bitmaps in
files that don't save an alpha channel.
For example if the decal is a red number 7 with a 
white background, then you would set m_transparent_color's
RGB to white and its A to zero.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnTexture.m_border_color">
            <value>
If ON_UNSET_COLOR != m_border_color, then this color
is used when the texture coordinates are &lt;=0 or &gt;=1
and the m_wrap* value is clamp_wrap.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnTexture.m_bApply_uvw">
            <value>
true if m_uvw is active.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnTexture.m_magfilter">
            <value>
The magfilter setting controls how the color
of the image pixel is calculated when the image pixel
corresponds to a fraction of a texture bitmap pixel.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnTexture.m_minfilter">
            <value>
The value of m_minfilter determines how the color
of the image pixel is calculated when the image pixel
corresponds to multiple texture bitmap pixels.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnTexture.m_bOn">
            <value>
If false, texture is off and should be ignored.
The intended use is to allow people to turn textures
on and off without have to create/destroy or change 
other texture settings.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnTexture.m_filename">
            <value>
Bitmap filename  
 During runtime, m_filename is the absolute path to the
 file in use.  If m_filename_bRelativePath is true, then
 the value saved in the 3dm archive will be a relative path.
 When m_filename_bRelativePath is true, user interface
 should display a relative path.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnTexture.m_mapping_channel_id">
            <value>
If this value is on of the built-in mappings list
in the MAPPING_CHANNEL enum, then that mapping
is used.  Otherwise, if an object has rendering
attributes with an ON_MappingChannel entry that
has a matching m_mapping_channel_id value, then
the mapping identified by
ON_MappingChannel::m_mapping_id is used.
A value of zero means no mapping is supplied
and the texture coordinates on the mesh are
used.
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTexture.IsTiled(System.Int32,System.Double@,System.Double@)">
            <summary>Examines the m_uvw matrix and harvests tiling constants.</summary>
            <param name="dir">[in] 0 = reverse "u", 1 = reverse "v", 2 = reverse "w".</param>
            <param name="count">[out] number of tiles</param>
            <param name="offset">[out] offset of the tile</param>
            <returns>True if if the m_uvw matrix had entries that were compatible with tiling.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTexture.m_runtime_ptr_id">
            <value>
Applications use the m_runtime_ptr_id and m_runtime_ptr fields
to cached runtime bitmaps. If either the id or the pointer
are non-zero, then you cannot use them.  If you hang something
on the pointer, then set the id to something unique to
prevent others from messing with it.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTexture.m_blend_order">
            <value>
If an ON_Material m_textures[] array has more than
one texture, the textures are blended, and the textures
have different m_blend_order values, the the texture 
with the smaller m_blend_order is first.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTexture.m_blend_constant_A">
            <value>
If the m_mode is blend_texture, then m_blend_A[]
and m_blend_RGB[] determine the blending function.
new alpha  = m_blend_constant_A 
           + m_blend_A[0]*(current alpha)
           + m_blend_A[1]*(texture alpha)
           + m_blend_A[2]*min(current alpha,texture alpha)
           + m_blend_A[3]*max(current alpha,texture alpha)
new rgb    = m_blend_constant_RGB 
           + m_blend_RGB[0]*(current RGB)
           + m_blend_RGB[1]*(texture RGB)
           + m_blend_RGB[2]*min(current RGB,texture RGB)
           + m_blend_RGB[3]*max(current RGB,texture RGB)
Results are clamped to handle underflow or overflow.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTexture.m_bump_scale">
            <value>
If the m_type is bump_texture, the height of the
bump is m_bump_scale.ParameterAt(value), where
value is in the HSV sense and normalized 
(black=0, white=1).  The interval can be 
decreasing.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTexture.m_transparency_texture_id">
            <value>
This field is used for textures with type
bitmap_texture that reference bitmap files that do
not have an alpha channel and is used to set
runtime alpha values.  It needs to be parsed when the
texture is loaded and can be ignored at runtime.
If m_transparency_id is not nil, it is the id of another
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTexture.m_transparent_color">
            <value>
This field is used for textures with type
bitmap_texture that reference bitmap files that do
not have an alpha channel and is used to set
runtime alpha values.  It needs to be parsed when the
texture is loaded and can be ignored at runtime.
If ON_UNSET_COLOR != m_transparent_color, then 
a pixel in the bitmap file with a matching RGB
value is assigned the alpha value (ON_Color::Alpha)
in m_transparent_color. The intended use is 
for non-rectangular decals defined by RGB bitmaps in
files that don't save an alpha channel.
For example if the decal is a red number 7 with a 
white background, then you would set m_transparent_color's
RGB to white and its A to zero.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTexture.m_border_color">
            <value>
If ON_UNSET_COLOR != m_border_color, then this color
is used when the texture coordinates are &lt;=0 or &gt;=1
and the m_wrap* value is clamp_wrap.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTexture.m_bApply_uvw">
            <value>
true if m_uvw is active.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTexture.m_magfilter">
            <value>
The magfilter setting controls how the color
of the image pixel is calculated when the image pixel
corresponds to a fraction of a texture bitmap pixel.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTexture.m_minfilter">
            <value>
The value of m_minfilter determines how the color
of the image pixel is calculated when the image pixel
corresponds to multiple texture bitmap pixels.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTexture.m_bOn">
            <value>
If false, texture is off and should be ignored.
The intended use is to allow people to turn textures
on and off without have to create/destroy or change 
other texture settings.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTexture.m_filename">
            <value>
Bitmap filename  
 During runtime, m_filename is the absolute path to the
 file in use.  If m_filename_bRelativePath is true, then
 the value saved in the 3dm archive will be a relative path.
 When m_filename_bRelativePath is true, user interface
 should display a relative path.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTexture.m_mapping_channel_id">
            <value>
If this value is on of the built-in mappings list
in the MAPPING_CHANNEL enum, then that mapping
is used.  Otherwise, if an object has rendering
attributes with an ON_MappingChannel entry that
has a matching m_mapping_channel_id value, then
the mapping identified by
ON_MappingChannel::m_mapping_id is used.
A value of zero means no mapping is supplied
and the texture coordinates on the mesh are
used.
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnTexture.MODE">
            <summary>
m_mode determines how the texture is
do not change MODE enum values - they are saved in 3dm files.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnTexture.TYPE">
            <summary>
do not change TYPE enum values - they are saved in 3dm files.
The "TYPE" setting controls how the pixels in the bitmap
are interpreted.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnTexture.MAPPING_CHANNEL">
            <summary>list of pre-defined channel ids</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.GetTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.ArrayOn2fPoint@)">
            <summary>
Get texture coordinates. This calculation is expensive. When possible,
use a MappingMatch() query to avoid unnecessary calculations.
</summary>
            <param name="mesh">[in]</param>
            <param name="T">[out] Texture coordinates returned here.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.GetTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.ArrayOn2fPoint@,RMA.OpenNURBS.IOnXform)">
            <summary>
Get texture coordinates. This calculation is expensive. When possible,
use a MappingMatch() query to avoid unnecessary calculations.
</summary>
            <param name="mesh">[in]</param>
            <param name="T">[out] Texture coordinates returned here.</param>
            <param name="mesh_xform">
[in] (optional) If the mesh has been transformed since the texture mapping was set up,
pass the transformation here. Typically this is the value of ON_Mesh::m_mapping_xform
or ON_MappingRef::m_object_xform
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.GetTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.ArrayOn2fPoint@,RMA.OpenNURBS.IOnXform,System.Boolean)">
            <summary>
Get texture coordinates. This calculation is expensive. When possible,
use a MappingMatch() query to avoid unnecessary calculations.
</summary>
            <param name="mesh">[in]</param>
            <param name="T">[out] Texture coordinates returned here.</param>
            <param name="mesh_xform">
[in] (optional) If the mesh has been transformed since the texture mapping was set up,
pass the transformation here. Typically this is the value of ON_Mesh::m_mapping_xform
or ON_MappingRef::m_object_xform
</param>
            <param name="bLazy">
[in] If true and the mesh.m_T[] values were calculated using this mapping,
they are simply copied to the T[] array and no calculations are performed.
If you are calling the 3d point version and you care about the z-coordinate,
then do not use the lazy option (meshes only store 2d texture coordinates).
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.GetTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.ArrayOn2fPoint@,RMA.OpenNURBS.IOnXform,System.Boolean,RMA.OpenNURBS.Arrayint)">
            <summary>
Get texture coordinates. This calculation is expensive. When possible,
use a MappingMatch() query to avoid unnecessary calculations.
</summary>
            <param name="mesh">[in]</param>
            <param name="T">[out] Texture coordinates returned here.</param>
            <param name="mesh_xform">
[in] (optional) If the mesh has been transformed since the texture mapping was set up,
pass the transformation here. Typically this is the value of ON_Mesh::m_mapping_xform
or ON_MappingRef::m_object_xform
</param>
            <param name="bLazy">
[in] If true and the mesh.m_T[] values were calculated using this mapping,
they are simply copied to the T[] array and no calculations are performed.
If you are calling the 3d point version and you care about the z-coordinate,
then do not use the lazy option (meshes only store 2d texture coordinates).
</param>
            <param name="Tside">
[out] In the case of divided textures, side information is returned here if
a lazy mapping is not done. Otherwise Tside-&gt;Count() will be zero.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.GetTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.ArrayOn3fPoint@)">
            <summary>
Get texture coordinates. This calculation is expensive. When possible,
use a MappingMatch() query to avoid unnecessary calculations.
</summary>
            <param name="mesh">[in]</param>
            <param name="T">[out] Texture coordinates returned here.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.GetTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.ArrayOn3fPoint@,RMA.OpenNURBS.IOnXform)">
            <summary>
Get texture coordinates. This calculation is expensive. When possible,
use a MappingMatch() query to avoid unnecessary calculations.
</summary>
            <param name="mesh">[in]</param>
            <param name="T">[out] Texture coordinates returned here.</param>
            <param name="mesh_xform">
[in] (optional) If the mesh has been transformed since the texture mapping was set up,
pass the transformation here. Typically this is the value of ON_Mesh::m_mapping_xform
or ON_MappingRef::m_object_xform
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.GetTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.ArrayOn3fPoint@,RMA.OpenNURBS.IOnXform,System.Boolean)">
            <summary>
Get texture coordinates. This calculation is expensive. When possible,
use a MappingMatch() query to avoid unnecessary calculations.
</summary>
            <param name="mesh">[in]</param>
            <param name="T">[out] Texture coordinates returned here.</param>
            <param name="mesh_xform">
[in] (optional) If the mesh has been transformed since the texture mapping was set up,
pass the transformation here. Typically this is the value of ON_Mesh::m_mapping_xform
or ON_MappingRef::m_object_xform
</param>
            <param name="bLazy">
[in] If true and the mesh.m_T[] values were calculated using this mapping,
they are simply copied to the T[] array and no calculations are performed.
If you are calling the 3d point version and you care about the z-coordinate,
then do not use the lazy option (meshes only store 2d texture coordinates).
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.GetTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.ArrayOn3fPoint@,RMA.OpenNURBS.IOnXform,System.Boolean,RMA.OpenNURBS.Arrayint)">
            <summary>
Get texture coordinates. This calculation is expensive. When possible,
use a MappingMatch() query to avoid unnecessary calculations.
</summary>
            <param name="mesh">[in]</param>
            <param name="T">[out] Texture coordinates returned here.</param>
            <param name="mesh_xform">
[in] (optional) If the mesh has been transformed since the texture mapping was set up,
pass the transformation here. Typically this is the value of ON_Mesh::m_mapping_xform
or ON_MappingRef::m_object_xform
</param>
            <param name="bLazy">
[in] If true and the mesh.m_T[] values were calculated using this mapping,
they are simply copied to the T[] array and no calculations are performed.
If you are calling the 3d point version and you care about the z-coordinate,
then do not use the lazy option (meshes only store 2d texture coordinates).
</param>
            <param name="Tside">
[out] In the case of divided textures, side information is returned here if
a lazy mapping is not done. Otherwise Tside-&gt;Count() will be zero.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.HasMatchingTextureCoordinates(RMA.OpenNURBS.IOnMappingTag)">
            <summary>Quickly check to see if a mesh or tag has texture coordinates set by this mapping.</summary>
            <param name="tag">[in]</param>
            <returns>True if the meshes texture coordinates were set by this mapping.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.HasMatchingTextureCoordinates(RMA.OpenNURBS.IOnMappingTag,RMA.OpenNURBS.IOnXform)">
            <summary>Quickly check to see if a mesh or tag has texture coordinates set by this mapping.</summary>
            <param name="tag">[in]</param>
            <param name="object_xform">
[in] (optional) If this transform is not NULL, then true will be returned only if the
mapping function is the same and the tag's m_mesh_xform field is the same as mesh_xform.
This parameter is typically NULL or the value of ON_MappingRef::m_object_xform.
</param>
            <returns>True if the meshes texture coordinates were set by this mapping.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.HasMatchingTextureCoordinates(RMA.OpenNURBS.IOnMesh)">
            <summary>Quickly check to see if a mesh or tag has texture coordinates set by this mapping.</summary>
            <param name="mesh">[in]</param>
            <returns>True if the meshes texture coordinates were set by this mapping.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.HasMatchingTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.IOnXform)">
            <summary>Quickly check to see if a mesh or tag has texture coordinates set by this mapping.</summary>
            <param name="mesh">[in]</param>
            <param name="object_xform">
[in] (optional) If this transform is not NULL, then true will be returned only if the
mapping function is the same and the tag's m_mesh_xform field is the same as mesh_xform.
This parameter is typically NULL or the value of ON_MappingRef::m_object_xform.
</param>
            <returns>True if the meshes texture coordinates were set by this mapping.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.EvaluateBrepMapping(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOnBrep,RMA.OpenNURBS.On3dPoint)">
            <summary>Evaluate the mapping to get a texture coordinate.</summary>
            <param name="P">[in] Vertex location</param>
            <param name="N">[in] If the mapping projection is ray_projection, then this is the vertex unit normal. Otherwise N is ignored.</param>
            <param name="T">[out] Texture coordinate (u,v,w)</param>
            <returns>
Nonzero if evaluation is successful. When the mapping is a box or capped cylinder mapping,
the value indicates which side was evaluated.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
See Also: ON_TextureMapping::GetTextureCoordinates ON_Mesh::SetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.EvaluateSurfaceMapping(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.On3dPoint)">
            <summary>Evaluate the mapping to get a texture coordinate.</summary>
            <param name="P">[in] Vertex location</param>
            <param name="N">[in] If the mapping projection is ray_projection, then this is the vertex unit normal. Otherwise N is ignored.</param>
            <param name="T">[out] Texture coordinate (u,v,w)</param>
            <returns>
Nonzero if evaluation is successful. When the mapping is a box or capped cylinder mapping,
the value indicates which side was evaluated.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
See Also: ON_TextureMapping::GetTextureCoordinates ON_Mesh::SetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.EvaluateMeshMapping(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.On3dPoint)">
            <summary>Evaluate the mapping to get a texture coordinate.</summary>
            <param name="P">[in] Vertex location</param>
            <param name="N">[in] If the mapping projection is ray_projection, then this is the vertex unit normal. Otherwise N is ignored.</param>
            <param name="T">[out] Texture coordinate (u,v,w)</param>
            <returns>
Nonzero if evaluation is successful. When the mapping is a box or capped cylinder mapping,
the value indicates which side was evaluated.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
See Also: ON_TextureMapping::GetTextureCoordinates ON_Mesh::SetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.EvaluateBoxMapping(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.On3dPoint)">
            <summary>Evaluate the mapping to get a texture coordinate.</summary>
            <param name="P">[in] Vertex location</param>
            <param name="N">[in] If the mapping projection is ray_projection, then this is the vertex unit normal. Otherwise N is ignored.</param>
            <param name="T">[out] Texture coordinate (u,v,w)</param>
            <returns>
Nonzero if evaluation is successful. When the mapping is a box or capped cylinder mapping,
the value indicates which side was evaluated.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
See Also: ON_TextureMapping::GetTextureCoordinates ON_Mesh::SetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.EvaluateCylinderMapping(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.On3dPoint)">
            <summary>Evaluate the mapping to get a texture coordinate.</summary>
            <param name="P">[in] Vertex location</param>
            <param name="N">[in] If the mapping projection is ray_projection, then this is the vertex unit normal. Otherwise N is ignored.</param>
            <param name="T">[out] Texture coordinate (u,v,w)</param>
            <returns>
Nonzero if evaluation is successful. When the mapping is a box or capped cylinder mapping,
the value indicates which side was evaluated.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
See Also: ON_TextureMapping::GetTextureCoordinates ON_Mesh::SetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.EvaluateSphereMapping(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.On3dPoint)">
            <summary>Evaluate the mapping to get a texture coordinate.</summary>
            <param name="P">[in] Vertex location</param>
            <param name="N">[in] If the mapping projection is ray_projection, then this is the vertex unit normal. Otherwise N is ignored.</param>
            <param name="T">[out] Texture coordinate (u,v,w)</param>
            <returns>
Nonzero if evaluation is successful. When the mapping is a box or capped cylinder mapping,
the value indicates which side was evaluated.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
See Also: ON_TextureMapping::GetTextureCoordinates ON_Mesh::SetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.EvaluatePlaneMapping(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.On3dPoint)">
            <summary>Evaluate the mapping to get a texture coordinate.</summary>
            <param name="P">[in] Vertex location</param>
            <param name="N">[in] If the mapping projection is ray_projection, then this is the vertex unit normal. Otherwise N is ignored.</param>
            <param name="T">[out] Texture coordinate (u,v,w)</param>
            <returns>
Nonzero if evaluation is successful. When the mapping is a box or capped cylinder mapping,
the value indicates which side was evaluated.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
See Also: ON_TextureMapping::GetTextureCoordinates ON_Mesh::SetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.Evaluate(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.On3dPoint,RMA.OpenNURBS.IOnXform,RMA.OpenNURBS.IOnXform)">
            <summary>Evaluate the mapping to get a texture coordinate.</summary>
            <param name="P">[in] Vertex location</param>
            <param name="N">[in] If the mapping projection is ray_projection, then this is the vertex unit normal. Otherwise N is ignored.</param>
            <param name="T">[out] Texture coordinate (u,v,w)</param>
            <param name="P_xform">[in] Transformation to be applied to P before performing the mapping calculation.</param>
            <param name="N_xform">
[in] Transformation to be applied to N before performing the mapping calculation.
One way to calculate N_xform is to use the call P_xform::GetVectorTransform(N_xform).
</param>
            <returns>
Nonzero if evaluation is successful. When the mapping is a box or capped cylinder mapping,
the value indicates which side was evaluated.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
See Also: ON_TextureMapping::GetTextureCoordinates ON_Mesh::SetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.Evaluate(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.On3dPoint)">
            <summary>Evaluate the mapping to get a texture coordinate.</summary>
            <param name="P">[in] Vertex location</param>
            <param name="N">[in] If the mapping projection is ray_projection, then this is the vertex unit normal. Otherwise N is ignored.</param>
            <param name="T">[out] Texture coordinate (u,v,w)</param>
            <returns>
Nonzero if evaluation is successful. When the mapping is a box or capped cylinder mapping,
the value indicates which side was evaluated.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
See Also: ON_TextureMapping::GetTextureCoordinates ON_Mesh::SetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.TileTextureCoordinate(System.Int32,System.Double,System.Double)">
            <summary>Tiles the specified texture coordinates.</summary>
            <param name="dir">[in] 0 = "u", 1 = "v", 2 = "w".</param>
            <param name="count">[in] number of tiles</param>
            <param name="offset">[in] offset of the tile</param>
            <remarks>Modies m_uvw so that the specified texture coordinate is tiled.</remarks>
            <returns>True if input is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.SwapTextureCoordinate(System.Int32,System.Int32)">
            <summary>Swaps the specified texture coordinates.</summary>
            <param name="i">[in]</param>
            <param name="j">[in]</param>
            <remarks>Modifies m_uvw so that the specified texture coordinates are swapped.</remarks>
            <returns>True if input is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.ReverseTextureCoordinate(System.Int32)">
            <summary>Reverses the texture in the specified direction.</summary>
            <param name="dir">[in] 0 = reverse "u", 1 = reverse "v", 2 = reverse "w".</param>
            <remarks>Modies m_uvw so that the spedified direction transforms the texture coordinate t to 1-t.</remarks>
            <returns>True if input is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.GetMappingBox(RMA.OpenNURBS.OnPlane@,RMA.OpenNURBS.OnInterval@,RMA.OpenNURBS.OnInterval@,RMA.OpenNURBS.OnInterval@)">
            <summary>Get a box projection from the texture mapping.</summary>
            <param name="plane">
[out] The center of the box is at plane.origin and the sides of the box
are parallel to the plane's coordinate planes.
</param>
            <param name="dx">
[out] The "front" and "back" sides of the box are in spanned by the
vectors plane.yaxis and plane.zaxis. The back plane contains the point plane.PointAt(dx[0],0,0)
and the front plane contains the point plane.PointAt(dx[1],0,0).
</param>
            <param name="dy">
[out] The "left" and "right" sides of the box are in spanned by the
vectors plane.zaxis and plane.xaxis. The left plane contains the point plane.PointAt(0,dx[0],0)
and the back plane contains the point plane.PointAt(0,dy[1],0).
</param>
            <param name="dz">
[out] The "top" and "bottom" sides of the box are in spanned by the
vectors plane.xaxis and plane.yaxis. The bottom plane contains the point plane.PointAt(0,0,dz[0])
and the top plane contains the point plane.PointAt(0,0,dz[1]).
</param>
            <returns>True if a valid box is returned.</returns>
            <remarks>
Generally, GetMappingBox will not return the same parameters passed to SetBoxMapping.
However, the location of the box will be the same.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.GetMappingSphere(RMA.OpenNURBS.OnSphere@)">
            <summary>Get a spherical projection parameters from this texture mapping.</summary>
            <param name="sphere">[out]</param>
            <returns>True if a valid sphere is returned.</returns>
            <remarks>
Generally, GetMappingShere will not return the same parameters passed to SetSphereMapping.
However, the location of the sphere will be the same. If this mapping is not cylindrical,
the cylinder will approximate the actual mapping primitive.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.GetMappingCylinder(RMA.OpenNURBS.OnCylinder@)">
            <summary>Get a cylindrical projection parameters from this texture mapping.</summary>
            <param name="cylinder">[out]</param>
            <returns>True if a valid cylinder is returned.</returns>
            <remarks>
Generally, GetMappingCylinder will not return the same parameters passed to SetCylinderMapping.
However, the location of the cylinder will be the same. If this mapping is not cylindrical,
the cylinder will approximate the actual mapping primitive.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.GetMappingPlane(RMA.OpenNURBS.OnPlane@,RMA.OpenNURBS.OnInterval@,RMA.OpenNURBS.OnInterval@,RMA.OpenNURBS.OnInterval@)">
            <summary>Get plane mapping parameters from this texture mapping.</summary>
            <param name="plane">[out]</param>
            <param name="dx">[out] Portion of the plane's x axis that is mapped to [0,1]</param>
            <param name="dy">[out] Portion of the plane's y axis that is mapped to [0,1]</param>
            <param name="dz">[out] Portion of the plane's z axis that is mapped to [0,1]</param>
            <returns>True if valid plane mapping parameters were returned.</returns>
            <remarks>
NOTE WELL:
Generally, GetMappingPlane will not return the same parameters passed to SetPlaneMapping.
However, the location of the plane will be the same.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.SetBoxMapping(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval,System.Boolean)">
            <summary>Create a box projection texture mapping.</summary>
            <param name="plane">
[in] The sides of the box the box are parallel to the plane's coordinate planes.
The dx, dy, dz intervals determine the location of the sides.
</param>
            <param name="dx">
[in] Determines the location of the front and back planes. The vector plane.xaxis is
perpindicular to these planes and they pass through plane.PointAt(dx[0],0,0) and
plane.PointAt(dx[1],0,0), respectivly.
</param>
            <param name="dy">
[in] Determines the location of the left and right planes. The vector plane.yaxis is
perpindicular to these planes and they pass through plane.PointAt(0,dy[0],0) and
plane.PointAt(0,dy[1],0), respectivly.
</param>
            <param name="dz">
[in] Determines the location of the top and bottom planes. The vector plane.zaxis is
perpindicular to these planes and they pass through plane.PointAt(0,0,dz[0]) and
plane.PointAt(0,0,dz[1]), respectivly.
</param>
            <param name="bIsCapped">[in] If true, the box is treated as a finite capped box.</param>
            <returns>True if input is valid.</returns>
            <remarks>
When m_texture_space = divided, the box is mapped to texture space as follows:

If the box is not capped, then each side maps to 1/4 of the texture map.
 v=1+---------+---------+---------+---------+
    | x=dx[1] | y=dy[1] | x=dx[0] | y=dy[0] |
    | Front   | Right   | Back    | Left    |
    | --y-&gt; | &lt;-x-- | &lt;-y-- | --x-&gt; |
 v=0+---------+---------+---------+---------+
   0/4 &lt;=u&lt;= 1/4 &lt;=u&lt;= 2/4 &lt;=u&lt;= 3/4 &lt;=u&lt;= 4/4

If the box is capped, then each side and cap gets 1/6 of the texture map.
 v=1+---------+---------+---------+---------+---------+---------+
    | x=dx[1] | y=dy[1] | x=dx[0] | y=dy[0] | z=dx[1] | z=dz[0] |
    | Front   | Right   | Back    | Left    | Top     | Bottom  |
    | --y-&gt; | &lt;-x-- | &lt;-y-- | --x-&gt; | --x-&gt; | --x-&gt; |
 v=0+---------+---------+---------+---------+---------+---------+
   0/6 &lt;=u&lt;= 1/6 &lt;=u&lt;= 2/6 &lt;=u&lt;= 3/6 &lt;=u&lt;= 4/6 &lt;=u&lt;= 5/6 &lt;=u&lt;= 6/6
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.SetSphereMapping(RMA.OpenNURBS.IOnSphere)">
            <summary>Create a spherical projection texture mapping.</summary>
            <param name="sphere">
[in] sphere in world space used to define a spherical coordinate system.
The longitude parameter maps (0,2pi) to texture "u" (0,1).
The latitude paramter maps (-pi/2,+pi/2) to texture "v" (0,1).
The radial parameter maps (0,r) to texture "w" (0,1).
</param>
            <returns>True if input is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.SetCylinderMapping(RMA.OpenNURBS.IOnCylinder,System.Boolean)">
            <summary>Create a cylindrical projection texture mapping.</summary>
            <param name="cylinder">
[in] cylinder in world space used to define a cylindrical coordinate system. The
angular parameter maps (0,2pi) to texture "u" (0,1), The height parameter
maps (height[0],height[1]) to texture "v" (0,1), and the radial parameter
maps (0,r) to texture "w" (0,1).
</param>
            <param name="bIsCapped">[in] If true, the cylinder is treated as a finite capped cylinder.</param>
            <returns>True if input is valid.</returns>
            <remarks>
When the cylinder is capped and m_texture_space = divided,
the cylinder is mapped to texture space as follows:
 The side is mapped to 0 &lt;= "u" &lt;= 2/3.
 The bottom is mapped to 2/3 &lt;= "u" &lt;= 5/6.
 The top is mapped to 5/6 &lt;= "u" &lt;= 5/6.
This is the same convention box mapping uses.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.SetPlaneMapping(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Create a planar projection texture mapping.</summary>
            <param name="plane">[in]</param>
            <param name="dx">[in] portion of the plane's x axis that is mapped to [0,1] (can be a decreasing interval)</param>
            <param name="dy">[in] portion of the plane's x axis that is mapped to [0,1] (can be a decreasing interval)</param>
            <param name="dz">[in] portion of the plane's x axis that is mapped to [0,1] (can be a decreasing interval)</param>
            <example>
Create a mapping that maps the world axis aligned rectangle in the world yz plane
with corners at (0,3,5) and (0,7,19) to the texture coordinate unit square.
 ON_3dVector plane_xaxis(0.0,1.0,0.0);
 ON_3dVector plane_yaxis(0.0,0,0,1.0);
 ON_3dPoint plane_origin(0.0,2.0,4.0);
 ON_Plane plane(plane_origin,plane_xaxis,plane_yaxis);
 ON_Interval dx( 0.0, 7.0 - 3.0);
 ON_Interval dy( 0.0, 19.0 - 5.0);
 ON_Interval dz( 0.0, 1.0 );
 ON_TextureMapping mapping;
 mapping.CreatePlaneMapping(plane,dx,dy,dz);
</example>
            <returns>True if input is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.SetSurfaceParameterMapping">
            <summary>Create a mapping that will convert surface parameters into normalized (0,1)x(0,1) texture coordinates.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.RequiresVertexNormals">
            <summary>
Determines whether the mapping, as currently set up, requires vertex normals to be
present on the mesh in order to evaluate the mapping correctly.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnTextureMapping.m_uvw">
            <value>
Transform applied to mapping coordinate (u,v,w) to 
convert it into a texture coordinate.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnTextureMapping.m_Nxyz">
            <value>
For primitive based mappings, these transformations are
used to map the world coordinate (x,y,z) point P and 
surface normal N before it is projected to the normalized 
mapping primitive. The surface normal transformation,
m_Nxyz, is always calculated from m_Pxyz.  It is a 
runtime setting that is not saved in 3dm files. 
If m_type is srfp_mapping, then m_Pxyz and m_Nxyz are
ignored.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnTextureMapping.m_Pxyz">
            <value>
For primitive based mappings, these transformations are
used to map the world coordinate (x,y,z) point P and 
surface normal N before it is projected to the normalized 
mapping primitive. The surface normal transformation,
m_Nxyz, is always calculated from m_Pxyz.  It is a 
runtime setting that is not saved in 3dm files. 
If m_type is srfp_mapping, then m_Pxyz and m_Nxyz are
ignored.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnTextureMapping.m_bCapped">
            <value>
The m_bCapped applies to cylinder and box mappings.  If
m_bCapped is false, the cylinder or box is "infinite".
If m_bCapped is true, they are finite.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnTextureMapping.m_mapping_name">
            <value>
The texture mapping name is for UI and user comfort. 
Duplicates are permitted.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnTextureMapping.m_mapping_index">
            <value>
Runtime texture mapping table index. 
This value is NOT SAVED IN 3DM FILES.
This value is constant for each runtime instance of Rhino,
but can change each time a model is loaded or saved.  
Once a texture mapping is in the CRhinoDoc material table,
its id and index never change in that instance of Rhino.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnTextureMapping.m_mapping_id">
            <value>
The only reliable and persistent way to reference texture 
mappings is by the mapping_id.  If the mapping id is
set to m_srfp_mapping_id, then all other mapping settings
are ignored.
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.GetTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.ArrayOn2fPoint@)">
            <summary>
Get texture coordinates. This calculation is expensive. When possible,
use a MappingMatch() query to avoid unnecessary calculations.
</summary>
            <param name="mesh">[in]</param>
            <param name="T">[out] Texture coordinates returned here.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.GetTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.ArrayOn2fPoint@,RMA.OpenNURBS.IOnXform)">
            <summary>
Get texture coordinates. This calculation is expensive. When possible,
use a MappingMatch() query to avoid unnecessary calculations.
</summary>
            <param name="mesh">[in]</param>
            <param name="T">[out] Texture coordinates returned here.</param>
            <param name="mesh_xform">
[in] (optional) If the mesh has been transformed since the texture mapping was set up,
pass the transformation here. Typically this is the value of ON_Mesh::m_mapping_xform
or ON_MappingRef::m_object_xform
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.GetTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.ArrayOn2fPoint@,RMA.OpenNURBS.IOnXform,System.Boolean)">
            <summary>
Get texture coordinates. This calculation is expensive. When possible,
use a MappingMatch() query to avoid unnecessary calculations.
</summary>
            <param name="mesh">[in]</param>
            <param name="T">[out] Texture coordinates returned here.</param>
            <param name="mesh_xform">
[in] (optional) If the mesh has been transformed since the texture mapping was set up,
pass the transformation here. Typically this is the value of ON_Mesh::m_mapping_xform
or ON_MappingRef::m_object_xform
</param>
            <param name="bLazy">
[in] If true and the mesh.m_T[] values were calculated using this mapping,
they are simply copied to the T[] array and no calculations are performed.
If you are calling the 3d point version and you care about the z-coordinate,
then do not use the lazy option (meshes only store 2d texture coordinates).
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.GetTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.ArrayOn2fPoint@,RMA.OpenNURBS.IOnXform,System.Boolean,RMA.OpenNURBS.Arrayint)">
            <summary>
Get texture coordinates. This calculation is expensive. When possible,
use a MappingMatch() query to avoid unnecessary calculations.
</summary>
            <param name="mesh">[in]</param>
            <param name="T">[out] Texture coordinates returned here.</param>
            <param name="mesh_xform">
[in] (optional) If the mesh has been transformed since the texture mapping was set up,
pass the transformation here. Typically this is the value of ON_Mesh::m_mapping_xform
or ON_MappingRef::m_object_xform
</param>
            <param name="bLazy">
[in] If true and the mesh.m_T[] values were calculated using this mapping,
they are simply copied to the T[] array and no calculations are performed.
If you are calling the 3d point version and you care about the z-coordinate,
then do not use the lazy option (meshes only store 2d texture coordinates).
</param>
            <param name="Tside">
[out] In the case of divided textures, side information is returned here if
a lazy mapping is not done. Otherwise Tside-&gt;Count() will be zero.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.GetTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.ArrayOn3fPoint@)">
            <summary>
Get texture coordinates. This calculation is expensive. When possible,
use a MappingMatch() query to avoid unnecessary calculations.
</summary>
            <param name="mesh">[in]</param>
            <param name="T">[out] Texture coordinates returned here.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.GetTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.ArrayOn3fPoint@,RMA.OpenNURBS.IOnXform)">
            <summary>
Get texture coordinates. This calculation is expensive. When possible,
use a MappingMatch() query to avoid unnecessary calculations.
</summary>
            <param name="mesh">[in]</param>
            <param name="T">[out] Texture coordinates returned here.</param>
            <param name="mesh_xform">
[in] (optional) If the mesh has been transformed since the texture mapping was set up,
pass the transformation here. Typically this is the value of ON_Mesh::m_mapping_xform
or ON_MappingRef::m_object_xform
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.GetTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.ArrayOn3fPoint@,RMA.OpenNURBS.IOnXform,System.Boolean)">
            <summary>
Get texture coordinates. This calculation is expensive. When possible,
use a MappingMatch() query to avoid unnecessary calculations.
</summary>
            <param name="mesh">[in]</param>
            <param name="T">[out] Texture coordinates returned here.</param>
            <param name="mesh_xform">
[in] (optional) If the mesh has been transformed since the texture mapping was set up,
pass the transformation here. Typically this is the value of ON_Mesh::m_mapping_xform
or ON_MappingRef::m_object_xform
</param>
            <param name="bLazy">
[in] If true and the mesh.m_T[] values were calculated using this mapping,
they are simply copied to the T[] array and no calculations are performed.
If you are calling the 3d point version and you care about the z-coordinate,
then do not use the lazy option (meshes only store 2d texture coordinates).
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.GetTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.ArrayOn3fPoint@,RMA.OpenNURBS.IOnXform,System.Boolean,RMA.OpenNURBS.Arrayint)">
            <summary>
Get texture coordinates. This calculation is expensive. When possible,
use a MappingMatch() query to avoid unnecessary calculations.
</summary>
            <param name="mesh">[in]</param>
            <param name="T">[out] Texture coordinates returned here.</param>
            <param name="mesh_xform">
[in] (optional) If the mesh has been transformed since the texture mapping was set up,
pass the transformation here. Typically this is the value of ON_Mesh::m_mapping_xform
or ON_MappingRef::m_object_xform
</param>
            <param name="bLazy">
[in] If true and the mesh.m_T[] values were calculated using this mapping,
they are simply copied to the T[] array and no calculations are performed.
If you are calling the 3d point version and you care about the z-coordinate,
then do not use the lazy option (meshes only store 2d texture coordinates).
</param>
            <param name="Tside">
[out] In the case of divided textures, side information is returned here if
a lazy mapping is not done. Otherwise Tside-&gt;Count() will be zero.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.HasMatchingTextureCoordinates(RMA.OpenNURBS.IOnMappingTag)">
            <summary>Quickly check to see if a mesh or tag has texture coordinates set by this mapping.</summary>
            <param name="tag">[in]</param>
            <returns>True if the meshes texture coordinates were set by this mapping.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.HasMatchingTextureCoordinates(RMA.OpenNURBS.IOnMappingTag,RMA.OpenNURBS.IOnXform)">
            <summary>Quickly check to see if a mesh or tag has texture coordinates set by this mapping.</summary>
            <param name="tag">[in]</param>
            <param name="object_xform">
[in] (optional) If this transform is not NULL, then true will be returned only if the
mapping function is the same and the tag's m_mesh_xform field is the same as mesh_xform.
This parameter is typically NULL or the value of ON_MappingRef::m_object_xform.
</param>
            <returns>True if the meshes texture coordinates were set by this mapping.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.HasMatchingTextureCoordinates(RMA.OpenNURBS.IOnMesh)">
            <summary>Quickly check to see if a mesh or tag has texture coordinates set by this mapping.</summary>
            <param name="mesh">[in]</param>
            <returns>True if the meshes texture coordinates were set by this mapping.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.HasMatchingTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.IOnXform)">
            <summary>Quickly check to see if a mesh or tag has texture coordinates set by this mapping.</summary>
            <param name="mesh">[in]</param>
            <param name="object_xform">
[in] (optional) If this transform is not NULL, then true will be returned only if the
mapping function is the same and the tag's m_mesh_xform field is the same as mesh_xform.
This parameter is typically NULL or the value of ON_MappingRef::m_object_xform.
</param>
            <returns>True if the meshes texture coordinates were set by this mapping.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.EvaluateBrepMapping(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOnBrep,RMA.OpenNURBS.On3dPoint)">
            <summary>Evaluate the mapping to get a texture coordinate.</summary>
            <param name="P">[in] Vertex location</param>
            <param name="N">[in] If the mapping projection is ray_projection, then this is the vertex unit normal. Otherwise N is ignored.</param>
            <param name="T">[out] Texture coordinate (u,v,w)</param>
            <returns>
Nonzero if evaluation is successful. When the mapping is a box or capped cylinder mapping,
the value indicates which side was evaluated.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
See Also: ON_TextureMapping::GetTextureCoordinates ON_Mesh::SetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.EvaluateSurfaceMapping(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.On3dPoint)">
            <summary>Evaluate the mapping to get a texture coordinate.</summary>
            <param name="P">[in] Vertex location</param>
            <param name="N">[in] If the mapping projection is ray_projection, then this is the vertex unit normal. Otherwise N is ignored.</param>
            <param name="T">[out] Texture coordinate (u,v,w)</param>
            <returns>
Nonzero if evaluation is successful. When the mapping is a box or capped cylinder mapping,
the value indicates which side was evaluated.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
See Also: ON_TextureMapping::GetTextureCoordinates ON_Mesh::SetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.EvaluateMeshMapping(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.On3dPoint)">
            <summary>Evaluate the mapping to get a texture coordinate.</summary>
            <param name="P">[in] Vertex location</param>
            <param name="N">[in] If the mapping projection is ray_projection, then this is the vertex unit normal. Otherwise N is ignored.</param>
            <param name="T">[out] Texture coordinate (u,v,w)</param>
            <returns>
Nonzero if evaluation is successful. When the mapping is a box or capped cylinder mapping,
the value indicates which side was evaluated.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
See Also: ON_TextureMapping::GetTextureCoordinates ON_Mesh::SetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.EvaluateBoxMapping(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.On3dPoint)">
            <summary>Evaluate the mapping to get a texture coordinate.</summary>
            <param name="P">[in] Vertex location</param>
            <param name="N">[in] If the mapping projection is ray_projection, then this is the vertex unit normal. Otherwise N is ignored.</param>
            <param name="T">[out] Texture coordinate (u,v,w)</param>
            <returns>
Nonzero if evaluation is successful. When the mapping is a box or capped cylinder mapping,
the value indicates which side was evaluated.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
See Also: ON_TextureMapping::GetTextureCoordinates ON_Mesh::SetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.EvaluateCylinderMapping(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.On3dPoint)">
            <summary>Evaluate the mapping to get a texture coordinate.</summary>
            <param name="P">[in] Vertex location</param>
            <param name="N">[in] If the mapping projection is ray_projection, then this is the vertex unit normal. Otherwise N is ignored.</param>
            <param name="T">[out] Texture coordinate (u,v,w)</param>
            <returns>
Nonzero if evaluation is successful. When the mapping is a box or capped cylinder mapping,
the value indicates which side was evaluated.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
See Also: ON_TextureMapping::GetTextureCoordinates ON_Mesh::SetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.EvaluateSphereMapping(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.On3dPoint)">
            <summary>Evaluate the mapping to get a texture coordinate.</summary>
            <param name="P">[in] Vertex location</param>
            <param name="N">[in] If the mapping projection is ray_projection, then this is the vertex unit normal. Otherwise N is ignored.</param>
            <param name="T">[out] Texture coordinate (u,v,w)</param>
            <returns>
Nonzero if evaluation is successful. When the mapping is a box or capped cylinder mapping,
the value indicates which side was evaluated.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
See Also: ON_TextureMapping::GetTextureCoordinates ON_Mesh::SetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.EvaluatePlaneMapping(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.On3dPoint)">
            <summary>Evaluate the mapping to get a texture coordinate.</summary>
            <param name="P">[in] Vertex location</param>
            <param name="N">[in] If the mapping projection is ray_projection, then this is the vertex unit normal. Otherwise N is ignored.</param>
            <param name="T">[out] Texture coordinate (u,v,w)</param>
            <returns>
Nonzero if evaluation is successful. When the mapping is a box or capped cylinder mapping,
the value indicates which side was evaluated.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
See Also: ON_TextureMapping::GetTextureCoordinates ON_Mesh::SetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.Evaluate(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.On3dPoint,RMA.OpenNURBS.IOnXform,RMA.OpenNURBS.IOnXform)">
            <summary>Evaluate the mapping to get a texture coordinate.</summary>
            <param name="P">[in] Vertex location</param>
            <param name="N">[in] If the mapping projection is ray_projection, then this is the vertex unit normal. Otherwise N is ignored.</param>
            <param name="T">[out] Texture coordinate (u,v,w)</param>
            <param name="P_xform">[in] Transformation to be applied to P before performing the mapping calculation.</param>
            <param name="N_xform">
[in] Transformation to be applied to N before performing the mapping calculation.
One way to calculate N_xform is to use the call P_xform::GetVectorTransform(N_xform).
</param>
            <returns>
Nonzero if evaluation is successful. When the mapping is a box or capped cylinder mapping,
the value indicates which side was evaluated.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
See Also: ON_TextureMapping::GetTextureCoordinates ON_Mesh::SetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.Evaluate(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.On3dPoint)">
            <summary>Evaluate the mapping to get a texture coordinate.</summary>
            <param name="P">[in] Vertex location</param>
            <param name="N">[in] If the mapping projection is ray_projection, then this is the vertex unit normal. Otherwise N is ignored.</param>
            <param name="T">[out] Texture coordinate (u,v,w)</param>
            <returns>
Nonzero if evaluation is successful. When the mapping is a box or capped cylinder mapping,
the value indicates which side was evaluated.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
See Also: ON_TextureMapping::GetTextureCoordinates ON_Mesh::SetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.GetMappingBox(RMA.OpenNURBS.OnPlane@,RMA.OpenNURBS.OnInterval@,RMA.OpenNURBS.OnInterval@,RMA.OpenNURBS.OnInterval@)">
            <summary>Get a box projection from the texture mapping.</summary>
            <param name="plane">
[out] The center of the box is at plane.origin and the sides of the box
are parallel to the plane's coordinate planes.
</param>
            <param name="dx">
[out] The "front" and "back" sides of the box are in spanned by the
vectors plane.yaxis and plane.zaxis. The back plane contains the point plane.PointAt(dx[0],0,0)
and the front plane contains the point plane.PointAt(dx[1],0,0).
</param>
            <param name="dy">
[out] The "left" and "right" sides of the box are in spanned by the
vectors plane.zaxis and plane.xaxis. The left plane contains the point plane.PointAt(0,dx[0],0)
and the back plane contains the point plane.PointAt(0,dy[1],0).
</param>
            <param name="dz">
[out] The "top" and "bottom" sides of the box are in spanned by the
vectors plane.xaxis and plane.yaxis. The bottom plane contains the point plane.PointAt(0,0,dz[0])
and the top plane contains the point plane.PointAt(0,0,dz[1]).
</param>
            <returns>True if a valid box is returned.</returns>
            <remarks>
Generally, GetMappingBox will not return the same parameters passed to SetBoxMapping.
However, the location of the box will be the same.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.GetMappingSphere(RMA.OpenNURBS.OnSphere@)">
            <summary>Get a spherical projection parameters from this texture mapping.</summary>
            <param name="sphere">[out]</param>
            <returns>True if a valid sphere is returned.</returns>
            <remarks>
Generally, GetMappingShere will not return the same parameters passed to SetSphereMapping.
However, the location of the sphere will be the same. If this mapping is not cylindrical,
the cylinder will approximate the actual mapping primitive.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.GetMappingCylinder(RMA.OpenNURBS.OnCylinder@)">
            <summary>Get a cylindrical projection parameters from this texture mapping.</summary>
            <param name="cylinder">[out]</param>
            <returns>True if a valid cylinder is returned.</returns>
            <remarks>
Generally, GetMappingCylinder will not return the same parameters passed to SetCylinderMapping.
However, the location of the cylinder will be the same. If this mapping is not cylindrical,
the cylinder will approximate the actual mapping primitive.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.GetMappingPlane(RMA.OpenNURBS.OnPlane@,RMA.OpenNURBS.OnInterval@,RMA.OpenNURBS.OnInterval@,RMA.OpenNURBS.OnInterval@)">
            <summary>Get plane mapping parameters from this texture mapping.</summary>
            <param name="plane">[out]</param>
            <param name="dx">[out] Portion of the plane's x axis that is mapped to [0,1]</param>
            <param name="dy">[out] Portion of the plane's y axis that is mapped to [0,1]</param>
            <param name="dz">[out] Portion of the plane's z axis that is mapped to [0,1]</param>
            <returns>True if valid plane mapping parameters were returned.</returns>
            <remarks>
NOTE WELL:
Generally, GetMappingPlane will not return the same parameters passed to SetPlaneMapping.
However, the location of the plane will be the same.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.RequiresVertexNormals">
            <summary>
Determines whether the mapping, as currently set up, requires vertex normals to be present on the mesh in order to evaluate the mapping correctly.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTextureMapping.m_uvw">
            <value>
Transform applied to mapping coordinate (u,v,w) to 
convert it into a texture coordinate.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTextureMapping.m_Nxyz">
            <value>
For primitive based mappings, these transformations are
used to map the world coordinate (x,y,z) point P and 
surface normal N before it is projected to the normalized 
mapping primitive. The surface normal transformation,
m_Nxyz, is always calculated from m_Pxyz.  It is a 
runtime setting that is not saved in 3dm files. 
If m_type is srfp_mapping, then m_Pxyz and m_Nxyz are
ignored.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTextureMapping.m_Pxyz">
            <value>
For primitive based mappings, these transformations are
used to map the world coordinate (x,y,z) point P and 
surface normal N before it is projected to the normalized 
mapping primitive. The surface normal transformation,
m_Nxyz, is always calculated from m_Pxyz.  It is a 
runtime setting that is not saved in 3dm files. 
If m_type is srfp_mapping, then m_Pxyz and m_Nxyz are
ignored.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTextureMapping.m_bCapped">
            <value>
The m_bCapped applies to cylinder and box mappings.  If
m_bCapped is false, the cylinder or box is "infinite".
If m_bCapped is true, they are finite.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTextureMapping.m_mapping_name">
            <value>
The texture mapping name is for UI and user comfort. 
Duplicates are permitted.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTextureMapping.m_mapping_index">
            <value>
Runtime texture mapping table index. 
This value is NOT SAVED IN 3DM FILES.
This value is constant for each runtime instance of Rhino,
but can change each time a model is loaded or saved.  
Once a texture mapping is in the CRhinoDoc material table,
its id and index never change in that instance of Rhino.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTextureMapping.m_mapping_id">
            <value>
The only reliable and persistent way to reference texture 
mappings is by the mapping_id.  If the mapping id is
set to m_srfp_mapping_id, then all other mapping settings
are ignored.
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnTextureMapping.TEXTURE_SPACE">
            <summary>
When a mapping primitive is a box or a capped cylinder,
there are two options for the mapping.  Either the sides
all map to (0,1)x(0,1) (so the either texture map appears 
on each side, or the sides map to distinct regions of the
texture space.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnTextureMapping.PROJECTION">
            <summary>
When a mapping primitive, like a plane, sphere, box,
or cylinder, is used, there are two projection options.

clspt_projection: world xyz maps to the point on the 
                 mapping primitive that is closest to xyz.
                 In this case, ON_TextureMapping::Evaluate
                 ignores the vector argument.

ray_projection:   world xyz + world vector defines a world line.
                 The world line is intersected with the mapping 
                 primitive and the intersection point that is
                 closest to the world xyz point is used to
                 calculate the mapping parameters.

The value of m_projection can be changed as needed.

If m_type = srfp_mapping, then m_projection is ignored.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnTextureMapping.TYPE">
            <summary>
Mapping types:
 You can either calculate texture coordinates based on
 the parameterization of the surface used to create a mesh,
 or project the natural parameterization from a mapping
 primitive, like a plane, sphere, box, or cylinder.

Do not change TYPE enum values - they are saved in 3dm files.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.ChangeViewportId(System.Guid@)">
            <summary>
EXPERT USER function to change the viewport's id.
If you change the id, you risk damaging display and visibility
relationships in the model.
</summary>
            <param name="viewport_id">[in]</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.SetViewportId(System.Guid@)">
            <summary>
Sets the viewport's id to the value used to uniquely identify this viewport.
</summary>
            <param name="viewport_id">[in]</param>
            <returns>
True if the viewport's id was successfully set and false
otherwise (ie. the viewport uuid has already been set).
</returns>
            <remarks>
There is no approved way to change the viewport id once it is set in
order to maintain consistency across multiple viewports and those
routines that manage them.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.PerspectiveMinNearDist">
            <summary>
Expert user function to get the minimum value of near when perspective projections are begin used.
</summary>
            <returns>The minimum permitted value of near when perspective projections are begin used.</returns>
            <remarks>This is a runtime setting and is not saved in 3dm files.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.SetPerspectiveMinNearDist(System.Double)">
            <summary>
Expert user function to control the minimum value of near when
perspective projections are begin used.
</summary>
            <param name="min_near_dist">[in]</param>
            <remarks>This is a runtime setting and is not saved in 3dm files.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.PerspectiveMinNearOverFar">
            <summary>
Expert user function to get the minimum runtime value of near/far
when perspective projections are begin used.
</summary>
            <returns>The minimum permitted value of near/far when perspective projections are begin used.</returns>
            <remarks>This is a runtime setting and is not saved in 3dm files.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.SetPerspectiveMinNearOverFar(System.Double)">
            <summary>
Expert user function to control the minimum ratio of near/far
when perspective projections are begin used.
</summary>
            <param name="min_near_over_far">[in]</param>
            <remarks>This is a runtime setting and is not saved in 3dm files.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.ClipModXformIsIdentity">
            <summary>
Returns: True if clip mod xform is identity.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.ClipModInverseXform">
            <summary>Gets the m_clip_mod_inverse transformation</summary>
            <returns>value of the m_clip_mod_inverse transformation.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.ClipModXform">
            <summary>Gets the m_clip_mod transformation</summary>
            <returns>value of the m_clip_mod transformation.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.SetViewScale(System.Double,System.Double)">
            <summary>
Apply scaling factors to parallel projection clipping coordinates by
setting the m_clip_mod transformation.
</summary>
            <param name="x">[in] x &gt; 0</param>
            <param name="y">[in] y &gt; 0</param>
            <example>
If you want to compress the view projection across the viewing plane,
then set x = 0.5, y = 1.0, and z = 1.0.
</example>
            <returns>
True if successful.
False if input is invalid or the view is a perspective view.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.DollyFrustum(System.Double)">
            <summary>Moves frustum's clipping planes</summary>
            <param name="dolly_distance">distance to move in camera direction</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetDollyCameraVector(System.Int32,System.Int32,System.Int32,System.Int32,System.Double,RMA.OpenNURBS.On3dVector@)">
            <summary>Gets a world coordinate dolly vector that can be passed to DollyCamera().</summary>
            <param name="screen_x0">(x,y) screen coords of start point</param>
            <param name="screen_y0">(x,y) screen coords of start point</param>
            <param name="screen_x1">(x,y) screen coords of end point</param>
            <param name="screen_y1">(x,y) screen coords of end point</param>
            <param name="proj_plane_dist">
distance of projection plane from camera.
When in doubt, use 0.5*(frus_near+frus_far).
</param>
            <param name="dolly_vector">world coordinate dolly vector returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.DollyCamera(RMA.OpenNURBS.IOn3dVector)">
            <summary>
DollyCamera() does not update the frustum's clipping planes.
To update the frustum's clipping planes call DollyFrustum(d)
with d = dollyVector o cameraFrameZ.  To convert screen locations
into a dolly vector, use GetDollyCameraVector().
</summary>
            <param name="dolly_vector">dolly vector in world coordinates</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.ZoomToScreenRect(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
View changing from screen input points.  Handy for
using a mouse to manipulate a view.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.Extents(System.Double,RMA.OpenNURBS.IOn3dPoint,System.Double)">
            <summary>
Use Extents() as a quick way to set a viewport to so that bounding
volume is inside of a viewports frusmtrum.
The view angle is used to determine the position of the camera.
</summary>
            <param name="half_view_angle">
1/2 smallest subtended view angle
(0 &lt; angle &lt; pi/2)
</param>
            <param name="center">3d world coordinate bounding sphere center</param>
            <param name="radius">3d sphere radius</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.Extents(System.Double,RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Use Extents() as a quick way to set a viewport to so that bounding
volume is inside of a viewports frusmtrum.
The view angle is used to determine the position of the camera.
</summary>
            <param name="half_view_angle">
1/2 smallest subtended view angle
(0 &lt; angle &lt; pi/2)
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetWorldToScreenScale(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>display tools</summary>
            <param name="point_in_frustum">[in]  point in viewing frustum.</param>
            <param name="pixels_per_unit">[out] scale = number of pixels per world unit at the 3d point</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetFrustumLine(System.Double,System.Double,RMA.OpenNURBS.OnLine@)">
            <summary>
Get the world coordinate line in the view frustum that projects to a point on the screen.
</summary>
            <param name="screenx">[in] (screenx,screeny) = screen location</param>
            <param name="screeny">[in] (screenx,screeny) = screen location</param>
            <param name="world_line">
[out] 3d world coordinate line segment starting on the near clipping plane
and ending on the far clipping plane.
</param>
            <returns>true if successful. false if view projection or frustum is invalid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetXform(RMA.OpenNURBS.IOn.coordinate_system,RMA.OpenNURBS.IOn.coordinate_system,RMA.OpenNURBS.OnXform@)">
            <param name="matrix">4x4 transformation matrix (acts on the left)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.SetCamera35mmLenseLength(System.Double)">
            <summary>
These functions assume the camera is horizontal and crop the
film rather than the image when the aspect of the frustum
is not 36/24.  (35mm film is 36mm wide and 24mm high.)
The SetCamera35mmLenseLength() preserves camera location,
changes the frustum, but maintains the frsutrum's aspect.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetCamera35mmLenseLength(System.Double@)">
            <summary>
These functions assume the camera is horizontal and crop the
film rather than the image when the aspect of the frustum
is not 36/24.  (35mm film is 36mm wide and 24mm high.)
The SetCamera35mmLenseLength() preserves camera location,
changes the frustum, but maintains the frsutrum's aspect.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.SetCameraAngle(System.Double)">
            <param name="half_smallest_angle">
1/2 of smallest subtended view angle
0 &lt; angle &lt; pi/2
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetCameraAngle(System.Double@)">
            <param name="half_smallest_angle">1/2 of smallest subtended view angle</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetCameraAngle(System.Double@,System.Double@,System.Double@)">
            <param name="half_diagonal_angle">1/2 of diagonal subtended angle</param>
            <param name="half_vertical_angle">1/2 of vertical subtended angle</param>
            <param name="half_horizontal_angle">1/2 of horizontal subtended angle</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetScreenPortAspect(System.Double@)">
            <summary>
port's |width/height|
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.SetScreenPort(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
Location of viewport in pixels. These are provided so you can set the port you
are using and get the appropriate transformations to and from screen space.
</summary>
            <param name="port_left">[in]</param>
            <param name="port_right">[in] (port_left != port_right)</param>
            <param name="port_bottom">[in]</param>
            <param name="port_top">[in] (port_top != port_bottom)</param>
            <example>
For a Windows window
int width = width of window client area in pixels;
int height = height of window client area in pixels;
port_left = 0;
port_right = width;
port_top = 0;
port_bottom = height; 
port_near = 0;
port_far = 1;
SetScreenPort( port_left, port_right, port_bottom, port_top, port_near, port_far );
</example>
            <returns>
true if input is valid.
See Also: ON_Viewport::GetScreenPort
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.SetScreenPort(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
Location of viewport in pixels. These are provided so you can set the port you
are using and get the appropriate transformations to and from screen space.
</summary>
            <param name="port_left">[in]</param>
            <param name="port_right">[in] (port_left != port_right)</param>
            <param name="port_bottom">[in]</param>
            <param name="port_top">[in] (port_top != port_bottom)</param>
            <param name="port_near">[in]</param>
            <example>
For a Windows window
int width = width of window client area in pixels;
int height = height of window client area in pixels;
port_left = 0;
port_right = width;
port_top = 0;
port_bottom = height; 
port_near = 0;
port_far = 1;
SetScreenPort( port_left, port_right, port_bottom, port_top, port_near, port_far );
</example>
            <returns>
true if input is valid.
See Also: ON_Viewport::GetScreenPort
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.SetScreenPort(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
Location of viewport in pixels. These are provided so you can set the port you
are using and get the appropriate transformations to and from screen space.
</summary>
            <param name="port_left">[in]</param>
            <param name="port_right">[in] (port_left != port_right)</param>
            <param name="port_bottom">[in]</param>
            <param name="port_top">[in] (port_top != port_bottom)</param>
            <param name="port_near">[in]</param>
            <param name="port_far">[in]</param>
            <example>
For a Windows window
int width = width of window client area in pixels;
int height = height of window client area in pixels;
port_left = 0;
port_right = width;
port_top = 0;
port_bottom = height; 
port_near = 0;
port_far = 1;
SetScreenPort( port_left, port_right, port_bottom, port_top, port_near, port_far );
</example>
            <returns>
true if input is valid.
See Also: ON_Viewport::GetScreenPort
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetFarRect(RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@)">
            <summary>Get corners of far clipping plane rectangle.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetNearRect(RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@)">
            <summary>Get corners of near clipping plane rectangle.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetFrustumTopPlane(RMA.OpenNURBS.OnPlane@)">
            <summary>Get top world frustum clipping plane.</summary>
            <param name="top_plane">
[out] frustum top side clipping plane. The normal points into the visible region
of the frustum. If the projection is perspective, the origin is at the camera location,
otherwise the origin isthe point on the plane that is closest to the camera location.
</param>
            <returns>True if camera and frustum are valid and plane was set.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetFrustumBottomPlane(RMA.OpenNURBS.OnPlane@)">
            <summary>Get bottom world frustum clipping plane.</summary>
            <param name="bottom_plane">
[out] frustum bottom side clipping plane. The normal points into the visible
region of the frustum. If the projection is perspective, the origin is at the
camera location, otherwise the origin isthe point on the plane that is closest
to the camera location.
</param>
            <returns>True if camera and frustum are valid and plane was set.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetFrustumRightPlane(RMA.OpenNURBS.OnPlane@)">
            <summary>Get right world frustum clipping plane.</summary>
            <param name="right_plane">
[out] frustum right side clipping plane. The normal points out of the visible 
region of the frustum. If the projection is perspective, the origin is at the
camera location, otherwise the origin isthe point on the plane that is closest
to the camera location.
</param>
            <returns>True if camera and frustum are valid and plane was set.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetFrustumLeftPlane(RMA.OpenNURBS.OnPlane@)">
            <summary>Get left world frustum clipping plane.</summary>
            <param name="left_plane">
[out] frustum left side clipping plane. The normal points into the visible
region of the frustum. If the projection is perspective, the origin is at
the camera location, otherwise the origin isthe point on the plane that is
closest to the camera location.
</param>
            <returns>True if camera and frustum are valid and plane was set.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetFarPlane(RMA.OpenNURBS.OnPlane@)">
            <summary>Get far clipping plane.</summary>
            <param name="far_plane">
[out] far clipping plane if camera and frustum are valid. The plane's frame
is the same as the camera's frame.  The origin is located at the intersection
of the camera direction ray and the far clipping plane.
</param>
            <returns>TRUE if camera and frustum are valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetNearPlane(RMA.OpenNURBS.OnPlane@)">
            <summary>Get near clipping plane.</summary>
            <param name="near_plane">
[out] near clipping plane if camera and frustum are valid. The plane's frame
is the same as the camera's frame.  The origin is located at the intersection
of the camera direction ray and the near clipping plane.
</param>
            <returns>TRUE if camera and frustum are valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.SetFrustumNearFar(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Set near and far clipping distance subject to constraints.</summary>
            <param name="near_dist">[in] (&gt;0) desired near clipping distance</param>
            <param name="far_dist">[in] (&gt;near_dist) desired near clipping distance</param>
            <param name="min_near_dist">
[in] If min_near_dist &lt;= 0.0, it is ignored.
If min_near_dist &gt; 0 and near_dist &lt; min_near_dist, then the frustum's near_dist
will be increased to min_near_dist.
</param>
            <param name="min_near_over_far">
[in] If min_near_over_far &lt;= 0.0, it is ignored.
If near_dist &lt; far_dist*min_near_over_far, then near_dist is increased and/or far_dist
is decreased so that near_dist = far_dist*min_near_over_far.
If near_dist &lt; target_dist &lt; far_dist, then near_dist near_dist is increased and
far_dist is decreased so that projection precision will be good at target_dist.
Otherwise, near_dist is simply set to far_dist*min_near_over_far.
</param>
            <param name="target_dist">
[in] If target_dist &lt;= 0.0, it is ignored.
If target_dist &gt; 0, it is used as described in the description of the min_near_over_far parameter.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetSphereDepth(RMA.OpenNURBS.IOnSphere,System.Double@,System.Double@)">
            <summary>Get near and far clipping distances of a bounding sphere.</summary>
            <param name="sphere">[in] bounding sphere</param>
            <param name="near_dist">[out] near distance of the sphere (can be &lt; 0)</param>
            <param name="far_dist">[out] far distance of the sphere (can be equal to near_dist)</param>
            <returns>
True if the sphere intersects the view frustum and near_dist/far_dist were set.
False if the sphere does not intesect the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetSphereDepth(RMA.OpenNURBS.IOnSphere,System.Double@,System.Double@,System.Boolean)">
            <summary>Get near and far clipping distances of a bounding sphere.</summary>
            <param name="sphere">[in] bounding sphere</param>
            <param name="near_dist">[out] near distance of the sphere (can be &lt; 0)</param>
            <param name="far_dist">[out] far distance of the sphere (can be equal to near_dist)</param>
            <param name="bGrowNearFar">
[in] If true and input values of near_dist and far_dist are not ON_UNSET_VALUE,
the near_dist and far_dist are enlarged to include bbox.
</param>
            <returns>
True if the sphere intersects the view frustum and near_dist/far_dist were set.
False if the sphere does not intesect the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetBoundingBoxDepth(RMA.OpenNURBS.IOnBoundingBox,System.Double@,System.Double@)">
            <summary>Get near and far clipping distances of a bounding box</summary>
            <param name="bbox">[in] bounding box</param>
            <param name="near_dist">[out] near distance of the box (can be &lt; 0)</param>
            <param name="far_dist">[out] far distance of the box (can be equal to near_dist)</param>
            <returns>
True if the bounding box intersects the view frustum and near_dist/far_dist were set.
False if the bounding box does not intesect the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetBoundingBoxDepth(RMA.OpenNURBS.IOnBoundingBox,System.Double@,System.Double@,System.Boolean)">
            <summary>Get near and far clipping distances of a bounding box</summary>
            <param name="bbox">[in] bounding box</param>
            <param name="near_dist">[out] near distance of the box (can be &lt; 0)</param>
            <param name="far_dist">[out] far distance of the box (can be equal to near_dist)</param>
            <param name="bGrowNearFar">
[in] If true and input values of near_dist and far_dist are not ON_UNSET_VALUE,
the near_dist and far_dist are enlarged to include bbox.
</param>
            <returns>
True if the bounding box intersects the view frustum and near_dist/far_dist were set.
False if the bounding box does not intesect the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetPointDepth(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@)">
            <summary>Get near and far clipping distances of a point</summary>
            <param name="point">[in]</param>
            <param name="near_dist">[out] near distance of the point (can be &lt; 0)</param>
            <param name="far_dist">[out] far distance of the point (can be equal to near_dist)</param>
            <returns>
True if the point is ing the view frustum and near_dist/far_dist were set.
False if the bounding box does not intesect the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetPointDepth(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@,System.Boolean)">
            <summary>Get near and far clipping distances of a point</summary>
            <param name="point">[in]</param>
            <param name="near_dist">[out] near distance of the point (can be &lt; 0)</param>
            <param name="far_dist">[out] far distance of the point (can be equal to near_dist)</param>
            <param name="bGrowNearFar">
[in] If true and input values of near_dist and far_dist are not ON_UNSET_VALUE,
the near_dist and far_dist are enlarged to include bbox.
</param>
            <returns>
True if the point is ing the view frustum and near_dist/far_dist were set.
False if the bounding box does not intesect the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.SetFrustumNearFar(System.Double,System.Double)">
            <param name="near_dist">&gt;0</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.SetFrustumNearFar(RMA.OpenNURBS.IOn3dPoint,System.Double)">
            <param name="center">3d bounding sphere center</param>
            <param name="radius">3d bounding sphere radius</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.FrustumLeft">
            <summary>
The near clipping plane stored in the Rhino 1.0 file is frequently very
small and useless for high quality z-buffer based rendering.  The far
clipping value is not stored in the file.  Use these functions to set
the frustum's near and far clipping planes to appropriate values.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetFrustumCenter(RMA.OpenNURBS.On3dPoint@)">
            <summary>
Returns world coordinates of frustum's center
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetFrustumAspect(System.Double@)">
            <summary>
Returns frustum's width/height
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.SetFrustumAspect(System.Double)">
            <summary>
SetFrustumAspect() changes the larger of the frustum's widht/height
so that the resulting value of width/height matches the requested
aspect.  The camera angle is not changed.  If you change the shape
of the view port with a call SetScreenPort(), then you generally 
want to call SetFrustumAspect() with the value returned by 
GetScreenPortAspect().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.SetFrustum(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
Rhino version 1.0 does not support skew frustums; i.e., the
viewing frustums used in Rhino have left = -right, bottom = -top.
If you specify a skew frustum, all the ON_Viewport functions
will work fine.  If you save it a file and read the file into Rhino 1.0,
then you will get a symmetric approximation.
</summary>
            <param name="right">left &lt; right</param>
            <param name="top">bottom &lt; top</param>
            <param name="far_dist">( 0 &lt; near_dist &lt; far_dist )</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetCameraExtents(RMA.OpenNURBS.On3dPoint@,System.Double,RMA.OpenNURBS.OnBoundingBox@)">
            <summary>
returns bounding box in camera coordinates - this is useful information
for setting view frustrums to include the point list
</summary>
            <param name="center">world coordinate bounding sphere center</param>
            <param name="radius">world coordinate bounding sphere radius</param>
            <param name="cambox">bounding box in camera coordinates</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetCameraExtents(RMA.OpenNURBS.On3dPoint@,System.Double,RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>
returns bounding box in camera coordinates - this is useful information
for setting view frustrums to include the point list
</summary>
            <param name="center">world coordinate bounding sphere center</param>
            <param name="radius">world coordinate bounding sphere radius</param>
            <param name="cambox">bounding box in camera coordinates</param>
            <param name="bGrowBox">set to TRUE if you want to enlarge an existing camera coordinate box</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetCameraExtents(RMA.OpenNURBS.IOnBoundingBox,RMA.OpenNURBS.OnBoundingBox@)">
            <summary>
returns bounding box in camera coordinates - this is useful information
for setting view frustrums to include the point list
</summary>
            <param name="worldbbox">world coordinate bounding box</param>
            <param name="cambbox">bounding box in camera coordinates</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetCameraExtents(RMA.OpenNURBS.IOnBoundingBox,RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>
returns bounding box in camera coordinates - this is useful information
for setting view frustrums to include the point list
</summary>
            <param name="worldbbox">world coordinate bounding box</param>
            <param name="cambbox">bounding box in camera coordinates</param>
            <param name="bGrowBox">set to TRUE if you want to enlarge an existing camera coordinate box</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.IsCameraFrameWorldPlan(System.Int32@,System.Int32@,System.Int32@)">
            <summary>
Returns true if the camera direction = some world axis.
The indices report which axes are used.  For a "twisted"
plan view it is possible to have zero x and y indices.
This function returns true if and only if the "z" index
is non-zero.

Indices are +/-1 = world +/-x, +/-2 = world +/-y, +/-3 = world +/-z,
</summary>
            <param name="arg1">if true and plan is axis aligned, view x index, else 0</param>
            <param name="arg2">if true and plan is axis aligned, view y index, else 0</param>
            <param name="arg3">if true, view z index, else 0</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.CameraZ">
            <summary>
unit vector in -CameraDirection
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.CameraY">
            <summary>
unit up vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.CameraX">
            <summary>
unit to right vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetCameraFrame(RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>returns TRUE if current camera orientation is valid</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.SetCameraUp(RMA.OpenNURBS.IOn3dVector)">
            <summary>
These return TRUE if the current direction and up are not zero and not
parallel so the camera position is well defined.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.SetCameraDirection(RMA.OpenNURBS.IOn3dVector)">
            <summary>
These return TRUE if the current direction and up are not zero and not
parallel so the camera position is well defined.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.SetCameraLocation(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
These return TRUE if the current direction and up are not zero and not
parallel so the camera position is well defined.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.Initialize">
            <summary>
Interface /////////////////////////////////////////////////////////////////
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.#ctor">
            <summary>
Construction
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnViewport">
            <summary>This object represents a viewing frustum</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.PerspectiveMinNearDist">
            <summary>
Expert user function to get the minimum value of near when perspective projections are begin used.
</summary>
            <returns>The minimum permitted value of near when perspective projections are begin used.</returns>
            <remarks>This is a runtime setting and is not saved in 3dm files.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.PerspectiveMinNearOverFar">
            <summary>
Expert user function to get the minimum runtime value of near/far
when perspective projections are begin used.
</summary>
            <returns>The minimum permitted value of near/far when perspective projections are begin used.</returns>
            <remarks>This is a runtime setting and is not saved in 3dm files.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.ClipModXformIsIdentity">
            <summary>
Returns: True if clip mod xform is identity.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.ClipModInverseXform">
            <summary>Gets the m_clip_mod_inverse transformation</summary>
            <returns>value of the m_clip_mod_inverse transformation.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.ClipModXform">
            <summary>Gets the m_clip_mod transformation</summary>
            <returns>value of the m_clip_mod transformation.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetDollyCameraVector(System.Int32,System.Int32,System.Int32,System.Int32,System.Double,RMA.OpenNURBS.On3dVector@)">
            <summary>Gets a world coordinate dolly vector that can be passed to DollyCamera().</summary>
            <param name="screen_x0">(x,y) screen coords of start point</param>
            <param name="screen_y0">(x,y) screen coords of start point</param>
            <param name="screen_x1">(x,y) screen coords of end point</param>
            <param name="screen_y1">(x,y) screen coords of end point</param>
            <param name="proj_plane_dist">
distance of projection plane from camera.
When in doubt, use 0.5*(frus_near+frus_far).
</param>
            <param name="dolly_vector">world coordinate dolly vector returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetWorldToScreenScale(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>display tools</summary>
            <param name="point_in_frustum">[in]  point in viewing frustum.</param>
            <param name="pixels_per_unit">[out] scale = number of pixels per world unit at the 3d point</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetFrustumLine(System.Double,System.Double,RMA.OpenNURBS.OnLine@)">
            <summary>
Get the world coordinate line in the view frustum that projects to a point on the screen.
</summary>
            <param name="screenx">[in] (screenx,screeny) = screen location</param>
            <param name="screeny">[in] (screenx,screeny) = screen location</param>
            <param name="world_line">
[out] 3d world coordinate line segment starting on the near clipping plane
and ending on the far clipping plane.
</param>
            <returns>true if successful. false if view projection or frustum is invalid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetXform(RMA.OpenNURBS.IOn.coordinate_system,RMA.OpenNURBS.IOn.coordinate_system,RMA.OpenNURBS.OnXform@)">
            <param name="matrix">4x4 transformation matrix (acts on the left)</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetCamera35mmLenseLength(System.Double@)">
            <summary>
These functions assume the camera is horizontal and crop the
film rather than the image when the aspect of the frustum
is not 36/24.  (35mm film is 36mm wide and 24mm high.)
The SetCamera35mmLenseLength() preserves camera location,
changes the frustum, but maintains the frsutrum's aspect.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetCameraAngle(System.Double@)">
            <param name="half_smallest_angle"> 1/2 of smallest subtended view angle</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetCameraAngle(System.Double@,System.Double@,System.Double@)">
            <param name="half_diagonal_angle">1/2 of diagonal subtended angle</param>
            <param name="half_vertical_angle">1/2 of vertical subtended angle</param>
            <param name="half_horizontal_angle">1/2 of horizontal subtended angle</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetScreenPortAspect(System.Double@)">
            <summary>
port's |width/height|
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetFarRect(RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@)">
            <summary>Get corners of far clipping plane rectangle.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetNearRect(RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@)">
            <summary>Get corners of near clipping plane rectangle.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetFrustumTopPlane(RMA.OpenNURBS.OnPlane@)">
            <summary>Get top world frustum clipping plane.</summary>
            <param name="top_plane">
[out] frustum top side clipping plane. The normal points into the visible region
of the frustum. If the projection is perspective, the origin is at the camera location,
otherwise the origin isthe point on the plane that is closest to the camera location.
</param>
            <returns>True if camera and frustum are valid and plane was set.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetFrustumBottomPlane(RMA.OpenNURBS.OnPlane@)">
            <summary>Get bottom world frustum clipping plane.</summary>
            <param name="bottom_plane">
[out] frustum bottom side clipping plane. The normal points into the visible
region of the frustum. If the projection is perspective, the origin is at the
camera location, otherwise the origin isthe point on the plane that is closest
to the camera location.
</param>
            <returns>True if camera and frustum are valid and plane was set.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetFrustumRightPlane(RMA.OpenNURBS.OnPlane@)">
            <summary>Get right world frustum clipping plane.</summary>
            <param name="right_plane">
[out] frustum right side clipping plane. The normal points out of the visible 
region of the frustum. If the projection is perspective, the origin is at the
camera location, otherwise the origin isthe point on the plane that is closest
to the camera location.
</param>
            <returns>True if camera and frustum are valid and plane was set.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetFrustumLeftPlane(RMA.OpenNURBS.OnPlane@)">
            <summary>Get left world frustum clipping plane.</summary>
            <param name="left_plane">
[out] frustum left side clipping plane. The normal points into the visible
region of the frustum. If the projection is perspective, the origin is at
the camera location, otherwise the origin isthe point on the plane that is
closest to the camera location.
</param>
            <returns>True if camera and frustum are valid and plane was set.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetFarPlane(RMA.OpenNURBS.OnPlane@)">
            <summary>Get far clipping plane.</summary>
            <param name="far_plane">
[out] far clipping plane if camera and frustum are valid. The plane's frame
is the same as the camera's frame.  The origin is located at the intersection
of the camera direction ray and the far clipping plane.
</param>
            <returns>TRUE if camera and frustum are valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetNearPlane(RMA.OpenNURBS.OnPlane@)">
            <summary>Get near clipping plane.</summary>
            <param name="near_plane">
[out] near clipping plane if camera and frustum are valid. The plane's frame
is the same as the camera's frame.  The origin is located at the intersection
of the camera direction ray and the near clipping plane.
</param>
            <returns>TRUE if camera and frustum are valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetSphereDepth(RMA.OpenNURBS.IOnSphere,System.Double@,System.Double@)">
            <summary>Get near and far clipping distances of a bounding sphere.</summary>
            <param name="sphere">[in] bounding sphere</param>
            <param name="near_dist">[out] near distance of the sphere (can be &lt; 0)</param>
            <param name="far_dist">[out] far distance of the sphere (can be equal to near_dist)</param>
            <returns>
True if the sphere intersects the view frustum and near_dist/far_dist were set.
False if the sphere does not intesect the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetSphereDepth(RMA.OpenNURBS.IOnSphere,System.Double@,System.Double@,System.Boolean)">
            <summary>Get near and far clipping distances of a bounding sphere.</summary>
            <param name="sphere">[in] bounding sphere</param>
            <param name="near_dist">[out] near distance of the sphere (can be &lt; 0)</param>
            <param name="far_dist">[out] far distance of the sphere (can be equal to near_dist)</param>
            <param name="bGrowNearFar">
[in] If true and input values of near_dist and far_dist are not ON_UNSET_VALUE,
the near_dist and far_dist are enlarged to include bbox.
</param>
            <returns>
True if the sphere intersects the view frustum and near_dist/far_dist were set.
False if the sphere does not intesect the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetBoundingBoxDepth(RMA.OpenNURBS.IOnBoundingBox,System.Double@,System.Double@)">
            <summary>Get near and far clipping distances of a bounding box</summary>
            <param name="bbox">[in] bounding box</param>
            <param name="near_dist">[out] near distance of the box (can be &lt; 0)</param>
            <param name="far_dist">[out] far distance of the box (can be equal to near_dist)</param>
            <returns>
True if the bounding box intersects the view frustum and near_dist/far_dist were set.
False if the bounding box does not intesect the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetBoundingBoxDepth(RMA.OpenNURBS.IOnBoundingBox,System.Double@,System.Double@,System.Boolean)">
            <summary>Get near and far clipping distances of a bounding box</summary>
            <param name="bbox">[in] bounding box</param>
            <param name="near_dist">[out] near distance of the box (can be &lt; 0)</param>
            <param name="far_dist">[out] far distance of the box (can be equal to near_dist)</param>
            <param name="bGrowNearFar">
[in] If true and input values of near_dist and far_dist are not ON_UNSET_VALUE,
the near_dist and far_dist are enlarged to include bbox.
</param>
            <returns>
True if the bounding box intersects the view frustum and near_dist/far_dist were set.
False if the bounding box does not intesect the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetPointDepth(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@)">
            <summary>Get near and far clipping distances of a point</summary>
            <param name="point">[in]</param>
            <param name="near_dist">[out] near distance of the point (can be &lt; 0)</param>
            <param name="far_dist">[out] far distance of the point (can be equal to near_dist)</param>
            <returns>
True if the point is ing the view frustum and near_dist/far_dist were set.
False if the bounding box does not intesect the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetPointDepth(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@,System.Boolean)">
            <summary>Get near and far clipping distances of a point</summary>
            <param name="point">[in]</param>
            <param name="near_dist">[out] near distance of the point (can be &lt; 0)</param>
            <param name="far_dist">[out] far distance of the point (can be equal to near_dist)</param>
            <param name="bGrowNearFar">
[in] If true and input values of near_dist and far_dist are not ON_UNSET_VALUE,
the near_dist and far_dist are enlarged to include bbox.
</param>
            <returns>
True if the point is ing the view frustum and near_dist/far_dist were set.
False if the bounding box does not intesect the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.FrustumLeft">
            <summary>
The near clipping plane stored in the Rhino 1.0 file is frequently very
small and useless for high quality z-buffer based rendering.  The far
clipping value is not stored in the file.  Use these functions to set
the frustum's near and far clipping planes to appropriate values.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetFrustumCenter(RMA.OpenNURBS.On3dPoint@)">
            <summary>
Returns world coordinates of frustum's center
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetFrustumAspect(System.Double@)">
            <summary>
Returns frustum's width/height
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetCameraExtents(RMA.OpenNURBS.On3dPoint@,System.Double,RMA.OpenNURBS.OnBoundingBox@)">
            <summary>
returns bounding box in camera coordinates - this is useful information
for setting view frustrums to include the point list
</summary>
            <param name="center">world coordinate bounding sphere center</param>
            <param name="radius">world coordinate bounding sphere radius</param>
            <param name="cambox">bounding box in camera coordinates</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetCameraExtents(RMA.OpenNURBS.On3dPoint@,System.Double,RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>
returns bounding box in camera coordinates - this is useful information
for setting view frustrums to include the point list
</summary>
            <param name="center">world coordinate bounding sphere center</param>
            <param name="radius">world coordinate bounding sphere radius</param>
            <param name="cambox">bounding box in camera coordinates</param>
            <param name="bGrowBox">set to TRUE if you want to enlarge an existing camera coordinate box</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetCameraExtents(RMA.OpenNURBS.IOnBoundingBox,RMA.OpenNURBS.OnBoundingBox@)">
            <summary>
returns bounding box in camera coordinates - this is useful information
for setting view frustrums to include the point list
</summary>
            <param name="worldbbox">world coordinate bounding box</param>
            <param name="cambbox">bounding box in camera coordinates</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetCameraExtents(RMA.OpenNURBS.IOnBoundingBox,RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>
returns bounding box in camera coordinates - this is useful information
for setting view frustrums to include the point list
</summary>
            <param name="worldbbox">world coordinate bounding box</param>
            <param name="cambbox">bounding box in camera coordinates</param>
            <param name="bGrowBox">set to TRUE if you want to enlarge an existing camera coordinate box</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.CameraZ">
            <summary>
unit vector in -CameraDirection
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.CameraY">
            <summary>
unit up vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.CameraX">
            <summary>
unit to right vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetCameraFrame(RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>returns TRUE if current camera orientation is valid</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnViewport">
            <summary>This object represents a viewing frustum</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurfaceArray.Append(RMA.OpenNURBS.IOnSurface)">
            <summary>
Adds a copy of a surface to this list. DuplicateSurface is called on the input and the duplicate
is saved in the SurfaceArray
</summary>
            <param name="surface">the surface to copy and add to the array</param>
            <returns>the duplicated surface that has been added to the array</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@)">
            <summary>Calculate volume mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean)">
            <summary>Calculate volume mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Calculate volume mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <param name="base_point">
[in] If the surface is closed, then pass ON_UNSET_VALUE. This parameter is for expert users
who are computing a volume whose boundary is defined by several non-closed breps, surfaces,
and meshes. When computing the volume, volume centroid, or volume first moments of a volume
whose boundary is defined by several breps, surfaces, and meshes, pass the same base_point
to each call to VolumeMassProperties. When computing the volume second moments or volume
product moments of a volume whose boundary is defined by several breps, surfaces, and meshes,
you MUST pass the entire volume's centroid as the base_point and the input mp parameter
must contain the results of a previous call to VolumeMassProperties(mp,true,true,false,false,base_point).
In particular, in this case, you need to make two sets of calls; use first set to calculate
the volume centroid and the second set calculate the second moments and product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RMA.OpenNURBS.IOn3dPoint,System.Double)">
            <summary>Calculate volume mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <param name="base_point">
[in] If the surface is closed, then pass ON_UNSET_VALUE. This parameter is for expert users
who are computing a volume whose boundary is defined by several non-closed breps, surfaces,
and meshes. When computing the volume, volume centroid, or volume first moments of a volume
whose boundary is defined by several breps, surfaces, and meshes, pass the same base_point
to each call to VolumeMassProperties. When computing the volume second moments or volume
product moments of a volume whose boundary is defined by several breps, surfaces, and meshes,
you MUST pass the entire volume's centroid as the base_point and the input mp parameter
must contain the results of a previous call to VolumeMassProperties(mp,true,true,false,false,base_point).
In particular, in this case, you need to make two sets of calls; use first set to calculate
the volume centroid and the second set calculate the second moments and product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double)">
            <summary>Calculate volume mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <param name="base_point">
[in] If the surface is closed, then pass ON_UNSET_VALUE. This parameter is for expert users
who are computing a volume whose boundary is defined by several non-closed breps, surfaces,
and meshes. When computing the volume, volume centroid, or volume first moments of a volume
whose boundary is defined by several breps, surfaces, and meshes, pass the same base_point
to each call to VolumeMassProperties. When computing the volume second moments or volume
product moments of a volume whose boundary is defined by several breps, surfaces, and meshes,
you MUST pass the entire volume's centroid as the base_point and the input mp parameter
must contain the results of a previous call to VolumeMassProperties(mp,true,true,false,false,base_point).
In particular, in this case, you need to make two sets of calls; use first set to calculate
the volume centroid and the second set calculate the second moments and product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@)">
            <summary>Calculate area mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean)">
            <summary>Calculate area mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <param name="bProductMoments">[in] true to calculate area product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double)">
            <summary>Calculate area mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <param name="bProductMoments">[in] true to calculate area product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double,System.Double)">
            <summary>Calculate area mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <param name="bProductMoments">[in] true to calculate area product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.DestroySurfaceTree">
            <summary>
If the geometry surface is modified in any way, then
call DestroySurfaceTree().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.NurbsSurface">
            <summary>Get a NURBS surface representation of this surface.</summary>
            <returns>NULL or a NURBS representation of the surface.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Surface::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.NurbsSurface(RMA.OpenNURBS.OnNurbsSurface)">
            <summary>Get a NURBS surface representation of this surface.</summary>
            <param name="pNurbsSurface">
[in/out] if not NULL, this pNurbsSurface will be used to store the NURBS representation of the surface and will be returned.
</param>
            <returns>NULL or a NURBS representation of the surface.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Surface::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.NurbsSurface(RMA.OpenNURBS.OnNurbsSurface,System.Double)">
            <summary>Get a NURBS surface representation of this surface.</summary>
            <param name="pNurbsSurface">
[in/out] if not NULL, this pNurbsSurface will be used to store the NURBS representation of the surface and will be returned.
</param>
            <param name="tolerance">[in] tolerance to use when creating NURBS surface representation.</param>
            <returns>NULL or a NURBS representation of the surface.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Surface::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.NurbsSurface(RMA.OpenNURBS.OnNurbsSurface,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a NURBS surface representation of this surface.</summary>
            <param name="pNurbsSurface">
[in/out] if not NULL, this pNurbsSurface will be used to store the NURBS representation of the surface and will be returned.
</param>
            <param name="tolerance">[in] tolerance to use when creating NURBS surface representation.</param>
            <param name="s_subdomain">
[in] if not NULL, then the NURBS representation for this portion of the surface is returned.
</param>
            <returns>NULL or a NURBS representation of the surface.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Surface::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.NurbsSurface(RMA.OpenNURBS.OnNurbsSurface,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a NURBS surface representation of this surface.</summary>
            <param name="pNurbsSurface">
[in/out] if not NULL, this pNurbsSurface will be used to store the NURBS representation of the surface and will be returned.
</param>
            <param name="tolerance">[in] tolerance to use when creating NURBS surface representation.</param>
            <param name="s_subdomain">
[in] if not NULL, then the NURBS representation for this portion of the surface is returned.
</param>
            <param name="t_subdomain">
[in] if not NULL, then the NURBS representation for this portion of the surface is returned.
</param>
            <returns>NULL or a NURBS representation of the surface.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Surface::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.HasNurbForm">
            <summary>Is there a NURBS surface representation of this surface.</summary>
            <returns>
0 unable to create NURBS representation with desired accuracy.
1 success - NURBS parameterization matches the surface's
2 success - NURBS point locus matches the surface's and
           the domain of the NURBS surface is correct. However,
           This surface's parameterization and the NURBS
           surface parameterization may not match. This situation
           happens when getting NURBS representations of surfaces
           that have a transendental parameterization like spheres,
           cylinders, and cones.
</returns>
            <remarks>
This is a low-level virtual function.
See Also: ON_Surface::GetNurbForm ON_Surface::NurbsSurface
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetNurbForm(RMA.OpenNURBS.OnNurbsSurface@)">
            <summary>Get a NURBS surface representation of this surface.</summary>
            <param name="nurbs_surface">[out] NURBS representation returned here</param>
            <returns>
0 unable to create NURBS representation with desired accuracy.
1 success - returned NURBS parameterization matches the surface's to wthe desired accuracy
2 success - returned NURBS point locus matches the surface's to the desired accuracy and the
           domain of the NURBS surface is correct. On However, This surface's parameterization
           and the NURBS surface parameterization may not match to the desired accuracy. This
           situation happens when getting NURBS representations of surfaces that have a
           transendental parameterization like spheres, cylinders, and cones.
</returns>
            <remarks>
This is a low-level virtual function. If you do not need the parameterization information
provided by the return code, then ON_Surface::NurbsSurface may be easier to use.
See Also: ON_Surface::NurbsSurface
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetNurbForm(RMA.OpenNURBS.OnNurbsSurface@,System.Double)">
            <summary>Get a NURBS surface representation of this surface.</summary>
            <param name="nurbs_surface">[out] NURBS representation returned here</param>
            <param name="tolerance">[in] tolerance to use when creating NURBS representation.</param>
            <returns>
0 unable to create NURBS representation with desired accuracy.
1 success - returned NURBS parameterization matches the surface's to wthe desired accuracy
2 success - returned NURBS point locus matches the surface's to the desired accuracy and the
           domain of the NURBS surface is correct. On However, This surface's parameterization
           and the NURBS surface parameterization may not match to the desired accuracy. This
           situation happens when getting NURBS representations of surfaces that have a
           transendental parameterization like spheres, cylinders, and cones.
</returns>
            <remarks>
This is a low-level virtual function. If you do not need the parameterization information
provided by the return code, then ON_Surface::NurbsSurface may be easier to use.
See Also: ON_Surface::NurbsSurface
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Offset(System.Double,System.Double)">
            <summary>Offset surface.</summary>
            <param name="offset_distance">[in] offset distance</param>
            <param name="tolerance">
[in] Some surfaces do not have an exact offset that can be represented using
the same class of surface definition. In that case, the tolerance specifies
the desired accuracy.
</param>
            <returns>Offset surface.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Offset(System.Double,System.Double,System.Double@)">
            <summary>Offset surface.</summary>
            <param name="offset_distance">[in] offset distance</param>
            <param name="tolerance">
[in] Some surfaces do not have an exact offset that can be represented using
the same class of surface definition. In that case, the tolerance specifies
the desired accuracy.
</param>
            <param name="max_deviation">
[out] If this parameter is not NULL, the maximum deviation from the returned offset
to the TRUE offset is returned here. This deviation is zero except for cases where
an exact offset cannot be computed using the same class of surface definition.
</param>
            <returns>Offset surface.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double,System.Double@,System.Double@)">
            <summary>
Find parameters of the point on a surface that is locally closest to 
the test_point.  The search for a local close point starts at 
seed parameters. If a sub_domain parameter is not NULL, then
the search is restricted to the specified portion of the surface.
</summary>
            <returns>
TRUE if returned if the search is successful.  FALSE is returned if
the search fails.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval)">
            <summary>
Find parameters of the point on a surface that is locally closest to 
the test_point.  The search for a local close point starts at 
seed parameters. If a sub_domain parameter is not NULL, then
the search is restricted to the specified portion of the surface.
</summary>
            <returns>
TRUE if returned if the search is successful.  FALSE is returned if
the search fails.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>
Find parameters of the point on a surface that is locally closest to 
the test_point.  The search for a local close point starts at 
seed parameters. If a sub_domain parameter is not NULL, then
the search is restricted to the specified portion of the surface.
</summary>
            <returns>
TRUE if returned if the search is successful.  FALSE is returned if
the search fails.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@)">
            <summary>Get the parameters of the point on the surface that is closest to P.</summary>
            <param name="P">[in] test point</param>
            <param name="s">[out] (*s,*t) = parameters of the surface point that is closest to P.</param>
            <param name="t">[out] (*s,*t) = parameters of the surface point that is closest to P.</param>
            <returns>
True if successful. If false, the values of *s and *t are undefined.
See Also: ON_Surface::GetLocalClosestPoint.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@,System.Double)">
            <summary>Get the parameters of the point on the surface that is closest to P.</summary>
            <param name="P">[in] test point</param>
            <param name="s">[out] (*s,*t) = parameters of the surface point that is closest to P.</param>
            <param name="t">[out] (*s,*t) = parameters of the surface point that is closest to P.</param>
            <param name="maximum_distance">
[in] optional upper bound on the distance from P to the surface. If you are
only interested in finding a point Q on the surface when P.DistanceTo(Q) &lt; maximum_distance,
then set maximum_distance to that value.
</param>
            <returns>
True if successful. If false, the values of *s and *t are undefined.
See Also: ON_Surface::GetLocalClosestPoint.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Get the parameters of the point on the surface that is closest to P.</summary>
            <param name="P">[in] test point</param>
            <param name="s">[out] (*s,*t) = parameters of the surface point that is closest to P.</param>
            <param name="t">[out] (*s,*t) = parameters of the surface point that is closest to P.</param>
            <param name="maximum_distance">
[in] optional upper bound on the distance from P to the surface. If you are
only interested in finding a point Q on the surface when P.DistanceTo(Q) &lt; maximum_distance,
then set maximum_distance to that value.
</param>
            <param name="sdomain">[in] optional domain restriction</param>
            <returns>
True if successful. If false, the values of *s and *t are undefined.
See Also: ON_Surface::GetLocalClosestPoint.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Get the parameters of the point on the surface that is closest to P.</summary>
            <param name="P">[in] test point</param>
            <param name="s">[out] (*s,*t) = parameters of the surface point that is closest to P.</param>
            <param name="t">[out] (*s,*t) = parameters of the surface point that is closest to P.</param>
            <param name="maximum_distance">
[in] optional upper bound on the distance from P to the surface. If you are
only interested in finding a point Q on the surface when P.DistanceTo(Q) &lt; maximum_distance,
then set maximum_distance to that value.
</param>
            <param name="sdomain">[in] optional domain restriction</param>
            <param name="tdomain">[in] optional domain restriction</param>
            <returns>
True if successful. If false, the values of *s and *t are undefined.
See Also: ON_Surface::GetLocalClosestPoint.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Split(System.Int32,System.Double,RMA.OpenNURBS.OnSurface@,RMA.OpenNURBS.OnSurface@)">
            <summary>Splits (divides) the surface into two parts at the specified parameter.</summary>
            <param name="dir">
0 The surface is split vertically. The "west" side is returned in
 "west_or_south_side" and the "east" side is returned
 in "east_or_north_side".
1 The surface is split horizontally. The "south" side is returned in
 "west_or_south_side" and the "north" side is returned in
 "east_or_north_side".
</param>
            <param name="c">[in] value of constant parameter in interval returned by Domain(dir)</param>
            <param name="west_or_south_side">[out] west/south portion of surface returned here</param>
            <param name="east_or_north_side">[out] east/north portion of surface returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Extend(System.Int32,RMA.OpenNURBS.IOnInterval)">
            <summary>
Pure virtual function. Default returns false. Where possible, analytically extends surface to include domain.
</summary>
            <param name="dir">
0 new Domain(0) will include domain. (the first surface parameter).
1 new Domain(1) will include domain. (the second surface parameter).
</param>
            <param name="domain">
[in] if domain is not included in surface domain, surface will be extended so
that its domain includes domain. Will not work if surface is closed in direction dir.
Original surface is identical to the restriction of the resulting surface to the
original surface domain
</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Trim(System.Int32,RMA.OpenNURBS.IOnInterval)">
            <summary>Removes the portions of the surface outside of the specified interval.</summary>
            <param name="dir">
0 The domain specifies an sub-interval of Domain(0) (the first surface parameter).
1 The domain specifies an sub-interval of Domain(1) (the second surface parameter).
</param>
            <param name="domain">
[in] interval of the surface to keep. If dir is 0, then the portions of the surface
with parameters (s,t) satisfying s &lt; Domain(0).Min() or s &gt; Domain(0).Max() are trimmed away.
If dir is 1, then the portions of the surface with parameters (s,t) satisfying t &lt; Domain(1).Min()
or t &gt; Domain(1).Max() are trimmed away.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Pullback(RMA.OpenNURBS.IOnCurve,System.Double)">
            <summary>Pull a 3d curve back to the surface's parameter space.</summary>
            <param name="curve_3d">[in] a 3d curve</param>
            <param name="tolerance">
[in] the maximum acceptable 3d distance between from surface(curve_2d(t)) to
the locus of points on the surface that are closest to curve_3d.
</param>
            <returns>
2d curve.
See Also: ON_Surface::IsoCurve ON_Surface::Pushup
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Pullback(RMA.OpenNURBS.IOnCurve,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Pull a 3d curve back to the surface's parameter space.</summary>
            <param name="curve_3d">[in] a 3d curve</param>
            <param name="tolerance">
[in] the maximum acceptable 3d distance between from surface(curve_2d(t)) to
the locus of points on the surface that are closest to curve_3d.
</param>
            <param name="curve_3d_subdomain">[in] optional subdomain for curve_3d</param>
            <returns>
2d curve.
See Also: ON_Surface::IsoCurve ON_Surface::Pushup
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Pullback(RMA.OpenNURBS.IOnCurve,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Pull a 3d curve back to the surface's parameter space.</summary>
            <param name="curve_3d">[in] a 3d curve</param>
            <param name="tolerance">
[in] the maximum acceptable 3d distance between from surface(curve_2d(t)) to
the locus of points on the surface that are closest to curve_3d.
</param>
            <param name="curve_3d_subdomain">[in] optional subdomain for curve_3d</param>
            <param name="start_uv">[in] optional starting point (if known)</param>
            <returns>
2d curve.
See Also: ON_Surface::IsoCurve ON_Surface::Pushup
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Pullback(RMA.OpenNURBS.IOnCurve,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Pull a 3d curve back to the surface's parameter space.</summary>
            <param name="curve_3d">[in] a 3d curve</param>
            <param name="tolerance">
[in] the maximum acceptable 3d distance between from surface(curve_2d(t)) to
the locus of points on the surface that are closest to curve_3d.
</param>
            <param name="curve_3d_subdomain">[in] optional subdomain for curve_3d</param>
            <param name="start_uv">[in] optional starting point (if known)</param>
            <param name="end_uv">[in] optional ending point (if known)</param>
            <returns>
2d curve.
See Also: ON_Surface::IsoCurve ON_Surface::Pushup
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Pushup(RMA.OpenNURBS.IOnCurve,System.Double)">
            <summary>Compute a 3d curve that is the composite of a 2d curve and the surface map.</summary>
            <param name="curve_2d">[in] a 2d curve whose image is in the surface's domain.</param>
            <param name="tolerance">
[in] the maximum acceptable distance from the returned 3d curve to the image of curve_2d on the surface.
</param>
            <returns>
3d curve.
See Also: ON_Surface::IsoCurve ON_Surface::Pullback
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Pushup(RMA.OpenNURBS.IOnCurve,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Compute a 3d curve that is the composite of a 2d curve and the surface map.</summary>
            <param name="curve_2d">[in] a 2d curve whose image is in the surface's domain.</param>
            <param name="tolerance">
[in] the maximum acceptable distance from the returned 3d curve to the image of curve_2d on the surface.
</param>
            <param name="curve_2d_subdomain">[in] optional subdomain for curve_2d</param>
            <returns>
3d curve.
See Also: ON_Surface::IsoCurve ON_Surface::Pullback
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsoCurve(System.Int32,System.Double)">
            <summary>Get isoparametric curve.</summary>
            <param name="dir">
0 first parameter varies and second parameter is constant e.g., point on
 IsoCurve(0,c) at t is srf(t,c) This is a horizontal line from left to right
1 first parameter is constant and second parameter varies e.g., point on
 IsoCurve(1,c) at t is srf(c,t This is a vertical line from bottom to top
</param>
            <param name="c">[in] value of constant parameter</param>
            <returns>Isoparametric curve.</returns>
            <remarks>
In this function "dir" indicates which direction
the resulting curve runs. 0: horizontal, 1: vertical
In the other ON_Surface functions that take a "dir" argument,
"dir" indicates if "c" is a "u" or "v" parameter.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.EvNormal(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
            <param name="normal">unit normal</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.EvNormal(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
            <param name="normal">unit normal</param>
            <param name="quadrant">
optional - determines which side to evaluate from
   0 = default
   1 from NE quadrant
   2 from NW quadrant
   3 from SW quadrant
   4 from SE quadrant
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.EvNormal(System.Double,System.Double,RMA.OpenNURBS.On3dVector@)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="normal">unit normal</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.EvNormal(System.Double,System.Double,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="normal">unit normal</param>
            <param name="quadrant">
optional - determines which side to evaluate from
   0 = default
   1 from NE quadrant
   2 from NW quadrant
   3 from SW quadrant
   4 from SE quadrant
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.EvNormal(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="normal">unit normal</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.EvNormal(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="normal">unit normal</param>
            <param name="quadrant">
optional - determines which side to evaluate from
   0 = default
   1 from NE quadrant
   2 from NW quadrant
   3 from SW quadrant
   4 from SE quadrant
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Ev2Der(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
            <param name="duu">second partial derivatives (Dss)</param>
            <param name="duv">second partial derivatives (Dst)</param>
            <param name="dvv">second partial derivatives (Dtt)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Ev2Der(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
            <param name="duu">second partial derivatives (Dss)</param>
            <param name="duv">second partial derivatives (Dst)</param>
            <param name="dvv">second partial derivatives (Dtt)</param>
            <param name="quadrant">
optional - determines which side to evaluate from
   0 = default
   1 from NE quadrant
   2 from NW quadrant
   3 from SW quadrant
   4 from SE quadrant
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Ev1Der(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Ev1Der(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
            <param name="quadrant">
optional - determines which side to evaluate from
   0 = default
   1 from NE quadrant
   2 from NW quadrant
   3 from SW quadrant
   4 from SE quadrant
</param>
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
            <param name="quadrant">
optional - determines which side to evaluate from
   0 = default
   1 from NE quadrant
   2 from NW quadrant
   3 from SW quadrant
   4 from SE quadrant
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.EvPoint(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.EvPoint(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,System.Int32)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="quadrant">
optional - determines which side to evaluate from
   0 = default
   1 from NE quadrant
   2 from NW quadrant
   3 from SW quadrant
   4 from SE quadrant
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.FrameAt(System.Double,System.Double,RMA.OpenNURBS.OnPlane@)">
            <summary>simple evaluation interface - no error handling</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.NormalAt(System.Double,System.Double)">
            <summary>simple evaluation interface - no error handling</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.PointAt(System.Double,System.Double)">
            <summary>simple evaluation interface - no error handling</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Transpose">
            <summary>transpose surface parameterization (swap "s" and "t")</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Reverse(System.Int32)">
            <summary>reverse parameterizatrion, Domain changes from [a,b] to [-b,-a]</summary>
            <param name="dir">0 = "s", 1 = "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double)">
            <summary>Test continuity at a surface parameter value.</summary>
            <param name="c">[in] continuity to test for</param>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <returns>TRUE if the surface has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Int32@)">
            <summary>Test continuity at a surface parameter value.</summary>
            <param name="c">[in] continuity to test for</param>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <returns>TRUE if the surface has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Int32@,System.Double)">
            <summary>Test continuity at a surface parameter value.</summary>
            <param name="c">[in] continuity to test for</param>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance,
then the surface is not C0.
</param>
            <returns>TRUE if the surface has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Int32@,System.Double,System.Double)">
            <summary>Test continuity at a surface parameter value.</summary>
            <param name="c">[in] continuity to test for</param>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance,
then the surface is not C0.
</param>
            <param name="d1_tolerance">
[in] if the difference between two first derivatives is greater than d1_tolerance, then the surface is not C1.
</param>
            <returns>TRUE if the surface has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Int32@,System.Double,System.Double,System.Double)">
            <summary>Test continuity at a surface parameter value.</summary>
            <param name="c">[in] continuity to test for</param>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance,
then the surface is not C0.
</param>
            <param name="d1_tolerance">
[in] if the difference between two first derivatives is greater than d1_tolerance, then the surface is not C1.
</param>
            <param name="d2_tolerance">
[in] if the difference between two second derivatives is greater than d2_tolerance, then the surface is not C2.
</param>
            <returns>TRUE if the surface has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Int32@,System.Double,System.Double,System.Double,System.Double)">
            <summary>Test continuity at a surface parameter value.</summary>
            <param name="c">[in] continuity to test for</param>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance,
then the surface is not C0.
</param>
            <param name="d1_tolerance">
[in] if the difference between two first derivatives is greater than d1_tolerance, then the surface is not C1.
</param>
            <param name="d2_tolerance">
[in] if the difference between two second derivatives is greater than d2_tolerance, then the surface is not C2.
</param>
            <param name="cos_angle_tolerance">
[in] default = cos(1 degree) Used only when c is ON::G1_continuous or ON::G2_continuous.
If the cosine of the angle between two normal vectors is &lt;= cos_angle_tolerance,
then a G1 discontinuity is reported.
</param>
            <returns>TRUE if the surface has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Int32@,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Test continuity at a surface parameter value.</summary>
            <param name="c">[in] continuity to test for</param>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance,
then the surface is not C0.
</param>
            <param name="d1_tolerance">
[in] if the difference between two first derivatives is greater than d1_tolerance, then the surface is not C1.
</param>
            <param name="d2_tolerance">
[in] if the difference between two second derivatives is greater than d2_tolerance, then the surface is not C2.
</param>
            <param name="cos_angle_tolerance">
[in] default = cos(1 degree) Used only when c is ON::G1_continuous or ON::G2_continuous.
If the cosine of the angle between two normal vectors is &lt;= cos_angle_tolerance,
then a G1 discontinuity is reported.
</param>
            <param name="curvature_tolerance">
[in] (default = ON_SQRT_EPSILON) Used only when c is ON::G2_continuous. If K0 and K1 are
curvatures evaluated from above and below and |K0 - K1| &gt; curvature_tolerance, then a
curvature discontinuity is reported.
</param>
            <returns>TRUE if the surface has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetNextDiscontinuity(System.Int32,RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="dir">
[in] If 0, then "u" parameter is checked.
If 1, then the "v" parameter is checked.
</param>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c 
is a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1. Note
 well that all curves are parametrically continuous at the ends of their domains.

Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetNextDiscontinuity(System.Int32,RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@,System.Int32@)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="dir">
[in] If 0, then "u" parameter is checked.
If 1, then the "v" parameter is checked.
</param>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c 
is a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.</param>
            <param name="hint">
[in/out] if GetNextDiscontinuity will be called repeatedly, passing a "hint"
with initial value *hint=0 will increase the speed of the search.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1. Note
 well that all curves are parametrically continuous at the ends of their domains.

Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetNextDiscontinuity(System.Int32,RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@,System.Int32@,System.Int32@)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="dir">
[in] If 0, then "u" parameter is checked.
If 1, then the "v" parameter is checked.
</param>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c 
is a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.</param>
            <param name="hint">
[in/out] if GetNextDiscontinuity will be called repeatedly, passing a "hint"
with initial value *hint=0 will increase the speed of the search.
</param>
            <param name="dtype">
[out] if not NULL, *dtype reports the kind of discontinuity found at *t. A value
of 1 means the first derivative or unit tangent was discontinuous. A value of 2
means the second derivative or curvature was discontinuous. A value of 0 means the
curve is not closed, a locus discontinuity test was applied, and t1 is at the start
of end of the curve.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1. Note
 well that all curves are parametrically continuous at the ends of their domains.

Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetNextDiscontinuity(System.Int32,RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@,System.Int32@,System.Int32@,System.Double)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="dir">
[in] If 0, then "u" parameter is checked.
If 1, then the "v" parameter is checked.
</param>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c 
is a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.</param>
            <param name="hint">
[in/out] if GetNextDiscontinuity will be called repeatedly, passing a "hint"
with initial value *hint=0 will increase the speed of the search.
</param>
            <param name="dtype">
[out] if not NULL, *dtype reports the kind of discontinuity found at *t. A value
of 1 means the first derivative or unit tangent was discontinuous. A value of 2
means the second derivative or curvature was discontinuous. A value of 0 means the
curve is not closed, a locus discontinuity test was applied, and t1 is at the start
of end of the curve.
</param>
            <param name="cos_angle_tolerance">
[in] default = cos(1 degree) Used only when c is ON::G1_continuous or
ON::G2_continuous. If the cosine of the angle between two tangent vectors
is &lt;= cos_angle_tolerance, then a G1 discontinuity is reported.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1. Note
 well that all curves are parametrically continuous at the ends of their domains.

Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetNextDiscontinuity(System.Int32,RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@,System.Int32@,System.Int32@,System.Double,System.Double)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="dir">
[in] If 0, then "u" parameter is checked.
If 1, then the "v" parameter is checked.
</param>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c 
is a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.</param>
            <param name="hint">
[in/out] if GetNextDiscontinuity will be called repeatedly, passing a "hint"
with initial value *hint=0 will increase the speed of the search.
</param>
            <param name="dtype">
[out] if not NULL, *dtype reports the kind of discontinuity found at *t. A value
of 1 means the first derivative or unit tangent was discontinuous. A value of 2
means the second derivative or curvature was discontinuous. A value of 0 means the
curve is not closed, a locus discontinuity test was applied, and t1 is at the start
of end of the curve.
</param>
            <param name="cos_angle_tolerance">
[in] default = cos(1 degree) Used only when c is ON::G1_continuous or
ON::G2_continuous. If the cosine of the angle between two tangent vectors
is &lt;= cos_angle_tolerance, then a G1 discontinuity is reported.
</param>
            <param name="curvature_tolerance">
[in] (default = ON_SQRT_EPSILON) Used only when c is ON::G2_continuous. If K0
and K1 are curvatures evaluated from above and below and |K0 - K1| &gt; curvature_tolerance,
then a curvature discontinuity is reported.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1. Note
 well that all curves are parametrically continuous at the ends of their domains.

Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsAtSeam(System.Double,System.Double)">
            <summary>Test if a surface parameter value is at a seam.</summary>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <returns>
0 if not a seam,
1 if s == Domain(0)[i] and srf(s, t) == srf(Domain(0)[1-i], t)
2 if t == Domain(1)[i] and srf(s, t) == srf(s, Domain(1)[1-i])
3 if 1 and 2 are true.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsAtSingularity(System.Double,System.Double)">
            <summary>Test if a surface parameter value is at a singularity.</summary>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <returns>true if surface is singular at (s,t)</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsAtSingularity(System.Double,System.Double,System.Boolean)">
            <summary>Test if a surface parameter value is at a singularity.</summary>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <param name="bExact">
[in] if true, test if s,t is exactly at a singularity 
if false, test if close enough to cause numerical problems.
</param>
            <returns>true if surface is singular at (s,t)</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsSingular(System.Int32)">
            <returns>TRUE if surface side is collapsed to a point</returns>
            <param name="side">
side of parameter space to test
0 = south, 1 = east, 2 = north, 3 = west
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsPeriodic(System.Int32)">
            <returns>TRUE if surface is periodic in direction (default is FALSE)</returns>
            <param name="dir">0 = "s", 1 = "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsClosed(System.Int32)">
            <returns>TRUE if surface is closed in direction</returns>
            <param name="dir">0 = "s", 1 = "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsPlanar">
            <summary>Test a surface to see if it is planar.</summary>
            <returns>
TRUE if there is a plane such that the maximum distance from the surface to the plane is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsPlanar(RMA.OpenNURBS.OnPlane)">
            <summary>Test a surface to see if it is planar.</summary>
            <param name="plane">[out] if not NULL and TRUE is returned, the plane parameters are filled in.</param>
            <returns>
TRUE if there is a plane such that the maximum distance from the surface to the plane is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsPlanar(RMA.OpenNURBS.OnPlane,System.Double)">
            <summary>Test a surface to see if it is planar.</summary>
            <param name="plane">[out] if not NULL and TRUE is returned, the plane parameters are filled in.</param>
            <param name="tolerance">[in] tolerance to use when checking</param>
            <returns>
TRUE if there is a plane such that the maximum distance from the surface to the plane is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsIsoparametric(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Test a 2d bounding box to see if it is iso parameteric in the surface's parameter space.
</summary>
            <param name="bbox">[in] bounding box to test Returns: Isoparametric status of the bounding box.</param>
            <remarks>
Because it may transpose domains, ON_SurfaceProxy overrides this function.
All other surface classes just use the base class implementation.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsIsoparametric(RMA.OpenNURBS.IOnCurve)">
            <summary>Test a 2d curve to see if it is iso parameteric in the surface's parameter space.</summary>
            <param name="curve">[in] curve to test</param>
            <returns>Isoparametric status of the curve.</returns>
            <remarks>
Because it may transpose domains, ON_SurfaceProxy overrides this function.
All other surface classes just use the base class implementation.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsIsoparametric(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnInterval)">
            <summary>Test a 2d curve to see if it is iso parameteric in the surface's parameter space.</summary>
            <param name="curve">[in] curve to test</param>
            <param name="curve_domain">[in] optional sub domain of the curve</param>
            <returns>Isoparametric status of the curve.</returns>
            <remarks>
Because it may transpose domains, ON_SurfaceProxy overrides this function.
All other surface classes just use the base class implementation.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetParameterTolerance(System.Int32,System.Double,System.Double@,System.Double@)">
            <summary>returns tminus &lt; tplus: parameters tminus &lt;= s &lt;= tplus</summary>
            <param name="dir">0 gets first parameter, 1 gets second parameter</param>
            <param name="t">parameter in domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Degree(System.Int32)">
            <summary>
returns maximum algebraic degree of any span 
( or a good estimate if curve spans are not algebraic )
</summary>
            <param name="dir">0 gets first parameter's domain, 1 gets second parameter's domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetSpanVectorIndex(System.Int32,System.Double,System.Int32,System.Int32@,RMA.OpenNURBS.OnInterval@)">
            <summary>
If t is in the domain of the surface, GetSpanVectorIndex() returns the 
span vector index "i" such that span_vector[i] &lt;= t &lt;= span_vector[i+1].
The "side" parameter determines which span is selected when t is at the
end of a span.
</summary>
            <param name="dir">0 gets first parameter's domain, 1 gets second parameter's domain</param>
            <param name="t">[IN] evaluation parameter</param>
            <param name="side">[IN] 0 = default, -1 = from below, +1 = from above</param>
            <param name="span_vector_index">[OUT] span vector index</param>
            <param name="span_interval">[OUT] domain of the span containing t</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetSpanVector(System.Int32,System.Double[]@)">
            <summary>span knots</summary>
            <param name="dir">0 gets first parameter's domain, 1 gets second parameter's domain</param>
            <param name="span_vector">array of length SpanCount() + 1</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.SpanCount(System.Int32)">
            <returns>number of smooth nonempty spans in the parameter direction</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetSurfaceSize(System.Double@,System.Double@)">
            <summary>
Get an estimate of the size of the rectangle that would be created if the 3d
surface where flattened into a rectangle.
</summary>
            <param name="width">[out] (corresponds to the first surface parameter)</param>
            <param name="height">[out] (corresponds to the first surface parameter)</param>
            <example>
Reparameterize a surface to minimize distortion
in the map from parameter space to 3d.
  ON_Surface* surf = ...;
  double width, height;
  if ( surf-&gt;GetSurfaceSize( &amp;width, &amp;height ) )
  {
    srf-&gt;SetDomain( 0, ON_Interval( 0.0, width ) );
    srf-&gt;SetDomain( 1, ON_Interval( 0.0, height ) );
  }
</example>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Domain(System.Int32)">
            <param name="dir">0 gets first parameter's domain, 1 gets second parameter's domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.SetDomain(System.Int32,System.Double,System.Double)">
            <param name="dir">0 sets first parameter's domain, 1 sets second parameter's domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.SetDomain(System.Int32,RMA.OpenNURBS.IOnInterval)">
            <param name="dir">0 sets first parameter's domain, 1 sets second parameter's domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetDomain(System.Int32,System.Double@,System.Double@)">
            <param name="dir">0 gets first parameter, 1 gets second parameter</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.CreateMesh(RMA.OpenNURBS.IOnMeshParameters)">
            <summary>Computes a polygon mesh approximation of the surface.</summary>
            <param name="mp">[in] meshing parameters</param>
            <returns>A polygon mesh of the surface.</returns>
            <remarks>
This virtual function works in the openNURBS that is part of the Rhino SDK.
The source code for this functionallity is not provided in the free openNURBS toolkit.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.CreateMesh(RMA.OpenNURBS.IOnMeshParameters,RMA.OpenNURBS.OnMesh)">
            <summary>Computes a polygon mesh approximation of the surface.</summary>
            <param name="mp">[in] meshing parameters</param>
            <param name="mesh">[in] if not NULL, the surface mesh will be put into this mesh.</param>
            <returns>A polygon mesh of the surface.</returns>
            <remarks>
This virtual function works in the openNURBS that is part of the Rhino SDK.
The source code for this functionallity is not provided in the free openNURBS toolkit.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.DuplicateSurface">
            <summary>Get a duplicate of the surface.</summary>
            <returns>A duplicate of the surface.</returns>
            <remarks>
The caller must delete the returned surface. For non-ON_SurfaceProxy objects,
this simply duplicates the surface using ON_Object::Duplicate.
For ON_SurfaceProxy objects, this duplicates the actual proxy surface geometry and,
if necessary, transposes the result to that the returned surfaces's
parameterization and locus match the proxy surface's.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@)">
            <summary>Calculate volume mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean)">
            <summary>Calculate volume mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Calculate volume mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <param name="base_point">
[in] If the surface is closed, then pass ON_UNSET_VALUE. This parameter is for expert users
who are computing a volume whose boundary is defined by several non-closed breps, surfaces,
and meshes. When computing the volume, volume centroid, or volume first moments of a volume
whose boundary is defined by several breps, surfaces, and meshes, pass the same base_point
to each call to VolumeMassProperties. When computing the volume second moments or volume
product moments of a volume whose boundary is defined by several breps, surfaces, and meshes,
you MUST pass the entire volume's centroid as the base_point and the input mp parameter
must contain the results of a previous call to VolumeMassProperties(mp,true,true,false,false,base_point).
In particular, in this case, you need to make two sets of calls; use first set to calculate
the volume centroid and the second set calculate the second moments and product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RMA.OpenNURBS.IOn3dPoint,System.Double)">
            <summary>Calculate volume mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <param name="base_point">
[in] If the surface is closed, then pass ON_UNSET_VALUE. This parameter is for expert users
who are computing a volume whose boundary is defined by several non-closed breps, surfaces,
and meshes. When computing the volume, volume centroid, or volume first moments of a volume
whose boundary is defined by several breps, surfaces, and meshes, pass the same base_point
to each call to VolumeMassProperties. When computing the volume second moments or volume
product moments of a volume whose boundary is defined by several breps, surfaces, and meshes,
you MUST pass the entire volume's centroid as the base_point and the input mp parameter
must contain the results of a previous call to VolumeMassProperties(mp,true,true,false,false,base_point).
In particular, in this case, you need to make two sets of calls; use first set to calculate
the volume centroid and the second set calculate the second moments and product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double)">
            <summary>Calculate volume mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <param name="base_point">
[in] If the surface is closed, then pass ON_UNSET_VALUE. This parameter is for expert users
who are computing a volume whose boundary is defined by several non-closed breps, surfaces,
and meshes. When computing the volume, volume centroid, or volume first moments of a volume
whose boundary is defined by several breps, surfaces, and meshes, pass the same base_point
to each call to VolumeMassProperties. When computing the volume second moments or volume
product moments of a volume whose boundary is defined by several breps, surfaces, and meshes,
you MUST pass the entire volume's centroid as the base_point and the input mp parameter
must contain the results of a previous call to VolumeMassProperties(mp,true,true,false,false,base_point).
In particular, in this case, you need to make two sets of calls; use first set to calculate
the volume centroid and the second set calculate the second moments and product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@)">
            <summary>Calculate area mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean)">
            <summary>Calculate area mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <param name="bProductMoments">[in] true to calculate area product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double)">
            <summary>Calculate area mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <param name="bProductMoments">[in] true to calculate area product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double,System.Double)">
            <summary>Calculate area mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <param name="bProductMoments">[in] true to calculate area product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.NurbsSurface">
            <summary>Get a NURBS surface representation of this surface.</summary>
            <returns>NULL or a NURBS representation of the surface.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Surface::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.NurbsSurface(RMA.OpenNURBS.OnNurbsSurface)">
            <summary>Get a NURBS surface representation of this surface.</summary>
            <param name="pNurbsSurface">
[in/out] if not NULL, this pNurbsSurface will be used to store the NURBS representation of the surface and will be returned.
</param>
            <returns>NULL or a NURBS representation of the surface.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Surface::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.NurbsSurface(RMA.OpenNURBS.OnNurbsSurface,System.Double)">
            <summary>Get a NURBS surface representation of this surface.</summary>
            <param name="pNurbsSurface">
[in/out] if not NULL, this pNurbsSurface will be used to store the NURBS representation of the surface and will be returned.
</param>
            <param name="tolerance">[in] tolerance to use when creating NURBS surface representation.</param>
            <returns>NULL or a NURBS representation of the surface.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Surface::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.NurbsSurface(RMA.OpenNURBS.OnNurbsSurface,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a NURBS surface representation of this surface.</summary>
            <param name="pNurbsSurface">
[in/out] if not NULL, this pNurbsSurface will be used to store the NURBS representation of the surface and will be returned.
</param>
            <param name="tolerance">[in] tolerance to use when creating NURBS surface representation.</param>
            <param name="s_subdomain">
[in] if not NULL, then the NURBS representation for this portion of the surface is returned.
</param>
            <returns>NULL or a NURBS representation of the surface.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Surface::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.NurbsSurface(RMA.OpenNURBS.OnNurbsSurface,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a NURBS surface representation of this surface.</summary>
            <param name="pNurbsSurface">
[in/out] if not NULL, this pNurbsSurface will be used to store the NURBS representation of the surface and will be returned.
</param>
            <param name="tolerance">[in] tolerance to use when creating NURBS surface representation.</param>
            <param name="s_subdomain">
[in] if not NULL, then the NURBS representation for this portion of the surface is returned.
</param>
            <param name="t_subdomain">
[in] if not NULL, then the NURBS representation for this portion of the surface is returned.
</param>
            <returns>NULL or a NURBS representation of the surface.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Surface::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.HasNurbForm">
            <summary>Is there a NURBS surface representation of this surface.</summary>
            <returns>
0 unable to create NURBS representation with desired accuracy.
1 success - NURBS parameterization matches the surface's
2 success - NURBS point locus matches the surface's and
           the domain of the NURBS surface is correct. However,
           This surface's parameterization and the NURBS
           surface parameterization may not match. This situation
           happens when getting NURBS representations of surfaces
           that have a transendental parameterization like spheres,
           cylinders, and cones.
</returns>
            <remarks>
This is a low-level virtual function.
See Also: ON_Surface::GetNurbForm ON_Surface::NurbsSurface
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetNurbForm(RMA.OpenNURBS.OnNurbsSurface@)">
            <summary>Get a NURBS surface representation of this surface.</summary>
            <param name="nurbs_surface">[out] NURBS representation returned here</param>
            <returns>
0 unable to create NURBS representation with desired accuracy.
1 success - returned NURBS parameterization matches the surface's to wthe desired accuracy
2 success - returned NURBS point locus matches the surface's to the desired accuracy and the
           domain of the NURBS surface is correct. On However, This surface's parameterization
           and the NURBS surface parameterization may not match to the desired accuracy. This
           situation happens when getting NURBS representations of surfaces that have a
           transendental parameterization like spheres, cylinders, and cones.
</returns>
            <remarks>
This is a low-level virtual function. If you do not need the parameterization information
provided by the return code, then ON_Surface::NurbsSurface may be easier to use.
See Also: ON_Surface::NurbsSurface
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetNurbForm(RMA.OpenNURBS.OnNurbsSurface@,System.Double)">
            <summary>Get a NURBS surface representation of this surface.</summary>
            <param name="nurbs_surface">[out] NURBS representation returned here</param>
            <param name="tolerance">[in] tolerance to use when creating NURBS representation.</param>
            <returns>
0 unable to create NURBS representation with desired accuracy.
1 success - returned NURBS parameterization matches the surface's to wthe desired accuracy
2 success - returned NURBS point locus matches the surface's to the desired accuracy and the
           domain of the NURBS surface is correct. On However, This surface's parameterization
           and the NURBS surface parameterization may not match to the desired accuracy. This
           situation happens when getting NURBS representations of surfaces that have a
           transendental parameterization like spheres, cylinders, and cones.
</returns>
            <remarks>
This is a low-level virtual function. If you do not need the parameterization information
provided by the return code, then ON_Surface::NurbsSurface may be easier to use.
See Also: ON_Surface::NurbsSurface
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Offset(System.Double,System.Double)">
            <summary>Offset surface.</summary>
            <param name="offset_distance">[in] offset distance</param>
            <param name="tolerance">
[in] Some surfaces do not have an exact offset that can be represented using
the same class of surface definition. In that case, the tolerance specifies
the desired accuracy.
</param>
            <returns>Offset surface.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Offset(System.Double,System.Double,System.Double@)">
            <summary>Offset surface.</summary>
            <param name="offset_distance">[in] offset distance</param>
            <param name="tolerance">
[in] Some surfaces do not have an exact offset that can be represented using
the same class of surface definition. In that case, the tolerance specifies
the desired accuracy.
</param>
            <param name="max_deviation">
[out] If this parameter is not NULL, the maximum deviation from the returned offset
to the TRUE offset is returned here. This deviation is zero except for cases where
an exact offset cannot be computed using the same class of surface definition.
</param>
            <returns>Offset surface.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double,System.Double@,System.Double@)">
            <summary>
Find parameters of the point on a surface that is locally closest to 
the test_point.  The search for a local close point starts at 
seed parameters. If a sub_domain parameter is not NULL, then
the search is restricted to the specified portion of the surface.
</summary>
            <returns>
TRUE if returned if the search is successful.  FALSE is returned if
the search fails.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval)">
            <summary>
Find parameters of the point on a surface that is locally closest to 
the test_point.  The search for a local close point starts at 
seed parameters. If a sub_domain parameter is not NULL, then
the search is restricted to the specified portion of the surface.
</summary>
            <returns>
TRUE if returned if the search is successful.  FALSE is returned if
the search fails.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>
Find parameters of the point on a surface that is locally closest to 
the test_point.  The search for a local close point starts at 
seed parameters. If a sub_domain parameter is not NULL, then
the search is restricted to the specified portion of the surface.
</summary>
            <returns>
TRUE if returned if the search is successful.  FALSE is returned if
the search fails.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@)">
            <summary>Get the parameters of the point on the surface that is closest to P.</summary>
            <param name="P">[in] test point</param>
            <param name="s">[out] (*s,*t) = parameters of the surface point that is closest to P.</param>
            <param name="t">[out] (*s,*t) = parameters of the surface point that is closest to P.</param>
            <returns>
True if successful. If false, the values of *s and *t are undefined.
See Also: ON_Surface::GetLocalClosestPoint.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@,System.Double)">
            <summary>Get the parameters of the point on the surface that is closest to P.</summary>
            <param name="P">[in] test point</param>
            <param name="s">[out] (*s,*t) = parameters of the surface point that is closest to P.</param>
            <param name="t">[out] (*s,*t) = parameters of the surface point that is closest to P.</param>
            <param name="maximum_distance">
[in] optional upper bound on the distance from P to the surface. If you are
only interested in finding a point Q on the surface when P.DistanceTo(Q) &lt; maximum_distance,
then set maximum_distance to that value.
</param>
            <returns>
True if successful. If false, the values of *s and *t are undefined.
See Also: ON_Surface::GetLocalClosestPoint.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Get the parameters of the point on the surface that is closest to P.</summary>
            <param name="P">[in] test point</param>
            <param name="s">[out] (*s,*t) = parameters of the surface point that is closest to P.</param>
            <param name="t">[out] (*s,*t) = parameters of the surface point that is closest to P.</param>
            <param name="maximum_distance">
[in] optional upper bound on the distance from P to the surface. If you are
only interested in finding a point Q on the surface when P.DistanceTo(Q) &lt; maximum_distance,
then set maximum_distance to that value.
</param>
            <param name="sdomain">[in] optional domain restriction</param>
            <returns>
True if successful. If false, the values of *s and *t are undefined.
See Also: ON_Surface::GetLocalClosestPoint.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Get the parameters of the point on the surface that is closest to P.</summary>
            <param name="P">[in] test point</param>
            <param name="s">[out] (*s,*t) = parameters of the surface point that is closest to P.</param>
            <param name="t">[out] (*s,*t) = parameters of the surface point that is closest to P.</param>
            <param name="maximum_distance">
[in] optional upper bound on the distance from P to the surface. If you are
only interested in finding a point Q on the surface when P.DistanceTo(Q) &lt; maximum_distance,
then set maximum_distance to that value.
</param>
            <param name="sdomain">[in] optional domain restriction</param>
            <param name="tdomain">[in] optional domain restriction</param>
            <returns>
True if successful. If false, the values of *s and *t are undefined.
See Also: ON_Surface::GetLocalClosestPoint.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Split(System.Int32,System.Double,RMA.OpenNURBS.OnSurface@,RMA.OpenNURBS.OnSurface@)">
            <summary>Splits (divides) the surface into two parts at the specified parameter.</summary>
            <param name="dir">
0 The surface is split vertically. The "west" side is returned in
 "west_or_south_side" and the "east" side is returned
 in "east_or_north_side".
1 The surface is split horizontally. The "south" side is returned in
 "west_or_south_side" and the "north" side is returned in
 "east_or_north_side".
</param>
            <param name="c">[in] value of constant parameter in interval returned by Domain(dir)</param>
            <param name="west_or_south_side">[out] west/south portion of surface returned here</param>
            <param name="east_or_north_side">[out] east/north portion of surface returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Pullback(RMA.OpenNURBS.IOnCurve,System.Double)">
            <summary>Pull a 3d curve back to the surface's parameter space.</summary>
            <param name="curve_3d">[in] a 3d curve</param>
            <param name="tolerance">
[in] the maximum acceptable 3d distance between from surface(curve_2d(t)) to
the locus of points on the surface that are closest to curve_3d.
</param>
            <returns>
2d curve.
See Also: ON_Surface::IsoCurve ON_Surface::Pushup
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Pullback(RMA.OpenNURBS.IOnCurve,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Pull a 3d curve back to the surface's parameter space.</summary>
            <param name="curve_3d">[in] a 3d curve</param>
            <param name="tolerance">
[in] the maximum acceptable 3d distance between from surface(curve_2d(t)) to
the locus of points on the surface that are closest to curve_3d.
</param>
            <param name="curve_3d_subdomain">[in] optional subdomain for curve_3d</param>
            <returns>
2d curve.
See Also: ON_Surface::IsoCurve ON_Surface::Pushup
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Pullback(RMA.OpenNURBS.IOnCurve,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Pull a 3d curve back to the surface's parameter space.</summary>
            <param name="curve_3d">[in] a 3d curve</param>
            <param name="tolerance">
[in] the maximum acceptable 3d distance between from surface(curve_2d(t)) to
the locus of points on the surface that are closest to curve_3d.
</param>
            <param name="curve_3d_subdomain">[in] optional subdomain for curve_3d</param>
            <param name="start_uv">[in] optional starting point (if known)</param>
            <returns>
2d curve.
See Also: ON_Surface::IsoCurve ON_Surface::Pushup
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Pullback(RMA.OpenNURBS.IOnCurve,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Pull a 3d curve back to the surface's parameter space.</summary>
            <param name="curve_3d">[in] a 3d curve</param>
            <param name="tolerance">
[in] the maximum acceptable 3d distance between from surface(curve_2d(t)) to
the locus of points on the surface that are closest to curve_3d.
</param>
            <param name="curve_3d_subdomain">[in] optional subdomain for curve_3d</param>
            <param name="start_uv">[in] optional starting point (if known)</param>
            <param name="end_uv">[in] optional ending point (if known)</param>
            <returns>
2d curve.
See Also: ON_Surface::IsoCurve ON_Surface::Pushup
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Pushup(RMA.OpenNURBS.IOnCurve,System.Double)">
            <summary>Compute a 3d curve that is the composite of a 2d curve and the surface map.</summary>
            <param name="curve_2d">[in] a 2d curve whose image is in the surface's domain.</param>
            <param name="tolerance">
[in] the maximum acceptable distance from the returned 3d curve to the image of curve_2d on the surface.
</param>
            <returns>
3d curve.
See Also: ON_Surface::IsoCurve ON_Surface::Pullback
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Pushup(RMA.OpenNURBS.IOnCurve,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Compute a 3d curve that is the composite of a 2d curve and the surface map.</summary>
            <param name="curve_2d">[in] a 2d curve whose image is in the surface's domain.</param>
            <param name="tolerance">
[in] the maximum acceptable distance from the returned 3d curve to the image of curve_2d on the surface.
</param>
            <param name="curve_2d_subdomain">[in] optional subdomain for curve_2d</param>
            <returns>
3d curve.
See Also: ON_Surface::IsoCurve ON_Surface::Pullback
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsoCurve(System.Int32,System.Double)">
            <summary>Get isoparametric curve.</summary>
            <param name="dir">
0 first parameter varies and second parameter is constant e.g., point on
 IsoCurve(0,c) at t is srf(t,c) This is a horizontal line from left to right
1 first parameter is constant and second parameter varies e.g., point on
 IsoCurve(1,c) at t is srf(c,t This is a vertical line from bottom to top
</param>
            <param name="c">[in] value of constant parameter</param>
            <returns>Isoparametric curve.</returns>
            <remarks>
In this function "dir" indicates which direction
the resulting curve runs. 0: horizontal, 1: vertical
In the other ON_Surface functions that take a "dir" argument,
"dir" indicates if "c" is a "u" or "v" parameter.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.EvNormal(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
            <param name="normal">unit normal</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.EvNormal(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
            <param name="normal">unit normal</param>
            <param name="quadrant">
optional - determines which side to evaluate from
   0 = default
   1 from NE quadrant
   2 from NW quadrant
   3 from SW quadrant
   4 from SE quadrant
</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.EvNormal(System.Double,System.Double,RMA.OpenNURBS.On3dVector@)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="normal">unit normal</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.EvNormal(System.Double,System.Double,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="normal">unit normal</param>
            <param name="quadrant">
optional - determines which side to evaluate from
   0 = default
   1 from NE quadrant
   2 from NW quadrant
   3 from SW quadrant
   4 from SE quadrant
</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.EvNormal(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="normal">unit normal</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.EvNormal(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="normal">unit normal</param>
            <param name="quadrant">
optional - determines which side to evaluate from
   0 = default
   1 from NE quadrant
   2 from NW quadrant
   3 from SW quadrant
   4 from SE quadrant
</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Ev2Der(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
            <param name="duu">second partial derivatives (Dss)</param>
            <param name="duv">second partial derivatives (Dst)</param>
            <param name="dvv">second partial derivatives (Dtt)</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Ev2Der(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
            <param name="duu">second partial derivatives (Dss)</param>
            <param name="duv">second partial derivatives (Dst)</param>
            <param name="dvv">second partial derivatives (Dtt)</param>
            <param name="quadrant">
optional - determines which side to evaluate from
   0 = default
   1 from NE quadrant
   2 from NW quadrant
   3 from SW quadrant
   4 from SE quadrant
</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Ev1Der(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Ev1Der(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>
returns FALSE if unable to evaluate
</summary>
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
            <param name="quadrant">
optional - determines which side to evaluate from
   0 = default
   1 from NE quadrant
   2 from NW quadrant
   3 from SW quadrant
   4 from SE quadrant
</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.EvPoint(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.EvPoint(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,System.Int32)">
            <summary>
returns FALSE if unable to evaluate
</summary>
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="quadrant">
optional - determines which side to evaluate from
   0 = default
   1 from NE quadrant
   2 from NW quadrant
   3 from SW quadrant
   4 from SE quadrant
</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.FrameAt(System.Double,System.Double,RMA.OpenNURBS.OnPlane@)">
            <summary>simple evaluation interface - no error handling</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.NormalAt(System.Double,System.Double)">
            <summary>simple evaluation interface - no error handling</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.PointAt(System.Double,System.Double)">
            <summary>simple evaluation interface - no error handling</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double)">
            <summary>Test continuity at a surface parameter value.</summary>
            <param name="c">[in] continuity to test for</param>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <returns>TRUE if the surface has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Int32@)">
            <summary>Test continuity at a surface parameter value.</summary>
            <param name="c">[in] continuity to test for</param>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <returns>TRUE if the surface has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Int32@,System.Double)">
            <summary>Test continuity at a surface parameter value.</summary>
            <param name="c">[in] continuity to test for</param>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance,
then the surface is not C0.
</param>
            <returns>TRUE if the surface has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Int32@,System.Double,System.Double)">
            <summary>Test continuity at a surface parameter value.</summary>
            <param name="c">[in] continuity to test for</param>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance,
then the surface is not C0.
</param>
            <param name="d1_tolerance">
[in] if the difference between two first derivatives is greater than d1_tolerance, then the surface is not C1.
</param>
            <returns>TRUE if the surface has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Int32@,System.Double,System.Double,System.Double)">
            <summary>Test continuity at a surface parameter value.</summary>
            <param name="c">[in] continuity to test for</param>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance,
then the surface is not C0.
</param>
            <param name="d1_tolerance">
[in] if the difference between two first derivatives is greater than d1_tolerance, then the surface is not C1.
</param>
            <param name="d2_tolerance">
[in] if the difference between two second derivatives is greater than d2_tolerance, then the surface is not C2.
</param>
            <returns>TRUE if the surface has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Int32@,System.Double,System.Double,System.Double,System.Double)">
            <summary>Test continuity at a surface parameter value.</summary>
            <param name="c">[in] continuity to test for</param>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance,
then the surface is not C0.
</param>
            <param name="d1_tolerance">
[in] if the difference between two first derivatives is greater than d1_tolerance, then the surface is not C1.
</param>
            <param name="d2_tolerance">
[in] if the difference between two second derivatives is greater than d2_tolerance, then the surface is not C2.
</param>
            <param name="cos_angle_tolerance">
[in] default = cos(1 degree) Used only when c is ON::G1_continuous or ON::G2_continuous.
If the cosine of the angle between two normal vectors is &lt;= cos_angle_tolerance,
then a G1 discontinuity is reported.
</param>
            <returns>TRUE if the surface has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Int32@,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Test continuity at a surface parameter value.</summary>
            <param name="c">[in] continuity to test for</param>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance,
then the surface is not C0.
</param>
            <param name="d1_tolerance">
[in] if the difference between two first derivatives is greater than d1_tolerance, then the surface is not C1.
</param>
            <param name="d2_tolerance">
[in] if the difference between two second derivatives is greater than d2_tolerance, then the surface is not C2.
</param>
            <param name="cos_angle_tolerance">
[in] default = cos(1 degree) Used only when c is ON::G1_continuous or ON::G2_continuous.
If the cosine of the angle between two normal vectors is &lt;= cos_angle_tolerance,
then a G1 discontinuity is reported.
</param>
            <param name="curvature_tolerance">
[in] (default = ON_SQRT_EPSILON) Used only when c is ON::G2_continuous. If K0 and K1 are
curvatures evaluated from above and below and |K0 - K1| &gt; curvature_tolerance, then a
curvature discontinuity is reported.
</param>
            <returns>TRUE if the surface has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetNextDiscontinuity(System.Int32,RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="dir">
[in] If 0, then "u" parameter is checked.
If 1, then the "v" parameter is checked.
</param>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c 
is a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1. Note
 well that all curves are parametrically continuous at the ends of their domains.

Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetNextDiscontinuity(System.Int32,RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@,System.Int32@)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="dir">
[in] If 0, then "u" parameter is checked.
If 1, then the "v" parameter is checked.
</param>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c 
is a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.</param>
            <param name="hint">
[in/out] if GetNextDiscontinuity will be called repeatedly, passing a "hint"
with initial value *hint=0 will increase the speed of the search.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1. Note
 well that all curves are parametrically continuous at the ends of their domains.

Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetNextDiscontinuity(System.Int32,RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@,System.Int32@,System.Int32@)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="dir">
[in] If 0, then "u" parameter is checked.
If 1, then the "v" parameter is checked.
</param>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c 
is a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.</param>
            <param name="hint">
[in/out] if GetNextDiscontinuity will be called repeatedly, passing a "hint"
with initial value *hint=0 will increase the speed of the search.
</param>
            <param name="dtype">
[out] if not NULL, *dtype reports the kind of discontinuity found at *t. A value
of 1 means the first derivative or unit tangent was discontinuous. A value of 2
means the second derivative or curvature was discontinuous. A value of 0 means the
curve is not closed, a locus discontinuity test was applied, and t1 is at the start
of end of the curve.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1. Note
 well that all curves are parametrically continuous at the ends of their domains.

Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetNextDiscontinuity(System.Int32,RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@,System.Int32@,System.Int32@,System.Double)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="dir">
[in] If 0, then "u" parameter is checked.
If 1, then the "v" parameter is checked.
</param>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c 
is a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.</param>
            <param name="hint">
[in/out] if GetNextDiscontinuity will be called repeatedly, passing a "hint"
with initial value *hint=0 will increase the speed of the search.
</param>
            <param name="dtype">
[out] if not NULL, *dtype reports the kind of discontinuity found at *t. A value
of 1 means the first derivative or unit tangent was discontinuous. A value of 2
means the second derivative or curvature was discontinuous. A value of 0 means the
curve is not closed, a locus discontinuity test was applied, and t1 is at the start
of end of the curve.
</param>
            <param name="cos_angle_tolerance">
[in] default = cos(1 degree) Used only when c is ON::G1_continuous or
ON::G2_continuous. If the cosine of the angle between two tangent vectors
is &lt;= cos_angle_tolerance, then a G1 discontinuity is reported.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1. Note
 well that all curves are parametrically continuous at the ends of their domains.

Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetNextDiscontinuity(System.Int32,RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@,System.Int32@,System.Int32@,System.Double,System.Double)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="dir">
[in] If 0, then "u" parameter is checked.
If 1, then the "v" parameter is checked.
</param>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c 
is a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.</param>
            <param name="hint">
[in/out] if GetNextDiscontinuity will be called repeatedly, passing a "hint"
with initial value *hint=0 will increase the speed of the search.
</param>
            <param name="dtype">
[out] if not NULL, *dtype reports the kind of discontinuity found at *t. A value
of 1 means the first derivative or unit tangent was discontinuous. A value of 2
means the second derivative or curvature was discontinuous. A value of 0 means the
curve is not closed, a locus discontinuity test was applied, and t1 is at the start
of end of the curve.
</param>
            <param name="cos_angle_tolerance">
[in] default = cos(1 degree) Used only when c is ON::G1_continuous or
ON::G2_continuous. If the cosine of the angle between two tangent vectors
is &lt;= cos_angle_tolerance, then a G1 discontinuity is reported.
</param>
            <param name="curvature_tolerance">
[in] (default = ON_SQRT_EPSILON) Used only when c is ON::G2_continuous. If K0
and K1 are curvatures evaluated from above and below and |K0 - K1| &gt; curvature_tolerance,
then a curvature discontinuity is reported.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1. Note
 well that all curves are parametrically continuous at the ends of their domains.

Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsAtSeam(System.Double,System.Double)">
            <summary>Test if a surface parameter value is at a seam.</summary>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <returns>
0 if not a seam,
1 if s == Domain(0)[i] and srf(s, t) == srf(Domain(0)[1-i], t)
2 if t == Domain(1)[i] and srf(s, t) == srf(s, Domain(1)[1-i])
3 if 1 and 2 are true.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsAtSingularity(System.Double,System.Double)">
            <summary>Test if a surface parameter value is at a singularity.</summary>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <returns>true if surface is singular at (s,t)</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsAtSingularity(System.Double,System.Double,System.Boolean)">
            <summary>Test if a surface parameter value is at a singularity.</summary>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <param name="bExact">
[in] if true, test if s,t is exactly at a singularity 
if false, test if close enough to cause numerical problems.
</param>
            <returns>true if surface is singular at (s,t)</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsSingular(System.Int32)">
            <returns>TRUE if surface side is collapsed to a point</returns>
            <param name="side">
side of parameter space to test
0 = south, 1 = east, 2 = north, 3 = west
</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsPeriodic(System.Int32)">
            <returns>TRUE if surface is periodic in direction (default is FALSE)</returns>
            <param name="dir">0 = "s", 1 = "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsClosed(System.Int32)">
            <returns>TRUE if surface is closed in direction</returns>
            <param name="dir">0 = "s", 1 = "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsPlanar">
            <summary>Test a surface to see if it is planar.</summary>
            <returns>
TRUE if there is a plane such that the maximum distance from the surface to the plane is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsPlanar(RMA.OpenNURBS.OnPlane)">
            <summary>Test a surface to see if it is planar.</summary>
            <param name="plane">[out] if not NULL and TRUE is returned, the plane parameters are filled in.</param>
            <returns>
TRUE if there is a plane such that the maximum distance from the surface to the plane is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsPlanar(RMA.OpenNURBS.OnPlane,System.Double)">
            <summary>Test a surface to see if it is planar.</summary>
            <param name="plane">[out] if not NULL and TRUE is returned, the plane parameters are filled in.</param>
            <param name="tolerance">[in] tolerance to use when checking</param>
            <returns>
TRUE if there is a plane such that the maximum distance from the surface to the plane is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsIsoparametric(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Test a 2d bounding box to see if it is iso parameteric in the surface's parameter space.
</summary>
            <param name="bbox">[in] bounding box to test Returns: Isoparametric status of the bounding box.</param>
            <remarks>
Because it may transpose domains, ON_SurfaceProxy overrides this function.
All other surface classes just use the base class implementation.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsIsoparametric(RMA.OpenNURBS.IOnCurve)">
            <summary>Test a 2d curve to see if it is iso parameteric in the surface's parameter space.</summary>
            <param name="curve">[in] curve to test</param>
            <returns>Isoparametric status of the curve.</returns>
            <remarks>
Because it may transpose domains, ON_SurfaceProxy overrides this function.
All other surface classes just use the base class implementation.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsIsoparametric(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnInterval)">
            <summary>Test a 2d curve to see if it is iso parameteric in the surface's parameter space.</summary>
            <param name="curve">[in] curve to test</param>
            <param name="curve_domain">[in] optional sub domain of the curve</param>
            <returns>Isoparametric status of the curve.</returns>
            <remarks>
Because it may transpose domains, ON_SurfaceProxy overrides this function.
All other surface classes just use the base class implementation.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetParameterTolerance(System.Int32,System.Double,System.Double@,System.Double@)">
            <summary>returns tminus &lt; tplus: parameters tminus &lt;= s &lt;= tplus</summary>
            <param name="dir">0 gets first parameter, 1 gets second parameter</param>
            <param name="t">parameter in domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Degree(System.Int32)">
            <summary>
returns maximum algebraic degree of any span 
( or a good estimate if curve spans are not algebraic )
</summary>
            <param name="dir">0 gets first parameter's domain, 1 gets second parameter's domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetSpanVectorIndex(System.Int32,System.Double,System.Int32,System.Int32@,RMA.OpenNURBS.OnInterval@)">
            <summary>
If t is in the domain of the surface, GetSpanVectorIndex() returns the 
span vector index "i" such that span_vector[i] &lt;= t &lt;= span_vector[i+1].
The "side" parameter determines which span is selected when t is at the
end of a span.
</summary>
            <param name="dir">0 gets first parameter's domain, 1 gets second parameter's domain</param>
            <param name="t">[IN] evaluation parameter</param>
            <param name="side">[IN] 0 = default, -1 = from below, +1 = from above</param>
            <param name="span_vector_index">[OUT] span vector index</param>
            <param name="span_interval">[OUT] domain of the span containing t</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetSpanVector(System.Int32,System.Double[]@)">
            <summary>span knots</summary>
            <param name="dir">0 gets first parameter's domain, 1 gets second parameter's domain</param>
            <param name="span_vector">array of length SpanCount() + 1</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.SpanCount(System.Int32)">
            <returns>number of smooth nonempty spans in the parameter direction</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetSurfaceSize(System.Double@,System.Double@)">
            <summary>
Get an estimate of the size of the rectangle that would be created if the 3d
surface where flattened into a rectangle.
</summary>
            <param name="width">[out] (corresponds to the first surface parameter)</param>
            <param name="height">[out] (corresponds to the first surface parameter)</param>
            <example>
Reparameterize a surface to minimize distortion
in the map from parameter space to 3d.
  ON_Surface* surf = ...;
  double width, height;
  if ( surf-&gt;GetSurfaceSize( &amp;width, &amp;height ) )
  {
    srf-&gt;SetDomain( 0, ON_Interval( 0.0, width ) );
    srf-&gt;SetDomain( 1, ON_Interval( 0.0, height ) );
  }
</example>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Domain(System.Int32)">
            <param name="dir">0 gets first parameter's domain, 1 gets second parameter's domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetDomain(System.Int32,System.Double@,System.Double@)">
            <param name="dir">0 gets first parameter, 1 gets second parameter</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.CreateMesh(RMA.OpenNURBS.IOnMeshParameters)">
            <summary>Computes a polygon mesh approximation of the surface.</summary>
            <param name="mp">[in] meshing parameters</param>
            <returns>A polygon mesh of the surface.</returns>
            <remarks>
This virtual function works in the openNURBS that is part of the Rhino SDK.
The source code for this functionallity is not provided in the free openNURBS toolkit.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.CreateMesh(RMA.OpenNURBS.IOnMeshParameters,RMA.OpenNURBS.OnMesh)">
            <summary>Computes a polygon mesh approximation of the surface.</summary>
            <param name="mp">[in] meshing parameters</param>
            <param name="mesh">[in] if not NULL, the surface mesh will be put into this mesh.</param>
            <returns>A polygon mesh of the surface.</returns>
            <remarks>
This virtual function works in the openNURBS that is part of the Rhino SDK.
The source code for this functionallity is not provided in the free openNURBS toolkit.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.DuplicateSurface">
            <summary>Get a duplicate of the surface.</summary>
            <returns>A duplicate of the surface.</returns>
            <remarks>
The caller must delete the returned surface. For non-ON_SurfaceProxy objects,
this simply duplicates the surface using ON_Object::Duplicate.
For ON_SurfaceProxy objects, this duplicates the actual proxy surface geometry and,
if necessary, transposes the result to that the returned surfaces's
parameterization and locus match the proxy surface's.
</remarks>
        </member>
        <member name="T:RMA.OpenNURBS.IOnSurface.ISO">
            <summary>
flags for isoparametric curves
note: odd values are all "x" = constant
and even values &gt; 0 are all "y" = constant
ON_BrepTrim::m_iso uses these flags
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnRayShooter.Shoot(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOnSurfaceTreeNode[],RMA.OpenNURBS.OnX_EVENT@)">
            <summary>Shoot a ray at a surface or collection of surfaces.</summary>
            <param name="P">[in] start point</param>
            <param name="D">[in] direction of infinite ray</param>
            <param name="snode_list">[in]</param>
            <param name="hit">
[in/out] If hit.m_type = ON_X_EVENT::csx_point and 0.0 &lt; hit.m_a[0],
then a new hit will be returned only if it closer to the start of the ray.
</param>
            <returns>True if the ray hits a surface.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnRayShooter.Shoot(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOnSurfaceTreeNode,RMA.OpenNURBS.OnX_EVENT@)">
            <summary>Shoot a ray at a surface or collection of surfaces.</summary>
            <param name="P">[in] start point</param>
            <param name="D">[in] direction of infinite ray</param>
            <param name="snode">[in]</param>
            <param name="hit">
[in/out] If hit.m_type = ON_X_EVENT::csx_point and 0.0 &lt; hit.m_a[0],
then a new hit will be returned only if it closer to the start of the ray.
</param>
            <returns>True if the ray hits a surface.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnRayShooter.Shoot(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOnSurface[],RMA.OpenNURBS.OnX_EVENT@)">
            <summary>Shoot a ray at a surface or collection of surfaces.</summary>
            <param name="P">[in] start point</param>
            <param name="D">[in] direction of infinite ray</param>
            <param name="surface_list">[in]</param>
            <param name="hit">
[in/out] If hit.m_type = ON_X_EVENT::csx_point and 0.0 &lt; hit.m_a[0],
then a new hit will be returned only if it closer to the start of the ray.
</param>
            <returns>True if the ray hits a surface.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnRayShooter.Shoot(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.OnX_EVENT@)">
            <summary>Shoot a ray at a surface or collection of surfaces.</summary>
            <param name="P">[in] start point</param>
            <param name="D">[in] direction of infinite ray</param>
            <param name="surface">[in]</param>
            <param name="hit">
[in/out] If hit.m_type = ON_X_EVENT::csx_point and 0.0 &lt; hit.m_a[0],
then a new hit will be returned only if it closer to the start of the ray.
</param>
            <returns>True if the ray hits a surface.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnRayShooter.m_min_travel_distance">
            <value>
Minimum 3d distance the ray must travel from P
before an intersection is considered a hit.  
The default is zero.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnRayShooter.m_min_travel_distance">
            <value>
Minimum 3d distance the ray must travel from P
before an intersection is considered a hit.  
The default is zero.
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurfaceTree.NewLeaf">
            <summary>
Description: Expert user tool to get a surface tree leaf node. This node will be destroyed by this tree's destructor. Returns: A surface tree node with m_bez and m_bez-&gt;m_cv. Never delete or free the returned pointer, m_bez, or m_bez-&gt;m_cv.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurfaceTree.NewNode">
            <summary>
Description: Expert user tool to get a surface tree interior node. This node will be destroyed by this tree's destructor. Returns: A surface tree node. Never delete or free the returned pointer.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurfaceTree.DestroyTree">
            <summary>
Description: Destroy existing information. Leaves tree in a state where it can be reused for another curve.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurfaceTree.LastLeaf">
            <summary>
Last() returns the last leaf interval in the curve tree.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurfaceTree.FirstLeaf">
            <summary>
First() returns the first leaf interval in the curve tree.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurfaceTree.LastLeaf">
            <summary>
Last() returns the last leaf interval in the curve tree.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurfaceTree.FirstLeaf">
            <summary>
First() returns the first leaf interval in the curve tree.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurfaceTreeNode.IsNearSingularity(System.Double,System.Double)">
            <summary>
Description: Test normalized span parameters to see if they are near a singularity. Parameters: s0 - [in] 0 &lt;= s1 &lt;= 1 s1 - [in] 0 &lt;= s1 &lt;= 1 Returns: True if the parameters are near a singularity.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurfaceTreeNode.Split(System.Int32,System.Double,RMA.OpenNURBS.OnSurfaceTreeNode@,RMA.OpenNURBS.OnSurfaceTreeNode@)">
            <summary>
Description: Expert user tool to split a surface tree node. Does not modify this node's m_down[] pointers or left and right's m_up pointers. Care must be take to gaurd against memory leaks and double deletes. Parameters: dir - [in] 0 = split first parameter direction 1 = split second parameter direction s - [in] normalized (bezier parameter) 0 &lt; s &lt; 1 The cooresponding surface domain parameter is m_domain[dir].ParameterAt(s). left_node - [in] node to hold the left half. right_node - [in] node to hold the right half. Returns: True if input is valid and split was performed.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurfaceTreeNode.IsFartherThan(System.Double,RMA.OpenNURBS.IOnCurveTreeNode)">
            <summary>
Description: Quickly find an upper bound on the longest distance this surface node to the other object. Parameters: P - [in] other - [in] Returns: A distance that is greater than or equal to the longest distance from this surface node to the other object. Put another way, if Q is any point on the portion of the surface covered by this node and P is any point on the other object, then P.DistanceTo(Q) &lt;= MaximumDistanceTo(P);
</summary>
            <summary>
Description: Quickly determine if the shortest distance from the portion of the surface covered by this node to the other object is greater than d. Parameters: d - [in] distance (&gt; 0.0) P - [in] other - [in] Returns: True if if the shortest distance from this node to the other object is greater than d. Put another way, true if returned if for every point Q on the portion of the surface covered by this node and for every point P on the other object Q.DistanceTo(P) &gt; d. Remarks: This is conceptually the same but faster than calling MinimumDistanceUpperBound(other) &gt; d.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurfaceTreeNode.MinimumDistanceUpperBound(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Quickly find an upper bound on the shortest distance from this curve node to the other object. Parameters: P - [in] other - [in] Returns: A distance that is greater than or equal to the shortest distance from this surface node to the other object. Put another way, there exists a point Q on the portion of the surface covered by this node and a point P on the other object such that P.DistanceTo(Q) &lt;= MinimumDistanceUpperBound();
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurfaceTreeNode.MinimumDistanceLowerBound(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Quickly find a lower bound on the distance from a P to the portion of the curve covered by this node. Parameters: P - [in] Returns: A distance that is less than or equal to the shortest distance from P to a point on the curve covered by this node. Put another way, if Q is any point on the portion of the curve covered by this node, then P.DistanceTo(Q) &gt;= MinimumDistanceTo(P);
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurfaceTreeNode.SplitDir">
            <summary>
Description: Reports the direction this node was split or would be split. Parameters: Returns: 0: the node was split in the "u" direction 1: the node was split in the "v" direction -1: otherwise
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurfaceTreeNode.NorthNode">
            <summary>
For any SurfaceTreeNode, not just leafs, the NorthNode(), SouthNode(), EastNode()
and WestNode() functions returns a pointer to the SurfaceTreeNode of the neighboring
region.  For example, for any SurfaceTreeNode N with non-null N.NorthNode() we have 
the relations
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurfaceTreeNode.TreeContaining(RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>
Description: Find the smallest node that contains the specfied paramter range. Parameters: Urange - [in] Vrange - [in] Returns: A pointer to the smallest child node (possibly this) that contains the specified parameter range or NULL if no such node exists.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurfaceTreeNode.PrevLeaf">
            <summary>
Prev() moves to the previous leaf interval in the curve tree if this
node is a leaf node.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurfaceTreeNode.AdjustParameter">
            <summary>
Description: Used to determine if the node's parametization differs from the tree's surface parametization. If the parameterizations are different, then use ON_Surface::GetSurfaceParameterFromNurbFormParameter to convert node parameters to surface parameters and ON_Surface::GetNurbFormParameterFromSurfaceParameter to convert surface parameters to node parameters. Returns: True if the node's parametization differs from the tree's surface parametization. See Also: ON_Surface::GetSurfaceParameterFromNurbFormParameter ON_Surface::GetNurbFormParameterFromSurfaceParameter
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurfaceTreeNode.FindLeaf(System.Double,System.Double)">
            <summary>
Description: Starting at this node, find the leaf node whose domain contains that parameter (s,t). Parameters: t - [in] quadrant - [in] optional - 1,2,3 or 4 Determines which quadrant to use from when (s,t) is on the side of a leaf node. Values &lt; 1 or &gt; 4 are treated as 1 Returns: Pointer to the node that contains (s,t). If (s,t) is outside this node's domain, then the leaf closest to (s,t) is returned.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurfaceTreeNode.FindLeaf(System.Double,System.Double,System.Int32)">
            <summary>
Description: Starting at this node, find the leaf node whose domain contains that parameter (s,t). Parameters: t - [in] quadrant - [in] optional - 1,2,3 or 4 Determines which quadrant to use from when (s,t) is on the side of a leaf node. Values &lt; 1 or &gt; 4 are treated as 1 Returns: Pointer to the node that contains (s,t). If (s,t) is outside this node's domain, then the leaf closest to (s,t) is returned.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurfaceTreeNode.#ctor">
            <value>
1 = destroy with delete
2 = destroy with free
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnSurfaceTreeNode.m_bezmem">
            <value>
0 = do not destroy
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnSurfaceTreeNode.m_nodemem">
            <value>
0 = do not destroy
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnSurfaceTreeNode.m_nodetype">
            <value>
8 bits to flag special nodes
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnSurfaceTreeNode.m_nodesn">
            <value>
serial number of this node
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnSurfaceTreeNode.m_treesn">
            <value>
serial number of this tree
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnSurfaceTreeNode.m_bbox">
            <value>
m_domain records the portion of the surface's domain that
this node defines.  It is always increasing.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnSurfaceTreeNode.m_domain(System.Int32)">
            <value>
m_domain records the portion of the surface's domain that
this node defines.  It is always increasing.
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurfaceTreeNode.IsNearSingularity(System.Double,System.Double)">
            <summary>
Description: Expert user tool to split a surface tree node. Does not modify this node's m_down[] pointers or left and right's m_up pointers. Care must be take to gaurd against memory leaks and double deletes. Parameters: dir - [in] 0 = split first parameter direction 1 = split second parameter direction s - [in] normalized (bezier parameter) 0 &lt; s &lt; 1 The cooresponding surface domain parameter is m_domain[dir].ParameterAt(s). left_node - [in] node to hold the left half. right_node - [in] node to hold the right half. Returns: True if input is valid and split was performed.
</summary>
            <summary>
Description: Test normalized span parameters to see if they are near a singularity. Parameters: s0 - [in] 0 &lt;= s1 &lt;= 1 s1 - [in] 0 &lt;= s1 &lt;= 1 Returns: True if the parameters are near a singularity.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurfaceTreeNode.IsFartherThan(System.Double,RMA.OpenNURBS.IOnCurveTreeNode)">
            <summary>
Description: Quickly find an upper bound on the longest distance this surface node to the other object. Parameters: P - [in] other - [in] Returns: A distance that is greater than or equal to the longest distance from this surface node to the other object. Put another way, if Q is any point on the portion of the surface covered by this node and P is any point on the other object, then P.DistanceTo(Q) &lt;= MaximumDistanceTo(P);
</summary>
            <summary>
Description: Quickly determine if the shortest distance from the portion of the surface covered by this node to the other object is greater than d. Parameters: d - [in] distance (&gt; 0.0) P - [in] other - [in] Returns: True if if the shortest distance from this node to the other object is greater than d. Put another way, true if returned if for every point Q on the portion of the surface covered by this node and for every point P on the other object Q.DistanceTo(P) &gt; d. Remarks: This is conceptually the same but faster than calling MinimumDistanceUpperBound(other) &gt; d.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurfaceTreeNode.MinimumDistanceUpperBound(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Quickly find an upper bound on the shortest distance from this curve node to the other object. Parameters: P - [in] other - [in] Returns: A distance that is greater than or equal to the shortest distance from this surface node to the other object. Put another way, there exists a point Q on the portion of the surface covered by this node and a point P on the other object such that P.DistanceTo(Q) &lt;= MinimumDistanceUpperBound();
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurfaceTreeNode.MinimumDistanceLowerBound(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Quickly find a lower bound on the distance from a P to the portion of the curve covered by this node. Parameters: P - [in] Returns: A distance that is less than or equal to the shortest distance from P to a point on the curve covered by this node. Put another way, if Q is any point on the portion of the curve covered by this node, then P.DistanceTo(Q) &gt;= MinimumDistanceTo(P);
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurfaceTreeNode.SplitDir">
            <summary>
Description: Reports the direction this node was split or would be split. Parameters: Returns: 0: the node was split in the "u" direction 1: the node was split in the "v" direction -1: otherwise
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurfaceTreeNode.NorthNode">
            <summary>
For any SurfaceTreeNode, not just leafs, the NorthNode(), SouthNode(), EastNode()
and WestNode() functions returns a pointer to the SurfaceTreeNode of the neighboring
region.  For example, for any SurfaceTreeNode N with non-null N.NorthNode() we have 
the relations
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurfaceTreeNode.TreeContaining(RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>
Description: Find the smallest node that contains the specfied paramter range. Parameters: Urange - [in] Vrange - [in] Returns: A pointer to the smallest child node (possibly this) that contains the specified parameter range or NULL if no such node exists.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurfaceTreeNode.PrevLeaf">
            <summary>
Prev() moves to the previous leaf interval in the curve tree if this
node is a leaf node.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurfaceTreeNode.AdjustParameter">
            <summary>
Used to determine if the node's parametization differs from the tree's surface parametization.
If the parameterizations are different, then use ON_Surface::GetSurfaceParameterFromNurbFormParameter to
convert node parameters to surface parameters and ON_Surface::GetNurbFormParameterFromSurfaceParameter to convert surface parameters to node parameters. Returns: True if the node's parametization differs from the tree's surface parametization. See Also: ON_Surface::GetSurfaceParameterFromNurbFormParameter ON_Surface::GetNurbFormParameterFromSurfaceParameter
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurfaceTreeNode.FindLeaf(System.Double,System.Double)">
            <summary>
Description: Starting at this node, find the leaf node whose domain contains that parameter (s,t). Parameters: t - [in] quadrant - [in] optional - 1,2,3 or 4 Determines which quadrant to use from when (s,t) is on the side of a leaf node. Values &lt; 1 or &gt; 4 are treated as 1 Returns: Pointer to the node that contains (s,t). If (s,t) is outside this node's domain, then the leaf closest to (s,t) is returned.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurfaceTreeNode.FindLeaf(System.Double,System.Double,System.Int32)">
            <summary>
Description: Starting at this node, find the leaf node whose domain contains that parameter (s,t). Parameters: t - [in] quadrant - [in] optional - 1,2,3 or 4 Determines which quadrant to use from when (s,t) is on the side of a leaf node. Values &lt; 1 or &gt; 4 are treated as 1 Returns: Pointer to the node that contains (s,t). If (s,t) is outside this node's domain, then the leaf closest to (s,t) is returned.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurfaceTreeNode.IsValid(RMA.OpenNURBS.OnTextLog,System.Int32,System.Int32,RMA.OpenNURBS.IOnSurface)">
            <value>
1 = destroy with delete
2 = destroy with free
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnSurfaceTreeNode.m_bezmem">
            <value>
0 = do not destroy
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnSurfaceTreeNode.m_nodemem">
            <value>
0 = do not destroy
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnSurfaceTreeNode.m_nodetype">
            <value>
8 bits to flag special nodes
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnSurfaceTreeNode.m_nodesn">
            <value>
serial number of this node
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnSurfaceTreeNode.m_treesn">
            <value>
serial number of this tree
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnSurfaceTreeNode.m_bbox">
            <value>
m_domain records the portion of the surface's domain that
this node defines.  It is always increasing.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnSurfaceTreeNode.m_domain(System.Int32)">
            <value>
m_domain records the portion of the surface's domain that
this node defines.  It is always increasing.
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveArray.Append(RMA.OpenNURBS.IOnCurve)">
            <summary>
Adds a copy of a curve to this list. DuplicateCurve is called on the input curve and the duplicate
is saved in the CurveArray
</summary>
            <param name="curve">the curve to copy and add to the array</param>
            <returns>the duplicated curve that has been added to the array</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.AreaMassProperties(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.OnMassProperties@)">
            <summary>Calculate area mass properties of a curve. The curve should be planar.</summary>
            <param name="base_point">
[in] A point on the plane that contians the curve. To get the best results,
the point should be in the near the curve's centroid. When computing
the area, area centroid, or area first moments of a planar area whose boundary
is defined by several curves, pass the same base_point and plane_normal to each
call to AreaMassProperties. The base_point must be in the plane of the curves.
When computing the area second moments or area product moments of a planar area
whose boundary is defined by several curves, you MUST pass the entire area's
centroid as the base_point and the input mp parameter must contain the results of
a previous call to AreaMassProperties(mp,true,true,false,false,base_point). In
particular, in this case, you need to make two sets of calls; use first set to
calculate the area centroid and the second set calculate the second moments and
product moments.
</param>
            <param name="plane_normal">
[in] nonzero unit normal to the plane of integration. If a closed curve has
counter clock-wise orientation with respect to this normal, the area will be
positive. If the a closed curve has clock-wise orientation with respect to
this normal, the area will be negative.
</param>
            <param name="mp">[out]</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.AreaMassProperties(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.OnMassProperties@,System.Boolean)">
            <summary>Calculate area mass properties of a curve. The curve should be planar.</summary>
            <param name="base_point">
[in] A point on the plane that contians the curve. To get the best results,
the point should be in the near the curve's centroid. When computing
the area, area centroid, or area first moments of a planar area whose boundary
is defined by several curves, pass the same base_point and plane_normal to each
call to AreaMassProperties. The base_point must be in the plane of the curves.
When computing the area second moments or area product moments of a planar area
whose boundary is defined by several curves, you MUST pass the entire area's
centroid as the base_point and the input mp parameter must contain the results of
a previous call to AreaMassProperties(mp,true,true,false,false,base_point). In
particular, in this case, you need to make two sets of calls; use first set to
calculate the area centroid and the second set calculate the second moments and
product moments.
</param>
            <param name="plane_normal">
[in] nonzero unit normal to the plane of integration. If a closed curve has
counter clock-wise orientation with respect to this normal, the area will be
positive. If the a closed curve has clock-wise orientation with respect to
this normal, the area will be negative.
</param>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate volume</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.AreaMassProperties(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of a curve. The curve should be planar.</summary>
            <param name="base_point">
[in] A point on the plane that contians the curve. To get the best results,
the point should be in the near the curve's centroid. When computing
the area, area centroid, or area first moments of a planar area whose boundary
is defined by several curves, pass the same base_point and plane_normal to each
call to AreaMassProperties. The base_point must be in the plane of the curves.
When computing the area second moments or area product moments of a planar area
whose boundary is defined by several curves, you MUST pass the entire area's
centroid as the base_point and the input mp parameter must contain the results of
a previous call to AreaMassProperties(mp,true,true,false,false,base_point). In
particular, in this case, you need to make two sets of calls; use first set to
calculate the area centroid and the second set calculate the second moments and
product moments.
</param>
            <param name="plane_normal">
[in] nonzero unit normal to the plane of integration. If a closed curve has
counter clock-wise orientation with respect to this normal, the area will be
positive. If the a closed curve has clock-wise orientation with respect to
this normal, the area will be negative.
</param>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area, and area centroid.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.AreaMassProperties(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of a curve. The curve should be planar.</summary>
            <param name="base_point">
[in] A point on the plane that contians the curve. To get the best results,
the point should be in the near the curve's centroid. When computing
the area, area centroid, or area first moments of a planar area whose boundary
is defined by several curves, pass the same base_point and plane_normal to each
call to AreaMassProperties. The base_point must be in the plane of the curves.
When computing the area second moments or area product moments of a planar area
whose boundary is defined by several curves, you MUST pass the entire area's
centroid as the base_point and the input mp parameter must contain the results of
a previous call to AreaMassProperties(mp,true,true,false,false,base_point). In
particular, in this case, you need to make two sets of calls; use first set to
calculate the area centroid and the second set calculate the second moments and
product moments.
</param>
            <param name="plane_normal">
[in] nonzero unit normal to the plane of integration. If a closed curve has
counter clock-wise orientation with respect to this normal, the area will be
positive. If the a closed curve has clock-wise orientation with respect to
this normal, the area will be negative.
</param>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area, and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.AreaMassProperties(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of a curve. The curve should be planar.</summary>
            <param name="base_point">
[in] A point on the plane that contians the curve. To get the best results,
the point should be in the near the curve's centroid. When computing
the area, area centroid, or area first moments of a planar area whose boundary
is defined by several curves, pass the same base_point and plane_normal to each
call to AreaMassProperties. The base_point must be in the plane of the curves.
When computing the area second moments or area product moments of a planar area
whose boundary is defined by several curves, you MUST pass the entire area's
centroid as the base_point and the input mp parameter must contain the results of
a previous call to AreaMassProperties(mp,true,true,false,false,base_point). In
particular, in this case, you need to make two sets of calls; use first set to
calculate the area centroid and the second set calculate the second moments and
product moments.
</param>
            <param name="plane_normal">
[in] nonzero unit normal to the plane of integration. If a closed curve has
counter clock-wise orientation with respect to this normal, the area will be
positive. If the a closed curve has clock-wise orientation with respect to
this normal, the area will be negative.
</param>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area, and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <param name="bProductMoments">[in] true to calculate area product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.AreaMassProperties(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double)">
            <summary>Calculate area mass properties of a curve. The curve should be planar.</summary>
            <param name="base_point">
[in] A point on the plane that contians the curve. To get the best results,
the point should be in the near the curve's centroid. When computing
the area, area centroid, or area first moments of a planar area whose boundary
is defined by several curves, pass the same base_point and plane_normal to each
call to AreaMassProperties. The base_point must be in the plane of the curves.
When computing the area second moments or area product moments of a planar area
whose boundary is defined by several curves, you MUST pass the entire area's
centroid as the base_point and the input mp parameter must contain the results of
a previous call to AreaMassProperties(mp,true,true,false,false,base_point). In
particular, in this case, you need to make two sets of calls; use first set to
calculate the area centroid and the second set calculate the second moments and
product moments.
</param>
            <param name="plane_normal">
[in] nonzero unit normal to the plane of integration. If a closed curve has
counter clock-wise orientation with respect to this normal, the area will be
positive. If the a closed curve has clock-wise orientation with respect to
this normal, the area will be negative.
</param>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area, and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <param name="bProductMoments">[in] true to calculate area product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.AreaMassProperties(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double,System.Double)">
            <summary>Calculate area mass properties of a curve. The curve should be planar.</summary>
            <param name="base_point">
[in] A point on the plane that contians the curve. To get the best results,
the point should be in the near the curve's centroid. When computing
the area, area centroid, or area first moments of a planar area whose boundary
is defined by several curves, pass the same base_point and plane_normal to each
call to AreaMassProperties. The base_point must be in the plane of the curves.
When computing the area second moments or area product moments of a planar area
whose boundary is defined by several curves, you MUST pass the entire area's
centroid as the base_point and the input mp parameter must contain the results of
a previous call to AreaMassProperties(mp,true,true,false,false,base_point). In
particular, in this case, you need to make two sets of calls; use first set to
calculate the area centroid and the second set calculate the second moments and
product moments.
</param>
            <param name="plane_normal">
[in] nonzero unit normal to the plane of integration. If a closed curve has
counter clock-wise orientation with respect to this normal, the area will be
positive. If the a closed curve has clock-wise orientation with respect to
this normal, the area will be negative.
</param>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area, and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <param name="bProductMoments">[in] true to calculate area product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.LengthMassProperties(RMA.OpenNURBS.OnMassProperties@)">
            <summary>Calculate length mass properties of the curve.</summary>
            <param name="mp">[out]</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.LengthMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean)">
            <summary>Calculate length mass properties of the curve.</summary>
            <param name="mp">[out]</param>
            <param name="bLength">[in] true to calculate length</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.LengthMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean)">
            <summary>Calculate length mass properties of the curve.</summary>
            <param name="mp">[out]</param>
            <param name="bLength">[in] true to calculate length</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, length, and length centroid.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.LengthMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate length mass properties of the curve.</summary>
            <param name="mp">[out]</param>
            <param name="bLength">[in] true to calculate length</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, length, and length centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate length second moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.LengthMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate length mass properties of the curve.</summary>
            <param name="mp">[out]</param>
            <param name="bLength">[in] true to calculate length</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, length, and length centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate length second moments.</param>
            <param name="bProductMoments">[in] true to calculate length product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.LengthMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double)">
            <summary>Calculate length mass properties of the curve.</summary>
            <param name="mp">[out]</param>
            <param name="bLength">[in] true to calculate length</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, length, and length centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate length second moments.</param>
            <param name="bProductMoments">[in] true to calculate length product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.LengthMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double,System.Double)">
            <summary>Calculate length mass properties of the curve.</summary>
            <param name="mp">[out]</param>
            <param name="bLength">[in] true to calculate length</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, length, and length centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate length second moments.</param>
            <param name="bProductMoments">[in] true to calculate length product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.CurveTree">
            <summary>
Get the runtime curve tree used to speed closest point
and intersection calcuations.
</summary>
            <returns>Pointer to the curve tree.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.DestroyCurveTree">
            <summary>
Destroys the runtime curve tree used to speed closest
point and intersection calcuations.
</summary>
            <remarks>
If the geometry of the curve is modified in any way,
then call DestroyCurveTree();  The curve tree is 
created as needed.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetNurbFormParameterFromCurveParameter(System.Double,System.Double@)">
            <summary>Convert a curve parameter to a NURBS curve parameter.</summary>
            <param name="curve_t">[in] curve parameter</param>
            <param name="nurbs_t">[out] nurbs form parameter</param>
            <remarks>
If GetNurbForm returns 2, this function converts the curve
parameter to the NURBS curve parameter.
See Also:
 ON_Curve::GetNurbForm, ON_Curve::GetCurveParameterFromNurbFormParameter
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetCurveParameterFromNurbFormParameter(System.Double,System.Double@)">
            <summary>Convert a NURBS curve parameter to a curve parameter</summary>
            <param name="nurbs_t">[in] nurbs form parameter</param>
            <param name="curve_t">[out] curve parameter</param>
            <remarks>
If GetNurbForm returns 2, this function converts the curve
parameter to the NURBS curve parameter.
See Also:
ON_Curve::GetNurbForm, ON_Curve::GetNurbFormParameterFromCurveParameter
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.NurbsCurve">
            <summary>Get a NURBS curve representation of this curve.</summary>
            <returns>NULL or a NURBS representation of the curve.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Curve::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.NurbsCurve(RMA.OpenNURBS.OnNurbsCurve)">
            <summary>Get a NURBS curve representation of this curve.</summary>
            <param name="pNurbsCurve">
[in/out] if not NULL, this ON_NurbsCurve will be used to store the NURBS representation
of the curve will be returned.
</param>
            <returns>NULL or a NURBS representation of the curve.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Curve::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.NurbsCurve(RMA.OpenNURBS.OnNurbsCurve,System.Double)">
            <summary>Get a NURBS curve representation of this curve.</summary>
            <param name="pNurbsCurve">
[in/out] if not NULL, this ON_NurbsCurve will be used to store the NURBS representation
of the curve will be returned.
</param>
            <param name="tolerance">[in] tolerance to use when creating NURBS representation.</param>
            <returns>NULL or a NURBS representation of the curve.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Curve::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.NurbsCurve(RMA.OpenNURBS.OnNurbsCurve,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a NURBS curve representation of this curve.</summary>
            <param name="pNurbsCurve">
[in/out] if not NULL, this ON_NurbsCurve will be used to store the NURBS representation
of the curve will be returned.
</param>
            <param name="tolerance">[in] tolerance to use when creating NURBS representation.</param>
            <param name="subdomain">
[in] if not NULL, then the NURBS representation for this portion of the curve is returned.
</param>
            <returns>NULL or a NURBS representation of the curve.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Curve::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.HasNurbForm">
            <summary>Does a NURBS curve representation of this curve.</summary>
            <returns>
0 unable to create NURBS representation with desired accuracy.
1 success - NURBS parameterization matches the curve's to wthe desired accuracy
2 success - NURBS point locus matches the curve's and the domain of the NURBS curve is correct.
           However, This curve's parameterization and the NURBS curve parameterization may not
           match. This situation happens when getting NURBS representations of curves that have a
           transendental parameterization like circles
</returns>
            <remarks>
This is a low-level virtual function.
See Also: ON_Curve::GetNurbForm ON_Curve::NurbsCurve
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetNurbForm(RMA.OpenNURBS.OnNurbsCurve@)">
            <summary>Get a NURBS curve representation of this curve.</summary>
            <param name="nurbs_curve">[out] NURBS representation returned here</param>
            <returns>
0 unable to create NURBS representation with desired accuracy.
1 success - returned NURBS parameterization matches the curve's to wthe desired accuracy
2 success - returned NURBS point locus matches the curve's to the desired accuracy and
           the domain of the NURBS curve is correct. On However, This curve's parameterization
           and the NURBS curve parameterization may not match to the desired accuracy. This
           situation happens when getting NURBS representations of curves that have a transendental
           parameterization like circles Remarks: This is a low-level virtual function. If you do
           not need the parameterization information provided by the return code, then
           ON_Curve::NurbsCurve may be easier to use.
See Also: ON_Curve::NurbsCurve
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetNurbForm(RMA.OpenNURBS.OnNurbsCurve@,System.Double)">
            <summary>Get a NURBS curve representation of this curve.</summary>
            <param name="nurbs_curve">[out] NURBS representation returned here</param>
            <param name="tolerance">[in] tolerance to use when creating NURBS representation.</param>
            <returns>
0 unable to create NURBS representation with desired accuracy.
1 success - returned NURBS parameterization matches the curve's to wthe desired accuracy
2 success - returned NURBS point locus matches the curve's to the desired accuracy and
           the domain of the NURBS curve is correct. On However, This curve's parameterization
           and the NURBS curve parameterization may not match to the desired accuracy. This
           situation happens when getting NURBS representations of curves that have a transendental
           parameterization like circles Remarks: This is a low-level virtual function. If you do
           not need the parameterization information provided by the return code, then
           ON_Curve::NurbsCurve may be easier to use.
See Also: ON_Curve::NurbsCurve
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetNurbForm(RMA.OpenNURBS.OnNurbsCurve@,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a NURBS curve representation of this curve.</summary>
            <param name="nurbs_curve">[out] NURBS representation returned here</param>
            <param name="tolerance">[in] tolerance to use when creating NURBS representation.</param>
            <param name="subdomain">
[in] if not NULL, then the NURBS representation for this portion of the curve is returned.
</param>
            <returns>
0 unable to create NURBS representation with desired accuracy.
1 success - returned NURBS parameterization matches the curve's to wthe desired accuracy
2 success - returned NURBS point locus matches the curve's to the desired accuracy and
           the domain of the NURBS curve is correct. On However, This curve's parameterization
           and the NURBS curve parameterization may not match to the desired accuracy. This
           situation happens when getting NURBS representations of curves that have a transendental
           parameterization like circles Remarks: This is a low-level virtual function. If you do
           not need the parameterization information provided by the return code, then
           ON_Curve::NurbsCurve may be easier to use.
See Also: ON_Curve::NurbsCurve
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.Split(System.Double,RMA.OpenNURBS.OnCurve@,RMA.OpenNURBS.OnCurve@)">
            <summary>
Splits (divides) the curve at the specified parameter. The parameter must be
in the interior of the curve's domain. The pointers passed to Split must
either be NULL or point to an ON_Curve object of the same type. If the pointer
is NULL, then a curve will be created in Split(). You may pass "this"
as left_side or right_side.
</summary>
            <param name="t">[in] parameter to split the curve at in the interval returned by Domain().</param>
            <param name="left_side">[out] left portion of curve returned here</param>
            <param name="right_side">[out] right portion of curve returned here</param>
            <returns>
TRUE - The curve was split into two pieces.
FALSE - The curve could not be split. For example if the parameter is too close to an endpoint.
</returns>
            <example>
For example, if crv were an ON_NurbsCurve, then
  ON_NurbsCurve right_side;
  crv.Split( crv.Domain().Mid() &amp;crv, &amp;right_side );
would split crv at the parametric midpoint, put the left side in crv, and return the right side in right_side.
</example>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.Extend(RMA.OpenNURBS.IOnInterval)">
            <summary>
Pure virtual function. Default returns false.
Where possible, analytically extends curve to include domain.
</summary>
            <param name="domain">
[in] if domain is not included in curve domain, curve will be extended so
that its domain includes domain. Will not work if curve is closed.
Original curve is identical to the restriction of the resulting curve to
the original curve domain, 
</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.Trim(RMA.OpenNURBS.IOnInterval)">
            <summary>Removes portions of the curve outside the specified interval.</summary>
            <param name="domain">
[in] interval of the curve to keep.  Portions of the curve before
curve(domain[0]) and after curve(domain[1]) are removed.
</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetNormalizedArcLengthPoints(System.Double[],System.Double[]@)">
            <summary>
Get the parameter of the point on the curve that is a prescribed arc length from the start of the curve.
</summary>
            <param name="s">
[in] array of normalized arc length parameters.
E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.
</param>
            <param name="t">
[out] array of curve parameters such that the length of the curve from its
start to t[i] is s[i]*curve_length.
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetNormalizedArcLengthPoints(System.Double[],System.Double[]@,System.Double)">
            <summary>
Get the parameter of the point on the curve that is a prescribed arc length from the start of the curve.
</summary>
            <param name="s">
[in] array of normalized arc length parameters.
E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.
</param>
            <param name="t">
[out] array of curve parameters such that the length of the curve from its
start to t[i] is s[i]*curve_length.
</param>
            <param name="absolute_tolerance">
[in] if absolute_tolerance &gt; 0, then the difference between (s[i+1]-s[i])*curve_length
and the length of the curve segment from t[i] to t[i+1] will be &lt;= absolute_tolerance.
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetNormalizedArcLengthPoints(System.Double[],System.Double[]@,System.Double,System.Double)">
            <summary>
Get the parameter of the point on the curve that is a prescribed arc length from the start of the curve.
</summary>
            <param name="s">
[in] array of normalized arc length parameters.
E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.
</param>
            <param name="t">
[out] array of curve parameters such that the length of the curve from its
start to t[i] is s[i]*curve_length.
</param>
            <param name="absolute_tolerance">
[in] if absolute_tolerance &gt; 0, then the difference between (s[i+1]-s[i])*curve_length
and the length of the curve segment from t[i] to t[i+1] will be &lt;= absolute_tolerance.
</param>
            <param name="fractional_tolerance">
[in] desired fractional precision for each segment.
fabs("true" length - actual length)/(actual length) &lt;= fractional_tolerance
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetNormalizedArcLengthPoints(System.Double[],System.Double[]@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>
Get the parameter of the point on the curve that is a prescribed arc length from the start of the curve.
</summary>
            <param name="s">
[in] array of normalized arc length parameters.
E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.
</param>
            <param name="t">
[out] array of curve parameters such that the length of the curve from its
start to t[i] is s[i]*curve_length.
</param>
            <param name="absolute_tolerance">
[in] if absolute_tolerance &gt; 0, then the difference between (s[i+1]-s[i])*curve_length
and the length of the curve segment from t[i] to t[i+1] will be &lt;= absolute_tolerance.
</param>
            <param name="fractional_tolerance">
[in] desired fractional precision for each segment.
fabs("true" length - actual length)/(actual length) &lt;= fractional_tolerance
</param>
            <param name="sub_domain">
[in] If not NULL, the calculation is performed on the specified sub-domain of the curve.
A 0.0 s value corresponds to sub_domain-&gt;Min() and a 1.0 s value corresponds to
sub_domain-&gt;Max().
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetNormalizedArcLengthPoint(System.Double,System.Double@)">
            <summary>
Get the parameter of the point on the curve that is a prescribed arc length from the start of the curve.
</summary>
            <param name="s">
[in] normalized arc length parameter.
E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.
</param>
            <param name="t">[out] parameter such that the length of the curve from its start to t is arc_length.</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetNormalizedArcLengthPoint(System.Double,System.Double@,System.Double)">
            <summary>
Get the parameter of the point on the curve that is a prescribed arc length from the start of the curve.
</summary>
            <param name="s">
[in] normalized arc length parameter.
E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.
</param>
            <param name="t">[out] parameter such that the length of the curve from its start to t is arc_length.</param>
            <param name="fractional_tolerance">
[in] desired fractional precision.
fabs(("exact" length from start to t) - arc_length)/arc_length &lt;= fractional_tolerance
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetNormalizedArcLengthPoint(System.Double,System.Double@,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>
Get the parameter of the point on the curve that is a prescribed arc length from the start of the curve.
</summary>
            <param name="s">
[in] normalized arc length parameter.
E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.
</param>
            <param name="t">[out] parameter such that the length of the curve from its start to t is arc_length.</param>
            <param name="fractional_tolerance">
[in] desired fractional precision.
fabs(("exact" length from start to t) - arc_length)/arc_length &lt;= fractional_tolerance
</param>
            <param name="sub_domain">
[in] If not NULL, the calculation is performed on the specified sub-domain of the curve.
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.RemoveShortSegments(System.Double)">
            <summary>
Looks for segments that are shorter than tolerance that can be removed.
If bRemoveShortSegments is true, then the short segments are removed.
Does not change the domain, but it will change the relative parameterization.
</summary>
            <param name="tolerance">[in]</param>
            <returns>
True if removable short segments can were found.
False if no removable short segments can were found.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.RemoveShortSegments(System.Double,System.Boolean)">
            <summary>
Looks for segments that are shorter than tolerance that can be removed.
If bRemoveShortSegments is true, then the short segments are removed.
Does not change the domain, but it will change the relative parameterization.
</summary>
            <param name="tolerance">[in]</param>
            <param name="bRemoveShortSegments">[in] If true, then short segments are removed.</param>
            <returns>
True if removable short segments can were found.
False if no removable short segments can were found.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsShort(System.Double)">
            <summary>Used to quickly find short curves.</summary>
            <param name="tolerance">[in] (&gt;=0)</param>
            <returns>True if the length of the curve is &lt;= tolerance.</returns>
            <remarks>Faster than calling Length() and testing the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsShort(System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Used to quickly find short curves.</summary>
            <param name="tolerance">[in] (&gt;=0)</param>
            <param name="sub_domain">
[in] If not NULL, the test is performed on the interval that is the intersection
of sub_domain with Domain().
</param>
            <returns>True if the length of the curve is &lt;= tolerance.</returns>
            <remarks>Faster than calling Length() and testing the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetLength(System.Double@)">
            <summary>Get the length of the curve.</summary>
            <param name="length">[out] length returned here.</param>
            <returns>
TRUE if returned if the length calculation is successful.
FALSE is returned if the length is not calculated.
</returns>
            <remarks>
The arc length will be computed so that (returned length - real length)/(real length) &lt;= fractional_tolerance
More simply, if you want N significant figures in the answer, set the fractional_tolerance to 1.0e-N.
For "nice" curves, 1.0e-8 works fine. For very high degree NURBS and NURBS with bad
parametrizations, use larger values of fractional_tolerance.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetLength(System.Double@,System.Double)">
            <summary>Get the length of the curve.</summary>
            <param name="length">[out] length returned here.</param>
            <param name="fractional_tolerance">
[in] desired fractional precision.
fabs(("exact" length from start to t) - arc_length)/arc_length &lt;= fractional_tolerance
</param>
            <returns>
TRUE if returned if the length calculation is successful.
FALSE is returned if the length is not calculated.
</returns>
            <remarks>
The arc length will be computed so that (returned length - real length)/(real length) &lt;= fractional_tolerance
More simply, if you want N significant figures in the answer, set the fractional_tolerance to 1.0e-N.
For "nice" curves, 1.0e-8 works fine. For very high degree NURBS and NURBS with bad
parametrizations, use larger values of fractional_tolerance.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetLength(System.Double@,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Get the length of the curve.</summary>
            <param name="length">[out] length returned here.</param>
            <param name="fractional_tolerance">
[in] desired fractional precision.
fabs(("exact" length from start to t) - arc_length)/arc_length &lt;= fractional_tolerance
</param>
            <param name="sub_domain">
[in] If not NULL, the calculation is performed on the specified sub-domain of
the curve (must be non-decreasing)
</param>
            <returns>
TRUE if returned if the length calculation is successful.
FALSE is returned if the length is not calculated.
</returns>
            <remarks>
The arc length will be computed so that (returned length - real length)/(real length) &lt;= fractional_tolerance
More simply, if you want N significant figures in the answer, set the fractional_tolerance to 1.0e-N.
For "nice" curves, 1.0e-8 works fine. For very high degree NURBS and NURBS with bad
parametrizations, use larger values of fractional_tolerance.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@)">
            <summary>Intersect this curve with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double)">
            <summary>Intersect this curve with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double)">
            <summary>Intersect this curve with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and the distance from curve(t)
to the surface is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then the event will
be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0,
then intersection_tolerance*2.0 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this curve with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and the distance from curve(t)
to the surface is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then the event will
be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0,
then intersection_tolerance*2.0 is used.
</param>
            <param name="curveA_domain">[in] optional restriction on this curve's domain</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this curve with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and the distance from curve(t)
to the surface is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then the event will
be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0,
then intersection_tolerance*2.0 is used.
</param>
            <param name="curveA_domain">[in] optional restriction on this curve's domain</param>
            <param name="surfaceB_udomain">[in] optional restriction on surfaceB u domain</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this curve with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and the distance from curve(t)
to the surface is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then the event will
be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0,
then intersection_tolerance*2.0 is used.
</param>
            <param name="curveA_domain">[in] optional restriction on this curve's domain</param>
            <param name="surfaceB_udomain">[in] optional restriction on surfaceB u domain</param>
            <param name="surfaceB_vdomain">[in] optional restriction on surfaceB v domain</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IntersectCurve(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.ArrayOnX_EVENT@)">
            <summary>Intersect this curve with curveB.</summary>
            <param name="curveB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IntersectCurve(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double)">
            <summary>Intersect this curve with curveB.</summary>
            <param name="curveB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to curveB is &lt;= intersection tolerance,
then the point will be part of an intersection event.
If the input intersection_tolerance &lt;= 0.0, then 0.001 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IntersectCurve(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double)">
            <summary>Intersect this curve with curveB.</summary>
            <param name="curveB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to curveB is &lt;= intersection tolerance,
then the point will be part of an intersection event.
If the input intersection_tolerance &lt;= 0.0, then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are parameters of this curve's intersection events
and the distance from curve(t) to curveB is &lt;= overlap_tolerance for
every t1 &lt;= t &lt;= t2, then the event will be returened as an overlap event.
If the input overlap_tolerance &lt;= 0.0, then intersection_tolerance*2.0 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IntersectCurve(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this curve with curveB.</summary>
            <param name="curveB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to curveB is &lt;= intersection tolerance,
then the point will be part of an intersection event.
If the input intersection_tolerance &lt;= 0.0, then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are parameters of this curve's intersection events
and the distance from curve(t) to curveB is &lt;= overlap_tolerance for
every t1 &lt;= t &lt;= t2, then the event will be returened as an overlap event.
If the input overlap_tolerance &lt;= 0.0, then intersection_tolerance*2.0 is used.
</param>
            <param name="curveA_domain">[in] optional restriction on this curve's domain</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IntersectCurve(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this curve with curveB.</summary>
            <param name="curveB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to curveB is &lt;= intersection tolerance,
then the point will be part of an intersection event.
If the input intersection_tolerance &lt;= 0.0, then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are parameters of this curve's intersection events
and the distance from curve(t) to curveB is &lt;= overlap_tolerance for
every t1 &lt;= t &lt;= t2, then the event will be returened as an overlap event.
If the input overlap_tolerance &lt;= 0.0, then intersection_tolerance*2.0 is used.
</param>
            <param name="curveA_domain">[in] optional restriction on this curve's domain</param>
            <param name="curveB_domain">[in] optional restriction on curveB domain</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IntersectSelf(RMA.OpenNURBS.ArrayOnX_EVENT@)">
            <summary>Find curve's self intersection points.</summary>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IntersectSelf(RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double)">
            <summary>Find curve's self intersection points.</summary>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">[in]</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IntersectSelf(RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Find curve's self intersection points.</summary>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">[in]</param>
            <param name="curve_domain">[in] optional restriction</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double@)">
            <summary>
Find parameter of the point on a curve that is locally closest to 
the test_point.  The search for a local close point starts at 
seed_parameter. If the sub_domain parameter is not NULL, then
the search is restricted to the specified portion of the curve.
</summary>
            <returns>
TRUE if returned if the search is successful.  FALSE is returned if
the search fails.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double@,RMA.OpenNURBS.IOnInterval)">
            <summary>
Find parameter of the point on a curve that is locally closest to 
the test_point.  The search for a local close point starts at 
seed_parameter. If the sub_domain parameter is not NULL, then
the search is restricted to the specified portion of the curve.
</summary>
            <returns>
TRUE if returned if the search is successful.  FALSE is returned if
the search fails.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>
Find parameter of the point on a curve that is closest to test_point.
If the maximum_distance parameter is &gt; 0, then only points whose distance
to the given point is &lt;= maximum_distance will be returned.  Using a 
positive value of maximum_distance can substantially speed up the search.
If the sub_domain parameter is not NULL, then the search is restricted
to the specified portion of the curve.
</summary>
            <returns>
TRUE if returned if the search is successful.  FALSE is returned if
the search fails.
</returns>
            <param name="t">parameter of local closest point returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double)">
            <summary>
Find parameter of the point on a curve that is closest to test_point.
If the maximum_distance parameter is &gt; 0, then only points whose distance
to the given point is &lt;= maximum_distance will be returned.  Using a 
positive value of maximum_distance can substantially speed up the search.
If the sub_domain parameter is not NULL, then the search is restricted
to the specified portion of the curve.
</summary>
            <returns>
TRUE if returned if the search is successful.  FALSE is returned if
the search fails.
</returns>
            <param name="t">parameter of local closest point returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>
Find parameter of the point on a curve that is closest to test_point.
If the maximum_distance parameter is &gt; 0, then only points whose distance
to the given point is &lt;= maximum_distance will be returned.  Using a 
positive value of maximum_distance can substantially speed up the search.
If the sub_domain parameter is not NULL, then the search is restricted
to the specified portion of the curve.
</summary>
            <returns>
TRUE if returned if the search is successful.  FALSE is returned if
the search fails.
</returns>
            <param name="t">parameter of local closest point returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.EvCurvature(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate unit tangent and curvature at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="tangent">[out] value of unit tangent</param>
            <param name="kappa">[out] value of curvature vector</param>
            <returns>
FALSE if unable to evaluate.
See Also: ON_Curve::CurvatureAt ON_Curve::Ev2Der ON_EvCurvature
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.EvCurvature(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>Evaluate unit tangent and curvature at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="tangent">[out] value of unit tangent</param>
            <param name="kappa">[out] value of curvature vector</param>
            <param name="side">
[in] optional - determines which side to evaluate from
=0 default
&lt;0 to evaluate from below,
&gt;0 to evaluate from above
</param>
            <returns>
FALSE if unable to evaluate.
See Also: ON_Curve::CurvatureAt ON_Curve::Ev2Der ON_EvCurvature
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.EvCurvature(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,System.Int32,System.Int32@)">
            <summary>Evaluate unit tangent and curvature at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="tangent">[out] value of unit tangent</param>
            <param name="kappa">[out] value of curvature vector</param>
            <param name="side">
[in] optional - determines which side to evaluate from
=0 default
&lt;0 to evaluate from below,
&gt;0 to evaluate from above
</param>
            <param name="hint">[in/out] optional evaluation hint used to speed repeated evaluations</param>
            <returns>
FALSE if unable to evaluate.
See Also: ON_Curve::CurvatureAt ON_Curve::Ev2Der ON_EvCurvature
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.EvTangent(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate unit tangent at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="tangent">[out] value of unit tangent</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>See Also: ON_Curve::TangentAt ON_Curve::Ev1Der</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.EvTangent(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>Evaluate unit tangent at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="tangent">[out] value of unit tangent</param>
            <param name="side">
[in] optional - determines which side to evaluate from
=0 default
&lt;0 to evaluate from below,
&gt;0 to evaluate from above
</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>See Also: ON_Curve::TangentAt ON_Curve::Ev1Der</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.EvTangent(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,System.Int32,System.Int32@)">
            <summary>Evaluate unit tangent at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="tangent">[out] value of unit tangent</param>
            <param name="side">
[in] optional - determines which side to evaluate from
=0 default
&lt;0 to evaluate from below,
&gt;0 to evaluate from above
</param>
            <param name="hint">[in/out] optional evaluation hint used to speed repeated evaluations</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>See Also: ON_Curve::TangentAt ON_Curve::Ev1Der</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.Ev2Der(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate second derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="first_derivative">[out] value of first derivative at t</param>
            <param name="second_derivative">[out] value of second derivative at t</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
ON_Curve::Ev1Der
ON_Curve::EvCurvature
ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.Ev2Der(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>Evaluate second derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="first_derivative">[out] value of first derivative at t</param>
            <param name="second_derivative">[out] value of second derivative at t</param>
            <param name="side">
[in] optional - determines which side to evaluate from
=0   default
&lt;0   to evaluate from below, 
&gt;0   to evaluate from above
</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
ON_Curve::Ev1Der
ON_Curve::EvCurvature
ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.Ev2Der(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,System.Int32,System.Int32@)">
            <summary>Evaluate second derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="first_derivative">[out] value of first derivative at t</param>
            <param name="second_derivative">[out] value of second derivative at t</param>
            <param name="side">
[in] optional - determines which side to evaluate from
=0   default
&lt;0   to evaluate from below, 
&gt;0   to evaluate from above
</param>
            <param name="hint">[in/out] optional evaluation hint used to speed repeated evaluations</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
ON_Curve::Ev1Der
ON_Curve::EvCurvature
ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.Ev1Der(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate first derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="first_derivative">[out] value of first derivative at t</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
 ON_Curve::EvPoint
 ON_Curve::Ev2Der
 ON_Curve::EvTangent
 ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.Ev1Der(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>Evaluate first derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="first_derivative">[out] value of first derivative at t</param>
            <param name="side">
[in] optional - determines which side to evaluate from
   =0   default
&lt;0   to evaluate from below, 
&gt;0   to evaluate from above
</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
 ON_Curve::EvPoint
 ON_Curve::Ev2Der
 ON_Curve::EvTangent
 ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.Ev1Der(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,System.Int32,System.Int32@)">
            <summary>Evaluate first derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="first_derivative">[out] value of first derivative at t</param>
            <param name="side">
[in] optional - determines which side to evaluate from
   =0   default
&lt;0   to evaluate from below, 
&gt;0   to evaluate from above
</param>
            <param name="hint">[in/out] optional evaluation hint used to speed repeated evaluations</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
 ON_Curve::EvPoint
 ON_Curve::Ev2Der
 ON_Curve::EvTangent
 ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.EvPoint(System.Double,RMA.OpenNURBS.On3dPoint@)">
            <summary>Evaluate point at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
 ON_Curve::PointAt
 ON_Curve::EvTangent
 ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.EvPoint(System.Double,RMA.OpenNURBS.On3dPoint@,System.Int32)">
            <summary>Evaluate point at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="side">
[in] optional - determines which side to evaluate from
    =0   default
 &lt;0   to evaluate from below, 
 &gt;0   to evaluate from above
</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
 ON_Curve::PointAt
 ON_Curve::EvTangent
 ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.EvPoint(System.Double,RMA.OpenNURBS.On3dPoint@,System.Int32,System.Int32@)">
            <summary>Evaluate point at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="side">
[in] optional - determines which side to evaluate from
    =0   default
 &lt;0   to evaluate from below, 
 &gt;0   to evaluate from above
</param>
            <param name="hint">[in/out] optional evaluation hint used to speed repeated evaluations</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
 ON_Curve::PointAt
 ON_Curve::EvTangent
 ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.FrameAt(System.Double,RMA.OpenNURBS.OnPlane@)">
            <summary>Return a 3d frame at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="plane">[out] the frame is returned here</param>
            <returns>TRUE if successful</returns>
            <remarks>
See Also:
 ON_Curve::PointAt, ON_Curve::TangentAt,
 ON_Curve::Ev1Der, Ev2Der
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.CurvatureAt(System.Double)">
            <summary>Evaluate the curvature vector at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <returns>curvature vector of the curve at the parameter t.</returns>
            <remarks>
No error handling.
See Also:
 ON_Curve::EvCurvature
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.TangentAt(System.Double)">
            <summary>Evaluate unit tangent vector at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <returns>Unit tangent vector of the curve at the parameter t.</returns>
            <remarks>
No error handling.
See Also:
 ON_Curve::EvTangent
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.DerivativeAt(System.Double)">
            <summary>Evaluate first derivative at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <returns>First derivative of the curve at the parameter t.</returns>
            <remarks>
No error handling.
See Also:
ON_Curve::Ev1Der
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.PointAtEnd">
            <summary>Evaluate point at the end of the curve.</summary>
            <returns>Point (location of the end of the curve.)</returns>
            <remarks>
No error handling.
See Also:
ON_Curve::PointAt
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.PointAtStart">
            <summary>Evaluate point at the start of the curve.</summary>
            <returns>Point (location of the start of the curve.)</returns>
            <remarks>
No error handling.
See Also:
ON_Curve::PointAt
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.PointAt(System.Double)">
            <summary>Evaluate point at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <returns>Point (location of curve at the parameter t).</returns>
            <remarks>
No error handling.
See Also:
ON_Curve::EvPoint
ON_Curve::PointAtStart
ON_Curve::PointAtEnd
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.SetEndPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Force the curve to end at a specified point.</summary>
            <param name="end_point">[in]</param>
            <returns>TRUE if successful.</returns>
            <remarks>
Some end points cannot be moved. Be sure to check return code.
See Also: ON_Curve::SetStartPoint ON_Curve::PointAtStart ON_Curve::PointAtEnd
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.SetStartPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Force the curve to start at a specified point.</summary>
            <param name="start_point">[in]</param>
            <returns>TRUE if successful.</returns>
            <remarks>
Some end points cannot be moved. Be sure to check return code.
See Also: ON_Curve::SetEndPoint ON_Curve::PointAtStart ON_Curve::PointAtEnd
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.Reverse">
            <summary>Reverse the direction of the curve.</summary>
            <returns>TRUE if curve was reversed.</returns>
            <remarks>If reveresed, the domain changes from [a,b] to [-b,-a]</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double)">
            <summary>Test continuity at a curve parameter value.</summary>
            <param name="c">[in] type of continuity to test for. Read ON::continuity comments for details.</param>
            <param name="t">[in] parameter to test</param>
            <returns>TRUE if the curve has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Int32@)">
            <summary>Test continuity at a curve parameter value.</summary>
            <param name="c">[in] type of continuity to test for. Read ON::continuity comments for details.</param>
            <param name="t">[in] parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <returns>TRUE if the curve has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Int32@,System.Double)">
            <summary>Test continuity at a curve parameter value.</summary>
            <param name="c">[in] type of continuity to test for. Read ON::continuity comments for details.</param>
            <param name="t">[in] parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance, then the curve is not C0.
</param>
            <returns>TRUE if the curve has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Int32@,System.Double,System.Double)">
            <summary>Test continuity at a curve parameter value.</summary>
            <param name="c">[in] type of continuity to test for. Read ON::continuity comments for details.</param>
            <param name="t">[in] parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance, then the curve is not C0.
</param>
            <param name="d1_tolerance">
[in] if the difference between two first derivatives is greater than d1_tolerance, then the curve is not C1.
</param>
            <returns>TRUE if the curve has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Int32@,System.Double,System.Double,System.Double)">
            <summary>Test continuity at a curve parameter value.</summary>
            <param name="c">[in] type of continuity to test for. Read ON::continuity comments for details.</param>
            <param name="t">[in] parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance, then the curve is not C0.
</param>
            <param name="d1_tolerance">
[in] if the difference between two first derivatives is greater than d1_tolerance, then the curve is not C1.
</param>
            <param name="d2_tolerance">
[in] if the difference between two second derivatives is greater than d2_tolerance, then the curve is not C2.
</param>
            <returns>TRUE if the curve has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Int32@,System.Double,System.Double,System.Double,System.Double)">
            <summary>Test continuity at a curve parameter value.</summary>
            <param name="c">[in] type of continuity to test for. Read ON::continuity comments for details.</param>
            <param name="t">[in] parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance, then the curve is not C0.
</param>
            <param name="d1_tolerance">
[in] if the difference between two first derivatives is greater than d1_tolerance, then the curve is not C1.
</param>
            <param name="d2_tolerance">
[in] if the difference between two second derivatives is greater than d2_tolerance, then the curve is not C2.
</param>
            <param name="cos_angle_tolerance">
[in] default = cos(1 degree) Used only when c is ON::G1_continuous or ON::G2_continuous.
If the cosine of the angle between two tangent vectors is &lt;= cos_angle_tolerance,
then a G1 discontinuity is reported.
</param>
            <returns>TRUE if the curve has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Int32@,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Test continuity at a curve parameter value.</summary>
            <param name="c">[in] type of continuity to test for. Read ON::continuity comments for details.</param>
            <param name="t">[in] parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance, then the curve is not C0.
</param>
            <param name="d1_tolerance">
[in] if the difference between two first derivatives is greater than d1_tolerance, then the curve is not C1.
</param>
            <param name="d2_tolerance">
[in] if the difference between two second derivatives is greater than d2_tolerance, then the curve is not C2.
</param>
            <param name="cos_angle_tolerance">
[in] default = cos(1 degree) Used only when c is ON::G1_continuous or ON::G2_continuous.
If the cosine of the angle between two tangent vectors is &lt;= cos_angle_tolerance,
then a G1 discontinuity is reported.
</param>
            <param name="curvature_tolerance">
[in] (default = ON_SQRT_EPSILON) Used only when c is ON::G2_continuous. If K0 and K1 are
curvatures evaluated from above and below and |K0 - K1| &gt; curvature_tolerance, then a
curvature discontinuity is reported.
</param>
            <returns>TRUE if the curve has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetNextDiscontinuity(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through
the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c is
a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">
[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1.
 Note well that all curves are parametrically continuous at the ends of
 their domains.
Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetNextDiscontinuity(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@,System.Int32@)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through
the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c is
a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">
[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.
</param>
            <param name="hint">
[in/out] if GetNextDiscontinuity will be called repeatedly, passing a "hint"
with initial value *hint=0 will increase the speed of the search.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1.
 Note well that all curves are parametrically continuous at the ends of
 their domains.
Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetNextDiscontinuity(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@,System.Int32@,System.Int32@)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through
the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c is
a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">
[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.
</param>
            <param name="hint">
[in/out] if GetNextDiscontinuity will be called repeatedly, passing a "hint"
with initial value *hint=0 will increase the speed of the search.
</param>
            <param name="dtype">
[out] if not NULL, *dtype reports the kind of discontinuity found at *t.
A value of 1 means the first derivative or unit tangent was discontinuous.
A value of 2 means the second derivative or curvature was discontinuous.
A value of 0 means teh curve is not closed, a locus discontinuity test was applied,
and t1 is at the start of end of the curve.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1.
 Note well that all curves are parametrically continuous at the ends of
 their domains.
Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetNextDiscontinuity(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@,System.Int32@,System.Int32@,System.Double)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through
the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c is
a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">
[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.
</param>
            <param name="hint">
[in/out] if GetNextDiscontinuity will be called repeatedly, passing a "hint"
with initial value *hint=0 will increase the speed of the search.
</param>
            <param name="dtype">
[out] if not NULL, *dtype reports the kind of discontinuity found at *t.
A value of 1 means the first derivative or unit tangent was discontinuous.
A value of 2 means the second derivative or curvature was discontinuous.
A value of 0 means teh curve is not closed, a locus discontinuity test was applied,
and t1 is at the start of end of the curve.
</param>
            <param name="cos_angle_tolerance">
[in] default = cos(1 degree) Used only when c is ON::G1_continuous or ON::G2_continuous.
If the cosine of the angle between two tangent vectors is &lt;= cos_angle_tolerance,
then a G1 discontinuity is reported.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1.
 Note well that all curves are parametrically continuous at the ends of
 their domains.
Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetNextDiscontinuity(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@,System.Int32@,System.Int32@,System.Double,System.Double)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through
the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c is
a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">
[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.
</param>
            <param name="hint">
[in/out] if GetNextDiscontinuity will be called repeatedly, passing a "hint"
with initial value *hint=0 will increase the speed of the search.
</param>
            <param name="dtype">
[out] if not NULL, *dtype reports the kind of discontinuity found at *t.
A value of 1 means the first derivative or unit tangent was discontinuous.
A value of 2 means the second derivative or curvature was discontinuous.
A value of 0 means teh curve is not closed, a locus discontinuity test was applied,
and t1 is at the start of end of the curve.
</param>
            <param name="cos_angle_tolerance">
[in] default = cos(1 degree) Used only when c is ON::G1_continuous or ON::G2_continuous.
If the cosine of the angle between two tangent vectors is &lt;= cos_angle_tolerance,
then a G1 discontinuity is reported.
</param>
            <param name="curvature_tolerance">
[in] (default = ON_SQRT_EPSILON) Used only when c is ON::G2_continuous.
If K0 and K1 are curvatures evaluated from above and below and |K0 - K1| &gt; curvature_tolerance,
then a curvature discontinuity is reported.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1.
 Note well that all curves are parametrically continuous at the ends of
 their domains.
Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsPeriodic">
            <summary>Test a curve to see if it is periodic.</summary>
            <returns>TRUE if the curve is closed and at least C2 at the start/end.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsClosed">
            <summary>Test a curve to see if it is closed.</summary>
            <returns>TRUE if the curve is closed.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsClosable(System.Double)">
            <summary>
Decide if it makes sense to close off this curve by moving 
the endpoint to the start based on start-end gap size and length
of curve as approximated by chord defined by 6 points.
</summary>
            <param name="tolerance">
[in] maximum allowable distance between start and end.
if start - end gap is greater than tolerance, returns false
</param>
            <returns>
true if start and end points are close enough based on above conditions.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsClosable(System.Double,System.Double)">
            <summary>
Decide if it makes sense to close off this curve by moving 
the endpoint to the start based on start-end gap size and length
of curve as approximated by chord defined by 6 points.
</summary>
            <param name="tolerance">
[in] maximum allowable distance between start and end.
if start - end gap is greater than tolerance, returns false
</param>
            <param name="min_abs_size">
[in] if greater than 0.0 and none of the interior sampled
points are at least min_abs_size from start, returns false.
</param>
            <returns>
true if start and end points are close enough based on above conditions.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsClosable(System.Double,System.Double,System.Double)">
            <summary>
Decide if it makes sense to close off this curve by moving 
the endpoint to the start based on start-end gap size and length
of curve as approximated by chord defined by 6 points.
</summary>
            <param name="tolerance">
[in] maximum allowable distance between start and end.
if start - end gap is greater than tolerance, returns false
</param>
            <param name="min_abs_size">
[in] if greater than 0.0 and none of the interior sampled
points are at least min_abs_size from start, returns false.
</param>
            <param name="min_rel_size">
[in] if greater than 1.0 and chord length is less than 
min_rel_size*gap, returns false.
</param>
            <returns>
true if start and end points are close enough based on above conditions.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsInPlane(RMA.OpenNURBS.IOnPlane)">
            <summary>
Test a curve to see if it lies in a specific plane.
</summary>
            <param name="test_plane">[in]</param>
            <returns>
TRUE if the maximum distance from the curve to the
test_plane is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsInPlane(RMA.OpenNURBS.IOnPlane,System.Double)">
            <summary>
Test a curve to see if it lies in a specific plane.
</summary>
            <param name="test_plane">[in]</param>
            <param name="tolerance">[in] tolerance to use when checking</param>
            <returns>
TRUE if the maximum distance from the curve to the
test_plane is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsPlanar">
            <summary>Test a curve to see if it is planar.</summary>
            <returns>
TRUE if there is a plane such that the maximum distance from
the curve to the plane is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsPlanar(RMA.OpenNURBS.OnPlane)">
            <summary>Test a curve to see if it is planar.</summary>
            <param name="plane">
[out] if not NULL and TRUE is returned, the plane parameters are filled in.
</param>
            <returns>
TRUE if there is a plane such that the maximum distance from
the curve to the plane is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsPlanar(RMA.OpenNURBS.OnPlane,System.Double)">
            <summary>Test a curve to see if it is planar.</summary>
            <param name="plane">
[out] if not NULL and TRUE is returned, the plane parameters are filled in.
</param>
            <param name="tolerance">[in] tolerance to use when checking</param>
            <returns>
TRUE if there is a plane such that the maximum distance from
the curve to the plane is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsArc">
            <summary>
Test a curve to see if the locus if its points is an arc or circle.
</summary>
            <returns>
ON_Arc.m_angle &gt; 0 if curve locus is an arc between
specified points.  If ON_Arc.m_angle is 2.0*ON_PI, then the curve
is a circle.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsArc(RMA.OpenNURBS.IOnPlane)">
            <summary>
Test a curve to see if the locus if its points is an arc or circle.
</summary>
            <param name="plane">[in] if not NULL, test is performed in this plane</param>
            <returns>
ON_Arc.m_angle &gt; 0 if curve locus is an arc between
specified points.  If ON_Arc.m_angle is 2.0*ON_PI, then the curve
is a circle.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsArc(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.OnArc)">
            <summary>
Test a curve to see if the locus if its points is an arc or circle.
</summary>
            <param name="plane">[in] if not NULL, test is performed in this plane</param>
            <param name="arc">[out] if not NULL and TRUE is returned, then arc parameters are filled in</param>
            <returns>
ON_Arc.m_angle &gt; 0 if curve locus is an arc between
specified points.  If ON_Arc.m_angle is 2.0*ON_PI, then the curve
is a circle.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsArc(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.OnArc,System.Double)">
            <summary>
Test a curve to see if the locus if its points is an arc or circle.
</summary>
            <param name="plane">[in] if not NULL, test is performed in this plane</param>
            <param name="arc">[out] if not NULL and TRUE is returned, then arc parameters are filled in</param>
            <param name="tolerance">[in] tolerance to use when checking</param>
            <returns>
ON_Arc.m_angle &gt; 0 if curve locus is an arc between
specified points.  If ON_Arc.m_angle is 2.0*ON_PI, then the curve
is a circle.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsPolyline">
            <summary>
Several types of ON_Curve can have the form of a polyline including a degree 1 ON_NurbsCurve,
an ON_PolylineCurve, and an ON_PolyCurve all of whose segments are some form of polyline.
IsPolyline tests a curve to see if it can be represented as a polyline.
</summary>
            <returns>
0 curve is not some form of a polyline
&gt;=2 number of points in polyline form
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsPolyline(RMA.OpenNURBS.ArrayOn3dPoint)">
            <summary>
Several types of ON_Curve can have the form of a polyline including a degree 1 ON_NurbsCurve,
an ON_PolylineCurve, and an ON_PolyCurve all of whose segments are some form of polyline.
IsPolyline tests a curve to see if it can be represented as a polyline.
</summary>
            <param name="pline_points">
[out] if not NULL and TRUE is returned, then the points of the polyline form are returned here.
</param>
            <returns>
0 curve is not some form of a polyline
&gt;=2 number of points in polyline form
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsPolyline(RMA.OpenNURBS.ArrayOn3dPoint,RMA.OpenNURBS.Arraydouble)">
            <summary>
Several types of ON_Curve can have the form of a polyline including a degree 1 ON_NurbsCurve,
an ON_PolylineCurve, and an ON_PolyCurve all of whose segments are some form of polyline.
IsPolyline tests a curve to see if it can be represented as a polyline.
</summary>
            <param name="pline_points">
[out] if not NULL and TRUE is returned, then the points of the polyline form are returned here.
</param>
            <param name="pline_t">
[out] if not NULL and TRUE is returned, then the parameters of the polyline points are returned here.
</param>
            <returns>
0 curve is not some form of a polyline
&gt;=2 number of points in polyline form
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsLinear">
            <summary>
Test a curve to see if the locus if its points is a line segment.
</summary>
            <returns>
TRUE if the ends of the curve are farther than tolerance apart
and the maximum distance from any point on the curve to
the line segment connecting the curve's ends is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsLinear(System.Double)">
            <summary>
Test a curve to see if the locus if its points is a line segment.
</summary>
            <param name="tolerance">[in] tolerance to use when checking linearity</param>
            <returns>
TRUE if the ends of the curve are farther than tolerance apart
and the maximum distance from any point on the curve to
the line segment connecting the curve's ends is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetParameterTolerance(System.Double,System.Double@,System.Double@)">
            <summary>
Returns maximum algebraic degree of any span
or a good estimate if curve spans are not algebraic.
</summary>
            <param name="t">[IN] t = parameter in domain</param>
            <param name="tminus">[OUT]</param>
            <param name="tplus">[OUT]</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.Degree">
            <summary>
Returns maximum algebraic degree of any span
or a good estimate if curve spans are not algebraic.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetSpanVectorIndex(System.Double,System.Int32,System.Int32@,RMA.OpenNURBS.OnInterval)">
            <summary>
If t is in the domain of the curve, GetSpanVectorIndex() returns the 
span vector index "i" such that span_vector[i] &lt;= t &lt;= span_vector[i+1].
The "side" parameter determines which span is selected when t is at the
end of a span.
</summary>
            <param name="t">[IN] t = evaluation parameter</param>
            <param name="side">[IN] side 0 = default, -1 = from below, +1 = from above</param>
            <param name="span_vector_index">[OUT] span vector index</param>
            <param name="span_domain">[OUT] domain of the span containing "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetSpanVector(System.Double[]@)">
            <summary>Get number of parameters of "knots".</summary>
            <param name="knots">
[out] an array of length SpanCount()+1 is filled in
with the parameters where the curve is not smooth (C-infinity).
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.SpanCount">
            <summary>Get number of nonempty smooth (c-infinity) spans in curve</summary>
            <returns>Number of nonempty smooth (c-infinity) spans.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.ChangeDimension(System.Int32)">
            <summary>Change the dimension of a curve.</summary>
            <param name="desired_dimension">[in]</param>
            <returns>
TRUE if the curve's dimension was already desired_dimension or if the
curve's dimension was successfully changed to desired_dimension.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.ChangeClosedCurveSeam(System.Double)">
            <summary>
If this curve is closed, then modify it so that the start/end point is at curve parameter t.
</summary>
            <param name="t">[in] curve parameter of new start/end point. The returned curves domain will start at t.</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.SetDomain(System.Double,System.Double)">
            <summary>Set the domain of the curve.</summary>
            <param name="t0">[in]</param>
            <param name="t1">[in] new domain will be [t0,t1]</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.SetDomain(RMA.OpenNURBS.IOnInterval)">
            <summary>Set the domain of the curve.</summary>
            <param name="domain">[in] increasing interval Returns: true if successful.</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.Domain">
            <summary>
domain of the curve.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetDomain(System.Double@,System.Double@)">
            <summary>Gets domain of the curve</summary>
            <param name="t0">[out]</param>
            <param name="t1">[out] domain is [*t0, *t1]</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.DuplicateCurve">
            <summary>Get a duplicate of the curve.</summary>
            <returns>A duplicate of the curve.</returns>
            <remarks>
The caller must delete the returned curve. For non-ON_CurveProxy objects,
this simply duplicates the curve using ON_Object::Duplicate.
For ON_CurveProxy objects, this duplicates the actual proxy curve geometry and,
if necessary, trims and reverse the result to that the returned curve's
parameterization and locus match the proxy curve's.
</remarks>
        </member>
        <member name="T:RMA.OpenNURBS.OnCurve">
            <summary>pure virtual class for curve objects</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.AreaMassProperties(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.OnMassProperties@)">
            <summary>Calculate area mass properties of a curve. The curve should be planar.</summary>
            <param name="base_point">
[in] A point on the plane that contians the curve. To get the best results,
the point should be in the near the curve's centroid. When computing
the area, area centroid, or area first moments of a planar area whose boundary
is defined by several curves, pass the same base_point and plane_normal to each
call to AreaMassProperties. The base_point must be in the plane of the curves.
When computing the area second moments or area product moments of a planar area
whose boundary is defined by several curves, you MUST pass the entire area's
centroid as the base_point and the input mp parameter must contain the results of
a previous call to AreaMassProperties(mp,true,true,false,false,base_point). In
particular, in this case, you need to make two sets of calls; use first set to
calculate the area centroid and the second set calculate the second moments and
product moments.
</param>
            <param name="plane_normal">
[in] nonzero unit normal to the plane of integration. If a closed curve has
counter clock-wise orientation with respect to this normal, the area will be
positive. If the a closed curve has clock-wise orientation with respect to
this normal, the area will be negative.
</param>
            <param name="mp">[out]</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.AreaMassProperties(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.OnMassProperties@,System.Boolean)">
            <summary>Calculate area mass properties of a curve. The curve should be planar.</summary>
            <param name="base_point">
[in] A point on the plane that contians the curve. To get the best results,
the point should be in the near the curve's centroid. When computing
the area, area centroid, or area first moments of a planar area whose boundary
is defined by several curves, pass the same base_point and plane_normal to each
call to AreaMassProperties. The base_point must be in the plane of the curves.
When computing the area second moments or area product moments of a planar area
whose boundary is defined by several curves, you MUST pass the entire area's
centroid as the base_point and the input mp parameter must contain the results of
a previous call to AreaMassProperties(mp,true,true,false,false,base_point). In
particular, in this case, you need to make two sets of calls; use first set to
calculate the area centroid and the second set calculate the second moments and
product moments.
</param>
            <param name="plane_normal">
[in] nonzero unit normal to the plane of integration. If a closed curve has
counter clock-wise orientation with respect to this normal, the area will be
positive. If the a closed curve has clock-wise orientation with respect to
this normal, the area will be negative.
</param>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate volume</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.AreaMassProperties(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of a curve. The curve should be planar.</summary>
            <param name="base_point">
[in] A point on the plane that contians the curve. To get the best results,
the point should be in the near the curve's centroid. When computing
the area, area centroid, or area first moments of a planar area whose boundary
is defined by several curves, pass the same base_point and plane_normal to each
call to AreaMassProperties. The base_point must be in the plane of the curves.
When computing the area second moments or area product moments of a planar area
whose boundary is defined by several curves, you MUST pass the entire area's
centroid as the base_point and the input mp parameter must contain the results of
a previous call to AreaMassProperties(mp,true,true,false,false,base_point). In
particular, in this case, you need to make two sets of calls; use first set to
calculate the area centroid and the second set calculate the second moments and
product moments.
</param>
            <param name="plane_normal">
[in] nonzero unit normal to the plane of integration. If a closed curve has
counter clock-wise orientation with respect to this normal, the area will be
positive. If the a closed curve has clock-wise orientation with respect to
this normal, the area will be negative.
</param>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area, and area centroid.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.AreaMassProperties(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of a curve. The curve should be planar.</summary>
            <param name="base_point">
[in] A point on the plane that contians the curve. To get the best results,
the point should be in the near the curve's centroid. When computing
the area, area centroid, or area first moments of a planar area whose boundary
is defined by several curves, pass the same base_point and plane_normal to each
call to AreaMassProperties. The base_point must be in the plane of the curves.
When computing the area second moments or area product moments of a planar area
whose boundary is defined by several curves, you MUST pass the entire area's
centroid as the base_point and the input mp parameter must contain the results of
a previous call to AreaMassProperties(mp,true,true,false,false,base_point). In
particular, in this case, you need to make two sets of calls; use first set to
calculate the area centroid and the second set calculate the second moments and
product moments.
</param>
            <param name="plane_normal">
[in] nonzero unit normal to the plane of integration. If a closed curve has
counter clock-wise orientation with respect to this normal, the area will be
positive. If the a closed curve has clock-wise orientation with respect to
this normal, the area will be negative.
</param>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area, and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.AreaMassProperties(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of a curve. The curve should be planar.</summary>
            <param name="base_point">
[in] A point on the plane that contians the curve. To get the best results,
the point should be in the near the curve's centroid. When computing
the area, area centroid, or area first moments of a planar area whose boundary
is defined by several curves, pass the same base_point and plane_normal to each
call to AreaMassProperties. The base_point must be in the plane of the curves.
When computing the area second moments or area product moments of a planar area
whose boundary is defined by several curves, you MUST pass the entire area's
centroid as the base_point and the input mp parameter must contain the results of
a previous call to AreaMassProperties(mp,true,true,false,false,base_point). In
particular, in this case, you need to make two sets of calls; use first set to
calculate the area centroid and the second set calculate the second moments and
product moments.
</param>
            <param name="plane_normal">
[in] nonzero unit normal to the plane of integration. If a closed curve has
counter clock-wise orientation with respect to this normal, the area will be
positive. If the a closed curve has clock-wise orientation with respect to
this normal, the area will be negative.
</param>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area, and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <param name="bProductMoments">[in] true to calculate area product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.AreaMassProperties(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double)">
            <summary>Calculate area mass properties of a curve. The curve should be planar.</summary>
            <param name="base_point">
[in] A point on the plane that contians the curve. To get the best results,
the point should be in the near the curve's centroid. When computing
the area, area centroid, or area first moments of a planar area whose boundary
is defined by several curves, pass the same base_point and plane_normal to each
call to AreaMassProperties. The base_point must be in the plane of the curves.
When computing the area second moments or area product moments of a planar area
whose boundary is defined by several curves, you MUST pass the entire area's
centroid as the base_point and the input mp parameter must contain the results of
a previous call to AreaMassProperties(mp,true,true,false,false,base_point). In
particular, in this case, you need to make two sets of calls; use first set to
calculate the area centroid and the second set calculate the second moments and
product moments.
</param>
            <param name="plane_normal">
[in] nonzero unit normal to the plane of integration. If a closed curve has
counter clock-wise orientation with respect to this normal, the area will be
positive. If the a closed curve has clock-wise orientation with respect to
this normal, the area will be negative.
</param>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area, and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <param name="bProductMoments">[in] true to calculate area product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.AreaMassProperties(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double,System.Double)">
            <summary>Calculate area mass properties of a curve. The curve should be planar.</summary>
            <param name="base_point">
[in] A point on the plane that contians the curve. To get the best results,
the point should be in the near the curve's centroid. When computing
the area, area centroid, or area first moments of a planar area whose boundary
is defined by several curves, pass the same base_point and plane_normal to each
call to AreaMassProperties. The base_point must be in the plane of the curves.
When computing the area second moments or area product moments of a planar area
whose boundary is defined by several curves, you MUST pass the entire area's
centroid as the base_point and the input mp parameter must contain the results of
a previous call to AreaMassProperties(mp,true,true,false,false,base_point). In
particular, in this case, you need to make two sets of calls; use first set to
calculate the area centroid and the second set calculate the second moments and
product moments.
</param>
            <param name="plane_normal">
[in] nonzero unit normal to the plane of integration. If a closed curve has
counter clock-wise orientation with respect to this normal, the area will be
positive. If the a closed curve has clock-wise orientation with respect to
this normal, the area will be negative.
</param>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area, and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <param name="bProductMoments">[in] true to calculate area product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.LengthMassProperties(RMA.OpenNURBS.OnMassProperties@)">
            <summary>Calculate length mass properties of the curve.</summary>
            <param name="mp">[out]</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.LengthMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean)">
            <summary>Calculate length mass properties of the curve.</summary>
            <param name="mp">[out]</param>
            <param name="bLength">[in] true to calculate length</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.LengthMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean)">
            <summary>Calculate length mass properties of the curve.</summary>
            <param name="mp">[out]</param>
            <param name="bLength">[in] true to calculate length</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, length, and length centroid.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.LengthMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate length mass properties of the curve.</summary>
            <param name="mp">[out]</param>
            <param name="bLength">[in] true to calculate length</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, length, and length centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate length second moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.LengthMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate length mass properties of the curve.</summary>
            <param name="mp">[out]</param>
            <param name="bLength">[in] true to calculate length</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, length, and length centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate length second moments.</param>
            <param name="bProductMoments">[in] true to calculate length product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.LengthMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double)">
            <summary>Calculate length mass properties of the curve.</summary>
            <param name="mp">[out]</param>
            <param name="bLength">[in] true to calculate length</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, length, and length centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate length second moments.</param>
            <param name="bProductMoments">[in] true to calculate length product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.LengthMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double,System.Double)">
            <summary>Calculate length mass properties of the curve.</summary>
            <param name="mp">[out]</param>
            <param name="bLength">[in] true to calculate length</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, length, and length centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate length second moments.</param>
            <param name="bProductMoments">[in] true to calculate length product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.CurveTree">
            <summary>
Get the runtime curve tree used to speed closest point
and intersection calcuations.
</summary>
            <returns>Pointer to the curve tree.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetNurbFormParameterFromCurveParameter(System.Double,System.Double@)">
            <summary>Convert a curve parameter to a NURBS curve parameter.</summary>
            <param name="curve_t">[in] curve parameter</param>
            <param name="nurbs_t">[out] nurbs form parameter</param>
            <remarks>
If GetNurbForm returns 2, this function converts the curve
parameter to the NURBS curve parameter.
See Also:
 ON_Curve::GetNurbForm, ON_Curve::GetCurveParameterFromNurbFormParameter
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetCurveParameterFromNurbFormParameter(System.Double,System.Double@)">
            <summary>Convert a NURBS curve parameter to a curve parameter</summary>
            <param name="nurbs_t">[in] nurbs form parameter</param>
            <param name="curve_t">[out] curve parameter</param>
            <remarks>
If GetNurbForm returns 2, this function converts the curve
parameter to the NURBS curve parameter.
See Also:
ON_Curve::GetNurbForm, ON_Curve::GetNurbFormParameterFromCurveParameter
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.NurbsCurve">
            <summary>Get a NURBS curve representation of this curve.</summary>
            <returns>NULL or a NURBS representation of the curve.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Curve::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.NurbsCurve(RMA.OpenNURBS.OnNurbsCurve)">
            <summary>Get a NURBS curve representation of this curve.</summary>
            <param name="pNurbsCurve">
[in/out] if not NULL, this ON_NurbsCurve will be used to store the NURBS representation
of the curve will be returned.
</param>
            <returns>NULL or a NURBS representation of the curve.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Curve::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.NurbsCurve(RMA.OpenNURBS.OnNurbsCurve,System.Double)">
            <summary>Get a NURBS curve representation of this curve.</summary>
            <param name="pNurbsCurve">
[in/out] if not NULL, this ON_NurbsCurve will be used to store the NURBS representation
of the curve will be returned.
</param>
            <param name="tolerance">[in] tolerance to use when creating NURBS representation.</param>
            <returns>NULL or a NURBS representation of the curve.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Curve::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.NurbsCurve(RMA.OpenNURBS.OnNurbsCurve,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a NURBS curve representation of this curve.</summary>
            <param name="pNurbsCurve">
[in/out] if not NULL, this ON_NurbsCurve will be used to store the NURBS representation
of the curve will be returned.
</param>
            <param name="tolerance">[in] tolerance to use when creating NURBS representation.</param>
            <param name="subdomain">
[in] if not NULL, then the NURBS representation for this portion of the curve is returned.
</param>
            <returns>NULL or a NURBS representation of the curve.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Curve::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.HasNurbForm">
            <summary>Does a NURBS curve representation of this curve.</summary>
            <returns>
0 unable to create NURBS representation with desired accuracy.
1 success - NURBS parameterization matches the curve's to wthe desired accuracy
2 success - NURBS point locus matches the curve's and the domain of the NURBS curve is correct.
           However, This curve's parameterization and the NURBS curve parameterization may not
           match. This situation happens when getting NURBS representations of curves that have a
           transendental parameterization like circles
</returns>
            <remarks>
This is a low-level virtual function.
See Also: ON_Curve::GetNurbForm ON_Curve::NurbsCurve
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetNurbForm(RMA.OpenNURBS.OnNurbsCurve@)">
            <summary>Get a NURBS curve representation of this curve.</summary>
            <param name="nurbs_curve">[out] NURBS representation returned here</param>
            <returns>
0 unable to create NURBS representation with desired accuracy.
1 success - returned NURBS parameterization matches the curve's to wthe desired accuracy
2 success - returned NURBS point locus matches the curve's to the desired accuracy and
           the domain of the NURBS curve is correct. On However, This curve's parameterization
           and the NURBS curve parameterization may not match to the desired accuracy. This
           situation happens when getting NURBS representations of curves that have a transendental
           parameterization like circles Remarks: This is a low-level virtual function. If you do
           not need the parameterization information provided by the return code, then
           ON_Curve::NurbsCurve may be easier to use.
See Also: ON_Curve::NurbsCurve
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetNurbForm(RMA.OpenNURBS.OnNurbsCurve@,System.Double)">
            <summary>Get a NURBS curve representation of this curve.</summary>
            <param name="nurbs_curve">[out] NURBS representation returned here</param>
            <param name="tolerance">[in] tolerance to use when creating NURBS representation.</param>
            <returns>
0 unable to create NURBS representation with desired accuracy.
1 success - returned NURBS parameterization matches the curve's to wthe desired accuracy
2 success - returned NURBS point locus matches the curve's to the desired accuracy and
           the domain of the NURBS curve is correct. On However, This curve's parameterization
           and the NURBS curve parameterization may not match to the desired accuracy. This
           situation happens when getting NURBS representations of curves that have a transendental
           parameterization like circles Remarks: This is a low-level virtual function. If you do
           not need the parameterization information provided by the return code, then
           ON_Curve::NurbsCurve may be easier to use.
See Also: ON_Curve::NurbsCurve
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetNurbForm(RMA.OpenNURBS.OnNurbsCurve@,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a NURBS curve representation of this curve.</summary>
            <param name="nurbs_curve">[out] NURBS representation returned here</param>
            <param name="tolerance">[in] tolerance to use when creating NURBS representation.</param>
            <param name="subdomain">
[in] if not NULL, then the NURBS representation for this portion of the curve is returned.
</param>
            <returns>
0 unable to create NURBS representation with desired accuracy.
1 success - returned NURBS parameterization matches the curve's to wthe desired accuracy
2 success - returned NURBS point locus matches the curve's to the desired accuracy and
           the domain of the NURBS curve is correct. On However, This curve's parameterization
           and the NURBS curve parameterization may not match to the desired accuracy. This
           situation happens when getting NURBS representations of curves that have a transendental
           parameterization like circles Remarks: This is a low-level virtual function. If you do
           not need the parameterization information provided by the return code, then
           ON_Curve::NurbsCurve may be easier to use.
See Also: ON_Curve::NurbsCurve
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.Split(System.Double,RMA.OpenNURBS.OnCurve@,RMA.OpenNURBS.OnCurve@)">
            <summary>
Splits (divides) the curve at the specified parameter. The parameter must be
in the interior of the curve's domain. The pointers passed to Split must
either be NULL or point to an ON_Curve object of the same type. If the pointer
is NULL, then a curve will be created in Split(). You may pass "this"
as left_side or right_side.
</summary>
            <param name="t">[in] parameter to split the curve at in the interval returned by Domain().</param>
            <param name="left_side">[out] left portion of curve returned here</param>
            <param name="right_side">[out] right portion of curve returned here</param>
            <returns>
TRUE - The curve was split into two pieces.
FALSE - The curve could not be split. For example if the parameter is too close to an endpoint.
</returns>
            <example>
For example, if crv were an ON_NurbsCurve, then
  ON_NurbsCurve right_side;
  crv.Split( crv.Domain().Mid() &amp;crv, &amp;right_side );
would split crv at the parametric midpoint, put the left side in crv, and return the right side in right_side.
</example>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetNormalizedArcLengthPoints(System.Double[],System.Double[]@)">
            <summary>
Get the parameter of the point on the curve that is a prescribed arc length from the start of the curve.
</summary>
            <param name="s">
[in] array of normalized arc length parameters.
E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.
</param>
            <param name="t">
[out] array of curve parameters such that the length of the curve from its
start to t[i] is s[i]*curve_length.
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetNormalizedArcLengthPoints(System.Double[],System.Double[]@,System.Double)">
            <summary>
Get the parameter of the point on the curve that is a prescribed arc length from the start of the curve.
</summary>
            <param name="s">
[in] array of normalized arc length parameters.
E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.
</param>
            <param name="t">
[out] array of curve parameters such that the length of the curve from its
start to t[i] is s[i]*curve_length.
</param>
            <param name="absolute_tolerance">
[in] if absolute_tolerance &gt; 0, then the difference between (s[i+1]-s[i])*curve_length
and the length of the curve segment from t[i] to t[i+1] will be &lt;= absolute_tolerance.
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetNormalizedArcLengthPoints(System.Double[],System.Double[]@,System.Double,System.Double)">
            <summary>
Get the parameter of the point on the curve that is a prescribed arc length from the start of the curve.
</summary>
            <param name="s">
[in] array of normalized arc length parameters.
E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.
</param>
            <param name="t">
[out] array of curve parameters such that the length of the curve from its
start to t[i] is s[i]*curve_length.
</param>
            <param name="absolute_tolerance">
[in] if absolute_tolerance &gt; 0, then the difference between (s[i+1]-s[i])*curve_length
and the length of the curve segment from t[i] to t[i+1] will be &lt;= absolute_tolerance.
</param>
            <param name="fractional_tolerance">
[in] desired fractional precision for each segment.
fabs("true" length - actual length)/(actual length) &lt;= fractional_tolerance
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetNormalizedArcLengthPoints(System.Double[],System.Double[]@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>
Get the parameter of the point on the curve that is a prescribed arc length from the start of the curve.
</summary>
            <param name="s">
[in] array of normalized arc length parameters.
E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.
</param>
            <param name="t">
[out] array of curve parameters such that the length of the curve from its
start to t[i] is s[i]*curve_length.
</param>
            <param name="absolute_tolerance">
[in] if absolute_tolerance &gt; 0, then the difference between (s[i+1]-s[i])*curve_length
and the length of the curve segment from t[i] to t[i+1] will be &lt;= absolute_tolerance.
</param>
            <param name="fractional_tolerance">
[in] desired fractional precision for each segment.
fabs("true" length - actual length)/(actual length) &lt;= fractional_tolerance
</param>
            <param name="sub_domain">
[in] If not NULL, the calculation is performed on the specified sub-domain of the curve.
A 0.0 s value corresponds to sub_domain-&gt;Min() and a 1.0 s value corresponds to
sub_domain-&gt;Max().
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetNormalizedArcLengthPoint(System.Double,System.Double@)">
            <summary>
Get the parameter of the point on the curve that is a prescribed arc length from the start of the curve.
</summary>
            <param name="s">
[in] normalized arc length parameter.
E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.
</param>
            <param name="t">[out] parameter such that the length of the curve from its start to t is arc_length.</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetNormalizedArcLengthPoint(System.Double,System.Double@,System.Double)">
            <summary>
Get the parameter of the point on the curve that is a prescribed arc length from the start of the curve.
</summary>
            <param name="s">
[in] normalized arc length parameter.
E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.
</param>
            <param name="t">[out] parameter such that the length of the curve from its start to t is arc_length.</param>
            <param name="fractional_tolerance">
[in] desired fractional precision.
fabs(("exact" length from start to t) - arc_length)/arc_length &lt;= fractional_tolerance
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetNormalizedArcLengthPoint(System.Double,System.Double@,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>
Get the parameter of the point on the curve that is a prescribed arc length from the start of the curve.
</summary>
            <param name="s">
[in] normalized arc length parameter.
E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.
</param>
            <param name="t">[out] parameter such that the length of the curve from its start to t is arc_length.</param>
            <param name="fractional_tolerance">
[in] desired fractional precision.
fabs(("exact" length from start to t) - arc_length)/arc_length &lt;= fractional_tolerance
</param>
            <param name="sub_domain">
[in] If not NULL, the calculation is performed on the specified sub-domain of the curve.
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsShort(System.Double)">
            <summary>Used to quickly find short curves.</summary>
            <param name="tolerance">[in] (&gt;=0)</param>
            <returns>True if the length of the curve is &lt;= tolerance.</returns>
            <remarks>Faster than calling Length() and testing the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsShort(System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Used to quickly find short curves.</summary>
            <param name="tolerance">[in] (&gt;=0)</param>
            <param name="sub_domain">
[in] If not NULL, the test is performed on the interval that is the intersection
of sub_domain with Domain().
</param>
            <returns>True if the length of the curve is &lt;= tolerance.</returns>
            <remarks>Faster than calling Length() and testing the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetLength(System.Double@)">
            <summary>Get the length of the curve.</summary>
            <param name="length">[out] length returned here.</param>
            <returns>
TRUE if returned if the length calculation is successful.
FALSE is returned if the length is not calculated.
</returns>
            <remarks>
The arc length will be computed so that (returned length - real length)/(real length) &lt;= fractional_tolerance
More simply, if you want N significant figures in the answer, set the fractional_tolerance to 1.0e-N.
For "nice" curves, 1.0e-8 works fine. For very high degree NURBS and NURBS with bad
parametrizations, use larger values of fractional_tolerance.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetLength(System.Double@,System.Double)">
            <summary>Get the length of the curve.</summary>
            <param name="length">[out] length returned here.</param>
            <param name="fractional_tolerance">
[in] desired fractional precision.
fabs(("exact" length from start to t) - arc_length)/arc_length &lt;= fractional_tolerance
</param>
            <returns>
TRUE if returned if the length calculation is successful.
FALSE is returned if the length is not calculated.
</returns>
            <remarks>
The arc length will be computed so that (returned length - real length)/(real length) &lt;= fractional_tolerance
More simply, if you want N significant figures in the answer, set the fractional_tolerance to 1.0e-N.
For "nice" curves, 1.0e-8 works fine. For very high degree NURBS and NURBS with bad
parametrizations, use larger values of fractional_tolerance.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetLength(System.Double@,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Get the length of the curve.</summary>
            <param name="length">[out] length returned here.</param>
            <param name="fractional_tolerance">
[in] desired fractional precision.
fabs(("exact" length from start to t) - arc_length)/arc_length &lt;= fractional_tolerance
</param>
            <param name="sub_domain">
[in] If not NULL, the calculation is performed on the specified sub-domain of
the curve (must be non-decreasing)
</param>
            <returns>
TRUE if returned if the length calculation is successful.
FALSE is returned if the length is not calculated.
</returns>
            <remarks>
The arc length will be computed so that (returned length - real length)/(real length) &lt;= fractional_tolerance
More simply, if you want N significant figures in the answer, set the fractional_tolerance to 1.0e-N.
For "nice" curves, 1.0e-8 works fine. For very high degree NURBS and NURBS with bad
parameterizations, use larger values of fractional_tolerance.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@)">
            <summary>Intersect this curve with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double)">
            <summary>Intersect this curve with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double)">
            <summary>Intersect this curve with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and the distance from curve(t)
to the surface is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then the event will
be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0,
then intersection_tolerance*2.0 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this curve with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and the distance from curve(t)
to the surface is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then the event will
be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0,
then intersection_tolerance*2.0 is used.
</param>
            <param name="curveA_domain">[in] optional restriction on this curve's domain</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this curve with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and the distance from curve(t)
to the surface is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then the event will
be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0,
then intersection_tolerance*2.0 is used.
</param>
            <param name="curveA_domain">[in] optional restriction on this curve's domain</param>
            <param name="surfaceB_udomain">[in] optional restriction on surfaceB u domain</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this curve with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and the distance from curve(t)
to the surface is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then the event will
be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0,
then intersection_tolerance*2.0 is used.
</param>
            <param name="curveA_domain">[in] optional restriction on this curve's domain</param>
            <param name="surfaceB_udomain">[in] optional restriction on surfaceB u domain</param>
            <param name="surfaceB_vdomain">[in] optional restriction on surfaceB v domain</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IntersectCurve(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.ArrayOnX_EVENT@)">
            <summary>Intersect this curve with curveB.</summary>
            <param name="curveB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IntersectCurve(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double)">
            <summary>Intersect this curve with curveB.</summary>
            <param name="curveB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to curveB is &lt;= intersection tolerance,
then the point will be part of an intersection event.
If the input intersection_tolerance &lt;= 0.0, then 0.001 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IntersectCurve(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double)">
            <summary>Intersect this curve with curveB.</summary>
            <param name="curveB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to curveB is &lt;= intersection tolerance,
then the point will be part of an intersection event.
If the input intersection_tolerance &lt;= 0.0, then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are parameters of this curve's intersection events
and the distance from curve(t) to curveB is &lt;= overlap_tolerance for
every t1 &lt;= t &lt;= t2, then the event will be returened as an overlap event.
If the input overlap_tolerance &lt;= 0.0, then intersection_tolerance*2.0 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IntersectCurve(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this curve with curveB.</summary>
            <param name="curveB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to curveB is &lt;= intersection tolerance,
then the point will be part of an intersection event.
If the input intersection_tolerance &lt;= 0.0, then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are parameters of this curve's intersection events
and the distance from curve(t) to curveB is &lt;= overlap_tolerance for
every t1 &lt;= t &lt;= t2, then the event will be returened as an overlap event.
If the input overlap_tolerance &lt;= 0.0, then intersection_tolerance*2.0 is used.
</param>
            <param name="curveA_domain">[in] optional restriction on this curve's domain</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IntersectCurve(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this curve with curveB.</summary>
            <param name="curveB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to curveB is &lt;= intersection tolerance,
then the point will be part of an intersection event.
If the input intersection_tolerance &lt;= 0.0, then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are parameters of this curve's intersection events
and the distance from curve(t) to curveB is &lt;= overlap_tolerance for
every t1 &lt;= t &lt;= t2, then the event will be returened as an overlap event.
If the input overlap_tolerance &lt;= 0.0, then intersection_tolerance*2.0 is used.
</param>
            <param name="curveA_domain">[in] optional restriction on this curve's domain</param>
            <param name="curveB_domain">[in] optional restriction on curveB domain</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IntersectSelf(RMA.OpenNURBS.ArrayOnX_EVENT@)">
            <summary>Find curve's self intersection points.</summary>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IntersectSelf(RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double)">
            <summary>Find curve's self intersection points.</summary>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">[in]</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IntersectSelf(RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Find curve's self intersection points.</summary>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">[in]</param>
            <param name="curve_domain">[in] optional restriction</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double@)">
            <summary>
Find parameter of the point on a curve that is locally closest to 
the test_point.  The search for a local close point starts at 
seed_parameter. If the sub_domain parameter is not NULL, then
the search is restricted to the specified portion of the curve.
</summary>
            <returns>
TRUE if returned if the search is successful.  FALSE is returned if
the search fails.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double@,RMA.OpenNURBS.IOnInterval)">
            <summary>
Find parameter of the point on a curve that is locally closest to 
the test_point.  The search for a local close point starts at 
seed_parameter. If the sub_domain parameter is not NULL, then
the search is restricted to the specified portion of the curve.
</summary>
            <returns>
TRUE if returned if the search is successful.  FALSE is returned if
the search fails.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>
Find parameter of the point on a curve that is closest to test_point.
If the maximum_distance parameter is &gt; 0, then only points whose distance
to the given point is &lt;= maximum_distance will be returned.  Using a 
positive value of maximum_distance can substantially speed up the search.
If the sub_domain parameter is not NULL, then the search is restricted
to the specified portion of the curve.
</summary>
            <returns>
TRUE if returned if the search is successful.  FALSE is returned if
the search fails.
</returns>
            <param name="t">parameter of local closest point returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double)">
            <summary>
Find parameter of the point on a curve that is closest to test_point.
If the maximum_distance parameter is &gt; 0, then only points whose distance
to the given point is &lt;= maximum_distance will be returned.  Using a 
positive value of maximum_distance can substantially speed up the search.
If the sub_domain parameter is not NULL, then the search is restricted
to the specified portion of the curve.
</summary>
            <returns>
TRUE if returned if the search is successful.  FALSE is returned if
the search fails.
</returns>
            <param name="t">parameter of local closest point returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>
Find parameter of the point on a curve that is closest to test_point.
If the maximum_distance parameter is &gt; 0, then only points whose distance
to the given point is &lt;= maximum_distance will be returned.  Using a 
positive value of maximum_distance can substantially speed up the search.
If the sub_domain parameter is not NULL, then the search is restricted
to the specified portion of the curve.
</summary>
            <returns>
TRUE if returned if the search is successful.  FALSE is returned if
the search fails.
</returns>
            <param name="t">parameter of local closest point returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.EvCurvature(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate unit tangent and curvature at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="tangent">[out] value of unit tangent</param>
            <param name="kappa">[out] value of curvature vector</param>
            <returns>
FALSE if unable to evaluate.
See Also: ON_Curve::CurvatureAt ON_Curve::Ev2Der ON_EvCurvature
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.EvCurvature(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>Evaluate unit tangent and curvature at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="tangent">[out] value of unit tangent</param>
            <param name="kappa">[out] value of curvature vector</param>
            <param name="side">
[in] optional - determines which side to evaluate from
=0 default
&lt;0 to evaluate from below,
&gt;0 to evaluate from above
</param>
            <returns>
FALSE if unable to evaluate.
See Also: ON_Curve::CurvatureAt ON_Curve::Ev2Der ON_EvCurvature
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.EvCurvature(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,System.Int32,System.Int32@)">
            <summary>Evaluate unit tangent and curvature at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="tangent">[out] value of unit tangent</param>
            <param name="kappa">[out] value of curvature vector</param>
            <param name="side">
[in] optional - determines which side to evaluate from
=0 default
&lt;0 to evaluate from below,
&gt;0 to evaluate from above
</param>
            <param name="hint">[in/out] optional evaluation hint used to speed repeated evaluations</param>
            <returns>
FALSE if unable to evaluate.
See Also: ON_Curve::CurvatureAt ON_Curve::Ev2Der ON_EvCurvature
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.EvTangent(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate unit tangent at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="tangent">[out] value of unit tangent</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>See Also: ON_Curve::TangentAt ON_Curve::Ev1Der</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.EvTangent(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>Evaluate unit tangent at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="tangent">[out] value of unit tangent</param>
            <param name="side">
[in] optional - determines which side to evaluate from
=0 default
&lt;0 to evaluate from below,
&gt;0 to evaluate from above
</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>See Also: ON_Curve::TangentAt ON_Curve::Ev1Der</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.EvTangent(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,System.Int32,System.Int32@)">
            <summary>Evaluate unit tangent at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="tangent">[out] value of unit tangent</param>
            <param name="side">
[in] optional - determines which side to evaluate from
=0 default
&lt;0 to evaluate from below,
&gt;0 to evaluate from above
</param>
            <param name="hint">[in/out] optional evaluation hint used to speed repeated evaluations</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>See Also: ON_Curve::TangentAt ON_Curve::Ev1Der</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.Ev2Der(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate second derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="first_derivative">[out] value of first derivative at t</param>
            <param name="second_derivative">[out] value of second derivative at t</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
ON_Curve::Ev1Der
ON_Curve::EvCurvature
ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.Ev2Der(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>Evaluate second derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="first_derivative">[out] value of first derivative at t</param>
            <param name="second_derivative">[out] value of second derivative at t</param>
            <param name="side">
[in] optional - determines which side to evaluate from
=0   default
&lt;0   to evaluate from below, 
&gt;0   to evaluate from above
</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
ON_Curve::Ev1Der
ON_Curve::EvCurvature
ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.Ev2Der(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,System.Int32,System.Int32@)">
            <summary>Evaluate second derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="first_derivative">[out] value of first derivative at t</param>
            <param name="second_derivative">[out] value of second derivative at t</param>
            <param name="side">
[in] optional - determines which side to evaluate from
=0   default
&lt;0   to evaluate from below, 
&gt;0   to evaluate from above
</param>
            <param name="hint">[in/out] optional evaluation hint used to speed repeated evaluations</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
ON_Curve::Ev1Der
ON_Curve::EvCurvature
ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.Ev1Der(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate first derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="first_derivative">[out] value of first derivative at t</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
 ON_Curve::EvPoint
 ON_Curve::Ev2Der
 ON_Curve::EvTangent
 ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.Ev1Der(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>Evaluate first derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="first_derivative">[out] value of first derivative at t</param>
            <param name="side">
[in] optional - determines which side to evaluate from
   =0   default
&lt;0   to evaluate from below, 
&gt;0   to evaluate from above
</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
 ON_Curve::EvPoint
 ON_Curve::Ev2Der
 ON_Curve::EvTangent
 ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.Ev1Der(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,System.Int32,System.Int32@)">
            <summary>Evaluate first derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="first_derivative">[out] value of first derivative at t</param>
            <param name="side">
[in] optional - determines which side to evaluate from
   =0   default
&lt;0   to evaluate from below, 
&gt;0   to evaluate from above
</param>
            <param name="hint">[in/out] optional evaluation hint used to speed repeated evaluations</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
 ON_Curve::EvPoint
 ON_Curve::Ev2Der
 ON_Curve::EvTangent
 ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.EvPoint(System.Double,RMA.OpenNURBS.On3dPoint@)">
            <summary>Evaluate point at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
 ON_Curve::PointAt
 ON_Curve::EvTangent
 ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.EvPoint(System.Double,RMA.OpenNURBS.On3dPoint@,System.Int32)">
            <summary>Evaluate point at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="side">
[in] optional - determines which side to evaluate from
    =0   default
 &lt;0   to evaluate from below, 
 &gt;0   to evaluate from above
</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
 ON_Curve::PointAt
 ON_Curve::EvTangent
 ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.EvPoint(System.Double,RMA.OpenNURBS.On3dPoint@,System.Int32,System.Int32@)">
            <summary>Evaluate point at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="side">
[in] optional - determines which side to evaluate from
    =0   default
 &lt;0   to evaluate from below, 
 &gt;0   to evaluate from above
</param>
            <param name="hint">[in/out] optional evaluation hint used to speed repeated evaluations</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
 ON_Curve::PointAt
 ON_Curve::EvTangent
 ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.FrameAt(System.Double,RMA.OpenNURBS.OnPlane@)">
            <summary>Return a 3d frame at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="plane">[out] the frame is returned here</param>
            <returns>TRUE if successful</returns>
            <remarks>
See Also:
 ON_Curve::PointAt, ON_Curve::TangentAt,
 ON_Curve::Ev1Der, Ev2Der
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.CurvatureAt(System.Double)">
            <summary>Evaluate the curvature vector at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <returns>curvature vector of the curve at the parameter t.</returns>
            <remarks>
No error handling.
See Also:
 ON_Curve::EvCurvature
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.TangentAt(System.Double)">
            <summary>Evaluate unit tangent vector at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <returns>Unit tangent vector of the curve at the parameter t.</returns>
            <remarks>
No error handling.
See Also:
 ON_Curve::EvTangent
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.DerivativeAt(System.Double)">
            <summary>Evaluate first derivative at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <returns>First derivative of the curve at the parameter t.</returns>
            <remarks>
No error handling.
See Also:
ON_Curve::Ev1Der
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.PointAtEnd">
            <summary>Evaluate point at the end of the curve.</summary>
            <returns>Point (location of the end of the curve.)</returns>
            <remarks>
No error handling.
See Also:
ON_Curve::PointAt
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.PointAtStart">
            <summary>Evaluate point at the start of the curve.</summary>
            <returns>Point (location of the start of the curve.)</returns>
            <remarks>
No error handling.
See Also:
ON_Curve::PointAt
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.PointAt(System.Double)">
            <summary>Evaluate point at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <returns>Point (location of curve at the parameter t).</returns>
            <remarks>
No error handling.
See Also:
ON_Curve::EvPoint
ON_Curve::PointAtStart
ON_Curve::PointAtEnd
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double)">
            <summary>Test continuity at a curve parameter value.</summary>
            <param name="c">[in] type of continuity to test for. Read ON::continuity comments for details.</param>
            <param name="t">[in] parameter to test</param>
            <returns>TRUE if the curve has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Int32@)">
            <summary>Test continuity at a curve parameter value.</summary>
            <param name="c">[in] type of continuity to test for. Read ON::continuity comments for details.</param>
            <param name="t">[in] parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <returns>TRUE if the curve has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Int32@,System.Double)">
            <summary>Test continuity at a curve parameter value.</summary>
            <param name="c">[in] type of continuity to test for. Read ON::continuity comments for details.</param>
            <param name="t">[in] parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance, then the curve is not C0.
</param>
            <returns>TRUE if the curve has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Int32@,System.Double,System.Double)">
            <summary>Test continuity at a curve parameter value.</summary>
            <param name="c">[in] type of continuity to test for. Read ON::continuity comments for details.</param>
            <param name="t">[in] parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance, then the curve is not C0.
</param>
            <param name="d1_tolerance">
[in] if the difference between two first derivatives is greater than d1_tolerance, then the curve is not C1.
</param>
            <returns>TRUE if the curve has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Int32@,System.Double,System.Double,System.Double)">
            <summary>Test continuity at a curve parameter value.</summary>
            <param name="c">[in] type of continuity to test for. Read ON::continuity comments for details.</param>
            <param name="t">[in] parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance, then the curve is not C0.
</param>
            <param name="d1_tolerance">
[in] if the difference between two first derivatives is greater than d1_tolerance, then the curve is not C1.
</param>
            <param name="d2_tolerance">
[in] if the difference between two second derivatives is greater than d2_tolerance, then the curve is not C2.
</param>
            <returns>TRUE if the curve has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Int32@,System.Double,System.Double,System.Double,System.Double)">
            <summary>Test continuity at a curve parameter value.</summary>
            <param name="c">[in] type of continuity to test for. Read ON::continuity comments for details.</param>
            <param name="t">[in] parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance, then the curve is not C0.
</param>
            <param name="d1_tolerance">
[in] if the difference between two first derivatives is greater than d1_tolerance, then the curve is not C1.
</param>
            <param name="d2_tolerance">
[in] if the difference between two second derivatives is greater than d2_tolerance, then the curve is not C2.
</param>
            <param name="cos_angle_tolerance">
[in] default = cos(1 degree) Used only when c is ON::G1_continuous or ON::G2_continuous.
If the cosine of the angle between two tangent vectors is &lt;= cos_angle_tolerance,
then a G1 discontinuity is reported.
</param>
            <returns>TRUE if the curve has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Int32@,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Test continuity at a curve parameter value.</summary>
            <param name="c">[in] type of continuity to test for. Read ON::continuity comments for details.</param>
            <param name="t">[in] parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance, then the curve is not C0.
</param>
            <param name="d1_tolerance">
[in] if the difference between two first derivatives is greater than d1_tolerance, then the curve is not C1.
</param>
            <param name="d2_tolerance">
[in] if the difference between two second derivatives is greater than d2_tolerance, then the curve is not C2.
</param>
            <param name="cos_angle_tolerance">
[in] default = cos(1 degree) Used only when c is ON::G1_continuous or ON::G2_continuous.
If the cosine of the angle between two tangent vectors is &lt;= cos_angle_tolerance,
then a G1 discontinuity is reported.
</param>
            <param name="curvature_tolerance">
[in] (default = ON_SQRT_EPSILON) Used only when c is ON::G2_continuous. If K0 and K1 are
curvatures evaluated from above and below and |K0 - K1| &gt; curvature_tolerance, then a
curvature discontinuity is reported.
</param>
            <returns>TRUE if the curve has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetNextDiscontinuity(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through
the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c is
a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">
[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1.
 Note well that all curves are parametrically continuous at the ends of
 their domains.
Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetNextDiscontinuity(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@,System.Int32@)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through
the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c is
a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">
[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.
</param>
            <param name="hint">
[in/out] if GetNextDiscontinuity will be called repeatedly, passing a "hint"
with initial value *hint=0 will increase the speed of the search.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1.
 Note well that all curves are parametrically continuous at the ends of
 their domains.
Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetNextDiscontinuity(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@,System.Int32@,System.Int32@)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through
the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c is
a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">
[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.
</param>
            <param name="hint">
[in/out] if GetNextDiscontinuity will be called repeatedly, passing a "hint"
with initial value *hint=0 will increase the speed of the search.
</param>
            <param name="dtype">
[out] if not NULL, *dtype reports the kind of discontinuity found at *t.
A value of 1 means the first derivative or unit tangent was discontinuous.
A value of 2 means the second derivative or curvature was discontinuous.
A value of 0 means teh curve is not closed, a locus discontinuity test was applied,
and t1 is at the start of end of the curve.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1.
 Note well that all curves are parametrically continuous at the ends of
 their domains.
Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetNextDiscontinuity(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@,System.Int32@,System.Int32@,System.Double)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through
the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c is
a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">
[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.
</param>
            <param name="hint">
[in/out] if GetNextDiscontinuity will be called repeatedly, passing a "hint"
with initial value *hint=0 will increase the speed of the search.
</param>
            <param name="dtype">
[out] if not NULL, *dtype reports the kind of discontinuity found at *t.
A value of 1 means the first derivative or unit tangent was discontinuous.
A value of 2 means the second derivative or curvature was discontinuous.
A value of 0 means teh curve is not closed, a locus discontinuity test was applied,
and t1 is at the start of end of the curve.
</param>
            <param name="cos_angle_tolerance">
[in] default = cos(1 degree) Used only when c is ON::G1_continuous or ON::G2_continuous.
If the cosine of the angle between two tangent vectors is &lt;= cos_angle_tolerance,
then a G1 discontinuity is reported.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1.
 Note well that all curves are parametrically continuous at the ends of
 their domains.
Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetNextDiscontinuity(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@,System.Int32@,System.Int32@,System.Double,System.Double)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through
the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c is
a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">
[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.
</param>
            <param name="hint">
[in/out] if GetNextDiscontinuity will be called repeatedly, passing a "hint"
with initial value *hint=0 will increase the speed of the search.
</param>
            <param name="dtype">
[out] if not NULL, *dtype reports the kind of discontinuity found at *t.
A value of 1 means the first derivative or unit tangent was discontinuous.
A value of 2 means the second derivative or curvature was discontinuous.
A value of 0 means teh curve is not closed, a locus discontinuity test was applied,
and t1 is at the start of end of the curve.
</param>
            <param name="cos_angle_tolerance">
[in] default = cos(1 degree) Used only when c is ON::G1_continuous or ON::G2_continuous.
If the cosine of the angle between two tangent vectors is &lt;= cos_angle_tolerance,
then a G1 discontinuity is reported.
</param>
            <param name="curvature_tolerance">
[in] (default = ON_SQRT_EPSILON) Used only when c is ON::G2_continuous.
If K0 and K1 are curvatures evaluated from above and below and |K0 - K1| &gt; curvature_tolerance,
then a curvature discontinuity is reported.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1.
 Note well that all curves are parametrically continuous at the ends of
 their domains.
Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsPeriodic">
            <summary>Test a curve to see if it is periodic.</summary>
            <returns>TRUE if the curve is closed and at least C2 at the start/end.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsClosed">
            <summary>Test a curve to see if it is closed.</summary>
            <returns>TRUE if the curve is closed.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsClosable(System.Double)">
            <summary>
Decide if it makes sense to close off this curve by moving 
the endpoint to the start based on start-end gap size and length
of curve as approximated by chord defined by 6 points.
</summary>
            <param name="tolerance">
[in] maximum allowable distance between start and end.
if start - end gap is greater than tolerance, returns false
</param>
            <returns>
true if start and end points are close enough based on above conditions.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsClosable(System.Double,System.Double)">
            <summary>
Decide if it makes sense to close off this curve by moving 
the endpoint to the start based on start-end gap size and length
of curve as approximated by chord defined by 6 points.
</summary>
            <param name="tolerance">
[in] maximum allowable distance between start and end.
if start - end gap is greater than tolerance, returns false
</param>
            <param name="min_abs_size">
[in] if greater than 0.0 and none of the interior sampled
points are at least min_abs_size from start, returns false.
</param>
            <returns>
true if start and end points are close enough based on above conditions.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsClosable(System.Double,System.Double,System.Double)">
            <summary>
Decide if it makes sense to close off this curve by moving 
the endpoint to the start based on start-end gap size and length
of curve as approximated by chord defined by 6 points.
</summary>
            <param name="tolerance">
[in] maximum allowable distance between start and end.
if start - end gap is greater than tolerance, returns false
</param>
            <param name="min_abs_size">
[in] if greater than 0.0 and none of the interior sampled
points are at least min_abs_size from start, returns false.
</param>
            <param name="min_rel_size">
[in] if greater than 1.0 and chord length is less than 
min_rel_size*gap, returns false.
</param>
            <returns>
true if start and end points are close enough based on above conditions.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsInPlane(RMA.OpenNURBS.IOnPlane)">
            <summary>
Test a curve to see if it lies in a specific plane.
</summary>
            <param name="test_plane">[in]</param>
            <returns>
TRUE if the maximum distance from the curve to the
test_plane is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsInPlane(RMA.OpenNURBS.IOnPlane,System.Double)">
            <summary>
Test a curve to see if it lies in a specific plane.
</summary>
            <param name="test_plane">[in]</param>
            <param name="tolerance">[in] tolerance to use when checking</param>
            <returns>
TRUE if the maximum distance from the curve to the
test_plane is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsPlanar">
            <summary>Test a curve to see if it is planar.</summary>
            <returns>
TRUE if there is a plane such that the maximum distance from
the curve to the plane is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsPlanar(RMA.OpenNURBS.OnPlane)">
            <summary>Test a curve to see if it is planar.</summary>
            <param name="plane">
[out] if not NULL and TRUE is returned, the plane parameters are filled in.
</param>
            <returns>
TRUE if there is a plane such that the maximum distance from
the curve to the plane is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsPlanar(RMA.OpenNURBS.OnPlane,System.Double)">
            <summary>Test a curve to see if it is planar.</summary>
            <param name="plane">
[out] if not NULL and TRUE is returned, the plane parameters are filled in.
</param>
            <param name="tolerance">[in] tolerance to use when checking</param>
            <returns>
TRUE if there is a plane such that the maximum distance from
the curve to the plane is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsArc">
            <summary>
Test a curve to see if the locus if its points is an arc or circle.
</summary>
            <returns>
ON_Arc.m_angle &gt; 0 if curve locus is an arc between
specified points.  If ON_Arc.m_angle is 2.0*ON_PI, then the curve
is a circle.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsArc(RMA.OpenNURBS.IOnPlane)">
            <summary>
Test a curve to see if the locus if its points is an arc or circle.
</summary>
            <param name="plane">[in] if not NULL, test is performed in this plane</param>
            <returns>
ON_Arc.m_angle &gt; 0 if curve locus is an arc between
specified points.  If ON_Arc.m_angle is 2.0*ON_PI, then the curve
is a circle.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsArc(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.OnArc)">
            <summary>
Test a curve to see if the locus if its points is an arc or circle.
</summary>
            <param name="plane">[in] if not NULL, test is performed in this plane</param>
            <param name="arc">[out] if not NULL and TRUE is returned, then arc parameters are filled in</param>
            <returns>
ON_Arc.m_angle &gt; 0 if curve locus is an arc between
specified points.  If ON_Arc.m_angle is 2.0*ON_PI, then the curve
is a circle.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsArc(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.OnArc,System.Double)">
            <summary>
Test a curve to see if the locus if its points is an arc or circle.
</summary>
            <param name="plane">[in] if not NULL, test is performed in this plane</param>
            <param name="arc">[out] if not NULL and TRUE is returned, then arc parameters are filled in</param>
            <param name="tolerance">[in] tolerance to use when checking</param>
            <returns>
ON_Arc.m_angle &gt; 0 if curve locus is an arc between
specified points.  If ON_Arc.m_angle is 2.0*ON_PI, then the curve
is a circle.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsPolyline">
            <summary>
Several types of ON_Curve can have the form of a polyline including a degree 1 ON_NurbsCurve,
an ON_PolylineCurve, and an ON_PolyCurve all of whose segments are some form of polyline.
IsPolyline tests a curve to see if it can be represented as a polyline.
</summary>
            <returns>
0 curve is not some form of a polyline
&gt;=2 number of points in polyline form
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsPolyline(RMA.OpenNURBS.ArrayOn3dPoint)">
            <summary>
Several types of ON_Curve can have the form of a polyline including a degree 1 ON_NurbsCurve,
an ON_PolylineCurve, and an ON_PolyCurve all of whose segments are some form of polyline.
IsPolyline tests a curve to see if it can be represented as a polyline.
</summary>
            <param name="pline_points">
[out] if not NULL and TRUE is returned, then the points of the polyline form are returned here.
</param>
            <returns>
0 curve is not some form of a polyline
&gt;=2 number of points in polyline form
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsPolyline(RMA.OpenNURBS.ArrayOn3dPoint,RMA.OpenNURBS.Arraydouble)">
            <summary>
Several types of ON_Curve can have the form of a polyline including a degree 1 ON_NurbsCurve,
an ON_PolylineCurve, and an ON_PolyCurve all of whose segments are some form of polyline.
IsPolyline tests a curve to see if it can be represented as a polyline.
</summary>
            <param name="pline_points">
[out] if not NULL and TRUE is returned, then the points of the polyline form are returned here.
</param>
            <param name="pline_t">
[out] if not NULL and TRUE is returned, then the parameters of the polyline points are returned here.
</param>
            <returns>
0 curve is not some form of a polyline
&gt;=2 number of points in polyline form
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsLinear">
            <summary>
Test a curve to see if the locus if its points is a line segment.
</summary>
            <returns>
TRUE if the ends of the curve are farther than tolerance apart
and the maximum distance from any point on the curve to
the line segment connecting the curve's ends is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsLinear(System.Double)">
            <summary>
Test a curve to see if the locus if its points is a line segment.
</summary>
            <param name="tolerance">[in] tolerance to use when checking linearity</param>
            <returns>
TRUE if the ends of the curve are farther than tolerance apart
and the maximum distance from any point on the curve to
the line segment connecting the curve's ends is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetParameterTolerance(System.Double,System.Double@,System.Double@)">
            <summary>
Returns maximum algebraic degree of any span
or a good estimate if curve spans are not algebraic.
</summary>
            <param name="t">[IN] t = parameter in domain</param>
            <param name="tminus">[OUT]</param>
            <param name="tplus">[OUT]</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.Degree">
            <summary>
Returns maximum algebraic degree of any span
or a good estimate if curve spans are not algebraic.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetSpanVectorIndex(System.Double,System.Int32,System.Int32@,RMA.OpenNURBS.OnInterval)">
            <summary>
If t is in the domain of the curve, GetSpanVectorIndex() returns the 
span vector index "i" such that span_vector[i] &lt;= t &lt;= span_vector[i+1].
The "side" parameter determines which span is selected when t is at the
end of a span.
</summary>
            <param name="t">[IN] t = evaluation parameter</param>
            <param name="side">[IN] side 0 = default, -1 = from below, +1 = from above</param>
            <param name="span_vector_index">[OUT] span vector index</param>
            <param name="span_domain">[OUT] domain of the span containing "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetSpanVector(System.Double[]@)">
            <summary>Get number of parameters of "knots".</summary>
            <param name="knots">
[out] an array of length SpanCount()+1 is filled in
with the parameters where the curve is not smooth (C-infinity).
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.SpanCount">
            <summary>Get number of nonempty smooth (c-infinity) spans in curve</summary>
            <returns>Number of nonempty smooth (c-infinity) spans.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.Domain">
            <summary>
domain of the curve.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetDomain(System.Double@,System.Double@)">
            <summary>Gets domain of the curve</summary>
            <param name="t0">[out]</param>
            <param name="t1">[out] domain is [*t0, *t1]</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.DuplicateCurve">
            <summary>Get a duplicate of the curve.</summary>
            <returns>A duplicate of the curve.</returns>
            <remarks>
The caller must delete the returned curve. For non-ON_CurveProxy objects,
this simply duplicates the curve using ON_Object::Duplicate.
For ON_CurveProxy objects, this duplicates the actual proxy curve geometry and,
if necessary, trims and reverse the result to that the returned curve's
parameterization and locus match the proxy curve's.
</remarks>
        </member>
        <member name="T:RMA.OpenNURBS.IOnCurve">
            <summary>pure virtual class for curve objects</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveTree.NewLeaf">
            <summary>
Description: Expert user tool to get a curve tree leaf node. This node will be destroyed by this tree's destructor. Returns: A surface tree node with m_bez and m_bez-&gt;m_cv. Never delete or free the returned pointer, m_bez, or m_bez-&gt;m_cv.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveTree.NewNode">
            <summary>
Description: Expert user tool to get a curve tree interior node. This node will be destroyed by this tree's destructor. Returns: A surface tree node. Never delete or free the returned pointer.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveTree.DestroyTree">
            <summary>
Description: Destroy existing information. Leaves tree in a state where it can be reused for another curve.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveTree.LastLeaf">
            <summary>
Last() returns the last leaf interval in the curve tree.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveTree.FirstLeaf">
            <summary>
First() returns the first leaf interval in the curve tree.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurveTree.LastLeaf">
            <summary>
Last() returns the last leaf interval in the curve tree.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurveTree.FirstLeaf">
            <summary>
First() returns the first leaf interval in the curve tree.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveTreeNode.Split(System.Double,RMA.OpenNURBS.OnCurveTreeNode@,RMA.OpenNURBS.OnCurveTreeNode@)">
            <summary>
Description: Expert user tool to split a curve tree node. Does not modify this node's m_down[] pointers or left and right's m_up pointers. Care must be take to gaurd against memory leaks and double deletes. Parameters: s - [in] normalized (bezier parameter) 0 &lt; s &lt; 1 The cooresponding surface domain parameter is m_domain.ParameterAt(s). left_node - [in] node to hold the left half. right_node - [in] node to hold the right half. Returns: True if input is valid and split was performed.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveTreeNode.TreeContaining(RMA.OpenNURBS.IOnInterval)">
            <summary>
Returns the smallest subtree that contain the given interval.
Returns NULL if range is not contained the domain of this subtree.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveTreeNode.IsFartherThan(System.Double,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Quickly determine if the shortest distance from the point P to the portion of the curve coverered by this node is greater than d. Parameters: d - [in] distance (&gt; 0.0) P - [in] other - [in] Returns: True if if the shortest distance from the point P to the portion of the curve covered by this node is greater than d. Remarks: This is conceptually the same but faster than calling MinimumDistanceUpperBound(other) &gt; d.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveTreeNode.MaximumDistanceUpperBound(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Quickly find an upper bound on the distance from a P to the portion of the curve covered by this node. Parameters: P - [in] Returns: A distance that is greater than or equal to the longest distance from P to a point on the curve covered by this node. Put another way, if Q is any point on the portion of the curve covered by this node, then P.DistanceTo(Q) &lt;= MaximumDistanceTo(P);
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveTreeNode.MinimumDistanceUpperBound(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Quickly find an upper bound on the shortest distance from this curve node to the other object. Parameters: P - [in] other - [in] Returns: A distance that is greater than or equal to the shortest distance from this curve node to the other object. Put another way, there exists a point Q on the portion of the curve covered by this node and a point P on the other object such that P.DistanceTo(Q) &lt;= MinimumDistanceUpperBound();
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveTreeNode.MinimumDistanceLowerBound(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Quickly find a lower bound on the distance from this curve node to the other object. Parameters: P - [in] other - [in] Returns: A distance that is less than or equal to the shortest distance from this curve node to the other object. Put another way, if Q is any point Q on the portion of the curve covered by this node and P is any point on the other object, then P.DistanceTo(Q) &gt;= MinimumDistanceTo();
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveTreeNode.PrevLeaf">
            <summary>
Prev() moves to the previous leaf interval in the curve tree if this
node is a leaf node.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveTreeNode.SetBezier(RMA.OpenNURBS.IOnBezierCurve)">
            <summary>
Set from a bezier or from the defining data for a bezier. Sets
m_bbox, m_bez,  m_radius.   Leaves m_domain unchanged.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveTreeNode.AdjustParameter">
            <summary>
Description: Used to determine if the node's parametization differs from the tree's curve parametization. If the parameterizations are different, then use ON_Curve::GetCurveParameterFromNurbFormParameter to convert node parameters to curve parameters and ON_Curve::GetCurveParameterFromNurbFormParameter to convert curve parameters to node parameters. Returns: True if the node's parametization differs from the tree's curve parametization. See Also: ON_Curve::GetCurveParameterFromNurbFormParameter ON_Curve::GetCurveParameterFromNurbFormParameter
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveTreeNode.FindLeaf(System.Double)">
            <summary>
Description: Starting at this node, find the leaf node whose domain contains that parameter t. Parameters: t - [in] side [in] If t lies at the start/end of a domain, side contols which leaf is returned. If side &gt;= 0, the node with domain (t,...) is returned. If side &lt; 0, the node with domain (...,t) is returned. Returns: Pointer to the node that contains t. If t &lt; the start of this node's domain, the node for the start is returned. If t &gt; the end of this node's domain, the node for the end parameter is returned.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveTreeNode.FindLeaf(System.Double,System.Int32)">
            <summary>
Description: Starting at this node, find the leaf node whose domain contains that parameter t. Parameters: t - [in] side [in] If t lies at the start/end of a domain, side contols which leaf is returned. If side &gt;= 0, the node with domain (t,...) is returned. If side &lt; 0, the node with domain (...,t) is returned. Returns: Pointer to the node that contains t. If t &lt; the start of this node's domain, the node for the start is returned. If t &gt; the end of this node's domain, the node for the end parameter is returned.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveTreeNode.#ctor">
            <value>
1 = destroy with delete
2 = destroy with free
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnCurveTreeNode.m_bezmem">
            <value>
0 = do not destroy
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnCurveTreeNode.m_nodemem">
            <value>
0 = do not destroy
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnCurveTreeNode.m_nodetype">
            <value>
8 bits to flag special nodes
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnCurveTreeNode.m_nodesn">
            <value>
serial number of this node
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnCurveTreeNode.m_treesn">
            <value>
serial number of this tree
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnCurveTreeNode.m_bbox">
            <value>
Bounding box of the portion of the curve with domain
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnCurveTreeNode.m_domain">
            <value>
m_domain records the portion of the curve's domain that
this node defines.  It is always increasing an included
in the curve's domain.
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurveTreeNode.Split(System.Double,RMA.OpenNURBS.OnCurveTreeNode@,RMA.OpenNURBS.OnCurveTreeNode@)">
            <summary>
Description: Expert user tool to split a curve tree node. Does not modify this node's m_down[] pointers or left and right's m_up pointers. Care must be take to gaurd against memory leaks and double deletes. Parameters: s - [in] normalized (bezier parameter) 0 &lt; s &lt; 1 The cooresponding surface domain parameter is m_domain.ParameterAt(s). left_node - [in] node to hold the left half. right_node - [in] node to hold the right half. Returns: True if input is valid and split was performed.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurveTreeNode.TreeContaining(RMA.OpenNURBS.IOnInterval)">
            <summary>
Returns the smallest subtree that contain the given interval.
Returns NULL if range is not contained the domain of this subtree.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurveTreeNode.IsFartherThan(System.Double,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Quickly determine if the shortest distance from the point P to the portion of the curve coverered by this node is greater than d. Parameters: d - [in] distance (&gt; 0.0) P - [in] other - [in] Returns: True if if the shortest distance from the point P to the portion of the curve covered by this node is greater than d. Remarks: This is conceptually the same but faster than calling MinimumDistanceUpperBound(other) &gt; d.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurveTreeNode.MaximumDistanceUpperBound(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Quickly find an upper bound on the distance from a P to the portion of the curve covered by this node. Parameters: P - [in] Returns: A distance that is greater than or equal to the longest distance from P to a point on the curve covered by this node. Put another way, if Q is any point on the portion of the curve covered by this node, then P.DistanceTo(Q) &lt;= MaximumDistanceTo(P);
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurveTreeNode.MinimumDistanceUpperBound(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Quickly find an upper bound on the shortest distance from this curve node to the other object. Parameters: P - [in] other - [in] Returns: A distance that is greater than or equal to the shortest distance from this curve node to the other object. Put another way, there exists a point Q on the portion of the curve covered by this node and a point P on the other object such that P.DistanceTo(Q) &lt;= MinimumDistanceUpperBound();
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurveTreeNode.MinimumDistanceLowerBound(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Quickly find a lower bound on the distance from this curve node to the other object. Parameters: P - [in] other - [in] Returns: A distance that is less than or equal to the shortest distance from this curve node to the other object. Put another way, if Q is any point Q on the portion of the curve covered by this node and P is any point on the other object, then P.DistanceTo(Q) &gt;= MinimumDistanceTo();
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurveTreeNode.PrevLeaf">
            <summary>
Prev() moves to the previous leaf interval in the curve tree if this
node is a leaf node.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurveTreeNode.AdjustParameter">
            <summary>
Description: Used to determine if the node's parametization differs from the tree's curve parametization. If the parameterizations are different, then use ON_Curve::GetCurveParameterFromNurbFormParameter to convert node parameters to curve parameters and ON_Curve::GetCurveParameterFromNurbFormParameter to convert curve parameters to node parameters. Returns: True if the node's parametization differs from the tree's curve parametization. See Also: ON_Curve::GetCurveParameterFromNurbFormParameter ON_Curve::GetCurveParameterFromNurbFormParameter
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurveTreeNode.FindLeaf(System.Double)">
            <summary>
Description: Starting at this node, find the leaf node whose domain contains that parameter t. Parameters: t - [in] side [in] If t lies at the start/end of a domain, side contols which leaf is returned. If side &gt;= 0, the node with domain (t,...) is returned. If side &lt; 0, the node with domain (...,t) is returned. Returns: Pointer to the node that contains t. If t &lt; the start of this node's domain, the node for the start is returned. If t &gt; the end of this node's domain, the node for the end parameter is returned.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurveTreeNode.FindLeaf(System.Double,System.Int32)">
            <summary>
Description: Starting at this node, find the leaf node whose domain contains that parameter t. Parameters: t - [in] side [in] If t lies at the start/end of a domain, side contols which leaf is returned. If side &gt;= 0, the node with domain (t,...) is returned. If side &lt; 0, the node with domain (...,t) is returned. Returns: Pointer to the node that contains t. If t &lt; the start of this node's domain, the node for the start is returned. If t &gt; the end of this node's domain, the node for the end parameter is returned.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurveTreeNode.IsValid(RMA.OpenNURBS.OnTextLog,System.Int32,System.Int32,RMA.OpenNURBS.IOnCurve)">
            <value>
1 = destroy with delete
2 = destroy with free
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnCurveTreeNode.m_bezmem">
            <value>
0 = do not destroy
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnCurveTreeNode.m_nodemem">
            <value>
0 = do not destroy
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnCurveTreeNode.m_nodetype">
            <value>
8 bits to flag special nodes
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnCurveTreeNode.m_nodesn">
            <value>
serial number of this node
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnCurveTreeNode.m_treesn">
            <value>
serial number of this tree
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnCurveTreeNode.m_bbox">
            <value>
Bounding box of the portion of the curve with domain
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnCurveTreeNode.m_domain">
            <value>
m_domain records the portion of the curve's domain that
this node defines.  It is always increasing an included
in the curve's domain.
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.EvaluatePoint(RMA.OpenNURBS.IOnObjRef,RMA.OpenNURBS.On3dPoint@)">
            <summary>Evaluate the location of a point from the object reference.</summary>
            <param name="objref">[in]</param>
            <param name="point">
[out] If the evaluation cannot be performed, ON_UNSET_POINT is returned.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.ComponentIndex">
            <summary>
If this piece of geometry is a component in something larger, like an ON_BrepEdge
in an ON_Brep, then this function returns the component index.
</summary>
            <returns>
This object's component index. If this object is not a sub-piece 
of a larger geometric entity, then the returned index has m_type = ON_COMPONENT_INDEX::invalid_type
and m_index = -1.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.BrepForm">
            <summary>If possible, BrepForm() creates a brep form of the ON_Geometry.</summary>
            <returns>
a pointer to on ON_Brep or NULL. If the brep parameter is not NULL,
then brep is returned if the geometry has a brep form and NULL is returned
if the geometry does not have a brep form.
</returns>
            <remarks>
The caller is responsible for managing the brep memory.
See Also ON_Geometry::HasBrepForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.BrepForm(RMA.OpenNURBS.OnBrep)">
            <summary>If possible, BrepForm() creates a brep form of the ON_Geometry.</summary>
            <param name="brep">[in] if not NULL, brep is used to store the brep form of the geometry.</param>
            <returns>
a pointer to on ON_Brep or NULL. If the brep parameter is not NULL,
then brep is returned if the geometry has a brep form and NULL is returned
if the geometry does not have a brep form.
</returns>
            <remarks>
The caller is responsible for managing the brep memory.
See Also ON_Geometry::HasBrepForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.HasBrepForm">
            <summary>Query an object to see if it has an ON_Brep form.</summary>
            <returns>
TRUE if the virtual ON_Geometry::BrepForm can compute an ON_Brep representation of this object.
</returns>
            <remarks>
The default implementation of ON_Geometry::BrepForm returns FALSE.
See Also ON_Geometry::BrepForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.IsMorphable">
            <summary>
Returns: True if the object can be morphed by calling Morph(). See Also: ON_Geometry::Morph
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.Morph(RMA.OpenNURBS.IOnSpaceMorph)">
            <summary>Apply the space morph to this geometry.</summary>
            <param name="morph">[in]</param>
            <returns>
True is successful. If false is returned, the object may be damaged and should be discarded.
See Also: ON_Geometry::IsMorphable
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.SwapCoordinates(System.Int32,System.Int32)">
            <summary>Swaps object coordinate values with indices i and j.</summary>
            <param name="i">[in] coordinate index</param>
            <param name="j">[in] coordinate index</param>
            <remarks>
The default implementation uses the virtual Transform() 
function to calculate the result.  If you are creating
an object where Transform() is slow, coordinate swapping
will be frequently used, and coordinate swapping can
be quickly accomplished, then override this function.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.MakeDeformable">
            <summary>
If possible, converts the object into a form that can be accuratly modified
with "squishy" transformations like projections, shears, and
non-uniform scaling.
</summary>
            <returns>
False if object cannot be converted to a deformable object.
True if object was already deformable or was converted into a deformable object.
See Also: ON_Geometry::IsDeformable();
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.IsDeformable">
            <summary>
Returns: True if object can be accuratly modified with "squishy"
transformations like projections, shears, an non-uniform scaling.
See Also: ON_Geometry::MakeDeformable();
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>Transforms the object.</summary>
            <param name="xform">
[in] transformation to apply to object. If xform.IsSimilarity() is zero,
then you may want to call MakeSquishy() before calling Transform.
</param>
            <remarks>
When overriding this function, be sure to include a call to
ON_Object::TransformUserData() which takes care of transforming
any ON_UserData that may be attached to the object.
See Also: ON_Geometry::IsDeformable();
Classes derived from ON_Geometry should call ON_Geometry::Transform()
to handle user data transformations and then transform their definition.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.ClearBoundingBox">
            <summary>
Some objects cache bounding box information.
If you modify an object, then call ClearBoundingBox()
to inform the object that any cached bounding boxes
are invalid.  
</summary>
            <remarks>
Generally, ClearBoundingBox() overrides
simply invalidate a cached bounding box and then wait
for a call to GetBBox() before recomputing the bounding box.
The default implementation does nothing.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <returns>True if a valid tight_bbox is returned.</returns>
            <remarks>In general, GetTightBoundingBox is slower that BoundingBox, especially when xform is not null.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true and the input tight_bbox is valid,
then returned tight_bbox is the union of the input tight_bbox
and the curve's tight bounding box.
</param>
            <returns>True if a valid tight_bbox is returned.</returns>
            <remarks>In general, GetTightBoundingBox is slower that BoundingBox, especially when xform is not null.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32,RMA.OpenNURBS.IOnXform)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true and the input tight_bbox is valid,
then returned tight_bbox is the union of the input tight_bbox
and the curve's tight bounding box.
</param>
            <param name="xform">
[in] (default=NULL) If not NULL, the tight bounding box of the
transformed geometry is calculated. The geometry is not modified.
</param>
            <returns>True if a valid tight_bbox is returned.</returns>
            <remarks>In general, GetTightBoundingBox is slower that BoundingBox, especially when xform is not null.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.Dimension">
            <summary>Dimension of the object.</summary>
            <remarks>
The dimension is typically three.  For parameter space trimming
curves the dimension is two.  In rare cases the dimension can
be one or greater than three.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.Scale(System.Double)">
            <summary>
Scales the object by the specified facotor.  The scale is
centered at the origin.
</summary>
            <returns>TRUE if object successfully scaled</returns>
            <remarks>Uses virtual Transform() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.Translate(RMA.OpenNURBS.IOn3dVector)">
            <summary>Translates the object along the specified vector.</summary>
            <returns>TRUE if object successfully translated</returns>
            <remarks>Uses virtual Transform() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.Rotate(System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Rotates the object about the specified axis.  A positive
rotation angle results in a counter-clockwise rotation
about the axis (right hand rule).
</summary>
            <param name="rotation_angle">[in] angle of rotation in radians</param>
            <param name="rotation_axis">[in] direction of the axis of rotation</param>
            <param name="rotation_center">[in] point on the axis of rotation</param>
            <returns>TRUE if object successfully rotated</returns>
            <remarks>Uses virtual Transform() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Rotates the object about the specified axis.  A positive
rotation angle results in a counter-clockwise rotation
about the axis (right hand rule).
</summary>
            <param name="sin_angle">[in] sine of rotation angle</param>
            <param name="cos_angle">[in] sine of rotation angle</param>
            <param name="rotation_axis">[in] direction of the axis of rotation</param>
            <param name="rotation_center">[in] point on the axis of rotation</param>
            <returns>TRUE if object successfully rotated</returns>
            <remarks>Uses virtual Transform() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.GetBoundingBox(RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@)">
            <summary>
Get corners of object's 3d axis aligned bounding box or
the union of the input box with the object's bounding box.
</summary>
            <param name="bbox_min">[in/out] minimum corner of the 3d bounding box</param>
            <param name="bbox_max">[in/out] maximum corner of the 3d bounding box</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.GetBoundingBox(RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@,System.Int32)">
            <summary>
Get corners of object's 3d axis aligned bounding box or
the union of the input box with the object's bounding box.
</summary>
            <param name="bbox_min">[in/out] minimum corner of the 3d bounding box</param>
            <param name="bbox_max">[in/out] maximum corner of the 3d bounding box</param>
            <param name="bGrowBox">
[in] (default=FALSE) 
If TRUE, then the union of the input bbox and the 
object's bounding box is returned.
If FALSE, the object's bounding box is returned.
</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>
Get object's 3d axis aligned bounding box or the
union of the input box with the object's bounding box.
</summary>
            <param name="bbox">[in/out] 3d axis aligned bounding box</param>
            <returns>TRUE if object has bounding box and calculation was successful.</returns>
            <remarks>Uses virtual GetBBox() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>
Get object's 3d axis aligned bounding box or the
union of the input box with the object's bounding box.
</summary>
            <param name="bbox">[in/out] 3d axis aligned bounding box</param>
            <param name="bGrowBox">
[in] (default=FALSE) 
If TRUE, then the union of the input bbox and the 
object's bounding box is returned in bbox.  
If FALSE, the object's bounding box is returned in bbox.
</param>
            <returns>TRUE if object has bounding box and calculation was successful.</returns>
            <remarks>Uses virtual GetBBox() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.BoundingBox">
            <summary>Get object's 3d axis aligned bounding box.</summary>
            <returns>3d bounding box.</returns>
            <remarks>Uses virtual GetBBox() function to calculate the result.</remarks>
        </member>
        <member name="T:RMA.OpenNURBS.OnGeometry">
            <summary>
Base class for all geometry classes that must
provide runtime class id.  Provides interface
for common geometric operations like finding bounding
boxes and transforming.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnGeometry.EvaluatePoint(RMA.OpenNURBS.IOnObjRef,RMA.OpenNURBS.On3dPoint@)">
            <summary>Evaluate the location of a point from the object reference.</summary>
            <param name="objref">[in]</param>
            <param name="point">
[out] If the evaluation cannot be performed, ON_UNSET_POINT is returned.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnGeometry.ComponentIndex">
            <summary>
If this piece of geometry is a component in something larger, like an ON_BrepEdge
in an ON_Brep, then this function returns the component index.
</summary>
            <returns>
This object's component index. If this object is not a sub-piece 
of a larger geometric entity, then the returned index has m_type = ON_COMPONENT_INDEX::invalid_type
and m_index = -1.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnGeometry.BrepForm">
            <summary>If possible, BrepForm() creates a brep form of the ON_Geometry.</summary>
            <returns>
a pointer to on ON_Brep or NULL. If the brep parameter is not NULL,
then brep is returned if the geometry has a brep form and NULL is returned
if the geometry does not have a brep form.
</returns>
            <remarks>
The caller is responsible for managing the brep memory.
See Also ON_Geometry::HasBrepForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnGeometry.BrepForm(RMA.OpenNURBS.OnBrep)">
            <summary>If possible, BrepForm() creates a brep form of the ON_Geometry.</summary>
            <param name="brep">[in] if not NULL, brep is used to store the brep form of the geometry.</param>
            <returns>
a pointer to on ON_Brep or NULL. If the brep parameter is not NULL,
then brep is returned if the geometry has a brep form and NULL is returned
if the geometry does not have a brep form.
</returns>
            <remarks>
The caller is responsible for managing the brep memory.
See Also ON_Geometry::HasBrepForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnGeometry.HasBrepForm">
            <summary>Query an object to see if it has an ON_Brep form.</summary>
            <returns>
TRUE if the virtual ON_Geometry::BrepForm can compute an ON_Brep representation of this object.
</returns>
            <remarks>
The default implementation of ON_Geometry::BrepForm returns FALSE.
See Also ON_Geometry::BrepForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnGeometry.IsMorphable">
            <summary>
Returns: True if the object can be morphed by calling Morph(). See Also: ON_Geometry::Morph
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnGeometry.IsDeformable">
            <summary>
Returns: True if object can be accuratly modified with "squishy"
transformations like projections, shears, an non-uniform scaling.
See Also: ON_Geometry::MakeDeformable();
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnGeometry.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <returns>True if a valid tight_bbox is returned.</returns>
            <remarks>In general, GetTightBoundingBox is slower that BoundingBox, especially when xform is not null.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnGeometry.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true and the input tight_bbox is valid,
then returned tight_bbox is the union of the input tight_bbox
and the curve's tight bounding box.
</param>
            <returns>True if a valid tight_bbox is returned.</returns>
            <remarks>In general, GetTightBoundingBox is slower that BoundingBox, especially when xform is not null.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnGeometry.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32,RMA.OpenNURBS.IOnXform)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true and the input tight_bbox is valid,
then returned tight_bbox is the union of the input tight_bbox
and the curve's tight bounding box.
</param>
            <param name="xform">
[in] (default=NULL) If not NULL, the tight bounding box of the
transformed geometry is calculated. The geometry is not modified.
</param>
            <returns>True if a valid tight_bbox is returned.</returns>
            <remarks>In general, GetTightBoundingBox is slower that BoundingBox, especially when xform is not null.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnGeometry.Dimension">
            <summary>Dimension of the object.</summary>
            <remarks>
The dimension is typically three.  For parameter space trimming
curves the dimension is two.  In rare cases the dimension can
be one or greater than three.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnGeometry.GetBoundingBox(RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@)">
            <summary>
Get corners of object's 3d axis aligned bounding box or
the union of the input box with the object's bounding box.
</summary>
            <param name="bbox_min">[in/out] minimum corner of the 3d bounding box</param>
            <param name="bbox_max">[in/out] maximum corner of the 3d bounding box</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnGeometry.GetBoundingBox(RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@,System.Int32)">
            <summary>
Get corners of object's 3d axis aligned bounding box or
the union of the input box with the object's bounding box.
</summary>
            <param name="bbox_min">[in/out] minimum corner of the 3d bounding box</param>
            <param name="bbox_max">[in/out] maximum corner of the 3d bounding box</param>
            <param name="bGrowBox">
[in] (default=FALSE) 
If TRUE, then the union of the input bbox and the 
object's bounding box is returned.
If FALSE, the object's bounding box is returned.
</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnGeometry.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>
Get object's 3d axis aligned bounding box or the
union of the input box with the object's bounding box.
</summary>
            <param name="bbox">[in/out] 3d axis aligned bounding box</param>
            <returns>TRUE if object has bounding box and calculation was successful.</returns>
            <remarks>Uses virtual GetBBox() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnGeometry.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>
Get object's 3d axis aligned bounding box or the
union of the input box with the object's bounding box.
</summary>
            <param name="bbox">[in/out] 3d axis aligned bounding box</param>
            <param name="bGrowBox">
[in] (default=FALSE) 
If TRUE, then the union of the input bbox and the 
object's bounding box is returned in bbox.  
If FALSE, the object's bounding box is returned in bbox.
</param>
            <returns>TRUE if object has bounding box and calculation was successful.</returns>
            <remarks>Uses virtual GetBBox() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnGeometry.BoundingBox">
            <summary>Get object's 3d axis aligned bounding box.</summary>
            <returns>3d bounding box.</returns>
            <remarks>Uses virtual GetBBox() function to calculate the result.</remarks>
        </member>
        <member name="T:RMA.OpenNURBS.IOnGeometry">
            <summary>
Base class for all geometry classes that must
provide runtime class id.  Provides interface
for common geometric operations like finding bounding
boxes and transforming.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.DuplicateOnObject">
            <summary>Create a copy of the object</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.DestroyRuntimeCache">
            <summary>
Expert user function. If you are using openNURBS in its default configuration
to read and write 3dm archives, you never need to call this function. Many
objects employ lazy creation of (runtime) caches that save information to help
speed geometric calculations. This function will destroy all runtime information.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.DestroyRuntimeCache(System.Boolean)">
            <summary>
Expert user function. If you are using openNURBS in its default configuration
to read and write 3dm archives, you never need to call this function. Many
objects employ lazy creation of (runtime) caches that save information to help
speed geometric calculations. This function will destroy all runtime information.
</summary>
            <param name="bDelete">
[in] if true, any cached information is properly deleted.
If false, any cached information is simply discarded.
This is useful when the cached information may be in alternate memory
pools that are managed in nonstandard ways.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.MoveUserData(RMA.OpenNURBS.OnObject@)">
            <summary>
Expert user tool Moves user data from source_object to this, including
user data with a nil m_userdata_copycount. Deletes any source user data
with a duplicate m_userdata_uuid on this.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.CopyUserData(RMA.OpenNURBS.IOnObject)">
            <summary>
Expert user tool that copies user data that has a positive m_userdata_copycount
from the source_object to this.
</summary>
            <param name="source_object">[in] source of user data to copy</param>
            <remarks>
Generally speaking you don't need to use CopyUserData().
Simply rely on ON_Object::operator=() or the copy constructor to do the right thing.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.TransformUserData(RMA.OpenNURBS.IOnXform)">
            <summary>
Description: User data is stored as a linked list of ON_UserData classes. FirstUserData gets the first item in the linked list. This is the most recent item attached using AttachUserData(). Remark: To iterate through all the user data on an object, call FirstUserData() and then use ON_UserData::Next() to traverse the list.
</summary>
            <summary>
Objects derived from ON_Geometry must call TransformUserData() in their Transform() member function.
</summary>
            <param name="xform">[in] transformation to apply to user data</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.PurgeUserData">
            <summary>
Description: Get a pointer to user data. Parameters: userdata_uuid - [in] value of the user data's m_userdata_uuid field. Remarks: The returned user data is still attached to the object. Deleting the returned user data will automatically remove the user data from the object.
</summary>
            <summary>PurgeUserData() removes all user data from object.</summary>
            <remarks>Use delete GetUserData(...) to destroy a single piece of user data.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.GetUserStringKeys(System.String[]@)">
            <summary>
Description: Get a list of all user strings on an object. Parameters: user_strings - [out] user strings are appended to this list. Returns: Number of elements appended to the user_strings list.
</summary>
            <summary>Get a list of all user string keys on an object.</summary>
            <param name="user_string_keys">[out] user string keys are appended to this list.</param>
            <returns>Number of elements appended to the user_strings list.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.GetUserString(System.String,System.String@)">
            <summary>Get user string from an object.</summary>
            <param name="key">[in] id used to retrieve the string.</param>
            <param name="string_value">[out]</param>
            <returns>True if a string with id was found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.SetUserString(System.String,System.String)">
            <summary>
Attach a user string to an object. This information will perisist through
copy construction, operator=, and file IO.
</summary>
            <param name="key">[in] id used to retrieve this string.</param>
            <param name="string_value">[in] If NULL, the string with this id will be removed.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.ModelObjectId">
            <summary>
All objects in an opennurbs model have an id
( ON_Layer.m_layer_id, ON_Font.m_font_id, ON_Material.m_material_id, ON_3dmObjectAttributes.m_uuid ).
</summary>
            <returns>The id used to identify the object in the openurbs model.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.ObjectType">
            <summary>
Useful for switch statements that need to differentiate between basic
object types like points, curves, surfaces, and so on.
</summary>
            <returns>
ON::object_type enum value.

ON::unknown_object_type unknown object
ON::point_object derived from ON_Point
ON::pointset_object some type of ON_PointCloud, ON_PointGrid, ...
ON::curve_object derived from ON_Curve
ON::surface_object derived from ON_Surface
ON::brep_object derived from ON_Brep
ON::mesh_object derived from ON_Mesh
ON::layer_object derived from ON_Layer
ON::material_object derived from ON_Material
ON::light_object derived from ON_Light
ON::annotation_object derived from ON_Annotation,
ON::userdata_object derived from ON_UserData
ON::text_dot derived from ON_TextDot
</returns>
            <remarks>The default implementation of this virtual function returns ON::unknown_object_type</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.Read(RMA.OpenNURBS.OnBinaryArchive@)">
            <summary>Low level archive writing tool used by ON_BinaryArchive::ReadObject().</summary>
            <param name="binary_archive">archive to read from</param>
            <returns>Returns TRUE if the read is successful.</returns>
            <remarks>
Use ON_BinaryArchive::ReadObject() to read objects. This Read() function
should read the objects definition back into its data members. The default
implementation of this virtual function returns FALSE and does nothing.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.Write(RMA.OpenNURBS.OnBinaryArchive@)">
            <summary>Low level archive writing tool used by ON_BinaryArchive::WriteObject().</summary>
            <param name="binary_archive">archive to write to</param>
            <returns>Returns TRUE if the write is successful.</returns>
            <remarks>
Use ON_BinaryArchive::WriteObject() to write objects. This Write() function
should just write the specific definition of this object. It should not write
and any chunk typecode or length information. The default implementation of
this virtual function returns FALSE and does nothing.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.DataCRC(System.UInt32)">
            <summary>
Returns a CRC calculated from the information that defines the object.
This CRC can be used as a quick way to see if two objects are not identical.
</summary>
            <param name="current_remainder">[in]</param>
            <returns>CRC of the information the defines the object.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.SizeOf">
            <summary>
Returns: An estimate of the amount of memory the class uses in bytes.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.Dump(RMA.OpenNURBS.OnTextLog@)">
            <summary>Creates a text dump of the object.</summary>
            <remarks>
Dump() is intended for debugging and is not suitable for creating
high quality text descriptions of an object. The default implementations
of this virtual function prints the class's name.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.IsValid">
            <summary>Tests an object to see if its data members are correctly initialized.</summary>
            <returns>
TRUE object is valid
FALSE object is invalid, uninitialized, etc.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.IsValid(RMA.OpenNURBS.OnTextLog)">
            <summary>Tests an object to see if its data members are correctly initialized.</summary>
            <param name="text_log">
[in] if the object is not valid and text_log is not NULL, then a brief
english description of the reason the object is not valid is appened to
the log. The information appended to text_log is suitable for low-level
debugging purposes by programmers and is not intended to be useful as a
high level user interface tool.
</param>
            <returns>
TRUE object is valid
FALSE object is invalid, uninitialized, etc.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.IsKindOf(RMA.OpenNURBS.IOnClassId)">
            <summary>
Low level tool to test if an object is derived
from a specified class.
</summary>
            <param name="pClassId">[in] use classname::ClassId()</param>
            <returns>
TRUE if the instantiated object is derived from the
class whose id is passed as the argument.
</returns>
            <example>
 ON_Object* p = ....;
 if ( p-&gt;IsKindOf( ON_NurbsCurve::ClassId() ) )
 {
   it's a NURBS curve
 }
</example>
            <remarks>
The primary reason for IsKindOf() is to support the
static Cast() members declared in the ON_OBJECT_DECLARE
macro.  If we determine that dynamic_cast is properly 
supported and implemented by all supported compilers, 
then IsKindOf() may dissappear.  If an application needs
to determine if a pointer points to a class derived from
ON_SomeClassName, then call 
ON_SomeClassName::Cast(mystery pointer) and check for 
a non-null return.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.MemoryRelocate">
            <summary>
The MemoryRelocate() function is called when an object's location in
memory is changed. For example, if an object resides in a chunk of memory
that is grown by calling a realloc that has to allocate a new chunk and
copy the contents of the old chunk to the new chunk, then the location of
the object's memory changes. In practice this happens when classes
derived from ON_Object are stored in dynamic arrays, like the default
implementation of ON_ObjectArray&lt;&gt;'s that use realloc to grow
the dynamic array.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnObject">
            <summary>
Pure virtual base class for all classes that must provide
runtime class id or support object level 3DM serialization
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnObject.DuplicateOnObject">
            <summary>
Description: Get a pointer to user data. Parameters: userdata_uuid - [in] value of the user data's m_userdata_uuid field. Remarks: The returned user data is still attached to the object. Deleting the returned user data will automatically remove the user data from the object.
</summary>
            <summary>
Description: User data is stored as a linked list of ON_UserData classes. FirstUserData gets the first item in the linked list. This is the most recent item attached using AttachUserData(). Remark: To iterate through all the user data on an object, call FirstUserData() and then use ON_UserData::Next() to traverse the list.
</summary>
            <summary>Create a copy of the object</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnObject.GetUserStringKeys(System.String[]@)">
            <summary>
Description: Get a list of all user strings on an object. Parameters: user_strings - [out] user strings are appended to this list. Returns: Number of elements appended to the user_strings list.
</summary>
            <summary>Get a list of all user string keys on an object.</summary>
            <param name="user_string_keys">[out] user string keys are appended to this list.</param>
            <returns>Number of elements appended to the user_strings list.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnObject.GetUserString(System.String,System.String@)">
            <summary>Get user string from an object.</summary>
            <param name="key">[in] id used to retrieve the string.</param>
            <param name="string_value">[out]</param>
            <returns>True if a string with id was found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnObject.ModelObjectId">
            <summary>
All objects in an opennurbs model have an id
( ON_Layer.m_layer_id, ON_Font.m_font_id, ON_Material.m_material_id, ON_3dmObjectAttributes.m_uuid ).
</summary>
            <returns>The id used to identify the object in the openurbs model.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnObject.ObjectType">
            <summary>
Useful for switch statements that need to differentiate between basic
object types like points, curves, surfaces, and so on.
</summary>
            <returns>
ON::object_type enum value.

ON::unknown_object_type unknown object
ON::point_object derived from ON_Point
ON::pointset_object some type of ON_PointCloud, ON_PointGrid, ...
ON::curve_object derived from ON_Curve
ON::surface_object derived from ON_Surface
ON::brep_object derived from ON_Brep
ON::mesh_object derived from ON_Mesh
ON::layer_object derived from ON_Layer
ON::material_object derived from ON_Material
ON::light_object derived from ON_Light
ON::annotation_object derived from ON_Annotation,
ON::userdata_object derived from ON_UserData
ON::text_dot derived from ON_TextDot
</returns>
            <remarks>The default implementation of this virtual function returns ON::unknown_object_type</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnObject.Write(RMA.OpenNURBS.OnBinaryArchive@)">
            <summary>Low level archive writing tool used by ON_BinaryArchive::WriteObject().</summary>
            <param name="binary_archive">archive to write to</param>
            <returns>Returns TRUE if the write is successful.</returns>
            <remarks>
Use ON_BinaryArchive::WriteObject() to write objects. This Write() function
should just write the specific definition of this object. It should not write
and any chunk typecode or length information. The default implementation of
this virtual function returns FALSE and does nothing.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnObject.DataCRC(System.UInt32)">
            <summary>
Returns a CRC calculated from the information that defines the object.
This CRC can be used as a quick way to see if two objects are not identical.
</summary>
            <param name="current_remainder">[in]</param>
            <returns>CRC of the information the defines the object.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnObject.SizeOf">
            <summary>
Returns: An estimate of the amount of memory the class uses in bytes.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnObject.Dump(RMA.OpenNURBS.OnTextLog@)">
            <summary>Creates a text dump of the object.</summary>
            <remarks>
Dump() is intended for debugging and is not suitable for creating
high quality text descriptions of an object. The default implementations
of this virtual function prints the class's name.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnObject.IsValid">
            <summary>Tests an object to see if its data members are correctly initialized.</summary>
            <returns>
TRUE object is valid
FALSE object is invalid, uninitialized, etc.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnObject.IsValid(RMA.OpenNURBS.OnTextLog)">
            <summary>Tests an object to see if its data members are correctly initialized.</summary>
            <param name="text_log">
[in] if the object is not valid and text_log is not NULL, then a brief
english description of the reason the object is not valid is appened to
the log. The information appended to text_log is suitable for low-level
debugging purposes by programmers and is not intended to be useful as a
high level user interface tool.
</param>
            <returns>
TRUE object is valid
FALSE object is invalid, uninitialized, etc.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnObject.IsKindOf(RMA.OpenNURBS.IOnClassId)">
            <summary>
Low level tool to test if an object is derived
from a specified class.
</summary>
            <param name="pClassId">[in] use classname::ClassId()</param>
            <returns>
TRUE if the instantiated object is derived from the
class whose id is passed as the argument.
</returns>
            <example>
 ON_Object* p = ....;
 if ( p-&gt;IsKindOf( ON_NurbsCurve::ClassId() ) )
 {
   it's a NURBS curve
 }
</example>
            <remarks>
The primary reason for IsKindOf() is to support the
static Cast() members declared in the ON_OBJECT_DECLARE
macro.  If we determine that dynamic_cast is properly 
supported and implemented by all supported compilers, 
then IsKindOf() may dissappear.  If an application needs
to determine if a pointer points to a class derived from
ON_SomeClassName, then call 
ON_SomeClassName::Cast(mystery pointer) and check for 
a non-null return.
</remarks>
        </member>
        <member name="T:RMA.OpenNURBS.IOnObject">
            <summary>
Pure virtual base class for all classes that must provide
runtime class id or support object level 3DM serialization
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnClassId.Mark">
            <summary>
Opennurbs classes have a mark value of 0.
Core Rhino classes have a mark value of 1.
Rhino plug-in classes have a mark value of &gt; 1.
</summary>
            <returns>Class mark value</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClassId.Uuid">
            <summary>
Returns: class uuid
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnClassId.Create">
            <summary>
Create an instance of the class associated with class id.
</summary>
            <returns>Instance of the class id's class.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClassId.IsDerivedFrom(RMA.OpenNURBS.IOnClassId)">
            <summary>
Determine if the class associated with this ON_ClassId
is derived from another class.
</summary>
            <param name="potential_parent">[in] Class to test as parent.</param>
            <returns>TRUE if this is derived from potential_parent.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClassId.BaseClass">
            <summary>
Returns: base class id
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnClassId.BaseClassName">
            <summary>
Returns: base class name
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnClassId.ClassName">
            <summary>
OnExitMemoryCleanup() releases all internal memory used by the
openNURBS classes for Cast() and serialization construction.
ON_ClassId::OnExitMemoryCleanup() should only be called when
the application is finished using the openNURBS library.
</summary>
            <summary>
Returns: class name
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnClassId.Dump(RMA.OpenNURBS.OnTextLog@)">
            <summary>Dumps the ON_ClassId list</summary>
            <param name="dump">[in] destination for the text dump.</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnClassId.Purge(System.Int32)">
            <summary>
Each class derived from ON_Object has a corresponding
ON_ClassId stored in a linked list.  If a class definition
is going to disappear (which happens when the derived object
definition is in a DLL that uses openNURBS as a DLL and the 
DLL containing the derived object's definition is unloaded),
then the class's ON_ClassId needs to be removed from the class 
list.  ON_ClassId::Purge( mark ) removes all ON_ClassIds with a
a prescribed mark and returns the number of classes that
were purged.  
</summary>
            <param name="mark">[in] All ON_ClassIds with this mark will be purged.</param>
            <returns>Number of classes that were purged.</returns>
            <example>
  // Call ON_ClassId::IncrementMark() BEFORE loading MY.DLL.
  int my_dll_classid_mark = ON_ClassId::IncrementMark();
  load MY.DLL with classes derived from ON_Object
  ...
  // Call ON_ClassId::Purge() BEFORE unloading MY.DLL.
  ON_ClassId::Purge( my_dll_classid_mark );
  unload MY.DLL
</example>
        </member>
        <member name="M:RMA.OpenNURBS.OnClassId.IncrementMark">
            <summary>
Each class derived from ON_Object has a corresponding ON_ClassId
stored in a linked list and the class is marked with an integer
value.  ON_ClassId::IncrementMark() increments the value used to
mark new classes and returns the new marking value.
</summary>
            <returns>Value that will be used to mark all future ON_ClassIds.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClassId.ClassId(System.Guid)">
            <summary>Gets a class's ON_ClassId from the class's uuid.</summary>
            <param name="class_uuid">[in] uuid for the class</param>
            <returns>Pointer to the class's ON_ClassId.</returns>
            <example>
ON_UUID brep_uuid = ON_UuidFromString("60B5DBC5-E660-11d3-BFE4-0010830122F0");
const ON_ClassId* brep_id = ON_CLassId::ClassId(brep_uuid);
</example>
        </member>
        <member name="M:RMA.OpenNURBS.OnClassId.ClassId(System.String)">
            <summary>Gets a class's ON_ClassId from the class's name.</summary>
            <param name="sClassName">[in] name of class</param>
            <returns>Pointer to the class's ON_ClassId.</returns>
            <example>const ON_ClassId* brep_id = ON_CLassId::ClassId("ON_Brep");</example>
        </member>
        <member name="T:RMA.OpenNURBS.OnClassId">
            <summary>
Every class derived from ON_Object has a class id that records
its class name, baseclass name, and class uuid.  The 
ON_OBJECT_DECLARE and ON_OBJECT_IMPLEMENT macros generate
the code that creates and initializes class ids.
The ON_Object::IsKindOf() and ON_Object::Cast() functions
use these class ids.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClassId.Mark">
            <summary>
Opennurbs classes have a mark value of 0.
Core Rhino classes have a mark value of 1.
Rhino plug-in classes have a mark value of &gt; 1.
</summary>
            <returns>Class mark value</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClassId.Uuid">
            <summary>
Returns: class uuid
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClassId.Create">
            <summary>
Create an instance of the class associated with class id.
</summary>
            <returns>Instance of the class id's class.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClassId.IsDerivedFrom(RMA.OpenNURBS.IOnClassId)">
            <summary>
Determine if the class associated with this ON_ClassId
is derived from another class.
</summary>
            <param name="potential_parent">[in] Class to test as parent.</param>
            <returns>TRUE if this is derived from potential_parent.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClassId.BaseClass">
            <summary>
Returns: base class id
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClassId.BaseClassName">
            <summary>
Returns: base class name
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClassId.ClassName">
            <summary>
Returns: class name
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnClassId">
            <summary>
Every class derived from ON_Object has a class id that records
its class name, baseclass name, and class uuid.  The 
ON_OBJECT_DECLARE and ON_OBJECT_IMPLEMENT macros generate
the code that creates and initializes class ids.
The ON_Object::IsKindOf() and ON_Object::Cast() functions
use these class ids.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.GetNurbFormParameterFromRadian(System.Double,System.Double@)">
            <summary>Convert a arc radians parameter to a NURBS curve arc parameter.</summary>
            <param name="arc_radians_parameter">[in] 0.0 to 2.0*ON_PI</param>
            <param name="nurbs_parameter">[out]</param>
            <example>
ON_Arc arc = ...;
double arc_t = 1.2345; // some number in interval (0,2.0*ON_PI).
double nurbs_t;
arc.GetNurbFormParameterFromRadian( arc_t, &amp;nurbs_t );
ON_NurbsCurve nurbs_curve;
arc.GetNurbsForm( nurbs_curve );
arc_pt = arc.PointAt(arc_t);
nurbs_pt = nurbs_curve.PointAt(nurbs_t);
// arc_pt and nurbs_pt will be the same
</example>
            <remarks>
The NURBS curve parameter is with respect to the NURBS curve
created by ON_Arc::GetNurbForm. At radian values of 0.0, 0.5*ON_PI,
ON_PI, 1.5*ON_PI, and 2.0*ON_PI, the nurbs parameter and radian
parameter are the same. At all other values the nurbs and radian
parameter values are different.
See Also: ON_Arc::GetNurbFormParameterFromRadian
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.GetRadianFromNurbFormParameter(System.Double,System.Double@)">
            <summary>Convert a NURBS curve arc parameter to a arc radians parameter.</summary>
            <param name="nurbs_parameter">[in]</param>
            <param name="arc_radians_parameter">[out]</param>
            <example>
ON_Arc arc = ...;
double nurbs_t = 1.2345; // some number in interval (0,2.0*ON_PI).
double arc_t;
arc.GetRadianFromNurbFormParameter( nurbs_t, &amp;arc_t );
ON_NurbsCurve nurbs_curve;
arc.GetNurbsForm( nurbs_curve );
arc_pt = arc.PointAt(arc_t);
nurbs_pt = nurbs_curve.PointAt(nurbs_t); 
arc_pt and nurbs_pt will be the same
</example>
            <remarks>
The NURBS curve parameter is with respect to the NURBS curve created
by ON_Arc::GetNurbForm. At nurbs parameter values of 0.0, 0.5*ON_PI, ON_PI,
1.5*ON_PI, and 2.0*ON_PI, the nurbs parameter and radian parameter are the same.
At all other values the nurbs and radian parameter values are different.
See Also: ON_Arc::GetNurbFormParameterFromRadian
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.GetNurbForm(RMA.OpenNURBS.OnNurbsCurve@)">
            <summary>
Get a rational degree 2 NURBS curve representation
of the arc.  Note that the parameterization of NURBS curve
does not match  arc's transcendental paramaterization.  
Use GetRadianFromNurbFormParameter() and
GetParameterFromRadian() to convert between the NURBS curve 
parameter and the transcendental parameter
</summary>
            <param name="nurbs_curve">[out] nurbs_curve returned here.</param>
            <returns>0 for failure and 2 for success.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.Reverse">
            <summary>
Reverse the orientation of the arc.  Changes the domain from [a,b] to [-b.-a].
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.Length">
            <summary>
Length of the arc = radius*(subtended angle in radians).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Get the point on the arc that is closest to test_point.</summary>
            <returns>
The point on the arc that is closest to test_point.
If test_point is the center of the arc, then the 
starting point of the arc is returned.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>Get the point on the arc that is closest to test_point.</summary>
            <param name="t">
[out] parameter (in radians) of the point on the arc that
is closest to test_point.  If test_point is the center
of the arc, then the starting point of the arc is
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.EndPoint">
            <summary>
Point at end of the arc.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.MidPoint">
            <summary>
Point at middle of the arc.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.StartPoint">
            <summary>
Point at start of the arc.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.SetAngleDegrees(System.Double)">
            <summary>Set arc's subtended angle in degrees.</summary>
            <param name="angle_in_degrees">[in] 0 &lt; angle_in_degrees &lt;= 360</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.Trim(RMA.OpenNURBS.IOnInterval)">
            <summary>Set arc's domain as a subdomain of the circle.</summary>
            <param name="domain_radian">[in] 0 &lt; domain_radian[1] - domain_radian[0] &lt;= 2.0 * ON*PI</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.SetAngleIntervalRadians(RMA.OpenNURBS.IOnInterval)">
            <summary>Set arc's angle interval in radians.</summary>
            <param name="angle_in_radians">
[in] increasing interval with start and end angle in radians.
Length of the interval &lt;= 2.0*ON_PI.
</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.SetAngleRadians(System.Double)">
            <summary>
Set arc's subtended angle in radians.
Parameters:
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.DomainDegrees">
            <summary>
The arc's domain in degrees.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.DomainRadians">
            <summary>
The arc's domain in radians.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.Domain">
            <summary>
Get evaluation domain. Returns Evaluation domain (same as DomainRadians()).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.AngleDegrees">
            <summary>
The arc's subtended angle in degrees.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.AngleRadians">
            <summary>
The arc's subtended angle in radians.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.IsCircle">
            <summary>
true if the arc is a complete circle; i.e., the arc's
angle is 360 degrees.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true and the input tight_bbox is valid,
then returned tight_bbox is the union of the input tight_bbox and
the arc's tight bounding box.
</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32,RMA.OpenNURBS.IOnXform)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true and the input tight_bbox is valid,
then returned tight_bbox is the union of the input tight_bbox and
the arc's tight bounding box.
</param>
            <param name="xform">
[in] (default=NULL) If not NULL, the tight bounding box of the
transformed arc is calculated. The arc is not modified.
</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>
Get arc's 3d axis aligned bounding box or the
union of the input box with the arc's bounding box.
</summary>
            <param name="bbox">[in/out] 3d axis aligned bounding box</param>
            <returns>true if arc has bounding box and calculation was successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>
Get arc's 3d axis aligned bounding box or the
union of the input box with the arc's bounding box.
</summary>
            <param name="bbox">[in/out] 3d axis aligned bounding box</param>
            <param name="bGrowBox">
[in] (default=false) 
If true, then the union of the input bbox and the 
arc's bounding box is returned in bbox.  
If false, the arc's bounding box is returned in bbox.
</param>
            <returns>true if arc has bounding box and calculation was successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.BoundingBox">
            <summary>Get arc's 3d axis aligned bounding box.</summary>
            <returns>3d bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.IsValid">
            <summary>Checks an arc to make sure it is valid.</summary>
            <remarks>Radius&gt;0 and 0&lt;AngleRadians()&lt;=2 ON_PI</remarks>
            <returns>true if the arc is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.Dump(RMA.OpenNURBS.OnTextLog@)">
            <summary>
Creates a text dump of the arc listing the normal, center
radius, start point, end point, and angle.
</summary>
            <remarks>
Dump() is intended for debugging and is not suitable
for creating high quality text descriptions of an arc.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.Create(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Create an arc from a 3d start point, 3d start direction, and 3d end point.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.Create(RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOn2dVector,RMA.OpenNURBS.IOn2dPoint)">
            <summary>
Create an arc from a 2d start point, 2d start direction, and 2d end point.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.Create(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
arc through 3 3d points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.Create(RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOn2dPoint)">
            <summary>
arc through 3 2d points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.Create(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double)">
            <summary>
Create an arc parallel to plane from a center point, radius, 
and angle in radians.  The arc starts at center+radius*plane.xaxis.
</summary>
            <param name="plane">circle will be parallel to this plane</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.Create(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double)">
            <summary>
Create an arc parallel to the world XY plane from a center point,
radius, and angle in radians.  The arc starts at center+(radius,0,0).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.Create(RMA.OpenNURBS.IOnPlane,System.Double,System.Double)">
            <summary>
Create an arc from a plane, radius and an angle in radians.
The center of the arc is at the plane's origin.
</summary>
            <param name="plane">[IN] circle is in this plane with center at m_origin</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.Create(RMA.OpenNURBS.IOnCircle,RMA.OpenNURBS.IOnInterval)">
            <summary>Create an arc from a circle and an increasing angle interval</summary>
            <param name="circle">[in]</param>
            <param name="angle_interval_in_radians">
[in] increasing angle interval in radians with angle_interval_in_radians.Length() &lt;= 2.0*ON_PI
</param>
            <returns>true if input is valid and a valid arc is created.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.Create(RMA.OpenNURBS.IOnCircle,System.Double)">
            <summary>Create an arc from a circle and an angle in radians</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.#ctor(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
arc through 3 3d points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.#ctor(RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOn2dPoint)">
            <summary />
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.#ctor(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double)">
            <summary>
arc parallel to a plane
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.#ctor(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double)">
            <summary>
arc is parallel to XY plane
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.#ctor(RMA.OpenNURBS.IOnPlane,System.Double,System.Double)">
            <summary>
circle is in this plane with center at m_origin
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.#ctor(RMA.OpenNURBS.IOnCircle,RMA.OpenNURBS.IOnInterval)">
            <param name="angle_interval_in_radians">
[in] increasing angle interval
in radians with angle_interval_in_radians.Length() &lt;= 2.0*ON_PI.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.#ctor">
            <summary>
Create a radius one arc with angle = 2*pi
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnArc">
            <summary>
An ON_Arc is a subcurve of 3d circle. 
Details:
The curve is parameterized by	an angle expressed in radians.   For an IsValid() arc 
the total subtended angle 	AngleRadians() = Domain()(1) - Domain()(0) must satisfy
			0&lt; AngleRadians() &lt;2*Pi .

The parameterization of the ON_Arc is inherited from the ON_Circle it is derived from.
In particular
		 t -&gt; center + cos(t)*radius*xaxis + sin(t)*radius*yaxis	
where xaxis and yaxis, (part of ON_Circle::m_plane) form an othonormal frame of the plane 
containing the circle.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.GetNurbFormParameterFromRadian(System.Double,System.Double@)">
            <summary>Convert a arc radians parameter to a NURBS curve arc parameter.</summary>
            <param name="arc_radians_parameter">[in] 0.0 to 2.0*ON_PI</param>
            <param name="nurbs_parameter">[out]</param>
            <example>
ON_Arc arc = ...;
double arc_t = 1.2345; // some number in interval (0,2.0*ON_PI).
double nurbs_t;
arc.GetNurbFormParameterFromRadian( arc_t, &amp;nurbs_t );
ON_NurbsCurve nurbs_curve;
arc.GetNurbsForm( nurbs_curve );
arc_pt = arc.PointAt(arc_t);
nurbs_pt = nurbs_curve.PointAt(nurbs_t);
// arc_pt and nurbs_pt will be the same
</example>
            <remarks>
The NURBS curve parameter is with respect to the NURBS curve
created by ON_Arc::GetNurbForm. At radian values of 0.0, 0.5*ON_PI,
ON_PI, 1.5*ON_PI, and 2.0*ON_PI, the nurbs parameter and radian
parameter are the same. At all other values the nurbs and radian
parameter values are different.
See Also: ON_Arc::GetNurbFormParameterFromRadian
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.GetRadianFromNurbFormParameter(System.Double,System.Double@)">
            <summary>Convert a NURBS curve arc parameter to a arc radians parameter.</summary>
            <param name="nurbs_parameter">[in]</param>
            <param name="arc_radians_parameter">[out]</param>
            <example>
ON_Arc arc = ...;
double nurbs_t = 1.2345; // some number in interval (0,2.0*ON_PI).
double arc_t;
arc.GetRadianFromNurbFormParameter( nurbs_t, &amp;arc_t );
ON_NurbsCurve nurbs_curve;
arc.GetNurbsForm( nurbs_curve );
arc_pt = arc.PointAt(arc_t);
nurbs_pt = nurbs_curve.PointAt(nurbs_t); 
arc_pt and nurbs_pt will be the same
</example>
            <remarks>
The NURBS curve parameter is with respect to the NURBS curve created
by ON_Arc::GetNurbForm. At nurbs parameter values of 0.0, 0.5*ON_PI, ON_PI,
1.5*ON_PI, and 2.0*ON_PI, the nurbs parameter and radian parameter are the same.
At all other values the nurbs and radian parameter values are different.
See Also: ON_Arc::GetNurbFormParameterFromRadian
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.GetNurbForm(RMA.OpenNURBS.OnNurbsCurve@)">
            <summary>
Get a rational degree 2 NURBS curve representation
of the arc.  Note that the parameterization of NURBS curve
does not match  arc's transcendental paramaterization.  
Use GetRadianFromNurbFormParameter() and
GetParameterFromRadian() to convert between the NURBS curve 
parameter and the transcendental parameter
</summary>
            <param name="nurbs_curve">[out] nurbs_curve returned here.</param>
            <returns>0 for failure and 2 for success.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.Length">
            <summary>
Length of the arc = radius*(subtended angle in radians).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Get the point on the arc that is closest to test_point.</summary>
            <returns>
The point on the arc that is closest to test_point.
If test_point is the center of the arc, then the 
starting point of the arc is returned.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>Get the point on the arc that is closest to test_point.</summary>
            <param name="t">
[out] parameter (in radians) of the point on the arc that
is closest to test_point.  If test_point is the center
of the arc, then the starting point of the arc is
</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.EndPoint">
            <summary>
Point at end of the arc.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.MidPoint">
            <summary>
Point at middle of the arc.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.StartPoint">
            <summary>
Point at start of the arc.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.DomainDegrees">
            <summary>
The arc's domain in degrees.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.DomainRadians">
            <summary>
The arc's domain in radians.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.Domain">
            <summary>
Get evaluation domain. Returns Evaluation domain (same as DomainRadians()).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.AngleDegrees">
            <summary>
The arc's subtended angle in degrees.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.AngleRadians">
            <summary>
The arc's subtended angle in radians.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.IsCircle">
            <summary>
true if the arc is a complete circle; i.e., the arc's
angle is 360 degrees.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true and the input tight_bbox is valid,
then returned tight_bbox is the union of the input tight_bbox and
the arc's tight bounding box.
</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32,RMA.OpenNURBS.IOnXform)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true and the input tight_bbox is valid,
then returned tight_bbox is the union of the input tight_bbox and
the arc's tight bounding box.
</param>
            <param name="xform">
[in] (default=NULL) If not NULL, the tight bounding box of the
transformed arc is calculated. The arc is not modified.
</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>
Get arc's 3d axis aligned bounding box or the
union of the input box with the arc's bounding box.
</summary>
            <param name="bbox">[in/out] 3d axis aligned bounding box</param>
            <returns>true if arc has bounding box and calculation was successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>
Get arc's 3d axis aligned bounding box or the
union of the input box with the arc's bounding box.
</summary>
            <param name="bbox">[in/out] 3d axis aligned bounding box</param>
            <param name="bGrowBox">
[in] (default=false) 
If true, then the union of the input bbox and the 
arc's bounding box is returned in bbox.  
If false, the arc's bounding box is returned in bbox.
</param>
            <returns>true if arc has bounding box and calculation was successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.BoundingBox">
            <summary>Get arc's 3d axis aligned bounding box.</summary>
            <returns>3d bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.IsValid">
            <summary>Checks an arc to make sure it is valid.</summary>
            <remarks>Radius&gt;0 and 0&lt;AngleRadians()&lt;=2 ON_PI</remarks>
            <returns>true if the arc is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.Dump(RMA.OpenNURBS.OnTextLog@)">
            <summary>
Creates a text dump of the arc listing the normal, center
radius, start point, end point, and angle.
</summary>
            <remarks>
Dump() is intended for debugging and is not suitable
for creating high quality text descriptions of an arc.
</remarks>
        </member>
        <member name="T:RMA.OpenNURBS.IOnArc">
            <summary>
An ON_Arc is a subcurve of 3d circle. 
Details:
The curve is parameterized by	an angle expressed in radians.   For an IsValid() arc 
the total subtended angle 	AngleRadians() = Domain()(1) - Domain()(0) must satisfy
			0&lt; AngleRadians() &lt;2*Pi .

The parameterization of the ON_Arc is inherited from the ON_Circle it is derived from.
In particular
		 t -&gt; center + cos(t)*radius*xaxis + sin(t)*radius*yaxis	
where xaxis and yaxis, (part of ON_Circle::m_plane) form an othonormal frame of the plane 
containing the circle.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.CentroidCoordPrincipalMoments(System.Double@,RMA.OpenNURBS.On3dVector@,System.Double@,RMA.OpenNURBS.On3dVector@,System.Double@,RMA.OpenNURBS.On3dVector@)">
            <summary>
Calculates the principal moments and principal axes with repect to centroid coordinates.
These are simply the eigenvalues and eigenvectors of the centroid coordinate inertia matrix.
</summary>
            <param name="pxx">[out] principal moment</param>
            <param name="Ax">[out] principal axis for pxx</param>
            <param name="pyy">[out] principal moment</param>
            <param name="Ay">[out] principal axis for pyy</param>
            <param name="pzz">[out] principal moment</param>
            <param name="Az">[out] principal axis for pzz</param>
            <returns>
True if successful.
See Also: WorldCoordPrincipalMoments
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.CentroidCoordIntertiaMatrix">
            <summary>
If moments are valid, then the 3x3 inertia matrix with respect to centroid coordinates is returned.
This matrix is sometimes called the "intertia tensor".
</summary>
            <returns>
The inertia matrix or NULL if the moments are not valid.
  m_ccs_xx m_ccs_xy m_ccs_xz
  m_ccs_xy m_ccs_yy m_ccs_yz
  m_ccs_xz m_ccs_yz m_ccs_zz
See Also: WorldCoordIntertiaMatrix
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.CentroidCoordIntertiaMatrix(RMA.OpenNURBS.OnMatrix)">
            <summary>
If moments are valid, then the 3x3 inertia matrix with respect to centroid coordinates is returned.
This matrix is sometimes called the "intertia tensor".
</summary>
            <param name="matrix">
[in] If you want to fill in an existing matrix, pass a pointer to that matrix.
Otherwise a matrix will be created and returned.
</param>
            <returns>
The inertia matrix or NULL if the moments are not valid.
  m_ccs_xx m_ccs_xy m_ccs_xz
  m_ccs_xy m_ccs_yy m_ccs_yz
  m_ccs_xz m_ccs_yz m_ccs_zz
See Also: WorldCoordIntertiaMatrix
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.CentroidCoordRadiiOfGyration">
            <summary>Calculates the radii of gyration about centroid coordinate axes.</summary>
            <returns>
Radii of gyration with respect to centroid coordinate system.
CentroidCoordRadiiOfGyration().x = sqrt(integral of ((y-y0)^2 + (z-z0)^2) dm/M)
CentroidCoordRadiiOfGyration().y = sqrt(integral of ((z-z0)^2 + (x-x0)^2) dm/M)
CentroidCoordRadiiOfGyration().z = sqrt(integral of ((z-z0)^2 + (y-y0)^2) dm/M)
where (x0,y0,z0) = centroid.
</returns>
            <remarks>
What is meant by "radii of gyration" varies widely in textbooks and papers.
The values returned here are the integrals listed in the Returns section.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.CentroidCoordMomentsOfInertia">
            <summary>Calculates the moments of inertia about centroid coordinate axes.</summary>
            <returns>
Moments of inertia with respect to centroid coordinate system.
WorldCoordMomentsOfInertia().x = integral of ((y-y0)^2 + (z-z0)^2) dm
WorldCoordMomentsOfInertia().y = integral of ((z-z0)^2 + (x-x0)^2) dm
WorldCoordMomentsOfInertia().z = integral of ((z-z0)^2 + (y-y0)^2) dm
where (x0,y0,z0) = centroid.
</returns>
            <remarks>
What is meant by "moments of intertia" varies widely in textbooks and papers.
The values returned here are the integrals listed in the Returns section.
Some applications may want the values from WorldCoordSecondMoments() instead of the values returned here.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.CentroidCoordSecondMoments">
            <summary>
If m_bValidSecondMoments is true, then the centroid coordinate second
moments are returned in a vector (m_ccs_xx,m_ccs_yy,m_ccs_zz)
If m_bValidSecondMoments is false, then (0,0,0) is returned.
</summary>
            <returns>
Second moments with respect to centroid coordinate system.
CentroidCoordSecondMoments().x = integral of (x-x0)^2 dm
CentroidCoordSecondMoments().y = integral of (y-y0)^2 dm
CentroidCoordSecondMoments().z = integral of (z-z0)^2 dm
where (x0,y0,z0) = centroid.
See Also: WorldCoordSecondMoments
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.WorldCoordPrincipalMoments(System.Double@,RMA.OpenNURBS.On3dVector@,System.Double@,RMA.OpenNURBS.On3dVector@,System.Double@,RMA.OpenNURBS.On3dVector@)">
            <summary>
Calculates the principal moments and principal axes with repect to world coordinates.
These are simply the eigenvalues and eigenvectors of the woorld coordinate inertia matrix.
</summary>
            <param name="pxx">[out] principal moment</param>
            <param name="Ax">[out] principal axis for pxx</param>
            <param name="pyy">[out] principal moment</param>
            <param name="Ay">[out] principal axis for pyy</param>
            <param name="pzz">[out] principal moment</param>
            <param name="Az">[out] principal axis for pzz</param>
            <returns>
True if successful.
See Also: CentroidCoordPrincipalMoments
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.WorldCoordIntertiaMatrix">
            <summary>
If moments are valid, then the 3x3 inertia matrix with respect to world coordinates is returned.
This matrix is sometimes called the "intertia tensor".
</summary>
            <returns>
The inertia matrix or NULL if the moments are not valid.
  m_world_xx m_world_xy m_world_xz
  m_world_xy m_world_yy m_world_yz
  m_world_xz m_world_yz m_world_zz
See Also: CentroidCoordIntertiaMatrix
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.WorldCoordIntertiaMatrix(RMA.OpenNURBS.OnMatrix)">
            <summary>
If moments are valid, then the 3x3 inertia matrix with respect to world coordinates is returned.
This matrix is sometimes called the "intertia tensor".
</summary>
            <param name="matrix">
[in] If you want to fill in an existing matrix, pass a pointer to that matrix.
Otherwise a matrix will be created and returned.
</param>
            <returns>
The inertia matrix or NULL if the moments are not valid.
  m_world_xx m_world_xy m_world_xz
  m_world_xy m_world_yy m_world_yz
  m_world_xz m_world_yz m_world_zz
See Also: CentroidCoordIntertiaMatrix
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.WorldCoordRadiiOfGyration">
            <summary>Calculates the radii of gyration about world coordinate axes.</summary>
            <returns>
Radii of gyration with respect to world coordinate system.
WorldCoordRadiiOfGyration().x = sqrt(integral of (y^2 + z^2) dm/M)
WorldCoordRadiiOfGyration().y = sqrt(integral of (z^2 + x^2) dm/M)
WorldCoordRadiiOfGyration().z = sqrt(integral of (z^2 + y^2) dm/M)
</returns>
            <remarks>
What is meant by "radii of gyration" varies widely in textbooks and papers.
The values returned here are the integrals listed in the Returns section.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.WorldCoordMomentsOfInertia">
            <summary>Calculates the moments of inertia about world coordinate axes.</summary>
            <returns>
Moments of inertia with respect to world coordinate system.
WorldCoordMomentsOfInertia().x = integral of (y^2 + z^2) dm
WorldCoordMomentsOfInertia().y = integral of (z^2 + x^2) dm
WorldCoordMomentsOfInertia().z = integral of (z^2 + y^2) dm
</returns>
            <remarks>
What is meant by "moments of intertia" varies widely in textbooks and papers.
The values returned here are the integrals listed in the Returns section.
Some applications may want the values from WorldCoordSecondMoments() instead of the values returned here.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.WorldCoordSecondMoments">
            <summary>
If m_bValidSecondMoments is true, then the world coordinate second moments
are returned in a vector (m_world_xx,m_world_yy,m_world_zz)
If m_bValidSecondMoments is false, then (0,0,0) is returned.
</summary>
            <returns>
Second moments with respect to world coordinate system.
WorldCoordSecondMoments().x = integral of x^2 dm
WorldCoordSecondMoments().y = integral of y^2 dm
WorldCoordSecondMoments().z = integral of z^2 dm
See Also: CentroidCoordSecondMoments
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.WorldCoordFirstMoments">
            <summary>
If m_bValidFirstMoments is true, then the world coordinate first moments
are returned in a vector (m_world_x,m_world_y,m_world_z)
If m_bValidFirstMoments is false, then (0,0,0) is returned.
</summary>
            <returns>
First moments with respect to world coordinate system.
WorldCoordFirstMoments().x = integral of x dm
WorldCoordFirstMoments().y = integral of y dm
WorldCoordFirstMoments().z = integral of z dm
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.Volume">
            <summary>
Returns volume of the solid if the mass properties calculation was a volume calculation.
</summary>
            <returns>Volume of the solid if m_mass_type = 3 and zero otherwise.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.Area">
            <summary>
Returns area of the surface or mesh if the mass properties calculation was an area calculation.
</summary>
            <returns>Area of the surface or mesh if m_mass_type = 2 and zero otherwise.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.Length">
            <summary>
Returns length of the curve if the mass properties calculation was a length calculation.
</summary>
            <returns>Length of the curve if m_mass_type = 1 and zero otherwise.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.Centroid">
            <summary>
Returns: Centroid of object.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.Sum(RMA.OpenNURBS.IOnMassProperties[])">
            <summary>Sum a list of mass properties together to get an aggregate mass.</summary>
            <param name="summands">[in] array of mass properties to add</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.Sum(RMA.OpenNURBS.IOnMassProperties[],System.Boolean)">
            <summary>Sum a list of mass properties together to get an aggregate mass.</summary>
            <param name="summands">[in] array of mass properties to add</param>
            <param name="bAddTo">[in] if true, then the summands are added to the existing mass.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.Dump(RMA.OpenNURBS.OnTextLog@)">
            <summary>Prints a text description of the mass properties information.</summary>
            <param name="dump">[in] target for text dump information.</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.Create">
            <summary>
Set values to constructor defaults.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_ccs_zx_err">
            <value>
uncertainty in calculation
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_ccs_zx">
            <value>
PRODUCT MOMENTS - with respect to centroid coordinate system
integral of "zx dm" over the length/area/volume
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_ccs_yz_err">
            <value>
uncertainty in calculation
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_ccs_yz">
            <value>
PRODUCT MOMENTS - with respect to centroid coordinate system
integral of "yz dm" over the length/area/volume
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_ccs_xy_err">
            <value>
uncertainty in calculation
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_ccs_xy">
            <value>
PRODUCT MOMENTS - with respect to centroid coordinate system
integral of "xy dm" over the length/area/volume
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_ccs_zz_err">
            <value>
uncertainty in calculation
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_ccs_zz">
            <value>
The "centroid coordinate system" (ccs) is the
coordinate system with origin at the centroid and
axes parallel to the world coordinate axes.
SECOND MOMENTS - with respect to centroid coordinate system
integral of "zz dm" over the length/area/volume
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_ccs_yy_err">
            <value>
uncertainty in calculation
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_ccs_yy">
            <value>
The "centroid coordinate system" (ccs) is the
coordinate system with origin at the centroid and
axes parallel to the world coordinate axes.
SECOND MOMENTS - with respect to centroid coordinate system
integral of "yy dm" over the length/area/volume
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_ccs_xx_err">
            <value>
uncertainty in calculation
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_ccs_xx">
            <value>
The "centroid coordinate system" (ccs) is the
coordinate system with origin at the centroid and
axes parallel to the world coordinate axes.
SECOND MOMENTS - with respect to centroid coordinate system
integral of "xx dm" over the length/area/volume
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_zx_err">
            <value>
uncertainty in calculation
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_zx">
            <value>
PRODUCT MOMENTS - with respect to world coordinate system
integral of "zx dm" over the length/area/volume
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_yz_err">
            <value>
uncertainty in calculation
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_yz">
            <value>
PRODUCT MOMENTS - with respect to world coordinate system
integral of "yz dm" over the length/area/volume
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_xy_err">
            <value>
uncertainty in calculation
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_xy">
            <value>
PRODUCT MOMENTS - with respect to world coordinate system
integral of "xy dm" over the length/area/volume
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_zz_err">
            <value>
uncertainty in calculation
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_zz">
            <value>
SECOND MOMENTS - with respect to world coordinate system
integral of "zz dm" over the length/area/volume
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_yy_err">
            <value>
uncertainty in calculation
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_yy">
            <value>
SECOND MOMENTS - with respect to world coordinate system
integral of "yy dm" over the length/area/volume
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_xx_err">
            <value>
uncertainty in calculation
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_xx">
            <value>
SECOND MOMENTS - with respect to world coordinate system
integral of "xx dm" over the length/area/volume
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_z_err">
            <value>
uncertainty in calculation
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_z">
            <value>
FIRST MOMENTS - with respect to world coordinate system
integral of "z dm" over the length/area/volume
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_y_err">
            <value>
uncertainty in calculation
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_y">
            <value>
FIRST MOMENTS - with respect to world coordinate system
integral of "y dm" over the length/area/volume
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_x_err">
            <value>
uncertainty in calculation
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_x">
            <value>
FIRST MOMENTS - with respect to world coordinate system
integral of "x dm" over the length/area/volume
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_z0">
            <value>
CENTROID - in world coordinate system
= m_world_z / m_mass
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_y0">
            <value>
CENTROID - in world coordinate system
= m_world_y / m_mass
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_x0">
            <value>
CENTROID - in world coordinate system
= m_world_x / m_mass
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_mass_err">
            <value>
uncertainty in calculation
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_mass">
            <value>
MASS - length, area, or volume of object
    = integral of "dm" over the object
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_bValidMass">
            <value>
These flags are set to true if the calcluation was
successful.  If a flag is false, the corresponding
values should not be used.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_mass_type">
            <value>
Determines what type of "mass" is returned.
1 = length, 2 = area, 3 = volume
</value>
        </member>
        <member name="T:RMA.OpenNURBS.OnMassProperties">
            <summary>
This class is used to returned results of mass properties calculations.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.CentroidCoordPrincipalMoments(System.Double@,RMA.OpenNURBS.On3dVector@,System.Double@,RMA.OpenNURBS.On3dVector@,System.Double@,RMA.OpenNURBS.On3dVector@)">
            <summary>
Calculates the principal moments and principal axes with repect to centroid coordinates.
These are simply the eigenvalues and eigenvectors of the centroid coordinate inertia matrix.
</summary>
            <param name="pxx">[out] principal moment</param>
            <param name="Ax">[out] principal axis for pxx</param>
            <param name="pyy">[out] principal moment</param>
            <param name="Ay">[out] principal axis for pyy</param>
            <param name="pzz">[out] principal moment</param>
            <param name="Az">[out] principal axis for pzz</param>
            <returns>
True if successful.
See Also: WorldCoordPrincipalMoments
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.CentroidCoordIntertiaMatrix">
            <summary>
If moments are valid, then the 3x3 inertia matrix with respect to centroid coordinates is returned.
This matrix is sometimes called the "intertia tensor".
</summary>
            <returns>
The inertia matrix or NULL if the moments are not valid.
  m_ccs_xx m_ccs_xy m_ccs_xz
  m_ccs_xy m_ccs_yy m_ccs_yz
  m_ccs_xz m_ccs_yz m_ccs_zz
See Also: WorldCoordIntertiaMatrix
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.CentroidCoordIntertiaMatrix(RMA.OpenNURBS.OnMatrix)">
            <summary>
If moments are valid, then the 3x3 inertia matrix with respect to centroid coordinates is returned.
This matrix is sometimes called the "intertia tensor".
</summary>
            <param name="matrix">
[in] If you want to fill in an existing matrix, pass a pointer to that matrix.
Otherwise a matrix will be created and returned.
</param>
            <returns>
The inertia matrix or NULL if the moments are not valid.
  m_ccs_xx m_ccs_xy m_ccs_xz
  m_ccs_xy m_ccs_yy m_ccs_yz
  m_ccs_xz m_ccs_yz m_ccs_zz
See Also: WorldCoordIntertiaMatrix
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.CentroidCoordRadiiOfGyration">
            <summary>Calculates the radii of gyration about centroid coordinate axes.</summary>
            <returns>
Radii of gyration with respect to centroid coordinate system.
CentroidCoordRadiiOfGyration().x = sqrt(integral of ((y-y0)^2 + (z-z0)^2) dm/M)
CentroidCoordRadiiOfGyration().y = sqrt(integral of ((z-z0)^2 + (x-x0)^2) dm/M)
CentroidCoordRadiiOfGyration().z = sqrt(integral of ((z-z0)^2 + (y-y0)^2) dm/M)
where (x0,y0,z0) = centroid.
</returns>
            <remarks>
What is meant by "radii of gyration" varies widely in textbooks and papers.
The values returned here are the integrals listed in the Returns section.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.CentroidCoordMomentsOfInertia">
            <summary>Calculates the moments of inertia about centroid coordinate axes.</summary>
            <returns>
Moments of inertia with respect to centroid coordinate system.
WorldCoordMomentsOfInertia().x = integral of ((y-y0)^2 + (z-z0)^2) dm
WorldCoordMomentsOfInertia().y = integral of ((z-z0)^2 + (x-x0)^2) dm
WorldCoordMomentsOfInertia().z = integral of ((z-z0)^2 + (y-y0)^2) dm
where (x0,y0,z0) = centroid.
</returns>
            <remarks>
What is meant by "moments of intertia" varies widely in textbooks and papers.
The values returned here are the integrals listed in the Returns section.
Some applications may want the values from WorldCoordSecondMoments() instead of the values returned here.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.CentroidCoordSecondMoments">
            <summary>
If m_bValidSecondMoments is true, then the centroid coordinate second
moments are returned in a vector (m_ccs_xx,m_ccs_yy,m_ccs_zz)
If m_bValidSecondMoments is false, then (0,0,0) is returned.
</summary>
            <returns>
Second moments with respect to centroid coordinate system.
CentroidCoordSecondMoments().x = integral of (x-x0)^2 dm
CentroidCoordSecondMoments().y = integral of (y-y0)^2 dm
CentroidCoordSecondMoments().z = integral of (z-z0)^2 dm
where (x0,y0,z0) = centroid.
See Also: WorldCoordSecondMoments
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.WorldCoordPrincipalMoments(System.Double@,RMA.OpenNURBS.On3dVector@,System.Double@,RMA.OpenNURBS.On3dVector@,System.Double@,RMA.OpenNURBS.On3dVector@)">
            <summary>
Calculates the principal moments and principal axes with repect to world coordinates.
These are simply the eigenvalues and eigenvectors of the woorld coordinate inertia matrix.
</summary>
            <param name="pxx">[out] principal moment</param>
            <param name="Ax">[out] principal axis for pxx</param>
            <param name="pyy">[out] principal moment</param>
            <param name="Ay">[out] principal axis for pyy</param>
            <param name="pzz">[out] principal moment</param>
            <param name="Az">[out] principal axis for pzz</param>
            <returns>
True if successful.
See Also: CentroidCoordPrincipalMoments
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.WorldCoordIntertiaMatrix">
            <summary>
If moments are valid, then the 3x3 inertia matrix with respect to world coordinates is returned.
This matrix is sometimes called the "intertia tensor".
</summary>
            <returns>
The inertia matrix or NULL if the moments are not valid.
  m_world_xx m_world_xy m_world_xz
  m_world_xy m_world_yy m_world_yz
  m_world_xz m_world_yz m_world_zz
See Also: CentroidCoordIntertiaMatrix
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.WorldCoordIntertiaMatrix(RMA.OpenNURBS.OnMatrix)">
            <summary>
If moments are valid, then the 3x3 inertia matrix with respect to world coordinates is returned.
This matrix is sometimes called the "intertia tensor".
</summary>
            <param name="matrix">
[in] If you want to fill in an existing matrix, pass a pointer to that matrix.
Otherwise a matrix will be created and returned.
</param>
            <returns>
The inertia matrix or NULL if the moments are not valid.
  m_world_xx m_world_xy m_world_xz
  m_world_xy m_world_yy m_world_yz
  m_world_xz m_world_yz m_world_zz
See Also: CentroidCoordIntertiaMatrix
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.WorldCoordRadiiOfGyration">
            <summary>Calculates the radii of gyration about world coordinate axes.</summary>
            <returns>
Radii of gyration with respect to world coordinate system.
WorldCoordRadiiOfGyration().x = sqrt(integral of (y^2 + z^2) dm/M)
WorldCoordRadiiOfGyration().y = sqrt(integral of (z^2 + x^2) dm/M)
WorldCoordRadiiOfGyration().z = sqrt(integral of (z^2 + y^2) dm/M)
</returns>
            <remarks>
What is meant by "radii of gyration" varies widely in textbooks and papers.
The values returned here are the integrals listed in the Returns section.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.WorldCoordMomentsOfInertia">
            <summary>Calculates the moments of inertia about world coordinate axes.</summary>
            <returns>
Moments of inertia with respect to world coordinate system.
WorldCoordMomentsOfInertia().x = integral of (y^2 + z^2) dm
WorldCoordMomentsOfInertia().y = integral of (z^2 + x^2) dm
WorldCoordMomentsOfInertia().z = integral of (z^2 + y^2) dm
</returns>
            <remarks>
What is meant by "moments of intertia" varies widely in textbooks and papers.
The values returned here are the integrals listed in the Returns section.
Some applications may want the values from WorldCoordSecondMoments() instead of the values returned here.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.WorldCoordSecondMoments">
            <summary>
If m_bValidSecondMoments is true, then the world coordinate second moments
are returned in a vector (m_world_xx,m_world_yy,m_world_zz)
If m_bValidSecondMoments is false, then (0,0,0) is returned.
</summary>
            <returns>
Second moments with respect to world coordinate system.
WorldCoordSecondMoments().x = integral of x^2 dm
WorldCoordSecondMoments().y = integral of y^2 dm
WorldCoordSecondMoments().z = integral of z^2 dm
See Also: CentroidCoordSecondMoments
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.WorldCoordFirstMoments">
            <summary>
If m_bValidFirstMoments is true, then the world coordinate first moments
are returned in a vector (m_world_x,m_world_y,m_world_z)
If m_bValidFirstMoments is false, then (0,0,0) is returned.
</summary>
            <returns>
First moments with respect to world coordinate system.
WorldCoordFirstMoments().x = integral of x dm
WorldCoordFirstMoments().y = integral of y dm
WorldCoordFirstMoments().z = integral of z dm
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.Volume">
            <summary>
Returns volume of the solid if the mass properties calculation was a volume calculation.
</summary>
            <returns>Volume of the solid if m_mass_type = 3 and zero otherwise.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.Area">
            <summary>
Returns area of the surface or mesh if the mass properties calculation was an area calculation.
</summary>
            <returns>Area of the surface or mesh if m_mass_type = 2 and zero otherwise.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.Length">
            <summary>
Returns length of the curve if the mass properties calculation was a length calculation.
</summary>
            <returns>Length of the curve if m_mass_type = 1 and zero otherwise.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.Centroid">
            <summary>
Returns: Centroid of object.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.Dump(RMA.OpenNURBS.OnTextLog@)">
            <summary>Prints a text description of the mass properties information.</summary>
            <param name="dump">[in] target for text dump information.</param>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_ccs_zx_err">
            <value>
uncertainty in calculation
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_ccs_zx">
            <value>
PRODUCT MOMENTS - with respect to centroid coordinate system
integral of "zx dm" over the length/area/volume
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_ccs_yz_err">
            <value>
uncertainty in calculation
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_ccs_yz">
            <value>
PRODUCT MOMENTS - with respect to centroid coordinate system
integral of "yz dm" over the length/area/volume
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_ccs_xy_err">
            <value>
uncertainty in calculation
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_ccs_xy">
            <value>
PRODUCT MOMENTS - with respect to centroid coordinate system
integral of "xy dm" over the length/area/volume
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_ccs_zz_err">
            <value>
uncertainty in calculation
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_ccs_zz">
            <value>
The "centroid coordinate system" (ccs) is the
coordinate system with origin at the centroid and
axes parallel to the world coordinate axes.
SECOND MOMENTS - with respect to centroid coordinate system
integral of "zz dm" over the length/area/volume
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_ccs_yy_err">
            <value>
uncertainty in calculation
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_ccs_yy">
            <value>
The "centroid coordinate system" (ccs) is the
coordinate system with origin at the centroid and
axes parallel to the world coordinate axes.
SECOND MOMENTS - with respect to centroid coordinate system
integral of "yy dm" over the length/area/volume
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_ccs_xx_err">
            <value>
uncertainty in calculation
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_ccs_xx">
            <value>
The "centroid coordinate system" (ccs) is the
coordinate system with origin at the centroid and
axes parallel to the world coordinate axes.
SECOND MOMENTS - with respect to centroid coordinate system
integral of "xx dm" over the length/area/volume
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_zx_err">
            <value>
uncertainty in calculation
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_zx">
            <value>
PRODUCT MOMENTS - with respect to world coordinate system
integral of "zx dm" over the length/area/volume
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_yz_err">
            <value>
uncertainty in calculation
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_yz">
            <value>
PRODUCT MOMENTS - with respect to world coordinate system
integral of "yz dm" over the length/area/volume
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_xy_err">
            <value>
uncertainty in calculation
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_xy">
            <value>
PRODUCT MOMENTS - with respect to world coordinate system
integral of "xy dm" over the length/area/volume
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_zz_err">
            <value>
uncertainty in calculation
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_zz">
            <value>
SECOND MOMENTS - with respect to world coordinate system
integral of "zz dm" over the length/area/volume
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_yy_err">
            <value>
uncertainty in calculation
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_yy">
            <value>
SECOND MOMENTS - with respect to world coordinate system
integral of "yy dm" over the length/area/volume
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_xx_err">
            <value>
uncertainty in calculation
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_xx">
            <value>
SECOND MOMENTS - with respect to world coordinate system
integral of "xx dm" over the length/area/volume
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_z_err">
            <value>
uncertainty in calculation
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_z">
            <value>
FIRST MOMENTS - with respect to world coordinate system
integral of "z dm" over the length/area/volume
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_y_err">
            <value>
uncertainty in calculation
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_y">
            <value>
FIRST MOMENTS - with respect to world coordinate system
integral of "y dm" over the length/area/volume
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_x_err">
            <value>
uncertainty in calculation
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_x">
            <value>
FIRST MOMENTS - with respect to world coordinate system
integral of "x dm" over the length/area/volume
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_z0">
            <value>
CENTROID - in world coordinate system
= m_world_z / m_mass
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_y0">
            <value>
CENTROID - in world coordinate system
= m_world_y / m_mass
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_x0">
            <value>
CENTROID - in world coordinate system
= m_world_x / m_mass
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_mass_err">
            <value>
uncertainty in calculation
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_mass">
            <value>
MASS - length, area, or volume of object
    = integral of "dm" over the object
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_bValidMass">
            <value>
These flags are set to true if the calcluation was
successful.  If a flag is false, the corresponding
values should not be used.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_mass_type">
            <value>
Determines what type of "mass" is returned.
1 = length, 2 = area, 3 = volume
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnMassProperties">
            <summary>
This class is used to returned results of mass properties calculations.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryFile.SeekFromEnd(System.Int32)">
            <summary>
fseek from end (since the file has an end)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Dump3dmChunk(RMA.OpenNURBS.OnTextLog@)">
            <summary>
Expert user function for studying contents of a file. The primary use is as an aid to help
dig through files that have been damaged (bad disks, transmission errors, etc.) If an error
is found, a line that begins with the word "ERROR" is printed.
</summary>
            <param name="text_log">[in] place to print informtion</param>
            <returns>0 if something went wrong, otherwise the typecode of the chunk that was just studied.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Dump3dmChunk(RMA.OpenNURBS.OnTextLog@,System.Int32)">
            <summary>
Expert user function for studying contents of a file. The primary use is as an aid to help
dig through files that have been damaged (bad disks, transmission errors, etc.) If an error
is found, a line that begins with the word "ERROR" is printed.
</summary>
            <param name="text_log">[in] place to print informtion</param>
            <param name="recursion_depth">[in] simply a counter to aid in debugging.</param>
            <returns>0 if something went wrong, otherwise the typecode of the chunk that was just studied.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.FindTableInDamagedArchive(System.UInt32,System.UInt32,System.Guid,System.Int32)">
            <summary>
Expert user function for reading damaged files. The search starts at the beginning of the file.
</summary>
            <param name="tcode_table">[in] typecode of the table</param>
            <param name="tcode_record">[in] typecode of the record</param>
            <param name="class_uuid">[in] id of the opennurbs class in the record</param>
            <param name="min_length_data">[in] minimum size of the opennurbs class data</param>
            <returns>
True if the table start is found. In this case the current position of the archive
is at the start of the table and the standared BeginRead3dm...Table() function can be used.
False if the table start is not found.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.GetCurrentChunk(RMA.OpenNURBS.On3DM_CHUNK@)">
            <summary>Expert user function for reading damaged files.</summary>
            <param name="chunk">[out] current chunk.</param>
            <returns>Level of the chunk or 0 if there is no current chunk.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ArchiveStartOffset">
            <summary>
When a 3dm archive is saved from an MFC application that supports Windows linking/embedding,
the first 5kb to 1mb of the file contains information that is put there by MFC. ArchiveStartOffset()
returns the offset into the file where the 3dm archive actually begins. The call to ON_BinaryArchive::Read3dmStartSection()
calculates this offset and stores the value in m_3dm_start_section_offset.
</summary>
            <returns>Offset into the binary "file" where the actual 3dm archive begins.</returns>
            <remarks>Generally, this value can be ignored. This function is a diagnostice tool that is used to analyzed damaged files.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ArchiveOpenNURBSVersion">
            <summary>
If a 3dm archive is being read, then this is the version of openNURBS that was used to write the archive.
This value is only available after ON_BinaryArchive::Read3dmProperties is called.
</summary>
            <returns>
Version of openNURBS used to write the archive. The openNURBS version is the value returned by ON::Version.
</returns>
            <remarks>This value is rarely needed. You probably want to use ON_BinaryArchive::Archive3dmVersion.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Archive3dmVersion">
            <summary>
Low level tool to writes user data attached to the object. This function should never be called directly. Parameters: object - [in] Returns: True if successful.
</summary>
            <summary>
Low level tool to read user data and attach it to the object. This function should never be called directly. Parameters: object - [in/out] Returns: True if successful.
</summary>
            <summary>
If a 3dm archive is being read or written, then this is the version of the 3dm archive format (1, 2, or 3).
</summary>
            <returns>
0 a 3dm archive is not being read/written
1 a version 1 3dm archive is being read/written
2 a version 2 3dm archive is being read/written
3 a version 3 3dm archive is being read/written
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Read3dmChunkVersion(System.Int32@,System.Int32@)">
            <summary>
A chunk version is a single byte that encodes a major.minor 
version number.  Useful when creating I/O code for 3dm chunks
that may change in the future.  Increment the minor version 
number if new information is added to the end of the chunk. 
Increment the major version if the format of the chunk changes
in some other way.
</summary>
            <param name="major">0 to 15</param>
            <param name="minor">0 to 16</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Write3dmChunkVersion(System.Int32,System.Int32)">
            <summary>
A chunk version is a single byte that encodes a major.minor 
version number.  Useful when creating I/O code for 3dm chunks
that may change in the future.  Increment the minor version 
number if new information is added to the end of the chunk. 
Increment the major version if the format of the chunk changes
in some other way.
</summary>
            <param name="major">0 to 15</param>
            <param name="minor">0 to 16</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Seek3dmChunkFromCurrentPosition(System.UInt32)">
            <summary>
beginning at the current position, search portion of archive
included in active chunk for the start of a subchunk with the
specified type.
if true is returned, then the position is set so the next call to
BeginRead3dmChunk() will read a chunk with the specified typecode
</summary>
            <param name="typecode">typecode from opennurbs_3dm.h</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Seek3dmChunkFromStart(System.UInt32)">
            <summary>
beginning at the start of the active chunk, search portion of
archive included in active chunk for the start of a subchunk 
with the specified type.
if true is returned, then the position is set so the next call to
BeginRead3dmChunk() will read a chunk with the specified typecode
</summary>
            <param name="typecode">typecode from opennurbs_3dm.h</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.PeekAt3dmChunkType(System.UInt32@,System.Int32@)">
            <summary>does not change file position</summary>
            <param name="typecode">typecode from opennurbs_3dm.h</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Read3dmGoo(RMA.OpenNURBS.On3dmGoo@)">
            <summary>Call to read "goo"</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.EndRead3dmChunk">
            <summary>Calling this will skip rest of stuff in chunk if it was only partially read.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.BeginRead3dmChunk(System.UInt32,System.Int32@,System.Int32@)">
            <summary>Begins reading a chunk that must be in the archive at this location.</summary>
            <param name="expected_tcode">[in] chunk's typecode from opennurbs_3dm.h</param>
            <param name="major_version">[out]</param>
            <param name="minor_version">[out]</param>
            <returns>
True if beginning of the chunk was read. In this case you must call EndRead3dmChunk(),
even if something goes wrong while you attempt to read the interior of the chunk.
False if the chunk did not exist at the current location in the file.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.BeginRead3dmChunk(System.UInt32@,System.Int32@)">
            <summary>
When the end of the 3dm file is reached, BeginReadChunk() will
return true with a typecode of TCODE_ENDOFFILE.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Write3dmGoo(RMA.OpenNURBS.IOn3dmGoo)">
            <summary>call to write "goo"</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.EndWrite3dmChunk">
            <summary>updates length in chunk header</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.BeginWrite3dmChunk(System.UInt32,System.Int32,System.Int32)">
            <summary>Begins writing a chunk.</summary>
            <param name="tcode">[in] chunk's typecode from opennurbs_3dm.h. This cannot be a short tcode.</param>
            <param name="major_version">[in] ( &gt;= 1)</param>
            <param name="minor_version">[in] ( &gt;= 0 )</param>
            <returns>
True if input was valid and chunk was started. In this case You must call EndWrite3dmChunk(),
even if something goes wrong while you attempt to write the contents of the chunk.
False if input was not valid or the write failed.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.BeginWrite3dmChunk(System.UInt32,System.Int32)">
            <summary>
Writes a chunk header containing 4 byte typecode and 4 byte value.

Low level tools to  Write/Read chunks. See opennurbs_3dm.h for details
about the structure of chunks. Every chunk must begin with a call to
BeginWrite/ReadChunk(). If BeginWriteChunk()/BeginReadChunk() returns
true, then you must call EndWrite/ReadChunk() or cease using the archive.
</summary>
            <param name="typecode">[in] a TCODE_* number from opennurbs_3dm.h</param>
            <param name="value">
[in] if (typecode AND TCODE_SHORT) is nonzero, then this is the value to be saved.
Otherwise, pass a zero and the EndWrite3dmChunk() call will store the length
of the chunk.
</param>
            <returns>true if write was successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Read3dmEndMark(System.UInt32@)">
            <summary>
Checks for a TCODE_ENDOFFILE chunk at the current position.
If it finds one, it reads it and returns the number of bytes in the archive.
Comparing this number with the current file position can help detect files
that have been damaged by loosing sections.
</summary>
            <param name="sizeof_archive">[out] number of bytes written to archive</param>
            <returns>
true if successful, false if unable to find or read a TCODE_ENDOFFILE chunk.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Write3dmEndMark">
            <summary>
Writes a TCODE_ENDOFFILE chunk that contains the number of bytes in the archive.
</summary>
            <returns>true if successful, false if unable to write to archive.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Read3dmAnonymousUserTable(RMA.OpenNURBS.On3dmGoo@)">
            <summary>
Use Read3dmAnonymousUserTableRecord() if you don't know how to decipher 
the contents of a user table but you need to rewrite it for some reason.
If you simple want to skip over the table, just call EndRead3dmUserTable().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.BeginRead3dmUserTable(System.Guid@)">
            <summary>
BeginRead3dmUserTable returns false when there are no more user tables
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Write3dmAnonymousUserTable(RMA.OpenNURBS.IOn3dmGoo)">
            <summary>
Use Write3dmAnonymousUserTable() to put back what Read3dmAnonymousUserTable() read.
(Generally a plugin or some other app will be called to write
it's information to the archive.)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Read3dmHistoryRecord(RMA.OpenNURBS.OnHistoryRecord@)">
            <returns>
0 at end of object table
1 if object is read
-1 if file is corrupt
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Read3dmObject(RMA.OpenNURBS.OnObject@,RMA.OpenNURBS.On3dmObjectAttributes@,System.UInt32)">
            <returns>
0 at end of object table
1 if object is read
2 if object is skipped because it does not match filter
-1 if file is corrupt
</returns>
            <param name="object">object returned here (NULL if skipped)</param>
            <param name="attributes">optional - if NOT NULL, object attributes are returned here</param>
            <param name="object_filter">
optional filter made by setting ON::object_type bits
set to 0 if no filter is to be applied
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Write3dmObject(RMA.OpenNURBS.IOnObject,RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <param name="attributes">optional, may be null</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Read3dmInstanceDefinition(RMA.OpenNURBS.OnInstanceDefinition@)">
            <summary>Reads instance definitions from instance defintion table.</summary>
            <param name="idef">
If an instance defintion is read, an instance defintion is created by calling new 
ON_InstanceDefinition(), initialized with values stored in the archive, and a
pointer to the new instance defintion is returned
</param>
            <returns>
0  at the end of the instance defintion table
1  instance defintion was successfully read
-1 archive is corrupt at this point
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Read3dmLight(RMA.OpenNURBS.OnLight@,RMA.OpenNURBS.On3dmObjectAttributes@)">
            <returns>
returns 0 at end of light table
1 light successfully read
-1 if file is corrupt
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Read3dmDimStyle(RMA.OpenNURBS.OnDimStyle@)">
            <summary>
Reads annotation dimension styles from dimension style table.
If the dimension style definition is read, a dimension style
is created by calling new ON_DimStyle(), initialized with
values stored in the archive, and returned.
</summary>
            <param name="ppDimStyle">
If the dimstyle definition is read, a dimstyle is created by
calling new ON_DimStyle(), initialized with values stored in
the archive, and a pointer to the new dimstyle is returned in *ppDimStyle.
</param>
            <returns>
0     at the end of the dimension style table
1     dimension style definition was successfully read
-1    archive is corrupt at this point
</returns>
            <remarks>
Calls to Read3dmDimStyle need to be bracketed by calls
to BeginRead3dmDimStyleTable() / EndRead3dmDimStyleTable().
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Read3dmFont(RMA.OpenNURBS.OnFont@)">
            <summary>
Reads fonts from font table. If the font definition is read, a font
is created by calling new ON_Font(), initialized with values stored
in the archive, and returned.
</summary>
            <param name="ppFont">
If the font definition is read, a font is created by calling new ON_Font(),
initialized with values stored in the archive, and a pointer to the new
font is returned in *ppFont.
</param>
            <returns>
0     at the end of the font table
1     font definition was successfully read
-1    archive is corrupt at this point
</returns>
            <remarks>
Calls to Read3dmFont need to be bracketed by calls
to BeginRead3dmFontTable() / EndRead3dmFontTable().
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Read3dmGroup(RMA.OpenNURBS.OnGroup@)">
            <summary>
Reads groups from group table.  If the group definition is read,
a group is created by calling new ON_Group(), initialized with
values stored in the archive, and returned.
</summary>
            <param name="ppGroup">
If the group definition is read, a group is created by calling
new ON_Group(), initialized with values stored in the archive,
and a pointer to the new group is returned in *ppGroup.
</param>
            <returns>
0     at the end of the group table
1     group definition was successfully read
-1    archive is corrupt at this point
</returns>
            <remarks>
Calls to Read3dmGroup need to be bracketed by calls
to BeginRead3dmGroupTable() / EndRead3dmGroupTable().
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Read3dmMaterial(RMA.OpenNURBS.OnMaterial@)">
            <returns>returns 0 at end of table</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Read3dmTextureMapping(RMA.OpenNURBS.OnTextureMapping@)">
            <returns>returns 0 at end of table</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Read3dmBitmap(RMA.OpenNURBS.OnBitmap@)">
            <returns>
0 at end of light table
1 bitmap successfully read
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Write3dmStartSection(System.Int32,System.String)">
            <param name="version">1 or 2</param>
            <param name="app_name">
NULL or ASCII string with application name, etc.
This information is primarily used when debugging files
that contain problems.  McNeel and Associates stores
application name, application version, compile date, 
OS in use when file was written.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.EnableSaveUserData">
            <summary>returns previous state</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.EnableSaveUserData(System.Boolean)">
            <summary>returns previous state</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.EnableSave3dmAnalysisMeshes">
            <summary>returns previous state</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.EnableSave3dmAnalysisMeshes(System.Boolean)">
            <summary>returns previous state</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.EnableSave3dmRenderMeshes">
            <summary>returns previous state</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.EnableSave3dmRenderMeshes(System.Boolean)">
            <summary>returns previous state</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteObject(RMA.OpenNURBS.IOnObject)">
            <summary>writes object definition</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ReadObject(RMA.OpenNURBS.OnObject@)">
            <summary>Reads and object from a 3dm archive.</summary>
            <param name="object">
[in] The value of object.ON_ClassId()-&gt;Uuid() must exactly match the class uuid
in of the next object in the archive.
</param>
            <returns>
0: failure - unable to read object because of file IO problems.
1: success
2: unable to read object because the class id in the archive did not match pObject-&gt;ClassId.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ReadOnObject(RMA.OpenNURBS.OnObject@)">
            <summary>Reads and object from a 3dm archive</summary>
            <param name="ppObject">
[out]  object is allocated and a pointer to the allocated object is returned
</param>
            <returns>
0: failure - unable to read object because of file IO problems
1: success
3: unable to read object because it's UUID is not registered
this could happen in cases where old code is attempting to read
new objects.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteString(System.String)">
            <summary>
All times are stored in universal coordinated time
( a.k.a GMT, UCT ).  Use ANSI C time() and gmtime() calls.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteDouble(System.Double)">
            <summary>Write a single double</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteFloat(System.Single)">
            <summary>Write a single float</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteBigTime(System.Int64)">
            <summary>UCT seconds since 1 January 1970 (64 bits)</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteBigSize(System.UInt32)">
            <summary>64 bits</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteSize(System.UInt32)">
            <summary>Write a single size_t</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteLong(System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>Write a single 32 bit unsigned integer</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteLong(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>Write a single 32 bit integer</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteInt(System.UInt32)">
            <summary>Write a single 32 bit unsigned integer</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteInt(System.Int32)">
            <summary>Write a single 32 bit integer</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteShort(System.UInt16)">
            <summary>Write a single 16 bit unsigned short</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteShort(System.Int16)">
            <summary>Write a single 16 bit short</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteChar(System.Byte)">
            <summary>Write a single 8 bit unsigned char</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteChar(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)">
            <summary>Write a single 8 bit char</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ReadAnsiString(System.String@)">
            <summary>
All times are stored in coordinated universal time
( a.k.a GMT, UTC ).  Use ANSI C time() and gmtime() calls.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ReadDouble(System.Double@)">
            <summary>Read a single double</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ReadFloat(System.Single@)">
            <summary>Read a single float</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ReadBigTime(System.Int64@)">
            <summary>UCT seconds since 1 January 1970 (64 bits)</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ReadBigSize(System.UInt32@)">
            <summary>64 bits</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ReadSize(System.UInt32@)">
            <summary>Read a single size_t</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ReadLong(System.UInt32!System.Runtime.CompilerServices.IsLong@)">
            <summary>Read a single 32 bit unsigned integer</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ReadLong(System.Int32!System.Runtime.CompilerServices.IsLong@)">
            <summary>Read a single 32 bit integer</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ReadInt(System.UInt32@)">
            <summary>Read a single 32 bit unsigned integer</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ReadInt(System.Int32@)">
            <summary>Read a single 32 bit integer</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ReadShort(System.UInt16@)">
            <summary>Read a single 16 bit unsigned short</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ReadShort(System.Int16@)">
            <summary>Read a single 16 bit short</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ReadChar(System.Byte@)">
            <summary>Read a single 8 bit unsigned char</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ReadChar(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte@)">
            <summary>Read a single 8 bit char</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.BadCRCCount">
            <summary>number of chunks read with bad CRC</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Endian">
            <returns>Endian-ness of the cpu reading this file.</returns>
            <remarks>3dm files are alwasy saved with little endian byte order.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteMode">
            <summary>true if writing is permitted</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ReadMode">
            <summary>true if reading is permitted</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.AtEnd">
            <summary>true if at end of file</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.SeekFromStart(System.UInt32)">
            <summary>seek from current position ( like fseek( ,SEEK_SET) )</summary>
            <param name="byte_offset">( &gt;= 0 )</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.SeekFromCurrentPosition(System.Int32)">
            <summary>seek from current position ( like fseek( ,SEEK_CUR) )</summary>
            <param name="byte_offset">( &gt;= -CurrentPostion() )</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.CurrentPosition">
            <summary>current offset (in bytes) into archive ( like ftell() )</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnBinaryArchive">
            <summary>use for generic serialization of binary data</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBinaryArchive.GetCurrentChunk(RMA.OpenNURBS.On3DM_CHUNK@)">
            <summary>Expert user function for reading damaged files.</summary>
            <param name="chunk">[out] current chunk.</param>
            <returns>Level of the chunk or 0 if there is no current chunk.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBinaryArchive.ArchiveStartOffset">
            <summary>
When a 3dm archive is saved from an MFC application that supports Windows linking/embedding,
the first 5kb to 1mb of the file contains information that is put there by MFC. ArchiveStartOffset()
returns the offset into the file where the 3dm archive actually begins. The call to ON_BinaryArchive::Read3dmStartSection()
calculates this offset and stores the value in m_3dm_start_section_offset.
</summary>
            <returns>Offset into the binary "file" where the actual 3dm archive begins.</returns>
            <remarks>Generally, this value can be ignored. This function is a diagnostice tool that is used to analyzed damaged files.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBinaryArchive.ArchiveOpenNURBSVersion">
            <summary>
If a 3dm archive is being read, then this is the version of openNURBS that was used to write the archive.
This value is only available after ON_BinaryArchive::Read3dmProperties is called.
</summary>
            <returns>
Version of openNURBS used to write the archive. The openNURBS version is the value returned by ON::Version.
</returns>
            <remarks>This value is rarely needed. You probably want to use ON_BinaryArchive::Archive3dmVersion.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBinaryArchive.Archive3dmVersion">
            <summary>
If a 3dm archive is being read or written, then this is the version of the 3dm archive format (1, 2, or 3).
</summary>
            <returns>
0  a 3dm archive is not being read/written
1  a version 1 3dm archive is being read/written
2  a version 2 3dm archive is being read/written
3  a version 3 3dm archive is being read/written
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBinaryArchive.BadCRCCount">
            <summary>
number of chunks read with bad CRC
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBinaryArchive.Endian">
            <returns>Endian-ness of the cpu reading this file.</returns>
            <remarks>3dm files are alwasy saved with little endian byte order.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBinaryArchive.WriteMode">
            <summary>
true if writing is permitted
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBinaryArchive.ReadMode">
            <summary>
true if reading is permitted
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBinaryArchive.AtEnd">
            <summary>true if at end of file</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBinaryArchive.CurrentPosition">
            <summary>current offset (in bytes) into archive ( like ftell() )</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnBinaryArchive">
            <summary>use for generic serialization of binary data</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3DM_CHUNK.m_do_crc32">
            <value>
32 bit CRC
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3DM_CHUNK.m_do_crc16">
            <value>
16 bit CRC using CCITT polynomial
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3DM_CHUNK.m_do_length">
            <value>
true if chunk is a long chunk with length
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3DM_CHUNK.m_typecode">
            <value>
file position of first byte after chunk's length.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.On3DM_CHUNK.m_offset">
            <value>
In read or write_using_fseek mode, this is the
file position of first byte after chunk's length.
In write_using_buffer mode, this of the m_buffer[]
position of first byte after chunk's length.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3DM_CHUNK.m_do_crc32">
            <value>
32 bit CRC
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3DM_CHUNK.m_do_crc16">
            <value>
16 bit CRC using CCITT polynomial
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3DM_CHUNK.m_do_length">
            <value>
true if chunk is a long chunk with length
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3DM_CHUNK.m_typecode">
            <value>
file position of first byte after chunk's length.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3DM_CHUNK.m_offset">
            <value>
In read or write_using_fseek mode, this is the
file position of first byte after chunk's length.
In write_using_buffer mode, this of the m_buffer[]
position of first byte after chunk's length.
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnObjectRenderingAttributes.ChangeMappingChannel(System.Guid@,System.Int32,System.Int32)">
            <param name="plugin_id">[in]</param>
            <param name="old_mapping_channel_id">[in]</param>
            <param name="new_mapping_channel_id">[in]</param>
            <returns>True if a matching mapping channel was found and changed.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnObjectRenderingAttributes.DeleteMappingChannel(System.Guid@,System.Guid@)">
            <param name="plugin_id">[in]</param>
            <param name="mapping_id">[in] ON_TextureMapping id</param>
            <returns>
True if a matching mapping channel was deleted.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnObjectRenderingAttributes.DeleteMappingChannel(System.Guid@,System.Int32)">
            <param name="plugin_id">[in]</param>
            <param name="mapping_channel_id">[in]</param>
            <returns>
True if a matching mapping channel was deleted.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnObjectRenderingAttributes.AddMappingChannel(System.Guid@,System.Int32,System.Guid@)">
            <param name="plugin_id">[in]</param>
            <param name="mapping_channel_id">[in]</param>
            <param name="mapping_id">[in] ON_TextureMapping id</param>
            <returns>
True if the mapping channel was added or a pefect match already existed.
False if a mapping channel with a different mapping_id already exists for this plug-in and channel.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnObjectRenderingAttributes.MappingChannel(System.Guid@,System.Guid@)">
            <param name="plugin_id">[in]</param>
            <param name="mapping_id">[in] ON_TextureMapping id</param>
            <returns>A pointer to the plug-in's mapping channel, if there is one. Otherwise NULL is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnObjectRenderingAttributes.MappingChannel(System.Guid@,System.Int32)">
            <param name="plugin_id">[in]</param>
            <param name="mapping_channel_id">[in]</param>
            <returns>A pointer to the plug-in's mapping channel, if there is one. Otherwise NULL is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnObjectRenderingAttributes.DeleteMappingRef(System.Guid@)">
            <param name="plugin_id">[in]</param>
            <returns>
If a mapping ref exists, it is returned. Otherwise one is added.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnObjectRenderingAttributes.AddMappingRef(System.Guid@)">
            <param name="plugin_id">[in]</param>
            <returns>
If a mapping ref exists, it is returned. Otherwise one is added.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnObjectRenderingAttributes.MappingRef(System.Guid@)">
            <param name="plugin_id">[in]</param>
            <returns>
A pointer to the plug-in's mapping reference, if there is one. Otherwise NULL is returned.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnObjectRenderingAttributes.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>Update mapping channel transformations.</summary>
            <param name="xform">[in] Transformation applied to parent object.</param>
            <returns>
True is successful.
False if there are mapping channels and xform cannot be inverted.
</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjectRenderingAttributes.m_bReceivesShadows">
            <value>default is true</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjectRenderingAttributes.m_bCastsShadows">
            <value>default is true</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjectRenderingAttributes.m_mappings">
            <value>
Use AddMappingRef() or AddMappingChannel() if you 
want to add an element to this array.
Every mapping ref in this array must have
a distinct value of ON_MappingRef.m_plugin_id.
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnObjectRenderingAttributes.MappingChannel(System.Guid@,System.Guid@)">
            <param name="plugin_id">[in]</param>
            <param name="mapping_id">[in] ON_TextureMapping id</param>
            <returns>A pointer to the plug-in's mapping channel, if there is one. Otherwise NULL is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnObjectRenderingAttributes.MappingChannel(System.Guid@,System.Int32)">
            <param name="plugin_id">[in]</param>
            <param name="mapping_channel_id">[in]</param>
            <returns>A pointer to the plug-in's mapping channel, if there is one. Otherwise NULL is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnObjectRenderingAttributes.MappingRef(System.Guid@)">
            <param name="plugin_id">[in]</param>
            <returns>
A pointer to the plug-in's mapping reference, if there is one. Otherwise NULL is returned.
</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjectRenderingAttributes.m_bReceivesShadows">
            <value>default is true</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjectRenderingAttributes.m_bCastsShadows">
            <value>default is true</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjectRenderingAttributes.m_mappings">
            <value>
Use AddMappingRef() or AddMappingChannel() if you 
want to add an element to this array.
Every mapping ref in this array must have
a distinct value of ON_MappingRef.m_plugin_id.
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnMaterialRef.#ctor">
            <summary>
If m_material_id = ON_MaterialRef::material_from_layer,
then the object's layer determine the material.
See ON::material_from_layer.
static const ON_UUID material_from_layer; // TOD0 - remove this
If m_material_id = ON_MaterialRef::material_from_layer,
then the object's parent determine the material.
See ON::material_from_parent.
static const ON_UUID material_from_parent; // TODO - remove this
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMaterialRef.m_material_backface_index">
            <value>
RUNTIME material table index for m_material_id.
This value is not saved in files.  If -1, then it
needs to be set.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMaterialRef.m_material_index">
            <value>
RUNTIME material table index for m_material_id.
This value is not saved in files.  If -1, then it
needs to be set.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMaterialRef.m_material_backface_id">
            <value>
If nil, then m_material_id is used for front and back faces
Identifies an ON_Material
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMaterialRef.m_material_id">
            <value>
Identifies an ON_Material
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMaterialRef.m_plugin_id">
            <value>
Identifies a rendering plugin
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMaterialRef.m_material_backface_index">
            <value>
RUNTIME material table index for m_material_id.
This value is not saved in files.  If -1, then it
needs to be set.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMaterialRef.m_material_index">
            <value>
RUNTIME material table index for m_material_id.
This value is not saved in files.  If -1, then it
needs to be set.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMaterialRef.m_material_backface_id">
            <value>
If nil, then m_material_id is used for front and back faces
Identifies an ON_Material
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMaterialRef.m_material_id">
            <value>
Identifies an ON_Material
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMaterialRef.m_plugin_id">
            <value>
Identifies a rendering plugin
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnMappingRef.ChangeMappingChannel(System.Int32,System.Int32)">
            <param name="old_mapping_channel_id">[in]</param>
            <param name="new_mapping_channel_id">[in]</param>
            <returns>True if a matching mapping channel was found and changed.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMappingRef.DeleteMappingChannel(System.Guid@)">
            <param name="mapping_id">[in] ON_TextureMapping id</param>
            <returns>True if a matching mapping channel was deleted.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMappingRef.DeleteMappingChannel(System.Int32)">
            <param name="mapping_channel_id">[in]</param>
            <returns>True if a matching mapping channel was deleted.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMappingRef.AddMappingChannel(System.Int32,System.Guid@)">
            <param name="mapping_channel_id">[in]</param>
            <param name="mapping_id">[in] ON_TextureMapping id</param>
            <returns>
True if the mapping channel was added or a pefect match already existed.
False if a mapping channel with a different mapping_id already exists for this plug-in and channel.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMappingRef.MappingChannel(System.Guid@)">
            <param name="mapping_id">[in] ON_TextureMapping id</param>
            <returns>A pointer to the plug-in's mapping channel, if there is one. Otherwise NULL is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMappingRef.MappingChannel(System.Int32)">
            <param name="mapping_channel_id">[in]</param>
            <returns>A pointer to the plug-in's mapping channel, if there is one. Otherwise NULL is returned.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnMappingRef.m_mapping_channels">
            <value>
Use AddMappingChannel() if you  want to add an 
element to this array.
Every mapping channel in this array must have
a distinct value of ON_MappingChannel.m_mapping_channel_id
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMappingRef.m_plugin_id">
            <value>
Identifies a rendering plugin
</value>
        </member>
        <member name="T:RMA.OpenNURBS.OnMappingRef">
            <summary>
ON_3dmObjectAttributes uses ON_MaterialRef to record which
rendering material and mappings a rendering plug-in wants to 
use.  This allows different rendering plug-ins to have different 
materials on the same object.  The values of
ON_3dmObjectAttributes.m_material_index and 
ON_3dmObjectAttributes.m_matrial_source reflect the settings
of the renderer that is currently active.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMappingRef.MappingChannel(System.Guid@)">
            <param name="mapping_id">[in] ON_TextureMapping id</param>
            <returns>A pointer to the plug-in's mapping channel, if there is one. Otherwise NULL is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMappingRef.MappingChannel(System.Int32)">
            <param name="mapping_channel_id">[in]</param>
            <returns>A pointer to the plug-in's mapping channel, if there is one. Otherwise NULL is returned.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMappingRef.m_mapping_channels">
            <value>
Use AddMappingChannel() if you  want to add an 
element to this array.
Every mapping channel in this array must have
a distinct value of ON_MappingChannel.m_mapping_channel_id
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMappingRef.m_plugin_id">
            <value>
Identifies a rendering plugin
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnMappingRef">
            <summary>
ON_3dmObjectAttributes uses ON_MaterialRef to record which
rendering material and mappings a rendering plug-in wants to 
use.  This allows different rendering plug-ins to have different 
materials on the same object.  The values of
ON_3dmObjectAttributes.m_material_index and 
ON_3dmObjectAttributes.m_matrial_source reflect the settings
of the renderer that is currently active.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMappingChannel.m_object_xform">
            <value>
The default value of m_object_xform is the identity.
When an object that uses this mapping is transformed
by "T", m_object_xform is updated using the formula
m_object_xform = T*m_object_xform.  If texture coordinates
are lost and need to be recalculated and m_object_xform
is not the identity, then m_object_xform should be passed
to ON_TextureMapping::Evaluate() as the mesh_xform parameter.
When validating mapping coordinates, m_object_xform itself 
be passed to HasMatchingTextureCoordinates() as the
object_transform parameter.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMappingChannel.m_mapping_channel_id">
            <value>
ON_Texture's with a matching m_mapping_channel_id value
use the mapping identified by m_mapping_id.  This id
must be &gt; 0 and &lt;= 2147483647 (0x7FFFFFFF)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMappingChannel.m_mapping_index">
            <value>
RUNTIME textrure mapping table index.
If -1, it needs to be set.  This value is not saved int files.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnMappingChannel.m_mapping_id">
            <value>
Identifies an ON_TextureMapping
</value>
        </member>
        <member name="T:RMA.OpenNURBS.OnMappingChannel">
            <summary>
ON_3dmObjectAttributes uses ON_MappingChannel to record 
which texture mapping function to use when applying a texture
with a matching mapping channel id.
When an object is rendered, if the material has textures and
ON_Texture::m_mapping_channel_id = ON_MappingChannel::m_mapping_channel_id,
then the mapping with id m_mapping_id is used to map the texture.
Otherwise, the mesh m_T[] texture coordinates are used to
apply the texture.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMappingChannel.m_object_xform">
            <value>
The default value of m_object_xform is the identity.
When an object that uses this mapping is transformed
by "T", m_object_xform is updated using the formula
m_object_xform = T*m_object_xform.  If texture coordinates
are lost and need to be recalculated and m_object_xform
is not the identity, then m_object_xform should be passed
to ON_TextureMapping::Evaluate() as the mesh_xform parameter.
When validating mapping coordinates, m_object_xform itself 
be passed to HasMatchingTextureCoordinates() as the
object_transform parameter.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMappingChannel.m_mapping_channel_id">
            <value>
ON_Texture's with a matching m_mapping_channel_id value
use the mapping identified by m_mapping_id.  This id
must be &gt; 0 and &lt;= 2147483647 (0x7FFFFFFF)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMappingChannel.m_mapping_index">
            <value>
RUNTIME textrure mapping table index.
If -1, it needs to be set.  This value is not saved int files.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMappingChannel.m_mapping_id">
            <value>
Identifies an ON_TextureMapping
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnMappingChannel">
            <summary>
ON_3dmObjectAttributes uses ON_MappingChannel to record 
which texture mapping function to use when applying a texture
with a matching mapping channel id.
When an object is rendered, if the material has textures and
ON_Texture::m_mapping_channel_id = ON_MappingChannel::m_mapping_channel_id,
then the mapping with id m_mapping_id is used to map the texture.
Otherwise, the mesh m_T[] texture coordinates are used to
apply the texture.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextLog.Print(System.String)">
            <summary>Print an unformatted UNICODE string of any length.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextLog.PrintWrappedText(System.String)">
            <summary>line length = 60</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextLog.SetIndentSize(System.Int32)">
            <summary>
0: one tab per indent
&gt;0: number of spaces per indent
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextLog.IndentSize">
            <summary>
0: one tab per indent
&gt;0: number of spaces per indent
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextLog.SetDoubleFormat(System.String)">
            <summary>
Description: Create a text log that dumps to a string. Parameters: s - [in] String that must exist as long as the text log is in use.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextLog.#ctor(RMA.OpenNURBS.OnFileHandle)">
            <summary>Create a text log that dumps to an ASCII file.</summary>
            <param name="fp">
[in] Pointer to an open ASCII text file.  The file  pointer must
remain valid as long as the text log is in use.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextLog.#ctor(System.IO.TextWriter)">
            <summary>Create a text log that dumps to a TextWriter</summary>
            <param name="log_destination">TextWriter to write log messages. Typically this would be System::Console::Out</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextLog.#ctor">
            <summary>Create a text log that dumps to Console.Out</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextLog.IndentSize">
            <summary>
0: one tab per indent
&gt;0: number of spaces per indent
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnEvaluator.Domain(System.Int32)">
            <summary>
Description: If a function has a periodic parameter, then the m_domain interval for that parameter is the fundamental domain and the m_bPeriodicParameter bool for that parameter is true. A parameter is periodic if, and only if, m_domain.Count() == m_parameter_count, and m_bPeriodicParameter.Count() == m_parameter_count, and m_bPeriodicParameter[parameter_index] is true. Returns: The domain of the parameter. If the domain is infinite, the (-1.0e300, +1.0e300) is returned.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnEvaluator.Periodic(System.Int32)">
            <summary>
Description: If a function has a periodic parameter, then the m_domain interval for that parameter is the fundamental domain and the m_bPeriodicParameter bool for that parameter is true. A parameter is periodic if, and only if, m_domain.Count() == m_parameter_count, and m_bPeriodicParameter.Count() == m_parameter_count, and m_bPeriodicParameter[parameter_index] is true. Returns: True if the function parameter is periodic.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnEvaluator.FiniteDomain">
            <summary>
Description: Functions can have finite or infinite domains. Finite domains are specified by passing the domain[] array to the constructor or filling in the m_domain[] member variable. If m_domain.Count() == m_parameter_count &gt; 0, then the function has finite domains. Returns: True if the domain of the function is finite.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnEvaluator.m_bPeriodicParameter">
            <value>
If the function has periodic parameters, then
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnEvaluator.m_domain">
            <value>
If the function has a finite domain or periodic
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnEvaluator.m_value_count">
            <value>
Number of the function's output values. This number
is &gt;= 1 and is specified in the constructor.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnEvaluator.m_parameter_count">
            <value>
Number of the function's input parameters. This number
is &gt;= 1 and is specified in the constructor.
</value>
        </member>
        <member name="T:RMA.OpenNURBS.OnEvaluator">
            <summary>
Abstract function with an arbitrary number of parameters
and values.  ON_Evaluator is used to pass functions to
local solvers.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEvaluator.Domain(System.Int32)">
            <summary>
Description: If a function has a periodic parameter, then the m_domain interval for that parameter is the fundamental domain and the m_bPeriodicParameter bool for that parameter is true. A parameter is periodic if, and only if, m_domain.Count() == m_parameter_count, and m_bPeriodicParameter.Count() == m_parameter_count, and m_bPeriodicParameter[parameter_index] is true. Returns: The domain of the parameter. If the domain is infinite, the (-1.0e300, +1.0e300) is returned.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEvaluator.Periodic(System.Int32)">
            <summary>
Description: If a function has a periodic parameter, then the m_domain interval for that parameter is the fundamental domain and the m_bPeriodicParameter bool for that parameter is true. A parameter is periodic if, and only if, m_domain.Count() == m_parameter_count, and m_bPeriodicParameter.Count() == m_parameter_count, and m_bPeriodicParameter[parameter_index] is true. Returns: True if the function parameter is periodic.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEvaluator.FiniteDomain">
            <summary>
Description: Functions can have finite or infinite domains. Finite domains are specified by passing the domain[] array to the constructor or filling in the m_domain[] member variable. If m_domain.Count() == m_parameter_count &gt; 0, then the function has finite domains. Returns: True if the domain of the function is finite.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnEvaluator.m_bPeriodicParameter">
            <value>
If the function has periodic parameters, then
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnEvaluator.m_domain">
            <value>
If the function has a finite domain or periodic
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnEvaluator.m_value_count">
            <value>
Number of the function's output values. This number
is &gt;= 1 and is specified in the constructor.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnEvaluator.m_parameter_count">
            <value>
Number of the function's input parameters. This number
is &gt;= 1 and is specified in the constructor.
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnEvaluator">
            <summary>
Abstract function with an arbitrary number of parameters
and values.  ON_Evaluator is used to pass functions to
local solvers.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSum.SummandCount">
            <summary>
Returns: Number of summands.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSum.Total">
            <summary>Calculates the total sum.</summary>
            <returns>Total of the sum.</returns>
            <remarks>
You can get subtotals by mixing calls to Plus() and Total().
In delicate sums, some precision may be lost in the final
total if you call Total() to calculate subtotals.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSum.Total(System.Double@)">
            <summary>Calculates the total sum.</summary>
            <param name="error_estimate">
[out] the returned value of error_estimate is an estimate of the error in the sum.
</param>
            <returns>Total of the sum.</returns>
            <remarks>
You can get subtotals by mixing calls to Plus() and Total().
In delicate sums, some precision may be lost in the final
total if you call Total() to calculate subtotals.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSum.Plus(System.Double)">
            <summary>
Description: Add x to the current sum. Parameters: x - [in] value to add to the current sum.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSum.Begin">
            <summary>
Description: If a sum is being used more than once, call Begin() before starting each sum. Parameters: starting_value - [in] Initial value of sum.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSum.Begin(System.Double)">
            <summary>
Description: If a sum is being used more than once, call Begin() before starting each sum. Parameters: starting_value - [in] Initial value of sum.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSum.#ctor">
            <summary>
Description: Creates a sum that is ready to be used.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSum.op_SubtractionAssignment(RMA.OpenNURBS.OnSum,System.Double)">
            <summary>
Description: Calls ON_Sum::Plus(-x);
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSum.op_AdditionAssignment(RMA.OpenNURBS.OnSum,System.Double)">
            <summary>
Description: Calls ON_Sum::Plus(x);
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSum.op_Implicit(System.Double)~RMA.OpenNURBS.OnSum">
            <summary>
Description: Calls ON_Sum::Begin(x)
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnSum">
            <summary>Class for carefully adding long list of numbers.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSum.SummandCount">
            <summary>
Returns: Number of summands.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnSum">
            <summary>Class for carefully adding long list of numbers.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCageMorph.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>Transforms the morph by transforming the bezier volume map.</summary>
            <param name="xform">[in]</param>
            <returns>True if input is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCageMorph.SetBezierCage(RMA.OpenNURBS.OnBezierCage@)">
            <summary>Set the unit cube to world map.</summary>
            <param name="unitcube2world">
[in] Bezier volume map from the unit cube (0,1)x(0,1)x(0,1) to world space.
</param>
            <returns>
True if current transformation matrix and input bezier volume are valid.
In all cases, the morph's m_rst2xyz member is set.
See Also:
ON_BezierCage::Create
ON_BezierCage::SetXform
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCageMorph.SetXform(RMA.OpenNURBS.IOnXform)">
            <summary>
Description: Set the world to unit cube map. Parameters: world2unitcube - [in] Tranformation matrix that maps world coordinates to the unit cube (0,1)x(0,1)x(0,1). Returns True if current bezier volum and input transformation matrix are valid. In all cases, the morph's m_xyz2rst member is set. See Also: ON_BezierCage::Create ON_BezierCage::SetBezierCage
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCageMorph.Create(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,System.Int32,System.Int32,System.Int32)">
            <summary>Create a Bezier volume.</summary>
            <remarks>
P0,P1,P2,P3 defines a parallepiped in world space. The morph maps
this parallepiped to the (0,1)x(0,1)x(0,1) unit cube and then applies
the BezierCage map.

point_countX, point_countY, point_countZ
Number of control points in the bezier volume map. The bezier volume
in the returned morph is the identity map which can be modified as needed. 
</remarks>
            <returns>
True if resulting morph is valid.
See Also: ON_BezierCage::SetBezierCage ON_BezierCage::SetXform
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCageMorph.MorphPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Override of virtual ON_SpaceMorph::MorphPoint.</summary>
            <param name="point">[in] (x,y,z) gets mapped to m_rst2xyz(m_xyz2rst*point);</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCageMorph.MorphPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Override of virtual ON_SpaceMorph::MorphPoint.</summary>
            <param name="point">[in] (x,y,z) gets mapped to m_rst2xyz(m_xyz2rst*point);</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.ReserveCVCapacity(System.Int32)">
            <summary>
Description: cv_capacity - [in] number of doubles to reserve
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.ZeroCVs">
            <summary>
zeros control vertices and, if rational, sets weights to 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.GetCV(System.Int32,System.Int32,System.Int32,RMA.OpenNURBS.On4dPoint@)">
            <summary>
get a single control vertex
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.GetCV(System.Int32,System.Int32,System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>
get a single control vertex
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.SetCV(System.Int32,System.Int32,System.Int32,RMA.OpenNURBS.IOn4dPoint)">
            <summary>
set a single control vertex
value of control vertex
If NURBS is not rational, euclidean
location of homogeneous point will
be used.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.SetCV(System.Int32,System.Int32,System.Int32,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
set a single control vertex
If NURBS is rational, weight
will be set to 1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.SetWeight(System.Int32,System.Int32,System.Int32,System.Double)">
            <summary>
get value of control vertex weight
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.Weight(System.Int32,System.Int32,System.Int32)">
            <summary>
get value of control vertex weight
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.CVStyle">
            <summary>
Description: Expert user function to get a pointer to control vertex memory. If you are not an expert user, please use ON_BezierCage::GetCV( ON_3dPoint&amp; ) or ON_BezierCage::GetCV( ON_4dPoint&amp; ). Parameters: cv_index0 - [in] (0 &lt;= cv_index0 &lt; m_order[0]) cv_index1 - [in] (0 &lt;= cv_index1 &lt; m_order[1]) Returns: Pointer to control vertex. Remarks: If the Bezier surface is rational, the format of the returned array is a homogeneos rational point with length m_dim+1. If the Bezier surface is not rational, the format of the returned array is a nonrational euclidean point with length m_dim. See Also ON_BezierCage::CVStyle ON_BezierCage::GetCV ON_BezierCage::Weight
</summary>
            <summary>Returns the style of control vertices in the m_cv array.</summary>
            <returns>
ON::not_rational m_is_rat is FALSE
ON::homogeneous_rational m_is_rat is TRUE
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.Degree(System.Int32)">
            <summary>
degree = order - 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.Order(System.Int32)">
            <summary>
order = degree + 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.CVSize">
            <summary>
number of doubles per control vertex
= IsRational() ? Dim()+1 : Dim()
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.IsSingular(System.Int32)">
            <summary>
TRUE if surface side is collapsed to a point
</summary>
            <param name="side">
side of parameter space to test
0 = south, 1 = east, 2 = north, 3 = west
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.IsRational">
            <summary>
TRUE if NURBS curve is rational
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.PointAt(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Evaluates bezer volume map.</summary>
            <returns>Value of the bezier volume map at (rst.x,rst.y,rst.z).</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.PointAt(System.Double,System.Double,System.Double)">
            <summary>Evaluates bezer volume map.</summary>
            <returns>Value of the bezier volume map at (r,s,t).</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.Domain(System.Int32)">
            <param name="arg1">0 = "u" domain, 1 = "v" domain, 2 = "w" domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.Scale(System.Double)">
            <summary>
Scales the bezier surface by the specified facotor.  The scale is
centered at the origin.
</summary>
            <param name="scale_factor">[in] scale factor</param>
            <returns>TRUE if bezier surface successfully scaled</returns>
            <remarks>Uses ON_BezierCage::Transform() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.Translate(RMA.OpenNURBS.IOn3dVector)">
            <summary>
Translates the bezier surface along the specified vector.
</summary>
            <param name="translation_vector">[in] translation vector</param>
            <returns>TRUE if bezier surface successfully translated</returns>
            <remarks>Uses ON_BezierCage::Transform() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.Rotate(System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Rotates the bezier surface about the specified axis.  A positive
rotation angle results in a counter-clockwise rotation
about the axis (right hand rule).
</summary>
            <param name="rotation_angle">[in] angle of rotation in radians</param>
            <param name="rotation_axis">[in] direction of the axis of rotation</param>
            <param name="rotation_center">[in] point on the axis of rotation</param>
            <returns>TRUE if bezier surface successfully rotated</returns>
            <remarks>Uses ON_BezierCage::Transform() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Rotates the bezier surface about the specified axis.  A positive
rotation angle results in a counter-clockwise rotation
about the axis (right hand rule).
</summary>
            <param name="sin_angle">[in] sine of rotation angle</param>
            <param name="cos_angle">[in] sine of rotation angle</param>
            <param name="rotation_axis">[in] direction of the axis of rotation</param>
            <param name="rotation_center">[in] point on the axis of rotation</param>
            <returns>TRUE if bezier surface successfully rotated</returns>
            <remarks>Uses ON_BezierCage::Transform() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.Write(RMA.OpenNURBS.OnBinaryArchive@)">
            <summary>
Saves the definition of this class in serial binary form that can be read by ON_BezierVolue::Read.
</summary>
            <param name="archive">[in] target archive</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.Read(RMA.OpenNURBS.OnBinaryArchive@)">
            <summary>
Reads the definition of this class from an archive previously saved by ON_BezierVolue::Write.
</summary>
            <param name="archive">[in] target archive</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.EmergencyDestroy">
            <summary>
Sets all members to zero. Does not free the CV array even when m_cv is not NULL.
Generally used when the CVs were allocated from a memory pool that no longer exists
and the free done in ~ON_BezierCage would cause a crash.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.Destroy">
            <summary>
Frees the CV array and sets all members to zero.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.Create(RMA.OpenNURBS.IOnBoundingBox,System.Int32,System.Int32,System.Int32)">
            <summary>Create a Bezier volume with corners defined by a bounding box.</summary>
            <param name="bbox">
[in] target bounding box - the bezier will map the unit cube onto this bounding box.
</param>
            <param name="order1">[in]</param>
            <param name="order2">[in]</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.Create(System.Int32,System.Boolean,System.Int32,System.Int32,System.Int32)">
            <summary>Creates a bezier volume with specified orders.</summary>
            <param name="dim">[in]</param>
            <param name="is_rat">[in]</param>
            <param name="order0">[in]</param>
            <param name="order1">[in]</param>
            <param name="order2">[in]</param>
            <returns>True if input was valid and creation succeded.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.Dimension">
            <summary>
The dimension of the image of the bazier volume map. This is generally three,
but can be any positive integer.
</summary>
            <returns>Dimesion of the image space.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.IsValid">
            <summary>Tests class to make sure members are correctly initialized.</summary>
            <returns>
True if the orders are all &gt;= 2, dimension is positive, and the
rest of the members have settings that are valid for the orders and dimension.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.#ctor(RMA.OpenNURBS.IOnBoundingBox,System.Int32,System.Int32,System.Int32)">
            <summary>
Construct a bezier volume that maps the unit cube to a bounding box.
</summary>
            <param name="bbox">[in] target bounding box</param>
            <param name="order0">[in]</param>
            <param name="order1">[in]</param>
            <param name="order2">[in]</param>
        </member>
        <member name="P:RMA.OpenNURBS.OnBezierCage.m_dim">
            <value>
NOTE: These members are left "public" so that expert users may efficiently
     create bezier curves using the default constructor and borrow the
     knot and CV arrays from their native NURBS representation.
     No technical support will be provided for users who access these
     members directly.  If you can't get your stuff to work, then use
     the constructor with the arguments and the SetKnot() and SetCV()
     functions to fill in the arrays.
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCage.GetCV(System.Int32,System.Int32,System.Int32,RMA.OpenNURBS.On4dPoint@)">
            <summary>
get a single control vertex
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCage.GetCV(System.Int32,System.Int32,System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>
get a single control vertex
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCage.Weight(System.Int32,System.Int32,System.Int32)">
            <summary>
get value of control vertex weight
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCage.CVStyle">
            <summary>
Description: Expert user function to get a pointer to control vertex memory. If you are not an expert user, please use ON_BezierCage::GetCV( ON_3dPoint&amp; ) or ON_BezierCage::GetCV( ON_4dPoint&amp; ). Parameters: cv_index0 - [in] (0 &lt;= cv_index0 &lt; m_order[0]) cv_index1 - [in] (0 &lt;= cv_index1 &lt; m_order[1]) Returns: Pointer to control vertex. Remarks: If the Bezier surface is rational, the format of the returned array is a homogeneos rational point with length m_dim+1. If the Bezier surface is not rational, the format of the returned array is a nonrational euclidean point with length m_dim. See Also ON_BezierCage::CVStyle ON_BezierCage::GetCV ON_BezierCage::Weight
</summary>
            <summary>Returns the style of control vertices in the m_cv array.</summary>
            <returns>
ON::not_rational m_is_rat is FALSE
ON::homogeneous_rational m_is_rat is TRUE
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCage.Degree(System.Int32)">
            <summary>
degree = order - 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCage.Order(System.Int32)">
            <summary>
order = degree + 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCage.CVSize">
            <summary>
number of doubles per control vertex
= IsRational() ? Dim()+1 : Dim()
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCage.IsSingular(System.Int32)">
            <summary>
TRUE if surface side is collapsed to a point
</summary>
            <param name="side">
side of parameter space to test
0 = south, 1 = east, 2 = north, 3 = west
</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCage.IsRational">
            <summary>
TRUE if NURBS curve is rational
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCage.PointAt(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Evaluates bezer volume map.</summary>
            <returns>Value of the bezier volume map at (rst.x,rst.y,rst.z).</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCage.PointAt(System.Double,System.Double,System.Double)">
            <summary>Evaluates bezer volume map.</summary>
            <returns>Value of the bezier volume map at (r,s,t).</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCage.Domain(System.Int32)">
            <param name="arg1">0 = "u" domain, 1 = "v" domain, 2 = "w" domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCage.Write(RMA.OpenNURBS.OnBinaryArchive@)">
            <summary>
Saves the definition of this class in serial binary form that can be read by ON_BezierVolue::Read.
</summary>
            <param name="archive">[in] target archive</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCage.Dimension">
            <summary>
The dimension of the image of the bazier volume map. This is generally three,
but can be any positive integer.
</summary>
            <returns>Dimesion of the image space.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCage.IsValid">
            <summary>Tests class to make sure members are correctly initialized.</summary>
            <returns>
True if the orders are all &gt;= 2, dimension is positive, and the
rest of the members have settings that are valid for the orders and dimension.
</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBezierCage.m_dim">
            <value>
NOTE: These members are left "public" so that expert users may efficiently
     create bezier curves using the default constructor and borrow the
     knot and CV arrays from their native NURBS representation.
     No technical support will be provided for users who access these
     members directly.  If you can't get your stuff to work, then use
     the constructor with the arguments and the SetKnot() and SetCV()
     functions to fill in the arrays.
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurfaceTreeBezier.SetLeafBox">
            <summary>
Description: Sets m_leafbox to be the smallest surface leaf box that contains the bezier surface. Returns: True if this bezier is valid and the leaf box is set.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurfaceTreeBezier.SetBezier(RMA.OpenNURBS.IOnBezierSurface)">
            <summary>
Description: Quickly find a lower bound on the distance from a point to this bezier curve. Parameters: P - [in] Returns: A distance that is less than or equal to the shortest distance from P to a point on the bezier curve. Put another way, if Q is any point on the bezier curve, then P.DistanceTo(Q) &gt;= MinimumDistanceTo(P);
</summary>
            <summary>
Description: Quickly find an upper bound on the distance from a point to this bezier curve. Parameters: pt - [in] Returns: A distance that is greater than or equal to the longest distance from P to a point on the bezier curve. Put another way, if Q is any point on the bezier curve, then P.DistanceTo(Q) &lt;= MaximumDistanceTo(P);
</summary>
            <summary>
Description: Quickly find a lower bound on the distance between the bezier curve and a bounding box. Parameters: bbox - [in] Returns: A distance that is less than or equal to the shortest distance from this curve to the bounding box. Put another way, if Q is any point on this bezier curve and P is any point in bbox, then P.DistanceTo(Q) &gt;= MinimumDistanceTo(bbox).
</summary>
            <summary>
Description: Quickly find an upper bound on the distance between the bezier curve and a bounding box. Parameters: bbox - [in] Returns: A distance that is greater than or equal to the longest distance from this curve to the bounding box. Put another way, if Q is any point on this bezier curve and P is any point in bbox, then P.DistanceTo(Q) &lt;= MaximumDistanceTo(bbox).
</summary>
            <summary>
Description: Quickly find a lower bound on the distance between the two bezier curves. Parameters: other - [in] another bezier curve Returns: A distance that is less than or equal to the shortest distance from this curve to the other curve. Put another way, if Q is any point on this bezier curve and P is any point on the other bezier curve, then then P.DistanceTo(Q) &gt;= MinimumDistanceTo(other).
</summary>
            <summary>
Description: Quickly find an upper bound on the distance between the two bezier curves. Parameters: other - [in] another bezier curve Returns: A distance that is greater than or equal to the longest distance from this curve to the other curve. Put another way, if Q is any point on this bezier curve and P is any point on the other bezier curve, then then P.DistanceTo(Q) &lt;= MaximumDistanceTo(other).
</summary>
            <summary>
Description: Quickly determine if the shortest distance from the point P to this bezier curve is greater than d. Parameters: d - [in] distance (&gt; 0.0) P - [in] Returns: True if the shortest distance from the point P to this bezier curve is greater than d. It is not the case that false means that the shortest distance is less than or equal to d.
</summary>
            <summary>
Description: Quickly determine if the shortest distance from the bounding box to this bezier curve is greater than d. Parameters: d - [in] distance (&gt; 0.0) bbox - [in] Returns: True if the shortest distance from the bounding box to this bezier curve is greater than d. It is not the case that false means that the shortest distance is less than or equal to d.
</summary>
            <summary>
Description: Quickly determine if the shortest distance from the other bezier to this bezier curve is greater than d. Parameters: d - [in] distance (&gt; 0.0) other - [in] Returns: True if the shortest distance from the other bezier to this bezier curve is greater than d. It is not the case that false means that the shortest distance is less than or equal to d.
</summary>
            <summary>
Description: Quickly determine if the shortest distance from the other bezier to this bezier curve is greater than d. Parameters: d - [in] distance (&gt; 0.0) other - [in] Returns: True if the shortest distance from the other bezier to this bezier curve is greater than d. It is not the case that false means that the shortest distance is less than or equal to d.
</summary>
            <summary>
Description: Copies bezier_surface and sets m_leafbox to be the smallest surface leaf box that contains the bezier surface. Returns: True if bezier_surface is valid and the leaf box is set.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurfaceTreeBezier.#ctor">
            <summary>
C++ defaults for destruction,
copy construction, and operator= work fine.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurfaceLeafBox.GetSideEquation(System.Int32,RMA.OpenNURBS.OnPlaneEquation@)">
            <summary>
Description: Get the equation of the 3d plane that lies on the side of the leaf box. Parameters: side - [in] 0: side from m_q[0] to m_q[1] 1: side from m_q[1] to m_q[2] 2: side from m_q[2] to m_q[3] 3: side from m_q[3] to m_q[0] 4: bottom 5: top e - [out] The leaf box lies on the negative side of the plane. Returns: True if successful.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurfaceLeafBox.IsPointIn(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Determine if the point P is in this surface leaf box. Parameters: P - [in] Returns: True if the point is in the surface leaf box.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurfaceLeafBox.Height">
            <summary>
Description: "Height" of the surface leaf box. Returns: Height of the surface leaf box.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurfaceLeafBox.PointAt(System.Double,System.Double)">
            <summary>
Description: Point on the planar quad/triangle that is the "center" of the surface leaf box. Parameters: s - [in] 0.0 &lt;= s &lt;= 1.0 t - [in] 0.0 &lt;= t &lt;= 1.0 Returns: point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurfaceLeafBox.IsFartherThan(System.Double,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Quickly determine if the shortest distance between this leaf box and the other object is greater than d. Parameters: d - [in] distance (&gt; 0.0) P - [in] another point bbox - [in] another axis aligned bounding box crvleafbox - [in] another curve tree node leaf box srfleafbox - [in] another surface tree node leaf box Returns: True if the shortest distance from this leaf box to the other object is greater than d. It is not the case that false means that the shortest distance is less than or equal to d.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurfaceLeafBox.MinimumDistanceTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Quickly find a lower bound on the distance between the this leaf box and the other object. Parameters: P - [in] another point bbox - [in] another axis aligned bounding box crvleafbox - [in] another curve tree node leaf box srfleafbox - [in] another surface tree node leaf box Returns: A distance that is less than or equal to the shortest distance from this leaf box to the other object. Put another way, if Q is any point on this leaf box and P is any point on the other object, then then P.DistanceTo(Q) &gt;= MinimumDistanceTo(other).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurfaceLeafBox.IsValid(RMA.OpenNURBS.OnTextLog)">
            <summary>
Description: Test the leaf box to make sure its settings are valid. Parameters: text_log - [in] If an error is found and text_log is not null, then a short description of the problem is printed to the text_log. Returns: True if the leaf box is valid, and false otherwise.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnSurfaceLeafBox.m_bDegen">
            <value>
True if the m_q[] are not convex (the m_c[] are always convex)
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurfaceLeafBox.GetSideEquation(System.Int32,RMA.OpenNURBS.OnPlaneEquation@)">
            <summary>
Description: Get the equation of the 3d plane that lies on the side of the leaf box. Parameters: side - [in] 0: side from m_q[0] to m_q[1] 1: side from m_q[1] to m_q[2] 2: side from m_q[2] to m_q[3] 3: side from m_q[3] to m_q[0] 4: bottom 5: top e - [out] The leaf box lies on the negative side of the plane. Returns: True if successful.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurfaceLeafBox.IsPointIn(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Determine if the point P is in this surface leaf box. Parameters: P - [in] Returns: True if the point is in the surface leaf box.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurfaceLeafBox.Height">
            <summary>
Description: "Height" of the surface leaf box. Returns: Height of the surface leaf box.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurfaceLeafBox.PointAt(System.Double,System.Double)">
            <summary>
Description: Point on the planar quad/triangle that is the "center" of the surface leaf box. Parameters: s - [in] 0.0 &lt;= s &lt;= 1.0 t - [in] 0.0 &lt;= t &lt;= 1.0 Returns: point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurfaceLeafBox.IsFartherThan(System.Double,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Quickly determine if the shortest distance between this leaf box and the other object is greater than d. Parameters: d - [in] distance (&gt; 0.0) P - [in] another point bbox - [in] another axis aligned bounding box crvleafbox - [in] another curve tree node leaf box srfleafbox - [in] another surface tree node leaf box Returns: True if the shortest distance from this leaf box to the other object is greater than d. It is not the case that false means that the shortest distance is less than or equal to d.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurfaceLeafBox.MinimumDistanceTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Quickly find a lower bound on the distance between the this leaf box and the other object. Parameters: P - [in] another point bbox - [in] another axis aligned bounding box crvleafbox - [in] another curve tree node leaf box srfleafbox - [in] another surface tree node leaf box Returns: A distance that is less than or equal to the shortest distance from this leaf box to the other object. Put another way, if Q is any point on this leaf box and P is any point on the other object, then then P.DistanceTo(Q) &gt;= MinimumDistanceTo(other).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurfaceLeafBox.IsValid(RMA.OpenNURBS.OnTextLog)">
            <summary>
Description: Test the leaf box to make sure its settings are valid. Parameters: text_log - [in] If an error is found and text_log is not null, then a short description of the problem is printed to the text_log. Returns: True if the leaf box is valid, and false otherwise.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnSurfaceLeafBox.m_bDegen">
            <value>
True if the m_q[] are not convex (the m_c[] are always convex)
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double,System.Double@,System.Double@)">
            <summary>
Get the parameter of the point on the bezier surface that is locally closest to
the point P when the search begins at (s_seed,t_seed).
</summary>
            <param name="P">[in]</param>
            <param name="s_seed">[in]Parameters where the search begins. </param>
            <param name="t_seed">[in]Parameters where the search begins. </param>
            <param name="s">[out] Closest point parameter</param>
            <param name="t">[out] Closest point parameter</param>
            <returns>True if a point is found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval)">
            <summary>
Get the parameter of the point on the bezier surface that is locally closest to
the point P when the search begins at (s_seed,t_seed).
</summary>
            <param name="P">[in]</param>
            <param name="s_seed">[in]Parameters where the search begins. </param>
            <param name="t_seed">[in]Parameters where the search begins. </param>
            <param name="s">[out] Closest point parameter</param>
            <param name="t">[out] Closest point parameter</param>
            <param name="sub_domain0">
[in] If not NULL, the search is confined to "s" parameters
in the intersection of the sub_domain0 interval and (0,1).
</param>
            <returns>True if a point is found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>
Get the parameter of the point on the bezier surface that is locally closest to
the point P when the search begins at (s_seed,t_seed).
</summary>
            <param name="P">[in]</param>
            <param name="s_seed">[in]Parameters where the search begins. </param>
            <param name="t_seed">[in]Parameters where the search begins. </param>
            <param name="s">[out] Closest point parameter</param>
            <param name="t">[out] Closest point parameter</param>
            <param name="sub_domain0">
[in] If not NULL, the search is confined to "s" parameters
in the intersection of the sub_domain0 interval and (0,1).
</param>
            <param name="sub_domain1">
[in] If not NULL, the search is confined to "t" parameters
in the intersection of the sub_domain1 interval and (0,1).
</param>
            <returns>True if a point is found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@)">
            <summary>
Get the parameters of the point on the bezier surface that is closest to the point P.
</summary>
            <param name="P">[in]</param>
            <param name="s">[out]</param>
            <param name="t">[out]</param>
            <returns>
True if a point is found.
See Also: ON_SurfaceTreeNode::GetClosestPoint
</returns>
            <remarks>
This function is not efficient if you will be finding multiple closest points
to the same bezier. To efficiently find multiple closest points, make a surface
tree and use it. See the ON_BezierSurface::GetClosestPoint code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@,System.Double)">
            <summary>
Get the parameters of the point on the bezier surface that is closest to the point P.
</summary>
            <param name="P">[in]</param>
            <param name="s">[out]</param>
            <param name="t">[out]</param>
            <param name="maximum_distance">
[in] If maximum_distance &gt; 0.0, then an answer is returned only if the distance
from the bezier surface to P is &lt;= maximum_distance. If maximum_distance &lt;= 0.0,
then maximum_distance is ignored.
</param>
            <returns>
True if a point is found.
See Also: ON_SurfaceTreeNode::GetClosestPoint
</returns>
            <remarks>
This function is not efficient if you will be finding multiple closest points
to the same bezier. To efficiently find multiple closest points, make a surface
tree and use it. See the ON_BezierSurface::GetClosestPoint code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>
Get the parameters of the point on the bezier surface that is closest to the point P.
</summary>
            <param name="P">[in]</param>
            <param name="s">[out]</param>
            <param name="t">[out]</param>
            <param name="maximum_distance">
[in] If maximum_distance &gt; 0.0, then an answer is returned only if the distance
from the bezier surface to P is &lt;= maximum_distance. If maximum_distance &lt;= 0.0,
then maximum_distance is ignored.
</param>
            <param name="sub_domain0">
[in] If not NULL, the search is confined to "s" parameters in the
intersection of the sub_domain0 interval and (0,1).
</param>
            <returns>
True if a point is found.
See Also: ON_SurfaceTreeNode::GetClosestPoint
</returns>
            <remarks>
This function is not efficient if you will be finding multiple closest points
to the same bezier. To efficiently find multiple closest points, make a surface
tree and use it. See the ON_BezierSurface::GetClosestPoint code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>
Get the parameters of the point on the bezier surface that is closest to the point P.
</summary>
            <param name="P">[in]</param>
            <param name="s">[out]</param>
            <param name="t">[out]</param>
            <param name="maximum_distance">
[in] If maximum_distance &gt; 0.0, then an answer is returned only if the distance
from the bezier surface to P is &lt;= maximum_distance. If maximum_distance &lt;= 0.0,
then maximum_distance is ignored.
</param>
            <param name="sub_domain0">
[in] If not NULL, the search is confined to "s" parameters in the
intersection of the sub_domain0 interval and (0,1).
</param>
            <param name="sub_domain1">
[in] If not NULL, the search is confined to "t" parameters in the
intersection of the sub_domain1 interval and (0,1).
</param>
            <returns>
True if a point is found.
See Also: ON_SurfaceTreeNode::GetClosestPoint
</returns>
            <remarks>
This function is not efficient if you will be finding multiple closest points
to the same bezier. To efficiently find multiple closest points, make a surface
tree and use it. See the ON_BezierSurface::GetClosestPoint code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.ReserveCVCapacity(System.Int32)">
            <param name="arg1">number of doubles to reserve</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.IsSingular(System.Int32)">
            <summary>
TRUE if surface side is collapsed to a point
</summary>
            <param name="side">
side of parameter space to test
0 = south, 1 = east, 2 = north, 3 = west
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.IsoCurve(System.Int32,System.Double)">
            <summary>returns the isocurve.</summary>
            <param name="dir">
0 first parameter varies and second parameter is constant
  e.g., point on IsoCurve(0,c) at t is srf(t,c)
1 first parameter is constant and second parameter varies
  e.g., point on IsoCurve(1,c) at t is srf(c,t)
</param>
            <param name="c">value of constant parameter</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.IsoCurve(System.Int32,System.Double,RMA.OpenNURBS.OnBezierCurve)">
            <summary>returns the isocurve.</summary>
            <param name="dir">
0 first parameter varies and second parameter is constant
  e.g., point on IsoCurve(0,c) at t is srf(t,c)
1 first parameter is constant and second parameter varies
  e.g., point on IsoCurve(1,c) at t is srf(c,t)
</param>
            <param name="c">value of constant parameter</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.Split(System.Int32,System.Double,RMA.OpenNURBS.OnBezierSurface@,RMA.OpenNURBS.OnBezierSurface@)">
            <param name="arg1">0 split at "u"=t, 1= split at "v"=t</param>
            <param name="t">splitting parameter must 0 &lt; t &lt; 1</param>
            <param name="arg3">west/south side returned here (can pass *this)</param>
            <param name="arg4">east/north side returned here (can pass *this)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.ZeroCVs">
            <summary>
zeros control vertices and, if rational, sets weights to 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.GetCV(System.Int32,System.Int32,RMA.OpenNURBS.On4dPoint@)">
            <summary>
get a single control vertex
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.GetCV(System.Int32,System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>
get a single control vertex
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.SetCV(System.Int32,System.Int32,RMA.OpenNURBS.IOn4dPoint)">
            <summary>
set a single control vertex
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.SetCV(System.Int32,System.Int32,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
set a single control vertex
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.SetWeight(System.Int32,System.Int32,System.Double)">
            <summary>
get value of control vertex weight
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.Weight(System.Int32,System.Int32)">
            <summary>
get value of control vertex weight
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.CVStyle">
            <summary>
Description: Expert user function to get a pointer to control vertex memory. If you are not an expert user, please use ON_BezierSurface::GetCV( ON_3dPoint&amp; ) or ON_BezierSurface::GetCV( ON_4dPoint&amp; ). Parameters: cv_index0 - [in] (0 &lt;= cv_index0 &lt; m_order[0]) cv_index1 - [in] (0 &lt;= cv_index1 &lt; m_order[1]) Returns: Pointer to control vertex. Remarks: If the Bezier surface is rational, the format of the returned array is a homogeneos rational point with length m_dim+1. If the Bezier surface is not rational, the format of the returned array is a nonrational euclidean point with length m_dim. See Also ON_BezierSurface::CVStyle ON_BezierSurface::GetCV ON_BezierSurface::Weight
</summary>
            <summary>Returns the style of control vertices in the m_cv array.</summary>
            <returns>
ON::not_rational m_is_rat is FALSE
ON::homogeneous_rational m_is_rat is TRUE
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.Degree(System.Int32)">
            <summary>
degree = order - 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.Order(System.Int32)">
            <summary>
order = degree + 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.CVSize">
            <summary>
number of doubles per control vertex
= IsRational() ? Dim()+1 : Dim()
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.IsRational">
            <summary>
TRUE if NURBS curve is rational
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.Transpose">
            <summary>
transpose surface parameterization (swap "s" and "t")
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.Reverse(System.Int32)">
            <summary>
reverse parameterizatrion
Domain changes from [a,b] to [-b,-a]
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.Domain(System.Int32)">
            <param name="arg1">0 = "u" domain, 1 = "v" domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.Scale(System.Double)">
            <summary>
Scales the bezier surface by the specified facotor.  The scale is
centered at the origin.
</summary>
            <param name="scale_factor">[in] scale factor</param>
            <returns>TRUE if bezier surface successfully scaled</returns>
            <remarks>Uses ON_BezierSurface::Transform() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.Translate(RMA.OpenNURBS.IOn3dVector)">
            <summary>Translates the bezier surface along the specified vector.</summary>
            <param name="translation_vector">[in] translation vector</param>
            <returns>TRUE if bezier surface successfully translated</returns>
            <remarks>Uses ON_BezierSurface::Transform() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.Rotate(System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Rotates the bezier surface about the specified axis.  A positive
rotation angle results in a counter-clockwise rotation
about the axis (right hand rule).
</summary>
            <param name="rotation_angle">[in] angle of rotation in radians</param>
            <param name="rotation_axis">[in] direction of the axis of rotation</param>
            <param name="rotation_center">[in] point on the axis of rotation</param>
            <returns>TRUE if bezier surface successfully rotated</returns>
            <remarks>Uses ON_BezierSurface::Transform() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Rotates the bezier surface about the specified axis.  A positive
rotation angle results in a counter-clockwise rotation
about the axis (right hand rule).
</summary>
            <param name="sin_angle">[in] sine of rotation angle</param>
            <param name="cos_angle">[in] sine of rotation angle</param>
            <param name="rotation_axis">[in] direction of the axis of rotation</param>
            <param name="rotation_center">[in] point on the axis of rotation</param>
            <returns>TRUE if bezier surface successfully rotated</returns>
            <remarks>Uses ON_BezierSurface::Transform() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.Loft(RMA.OpenNURBS.IOnBezierCurve[])">
            <summary>Loft a bezier surface through a list of bezier curves.</summary>
            <param name="curve_list">[in] list of curves that have the same degree.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.EmergencyDestroy">
            <summary>
call if memory used by ON_NurbsCurve becomes invalid
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.Dump(RMA.OpenNURBS.OnTextLog@)">
            <summary>
for debugging
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBezierSurface.m_cv_capacity">
            <value>
if 0, then destructor does not free m_cv
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBezierSurface.m_order(System.Int32)">
            <value>
order = degree+1 &gt;= 2
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBezierSurface.m_is_rat">
            <value>
0 = no, 1 = yes
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBezierSurface.m_dim">
            <value>
&gt;= 1
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double,System.Double@,System.Double@)">
            <summary>
Get the parameter of the point on the bezier surface that is locally closest to
the point P when the search begins at (s_seed,t_seed).
</summary>
            <param name="P">[in]</param>
            <param name="s_seed">[in]Parameters where the search begins. </param>
            <param name="t_seed">[in]Parameters where the search begins. </param>
            <param name="s">[out] Closest point parameter</param>
            <param name="t">[out] Closest point parameter</param>
            <returns>True if a point is found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval)">
            <summary>
Get the parameter of the point on the bezier surface that is locally closest to
the point P when the search begins at (s_seed,t_seed).
</summary>
            <param name="P">[in]</param>
            <param name="s_seed">[in]Parameters where the search begins. </param>
            <param name="t_seed">[in]Parameters where the search begins. </param>
            <param name="s">[out] Closest point parameter</param>
            <param name="t">[out] Closest point parameter</param>
            <param name="sub_domain0">
[in] If not NULL, the search is confined to "s" parameters
in the intersection of the sub_domain0 interval and (0,1).
</param>
            <returns>True if a point is found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>
Get the parameter of the point on the bezier surface that is locally closest to
the point P when the search begins at (s_seed,t_seed).
</summary>
            <param name="P">[in]</param>
            <param name="s_seed">[in]Parameters where the search begins. </param>
            <param name="t_seed">[in]Parameters where the search begins. </param>
            <param name="s">[out] Closest point parameter</param>
            <param name="t">[out] Closest point parameter</param>
            <param name="sub_domain0">
[in] If not NULL, the search is confined to "s" parameters
in the intersection of the sub_domain0 interval and (0,1).
</param>
            <param name="sub_domain1">
[in] If not NULL, the search is confined to "t" parameters
in the intersection of the sub_domain1 interval and (0,1).
</param>
            <returns>True if a point is found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@)">
            <summary>
Get the parameters of the point on the bezier surface that is closest to the point P.
</summary>
            <param name="P">[in]</param>
            <param name="s">[out]</param>
            <param name="t">[out]</param>
            <returns>
True if a point is found.
See Also: ON_SurfaceTreeNode::GetClosestPoint
</returns>
            <remarks>
This function is not efficient if you will be finding multiple closest points
to the same bezier. To efficiently find multiple closest points, make a surface
tree and use it. See the ON_BezierSurface::GetClosestPoint code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@,System.Double)">
            <summary>
Get the parameters of the point on the bezier surface that is closest to the point P.
</summary>
            <param name="P">[in]</param>
            <param name="s">[out]</param>
            <param name="t">[out]</param>
            <param name="maximum_distance">
[in] If maximum_distance &gt; 0.0, then an answer is returned only if the distance
from the bezier surface to P is &lt;= maximum_distance. If maximum_distance &lt;= 0.0,
then maximum_distance is ignored.
</param>
            <returns>
True if a point is found.
See Also: ON_SurfaceTreeNode::GetClosestPoint
</returns>
            <remarks>
This function is not efficient if you will be finding multiple closest points
to the same bezier. To efficiently find multiple closest points, make a surface
tree and use it. See the ON_BezierSurface::GetClosestPoint code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>
Get the parameters of the point on the bezier surface that is closest to the point P.
</summary>
            <param name="P">[in]</param>
            <param name="s">[out]</param>
            <param name="t">[out]</param>
            <param name="maximum_distance">
[in] If maximum_distance &gt; 0.0, then an answer is returned only if the distance
from the bezier surface to P is &lt;= maximum_distance. If maximum_distance &lt;= 0.0,
then maximum_distance is ignored.
</param>
            <param name="sub_domain0">
[in] If not NULL, the search is confined to "s" parameters in the
intersection of the sub_domain0 interval and (0,1).
</param>
            <returns>
True if a point is found.
See Also: ON_SurfaceTreeNode::GetClosestPoint
</returns>
            <remarks>
This function is not efficient if you will be finding multiple closest points
to the same bezier. To efficiently find multiple closest points, make a surface
tree and use it. See the ON_BezierSurface::GetClosestPoint code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>
Get the parameters of the point on the bezier surface that is closest to the point P.
</summary>
            <param name="P">[in]</param>
            <param name="s">[out]</param>
            <param name="t">[out]</param>
            <param name="maximum_distance">
[in] If maximum_distance &gt; 0.0, then an answer is returned only if the distance
from the bezier surface to P is &lt;= maximum_distance. If maximum_distance &lt;= 0.0,
then maximum_distance is ignored.
</param>
            <param name="sub_domain0">
[in] If not NULL, the search is confined to "s" parameters in the
intersection of the sub_domain0 interval and (0,1).
</param>
            <param name="sub_domain1">
[in] If not NULL, the search is confined to "t" parameters in the
intersection of the sub_domain1 interval and (0,1).
</param>
            <returns>
True if a point is found.
See Also: ON_SurfaceTreeNode::GetClosestPoint
</returns>
            <remarks>
This function is not efficient if you will be finding multiple closest points
to the same bezier. To efficiently find multiple closest points, make a surface
tree and use it. See the ON_BezierSurface::GetClosestPoint code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.IsSingular(System.Int32)">
            <summary>
TRUE if surface side is collapsed to a point
</summary>
            <param name="side">
side of parameter space to test
0 = south, 1 = east, 2 = north, 3 = west
</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.IsoCurve(System.Int32,System.Double)">
            <summary>returns the isocurve.</summary>
            <param name="dir">
0 first parameter varies and second parameter is constant
  e.g., point on IsoCurve(0,c) at t is srf(t,c)
1 first parameter is constant and second parameter varies
  e.g., point on IsoCurve(1,c) at t is srf(c,t)
</param>
            <param name="c">value of constant parameter</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.IsoCurve(System.Int32,System.Double,RMA.OpenNURBS.OnBezierCurve)">
            <summary>returns the isocurve.</summary>
            <param name="dir">
0 first parameter varies and second parameter is constant
  e.g., point on IsoCurve(0,c) at t is srf(t,c)
1 first parameter is constant and second parameter varies
  e.g., point on IsoCurve(1,c) at t is srf(c,t)
</param>
            <param name="c">value of constant parameter</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.Split(System.Int32,System.Double,RMA.OpenNURBS.OnBezierSurface@,RMA.OpenNURBS.OnBezierSurface@)">
            <param name="arg1">0 split at "u"=t, 1= split at "v"=t</param>
            <param name="t">splitting parameter must 0 &lt; t &lt; 1</param>
            <param name="arg3">west/south side returned here (can pass *this)</param>
            <param name="arg4">east/north side returned here (can pass *this)</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.GetCV(System.Int32,System.Int32,RMA.OpenNURBS.On4dPoint@)">
            <summary>
get a single control vertex
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.GetCV(System.Int32,System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>
get a single control vertex
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.Weight(System.Int32,System.Int32)">
            <summary>
get value of control vertex weight
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.CVStyle">
            <summary>
Description: Expert user function to get a pointer to control vertex memory. If you are not an expert user, please use ON_BezierSurface::GetCV( ON_3dPoint&amp; ) or ON_BezierSurface::GetCV( ON_4dPoint&amp; ). Parameters: cv_index0 - [in] (0 &lt;= cv_index0 &lt; m_order[0]) cv_index1 - [in] (0 &lt;= cv_index1 &lt; m_order[1]) Returns: Pointer to control vertex. Remarks: If the Bezier surface is rational, the format of the returned array is a homogeneos rational point with length m_dim+1. If the Bezier surface is not rational, the format of the returned array is a nonrational euclidean point with length m_dim. See Also ON_BezierSurface::CVStyle ON_BezierSurface::GetCV ON_BezierSurface::Weight
</summary>
            <summary>Returns the style of control vertices in the m_cv array.</summary>
            <returns>
ON::not_rational m_is_rat is FALSE
ON::homogeneous_rational m_is_rat is TRUE
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.Degree(System.Int32)">
            <summary>
degree = order - 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.Order(System.Int32)">
            <summary>
order = degree + 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.CVSize">
            <summary>
number of doubles per control vertex
= IsRational() ? Dim()+1 : Dim()
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.IsRational">
            <summary>
TRUE if NURBS curve is rational
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.Domain(System.Int32)">
            <param name="arg1">0 = "u" domain, 1 = "v" domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.Dump(RMA.OpenNURBS.OnTextLog@)">
            <summary>
for debugging
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBezierSurface.m_cv_capacity">
            <value>
if 0, then destructor does not free m_cv
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBezierSurface.m_order(System.Int32)">
            <value>
order = degree+1 &gt;= 2
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBezierSurface.m_is_rat">
            <value>
0 = no, 1 = yes
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBezierSurface.m_dim">
            <value>
&gt;= 1
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveTreeBezier.SetLeafBox">
            <summary>
Description: Sets m_leafbox to be the smallest curve leaf box that contains this bezier curve. Returns: True if this bezier is valid and the leaf box is set.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveTreeBezier.SetBezier(RMA.OpenNURBS.IOnBezierCurve)">
            <summary>
Description: Quickly determine if the shortest distance from the bezier surface to this bezier curve is greater than d. Parameters: d - [in] distance (&gt; 0.0) other - [in] Returns: True if the shortest distance from the other bezier to this bezier curve is greater than d. It is not the case that false means that the shortest distance is less than or equal to d.
</summary>
            <summary>
Description: Sets the bezier curve and its leaf box. Parameters: bezier_curve - [in] Returns: True if bezier_curve is valid. See Also: ON_CurveTreeBezier::SetLeafBox
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveTreeBezier.MaximumDistanceTo(RMA.OpenNURBS.IOnCurveTreeBezier)">
            <summary>
Description: Quickly find an upper bound on the distance between the two bezier curves. Parameters: other - [in] another bezier curve Returns: A distance that is greater than or equal to the longest distance from this curve to the other curve. Put another way, if Q is any point on this bezier curve and P is any point on the other bezier curve, then then P.DistanceTo(Q) &lt;= MaximumDistanceTo(other).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveTreeBezier.MinimumDistanceTo(RMA.OpenNURBS.IOnCurveTreeBezier)">
            <summary>
Description: Quickly find a lower bound on the distance between the two bezier curves. Parameters: other - [in] another bezier curve Returns: A distance that is less than or equal to the shortest distance from this curve to the other curve. Put another way, if Q is any point on this bezier curve and P is any point on the other bezier curve, then then P.DistanceTo(Q) &gt;= MinimumDistanceTo(other).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveTreeBezier.#ctor(RMA.OpenNURBS.IOnBezierCurve)">
            <summary>
Description: Copy constructs the bezier_curve and then sets the leaf box.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveTreeBezier.#ctor">
            <summary>
C++ defaults for destruction,
copy construction, and operator= work fine.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurveTreeBezier.MaximumDistanceTo(RMA.OpenNURBS.IOnCurveTreeBezier)">
            <summary>
Description: Quickly find an upper bound on the distance between the two bezier curves. Parameters: other - [in] another bezier curve Returns: A distance that is greater than or equal to the longest distance from this curve to the other curve. Put another way, if Q is any point on this bezier curve and P is any point on the other bezier curve, then then P.DistanceTo(Q) &lt;= MaximumDistanceTo(other).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurveTreeBezier.MinimumDistanceTo(RMA.OpenNURBS.IOnCurveTreeBezier)">
            <summary>
Description: Quickly find a lower bound on the distance between the two bezier curves. Parameters: other - [in] another bezier curve Returns: A distance that is less than or equal to the shortest distance from this curve to the other curve. Put another way, if Q is any point on this bezier curve and P is any point on the other bezier curve, then then P.DistanceTo(Q) &gt;= MinimumDistanceTo(other).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveLeafBox.IsPointIn(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Determine if the point P is in this curve leaf box. Parameters: P - [in] Returns: True if the point is in the curve leaf box.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveLeafBox.Radius">
            <summary>
Description: "Radius" of the curve leaf box. A point is in the leaf box if the shortest distance from the point to the chord m_M is &lt;= "radius". Returns: Radius of the leaf box.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveLeafBox.PointAt(System.Double)">
            <summary>
Description: Point on the chord connecting the bezier's endpoints. Parameters: t - [in] 0.0 &lt; t &lt; 1.0 Returns: m_L.PointAt(t)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveLeafBox.IsFartherThan(System.Double,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Quickly determine if the shortest distance between this leaf box and the other object is greater than d. Parameters: d - [in] distance (&gt; 0.0) P - [in] another point bbox - [in] another axis aligned bounding box crvleafbox - [in] another curve tree node leaf box srfleafbox - [in] another surface tree node leaf box Returns: True if the shortest distance from this leaf box to the other object is greater than d. It is not the case that false means that the shortest distance is less than or equal to d.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveLeafBox.MaximumDistanceTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Quickly find an upper bound on the longest distance between the this leaf box and the other object. Parameters: P - [in] another point line - [in] another line segment bbox - [in] another axis aligned bounding box crvleafbox - [in] crvleafbox - [in] Returns: A distance that is greater than or equal to the longest distance from this leaf box to the other object. Put another way, if Q is any point on this leaf box and P is any point on the other object, then P.DistanceTo(Q) &lt;= MaximumDistanceTo(other).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveLeafBox.MinimumDistanceTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Quickly find a lower bound on the distance between the this leaf box and the other object. Parameters: P - [in] another point bbox - [in] another axis aligned bounding box crvleafbox - [in] another curve tree node leaf box srfleafbox - [in] another surface tree node leaf box Returns: A distance that is less than or equal to the shortest distance from this leaf box to the other object. Put another way, if Q is any point on this leaf box and P is any point on the other object, then then P.DistanceTo(Q) &gt;= MinimumDistanceTo(other).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveLeafBox.IsValid(RMA.OpenNURBS.OnTextLog)">
            <summary>
Description: Test the leaf box to make sure its settings are valid. Parameters: text_log - [in] If an error is found and text_log is not null, then a short description of the problem is printed to the text_log. Returns: True if the leaf box is valid, and false otherwise.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnCurveLeafBox.m_bRes">
            <value>
NEVER set or reference this value
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnCurveLeafBox.m_bDegen">
            <value>
True if C is yukky
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnCurveLeafBox.m_bMono">
            <value>
True if m_L.Tangent()oC' &gt;= 0 for every point on C
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnCurveLeafBox.m_bValid">
            <value>
True if the curve leaf box is set
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnCurveLeafBox.m_r">
            <value>
The maximum distance from C to m_M.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnCurveLeafBox.m_e0">
            <value>
If P is a point on the curve, then m_e0 &lt;= m_e.ValueAt(P) &lt;= m_e1
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnCurveLeafBox.m_e">
            <value>
equation of a plane perpindicular to m_L and containing m_L.from
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnCurveLeafBox.m_M">
            <value>
smallest chord that contains m_L and such that
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnCurveLeafBox.m_L">
            <value>
chord from start of C to end of C
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurveLeafBox.IsPointIn(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Determine if the point P is in this curve leaf box. Parameters: P - [in] Returns: True if the point is in the curve leaf box.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurveLeafBox.Radius">
            <summary>
Description: "Radius" of the curve leaf box. A point is in the leaf box if the shortest distance from the point to the chord m_M is &lt;= "radius". Returns: Radius of the leaf box.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurveLeafBox.PointAt(System.Double)">
            <summary>
Description: Point on the chord connecting the bezier's endpoints. Parameters: t - [in] 0.0 &lt; t &lt; 1.0 Returns: m_L.PointAt(t)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurveLeafBox.IsFartherThan(System.Double,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Quickly determine if the shortest distance between this leaf box and the other object is greater than d. Parameters: d - [in] distance (&gt; 0.0) P - [in] another point bbox - [in] another axis aligned bounding box crvleafbox - [in] another curve tree node leaf box srfleafbox - [in] another surface tree node leaf box Returns: True if the shortest distance from this leaf box to the other object is greater than d. It is not the case that false means that the shortest distance is less than or equal to d.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurveLeafBox.MaximumDistanceTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Quickly find an upper bound on the longest distance between the this leaf box and the other object. Parameters: P - [in] another point line - [in] another line segment bbox - [in] another axis aligned bounding box crvleafbox - [in] crvleafbox - [in] Returns: A distance that is greater than or equal to the longest distance from this leaf box to the other object. Put another way, if Q is any point on this leaf box and P is any point on the other object, then P.DistanceTo(Q) &lt;= MaximumDistanceTo(other).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurveLeafBox.MinimumDistanceTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Quickly find a lower bound on the distance between the this leaf box and the other object. Parameters: P - [in] another point bbox - [in] another axis aligned bounding box crvleafbox - [in] another curve tree node leaf box srfleafbox - [in] another surface tree node leaf box Returns: A distance that is less than or equal to the shortest distance from this leaf box to the other object. Put another way, if Q is any point on this leaf box and P is any point on the other object, then then P.DistanceTo(Q) &gt;= MinimumDistanceTo(other).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurveLeafBox.IsValid(RMA.OpenNURBS.OnTextLog)">
            <summary>
Description: Test the leaf box to make sure its settings are valid. Parameters: text_log - [in] If an error is found and text_log is not null, then a short description of the problem is printed to the text_log. Returns: True if the leaf box is valid, and false otherwise.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnCurveLeafBox.m_bRes">
            <value>
NEVER set or reference this value
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnCurveLeafBox.m_bDegen">
            <value>
True if C is yukky
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnCurveLeafBox.m_bMono">
            <value>
True if m_L.Tangent()oC' &gt;= 0 for every point on C
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnCurveLeafBox.m_bValid">
            <value>
True if the curve leaf box is set
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnCurveLeafBox.m_r">
            <value>
The maximum distance from C to m_M.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnCurveLeafBox.m_e0">
            <value>
If P is a point on the curve, then m_e0 &lt;= m_e.ValueAt(P) &lt;= m_e1
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnCurveLeafBox.m_e">
            <value>
equation of a plane perpindicular to m_L and containing m_L.from
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnCurveLeafBox.m_M">
            <value>
smallest chord that contains m_L and such that
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnCurveLeafBox.m_L">
            <value>
chord from start of C to end of C
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.IntersectSurface(RMA.OpenNURBS.IOnBezierSurface,RMA.OpenNURBS.ArrayOnX_EVENT@)">
            <summary>Intersect this bezier curve with bezsrfB.</summary>
            <param name="bezsrfB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve and surface
trees and intersect them. See the IntersectBezierSurface code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.IntersectSurface(RMA.OpenNURBS.IOnBezierSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double)">
            <summary>Intersect this bezier curve with bezsrfB.</summary>
            <param name="bezsrfB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve and surface
trees and intersect them. See the IntersectBezierSurface code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.IntersectSurface(RMA.OpenNURBS.IOnBezierSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double)">
            <summary>Intersect this bezier curve with bezsrfB.</summary>
            <param name="bezsrfB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and the distance from
curve(t) to the surface is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then
the event will be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0, 
then intersection_tolerance*2.0 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve and surface
trees and intersect them. See the IntersectBezierSurface code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.IntersectSurface(RMA.OpenNURBS.IOnBezierSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this bezier curve with bezsrfB.</summary>
            <param name="bezsrfB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and the distance from
curve(t) to the surface is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then
the event will be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0, 
then intersection_tolerance*2.0 is used.
</param>
            <param name="bezierA_domain">[in] optional restriction on this curve's domain</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve and surface
trees and intersect them. See the IntersectBezierSurface code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.IntersectSurface(RMA.OpenNURBS.IOnBezierSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this bezier curve with bezsrfB.</summary>
            <param name="bezsrfB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and the distance from
curve(t) to the surface is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then
the event will be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0, 
then intersection_tolerance*2.0 is used.
</param>
            <param name="bezierA_domain">[in] optional restriction on this curve's domain</param>
            <param name="bezsrfB_udomain">[in] optional restriction on surfaceB u domain</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve and surface
trees and intersect them. See the IntersectBezierSurface code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.IntersectSurface(RMA.OpenNURBS.IOnBezierSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this bezier curve with bezsrfB.</summary>
            <param name="bezsrfB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and the distance from
curve(t) to the surface is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then
the event will be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0, 
then intersection_tolerance*2.0 is used.
</param>
            <param name="bezierA_domain">[in] optional restriction on this curve's domain</param>
            <param name="bezsrfB_udomain">[in] optional restriction on surfaceB u domain</param>
            <param name="bezsrfB_vdomain">[in] optional restriction on surfaceB v domain</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve and surface
trees and intersect them. See the IntersectBezierSurface code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetLocalSurfaceIntersection(RMA.OpenNURBS.IOnBezierSurface,System.Double,System.Double,System.Double,System.Double@,System.Double@,System.Double@)">
            <summary>Get a local curve-surface intersection point.</summary>
            <param name="bezsrf">[in]</param>
            <param name="seed_t">[in] curve paramter</param>
            <param name="seed_u">[in] surface parameter</param>
            <param name="seed_v">[in] surface parameter</param>
            <param name="t">[out] curve paramter</param>
            <param name="u">[out] surface parameter</param>
            <param name="v">[out] surface parameter</param>
            <returns>True if something is returned in (t,u,v). Check answer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetLocalSurfaceIntersection(RMA.OpenNURBS.IOnBezierSurface,System.Double,System.Double,System.Double,System.Double@,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a local curve-surface intersection point.</summary>
            <param name="bezsrf">[in]</param>
            <param name="seed_t">[in] curve paramter</param>
            <param name="seed_u">[in] surface parameter</param>
            <param name="seed_v">[in] surface parameter</param>
            <param name="t">[out] curve paramter</param>
            <param name="u">[out] surface parameter</param>
            <param name="v">[out] surface parameter</param>
            <param name="tdomain">[in] optional curve domain restriction</param>
            <returns>True if something is returned in (t,u,v). Check answer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetLocalSurfaceIntersection(RMA.OpenNURBS.IOnBezierSurface,System.Double,System.Double,System.Double,System.Double@,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a local curve-surface intersection point.</summary>
            <param name="bezsrf">[in]</param>
            <param name="seed_t">[in] curve paramter</param>
            <param name="seed_u">[in] surface parameter</param>
            <param name="seed_v">[in] surface parameter</param>
            <param name="t">[out] curve paramter</param>
            <param name="u">[out] surface parameter</param>
            <param name="v">[out] surface parameter</param>
            <param name="tdomain">[in] optional curve domain restriction</param>
            <param name="udomain">[in] optional surface domain restriction</param>
            <returns>True if something is returned in (t,u,v). Check answer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetLocalSurfaceIntersection(RMA.OpenNURBS.IOnBezierSurface,System.Double,System.Double,System.Double,System.Double@,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a local curve-surface intersection point.</summary>
            <param name="bezsrf">[in]</param>
            <param name="seed_t">[in] curve paramter</param>
            <param name="seed_u">[in] surface parameter</param>
            <param name="seed_v">[in] surface parameter</param>
            <param name="t">[out] curve paramter</param>
            <param name="u">[out] surface parameter</param>
            <param name="v">[out] surface parameter</param>
            <param name="tdomain">[in] optional curve domain restriction</param>
            <param name="udomain">[in] optional surface domain restriction</param>
            <param name="vdomain">[in] optional surface domain restriction</param>
            <returns>True if something is returned in (t,u,v). Check answer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.IntersectCurve(RMA.OpenNURBS.IOnBezierCurve,RMA.OpenNURBS.ArrayOnX_EVENT@)">
            <summary>Intersect this bezier with bezierB.</summary>
            <param name="bezierB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve trees
and intersect them. See the IntersectBezierCurve code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.IntersectCurve(RMA.OpenNURBS.IOnBezierCurve,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double)">
            <summary>Intersect this bezier with bezierB.</summary>
            <param name="bezierB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to curveB is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve trees
and intersect them. See the IntersectBezierCurve code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.IntersectCurve(RMA.OpenNURBS.IOnBezierCurve,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double)">
            <summary>Intersect this bezier with bezierB.</summary>
            <param name="bezierB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to curveB is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are parameters of this curve's intersection events and the distance
from curve(t) to curveB is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then the
event will be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0, then
intersection_tolerance*2.0 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve trees
and intersect them. See the IntersectBezierCurve code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.IntersectCurve(RMA.OpenNURBS.IOnBezierCurve,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this bezier with bezierB.</summary>
            <param name="bezierB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to curveB is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are parameters of this curve's intersection events and the distance
from curve(t) to curveB is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then the
event will be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0, then
intersection_tolerance*2.0 is used.
</param>
            <param name="bezierA_domain">[in] optional restriction on this bezier's domain</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve trees
and intersect them. See the IntersectBezierCurve code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.IntersectCurve(RMA.OpenNURBS.IOnBezierCurve,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this bezier with bezierB.</summary>
            <param name="bezierB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to curveB is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are parameters of this curve's intersection events and the distance
from curve(t) to curveB is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then the
event will be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0, then
intersection_tolerance*2.0 is used.
</param>
            <param name="bezierA_domain">[in] optional restriction on this bezier's domain</param>
            <param name="bezierB_domain">[in] optional restriction on bezierB domain</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve trees
and intersect them. See the IntersectBezierCurve code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.IntersectSelf(RMA.OpenNURBS.ArrayOnX_EVENT@)">
            <summary>Find bezier self intersection points.</summary>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.IntersectSelf(RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double)">
            <summary>Find bezier self intersection points.</summary>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">[in]</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetLocalCurveIntersection(RMA.OpenNURBS.IOnBezierCurve,System.Double,System.Double,System.Double@,System.Double@)">
            <summary>Get a local curve-curve intersection point.</summary>
            <param name="other_bezcrv">[in] other curve</param>
            <param name="this_seed_t">[in] this curve seed paramter</param>
            <param name="other_seed_t">[in] other curve seed paramter</param>
            <param name="this_t">[out] this curve paramter</param>
            <param name="other_t">[out] other curve paramter</param>
            <returns>True if something is returned in (t,u,v). Check answer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetLocalCurveIntersection(RMA.OpenNURBS.IOnBezierCurve,System.Double,System.Double,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a local curve-curve intersection point.</summary>
            <param name="other_bezcrv">[in] other curve</param>
            <param name="this_seed_t">[in] this curve seed paramter</param>
            <param name="other_seed_t">[in] other curve seed paramter</param>
            <param name="this_t">[out] this curve paramter</param>
            <param name="other_t">[out] other curve paramter</param>
            <param name="this_domain">[in] optional this curve domain restriction</param>
            <returns>True if something is returned in (t,u,v). Check answer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetLocalCurveIntersection(RMA.OpenNURBS.IOnBezierCurve,System.Double,System.Double,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a local curve-curve intersection point.</summary>
            <param name="other_bezcrv">[in] other curve</param>
            <param name="this_seed_t">[in] this curve seed paramter</param>
            <param name="other_seed_t">[in] other curve seed paramter</param>
            <param name="this_t">[out] this curve paramter</param>
            <param name="other_t">[out] other curve paramter</param>
            <param name="this_domain">[in] optional this curve domain restriction</param>
            <param name="other_domain">[in] optional other curve domain restriction</param>
            <returns>True if something is returned in (t,u,v). Check answer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double@)">
            <summary>
Get the parameter of the point on the bezier curve that is locally closest
to the point P when the search begins at seed_parameter.
</summary>
            <param name="P">[in]</param>
            <param name="seed_parameter">[in] Parameter where the search begins.</param>
            <param name="t">[out] Closest point parameter.</param>
            <returns>True if a point is found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double@,RMA.OpenNURBS.IOnInterval)">
            <summary>
Get the parameter of the point on the bezier curve that is locally closest
to the point P when the search begins at seed_parameter.
</summary>
            <param name="P">[in]</param>
            <param name="seed_parameter">[in] Parameter where the search begins.</param>
            <param name="t">[out] Closest point parameter.</param>
            <param name="sub_domain">
[in] If not NULL, the search is confined to the intersection of the sub_domain interval and (0,1).
</param>
            <returns>True if a point is found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>
Get the parameter of the point on the bezier curve that is closest to the point P.
</summary>
            <param name="P">[in]</param>
            <param name="t">[out] Closest point parameter.</param>
            <returns>
True if a point is found.
See Also: ON_CurveTreeNode::GetClosestPoint
</returns>
            <remarks>
This function is not efficient if you will be finding multiple closest points to
the same bezier. To efficiently find multiple closest points, make a curve tree
and use it.
See the ON_BezierCurve::GetClosestPoint code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double)">
            <summary>
Get the parameter of the point on the bezier curve that is closest to the point P.
</summary>
            <param name="P">[in]</param>
            <param name="t">[out] Closest point parameter.</param>
            <param name="maximum_distance">
[in] If maximum_distance &gt; 0.0, then an answer is returned only if the distance
then maximum_distance is ignored.
</param>
            <returns>
True if a point is found.
See Also: ON_CurveTreeNode::GetClosestPoint
</returns>
            <remarks>
This function is not efficient if you will be finding multiple closest points to
the same bezier. To efficiently find multiple closest points, make a curve tree
and use it.
See the ON_BezierCurve::GetClosestPoint code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>
Get the parameter of the point on the bezier curve that is closest to the point P.
</summary>
            <param name="P">[in]</param>
            <param name="t">[out] Closest point parameter.</param>
            <param name="maximum_distance">
[in] If maximum_distance &gt; 0.0, then an answer is returned only if the distance
then maximum_distance is ignored.
</param>
            <param name="sub_domain">
[in] If not NULL, the search is confined to the intersection of the sub_domain interval and (0,1).
</param>
            <returns>
True if a point is found.
See Also: ON_CurveTreeNode::GetClosestPoint
</returns>
            <remarks>
This function is not efficient if you will be finding multiple closest points to
the same bezier. To efficiently find multiple closest points, make a curve tree
and use it.
See the ON_BezierCurve::GetClosestPoint code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.ChangeWeights(System.Int32,System.Double,System.Int32,System.Double)">
            <summary>
Use a combination of scaling and reparametrization to set two rational Bezier weights to specified values.
</summary>
            <param name="i0">[in] control point index (0 &lt;= i0 &lt; order, i0 != i1)</param>
            <param name="w0">[in] Desired weight for i0-th control point</param>
            <param name="i1">[in] control point index (0 &lt;= i1 &lt; order, i0 != i1)</param>
            <param name="w1">[in] Desired weight for i1-th control point</param>
            <returns>
True if successful. The returned bezier has the same locus but probably has a different parameterization.
</returns>
            <remarks>
The i0-th cv will have weight w0 and the i1-rst cv will have weight w1. If v0 and v1 are 
the cv's input weights, then v0, v1, w0 and w1 must all be nonzero,
and w0*v0 and w1*v1 must have the same sign.

The equations
  s * r^i0 = w0/v0
  s * r^i1 = w1/v1
determine the scaling and reparametrization necessary to change v0,v1 to w0,w1.
If the input Bezier has control vertices (B_0, ..., B_d),
then the output Bezier has control vertices (s*B_0, ... s*r^i * B_i, ..., s*r^d * B_d).
See Also:
 ON_Bezier::Reparameterize
 ON_Bezier::ScaleConrolPoints
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.ScaleConrolPoints(System.Int32,System.Double)">
            <summary>
Scale a rational Bezier's control vertices to set a weight to a specified value.
</summary>
            <param name="i">[in] (0 &lt;= i &lt; order)</param>
            <param name="w">[in] w != 0.0</param>
            <returns>True if successful. The i-th control vertex will have weight w.</returns>
            <remarks>
Each control point is multiplied by w/w0, where w0 is the input value of Weight(i).
See Also: ON_Bezier::Reparameterize ON_Bezier::ChangeWeights
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Reparameterize(System.Double)">
            <summary>
Use a linear fractional tranformation for [0,1] to reparameterize the bezier.
The locus of the curve is not changed, but the parameterization is changed.
</summary>
            <param name="c">
[in] reparameterization constant (generally speaking, c should be &gt; 0).
If c != 1, then the returned bezier will be rational.
</param>
            <returns>true if successful.</returns>
            <remarks>
The reparametrization is performed by composing the input Bezier with
the function lambda: [0,1] -&gt; [0,1] given by
  t -&gt; c*t / ( (c-1)*t + 1 )

Note that lambda(0) = 0, lambda(1) = 1, lambda'(t) &gt; 0,
lambda'(0) = c and lambda'(1) = 1/c.

If the input Bezier has control vertices {B_0, ..., B_d},
then the output Bezier has control vertices
(B_0, ... c^i * B_i, ..., c^d * B_d).

To derive this formula, simply compute the i-th Bernstein
polynomial composed with lambda().

The inverse parametrization is given by 1/c. That is, the cumulative effect of the two calls
Reparameterize(c)
Reparameterize(1.0/c)
is to leave the bezier unchanged.
See Also: ON_Bezier::ScaleConrolPoints
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.ControlPolygonLength">
            <summary>returns the length of the control polygon</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Split(System.Double,RMA.OpenNURBS.OnBezierCurve@,RMA.OpenNURBS.OnBezierCurve@)">
            <summary>
Split() divides the Bezier curve at the specified parameter.
The parameter must satisfy 0 &lt; t &lt; 1.  You may pass *this as
one of the curves to be returned.
</summary>
            <param name="t">[in] (0 &lt; t &lt; 1 ) parameter to split at</param>
            <param name="left_side">[out]</param>
            <param name="right_side">[out]</param>
            <example>
ON_BezierCurve crv = ...;
ON_BezierCurve right_side;
crv.Split( 0.5, crv, right_side );
would split crv at the 1/2, put the left side in crv,
and return the right side in right_side.
</example>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Trim(RMA.OpenNURBS.IOnInterval)">
            <summary>
Trims (or extends) the bezier so the bezier so that the
result starts bezier(interval[0]) and ends at 
bezier(interval[1]) (Evaluation performed on input bezier.)
</summary>
            <example>
An interval of [0,1] leaves the bezier unchanged.  An
interval of [0.5,1] would trim away the left half.  An
interval of [0.0,2.0] would extend the right end.
</example>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.ReserveCVCapacity(System.Int32)">
            <summary>Make sure m_cv array has a certain length.</summary>
            <param name="desired_cv_capacity">[in] minimum length of m_cv array.</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.ChangeDimension(System.Int32)">
            <summary>Change dimension of bezier.</summary>
            <returns>TRUE if successful.  FALSE if desired_dimension &lt;1</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.IncreaseDegree(System.Int32)">
            <summary>Increase degree of bezier.</summary>
            <returns>TRUE if successful.  FALSE if desired_degree &lt; current degree.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.MakeNonRational">
            <summary>
Make beizer not rational by setting all control
vertices to their euclidean locations and setting
m_is_rat to FALSE.
See Also:
ON_Bezier::MakeRational
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.MakeRational">
            <summary>Make beizer rational.</summary>
            <returns>
TRUE if successful.
See Also:
 ON_Bezier::MakeNonRational
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.ZeroCVs">
            <summary>
Zeros control vertices and, if rational, sets weights to 1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetCV(System.Int32,RMA.OpenNURBS.On4dPoint@)">
            <summary>Get value of a control vertex.</summary>
            <param name="cv_index">[in] control vertex index (0 &lt;= cv_index &lt; m_order)</param>
            <param name="point">
[out] Homogenous value of control vertex.
If the bezier is not rational, the weight is 1.
</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetCV(System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>Get location of a control vertex.</summary>
            <param name="cv_index">[in] control vertex index (0 &lt;= cv_index &lt; m_order)</param>
            <param name="point">
[out] Location of control vertex.  If the bezier
is rational, the euclidean location is returned.
</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.SetCV(System.Int32,RMA.OpenNURBS.IOn4dPoint)">
            <summary>Set value of a control vertex.</summary>
            <param name="cv_index">[in] control vertex index (0 &lt;= cv_index &lt; m_order)</param>
            <param name="point">
[in] control vertex value.  If the bezier is not rational,
the euclidean location of homogenoeous point will be used.
</param>
            <returns>TRUE if successful.</returns>
            <remarks>
See Also:
 ON_BezierCurve::CV, ON_BezierCurve::SetCV,
 ON_BezierCurve::SetWeight, ON_BezierCurve::Weight
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.SetCV(System.Int32,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Set location of a control vertex.</summary>
            <param name="cv_index">[in] control vertex index (0 &lt;= cv_index &lt; m_order)</param>
            <param name="point">
[in] control vertex location.  If the bezier is rational, the weight will be set to 1.
</param>
            <returns>TRUE if successful.</returns>
            <remarks>
See Also:
 ON_BezierCurve::CV, ON_BezierCurve::SetCV,
 ON_BezierCurve::SetWeight, ON_BezierCurve::Weight
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.SetWeight(System.Int32,System.Double)">
            <summary>Set weight of a control vertex.</summary>
            <param name="cv_index">[in] control vertex index (0 &lt;= cv_index &lt; m_order)</param>
            <param name="weight">[in] weight</param>
            <returns>
TRUE if the weight can be set.  If weight is not 1 and
the bezier is not rational, then FALSE is returned.
Use ON_BezierCurve::MakeRational to make a bezier curve
rational.
</returns>
            <remarks>
See Also:
  ON_BezierCurve::SetCV, ON_BezierCurve::MakeRational,
  ON_BezierCurve::IsRational, ON_BezierCurve::Weight
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Weight(System.Int32)">
            <param name="cv_index">[in] control vertex index (0&lt;=i&lt;m_order)</param>
            <returns>Weight of the i-th control vertex.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.CVStyle">
            <summary>
Description: Expert user function to get a pointer to control vertex memory. If you are not an expert user, please use ON_BezierCurve::GetCV( ON_3dPoint&amp; ) or ON_BezierCurve::GetCV( ON_4dPoint&amp; ). Parameters: cv_index - [in] (0 &lt;= cv_index &lt; m_order) Returns: Pointer to control vertex. Remarks: If the Bezier curve is rational, the format of the returned array is a homogeneos rational point with length m_dim+1. If the Bezier curve is not rational, the format of the returned array is a nonrational euclidean point with length m_dim. See Also ON_BezierCurve::CVStyle ON_BezierCurve::GetCV ON_BezierCurve::Weight
</summary>
            <summary>Returns the style of control vertices in the m_cv array.</summary>
            <returns>
ON::not_rational m_is_rat is FALSE
ON::homogeneous_rational m_is_rat is TRUE
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Degree">
            <summary>
Degree of the bezier. (degree=order-1)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Order">
            <summary>
Order of the bezier. (order=degree+1)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.CVCount">
            <summary>
Number of control vertices in the bezier.
This is always the same as the order of the bezier.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.CVSize">
            <summary>
Number of doubles per control vertex.
(= IsRational() ? Dim()+1 : Dim())
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.IsRational">
            <summary>TRUE if bezier is rational.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetNurbForm(RMA.OpenNURBS.OnNurbsCurve@)">
            <summary>Get ON_NurbsCurve form of a bezier.</summary>
            <param name="nurbs_curve">
[out] NURBS curve form of a bezier.
The domain is [0,1].
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.EvCurvature(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate unit tangent and curvature at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="tangent">[out] value of unit tangent</param>
            <param name="kappa">[out] value of curvature vector</param>
            <returns>FALSE if unable to evaluate.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.EvTangent(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate unit tangent at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="tangent">[out] value of unit tangent</param>
            <returns>
FALSE if unable to evaluate.
See Also:
ON_Curve::TangentAt
ON_Curve::Ev1Der
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Ev2Der(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate second derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="first_derivative">[out] value of first derivative at t</param>
            <param name="second_derivative">[out] value of second derivative at t</param>
            <returns>FALSE if unable to evaluate.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Ev1Der(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate first derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="first_derivative">[out] value of first derivative at t</param>
            <returns>FALSE if unable to evaluate.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.EvPoint(System.Double,RMA.OpenNURBS.On3dPoint@)">
            <summary>Evaluate point at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <returns>FALSE if unable to evaluate.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.CurvatureAt(System.Double)">
            <summary>Evaluate the curvature vector at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <returns>curvature vector of the curve at the parameter t.</returns>
            <remarks>
No error handling.
See Also: ON_Curve::EvCurvature
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.TangentAt(System.Double)">
            <summary>Evaluate unit tangent vector at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <returns>Unit tangent vector of the curve at the parameter t.</returns>
            <remarks>
No error handling.
See Also: ON_Curve::EvTangent
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.DerivativeAt(System.Double)">
            <summary>Evaluate first derivative at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <returns>First derivative of the curve at the parameter t.</returns>
            <remarks>
No error handling.
See Also: ON_Curve::Ev1Der
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.PointAt(System.Double)">
            <summary>Evaluate point at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <returns>Point (location of curve at the parameter t).</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Reverse">
            <summary>
Reverses bezier by reversing the order
of the control points.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Domain">
            <summary>
Domain of bezier (always [0,1])
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Scale(System.Double)">
            <summary>
Scales the bezier curve by the specified facotor.  The scale is
centered at the origin.
</summary>
            <param name="scale_factor">[in] scale factor</param>
            <returns>TRUE if bezier curve successfully scaled</returns>
            <remarks>Uses ON_BezierCurve::Transform() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Translate(RMA.OpenNURBS.IOn3dVector)">
            <summary>Translates the bezier curve along the specified vector.</summary>
            <param name="translation_vector">[in] translation vector</param>
            <returns>TRUE if bezier curve successfully translated</returns>
            <remarks>Uses ON_BezierCurve::Transform() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Rotate(System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Rotates the bezier curve about the specified axis.  A positive
rotation angle results in a counter-clockwise rotation
about the axis (right hand rule).
</summary>
            <param name="rotation_angle">[in] angle of rotation in radians</param>
            <param name="rotation_axis">[in] direction of the axis of rotation</param>
            <param name="rotation_center">[in] point on the axis of rotation</param>
            <returns>TRUE if bezier curve successfully rotated</returns>
            <remarks>Uses ON_BezierCurve::Transform() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Rotates the bezier curve about the specified axis.  A positive
rotation angle results in a counter-clockwise rotation
about the axis (right hand rule).
</summary>
            <param name="sin_angle">[in] sine of rotation angle</param>
            <param name="cos_angle">[in] sine of rotation angle</param>
            <param name="rotation_axis">[in] direction of the axis of rotation</param>
            <param name="rotation_center">[in] point on the axis of rotation</param>
            <returns>TRUE if bezier curve successfully rotated</returns>
            <remarks>Uses ON_BezierCurve::Transform() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>Transform the bezier.</summary>
            <param name="xform">[in] transformation to apply to bezier</param>
            <returns>
TRUE if successful.  FALSE if bezier is invalid
and cannot be transformed.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>Get tight bounding box of the bezier.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>Get tight bounding box of the bezier.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true and the input tight_bbox is valid,
then returned tight_bbox is the union of the input tight_bbox
and the tight bounding box of the bezier curve.
</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32,RMA.OpenNURBS.IOnXform)">
            <summary>Get tight bounding box of the bezier.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true and the input tight_bbox is valid,
then returned tight_bbox is the union of the input tight_bbox
and the tight bounding box of the bezier curve.
</param>
            <param name="xform">
[in] (default=NULL) If not NULL, the tight bounding box of the
transformed bezier is calculated. The bezier curve is not modified.
</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.BoundingBox">
            <summary>Gets bounding box.</summary>
            <returns>Axis aligned bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>Gets bounding box.</summary>
            <param name="bbox">[out] axis aligned bounding box returned here.</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>Gets bounding box.</summary>
            <param name="bbox">[out] axis aligned bounding box returned here.</param>
            <param name="bGrowBox">
[in] if TRUE, input bbox must be a valid bounding box and this box is enlarged to
be the union of the input box and the bezier's bounding box.
</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Loft(RMA.OpenNURBS.IOn3dPointArray)">
            <summary>Loft a bezier curve through a list of points.</summary>
            <param name="points">[in] an array of 2 or more points to interpolate</param>
            <returns>TRUE if successful</returns>
            <remarks>
The result has order = points.Count() and the loft uses the 
uniform parameterizaton curve( i/(points.Count()-1) ) = points[i].
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.EmergencyDestroy">
            <summary>
call if memory used by ON_NurbsCurve becomes invalid
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Destroy">
            <summary>
Deallocates m_cv memory.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Create(System.Int32,System.Boolean,System.Int32)">
            <summary>Creates a bezier with cv memory allocated.</summary>
            <param name="dim">[in] (&gt;0) dimension of bezier curve</param>
            <param name="bIsRational">[in] TRUE for a rational bezier</param>
            <param name="order">[in] (&gt;=2) order (=degree+1) of bezier curve</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Dimension">
            <summary>
Dimension of bezier.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Dump(RMA.OpenNURBS.OnTextLog@)">
            <summary>
for debugging
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.op_Implicit(RMA.OpenNURBS.IOn4dPointArray)~RMA.OpenNURBS.OnBezierCurve">
            <summary>
sets control points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.op_Implicit(RMA.OpenNURBS.IOn3dPointArray)~RMA.OpenNURBS.OnBezierCurve">
            <summary>
sets control points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.op_Implicit(RMA.OpenNURBS.IOn2dPointArray)~RMA.OpenNURBS.OnBezierCurve">
            <summary>
sets control points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.#ctor(RMA.OpenNURBS.IOn4dPointArray)">
            <summary>
sets control points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.#ctor(RMA.OpenNURBS.IOn3dPointArray)">
            <summary>
sets control points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.#ctor(RMA.OpenNURBS.IOn2dPointArray)">
            <summary>
sets control points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.#ctor(System.Int32,System.Boolean,System.Int32)">
            <summary>Creates a bezier with cv memory allocated.</summary>
            <param name="dim">[in] (&gt;0) dimension of bezier curve</param>
            <param name="bIsRational">[in] TRUE for a rational bezier</param>
            <param name="order">[in] (&gt;=2) order (=degree+1) of bezier curve</param>
        </member>
        <member name="P:RMA.OpenNURBS.OnBezierCurve.m_cv_capacity">
            <value>
Number of doubles in m_cv array.  If m_cv_capacity is zero
and m_cv is not NULL, an expert user is managing the m_cv
memory.  ~ON_BezierCurve will not deallocate m_cv unless
m_cv_capacity is greater than zero.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBezierCurve.m_cv_stride">
            <value>
Number of doubles per cv ( &gt;= ((m_is_rat)?m_dim+1:m_dim) )
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBezierCurve.m_order">
            <value>
order = degree+1
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBezierCurve.m_is_rat">
            <value>
1 if bezier is rational, 0 if bezier is not rational
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnBezierCurve.m_dim">
            <value>
NOTE: These members are left "public" so that expert users may efficiently
     create bezier curves using the default constructor and borrow the
     knot and CV arrays from their native NURBS representation.
     No technical support will be provided for users who access these
     members directly.  If you can't get your stuff to work, then use
     the constructor with the arguments and the SetKnot() and SetCV()
     functions to fill in the arrays.
dimension of bezier (&gt;=1)
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.IntersectSurface(RMA.OpenNURBS.IOnBezierSurface,RMA.OpenNURBS.ArrayOnX_EVENT@)">
            <summary>Intersect this bezier curve with bezsrfB.</summary>
            <param name="bezsrfB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve and surface
trees and intersect them. See the IntersectBezierSurface code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.IntersectSurface(RMA.OpenNURBS.IOnBezierSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double)">
            <summary>Intersect this bezier curve with bezsrfB.</summary>
            <param name="bezsrfB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve and surface
trees and intersect them. See the IntersectBezierSurface code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.IntersectSurface(RMA.OpenNURBS.IOnBezierSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double)">
            <summary>Intersect this bezier curve with bezsrfB.</summary>
            <param name="bezsrfB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and the distance from
curve(t) to the surface is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then
the event will be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0, 
then intersection_tolerance*2.0 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve and surface
trees and intersect them. See the IntersectBezierSurface code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.IntersectSurface(RMA.OpenNURBS.IOnBezierSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this bezier curve with bezsrfB.</summary>
            <param name="bezsrfB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and the distance from
curve(t) to the surface is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then
the event will be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0, 
then intersection_tolerance*2.0 is used.
</param>
            <param name="bezierA_domain">[in] optional restriction on this curve's domain</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve and surface
trees and intersect them. See the IntersectBezierSurface code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.IntersectSurface(RMA.OpenNURBS.IOnBezierSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this bezier curve with bezsrfB.</summary>
            <param name="bezsrfB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and the distance from
curve(t) to the surface is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then
the event will be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0, 
then intersection_tolerance*2.0 is used.
</param>
            <param name="bezierA_domain">[in] optional restriction on this curve's domain</param>
            <param name="bezsrfB_udomain">[in] optional restriction on surfaceB u domain</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve and surface
trees and intersect them. See the IntersectBezierSurface code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.IntersectSurface(RMA.OpenNURBS.IOnBezierSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this bezier curve with bezsrfB.</summary>
            <param name="bezsrfB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and the distance from
curve(t) to the surface is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then
the event will be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0, 
then intersection_tolerance*2.0 is used.
</param>
            <param name="bezierA_domain">[in] optional restriction on this curve's domain</param>
            <param name="bezsrfB_udomain">[in] optional restriction on surfaceB u domain</param>
            <param name="bezsrfB_vdomain">[in] optional restriction on surfaceB v domain</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve and surface
trees and intersect them. See the IntersectBezierSurface code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetLocalSurfaceIntersection(RMA.OpenNURBS.IOnBezierSurface,System.Double,System.Double,System.Double,System.Double@,System.Double@,System.Double@)">
            <summary>Get a local curve-surface intersection point.</summary>
            <param name="bezsrf">[in]</param>
            <param name="seed_t">[in] curve paramter</param>
            <param name="seed_u">[in] surface parameter</param>
            <param name="seed_v">[in] surface parameter</param>
            <param name="t">[out] curve paramter</param>
            <param name="u">[out] surface parameter</param>
            <param name="v">[out] surface parameter</param>
            <returns>True if something is returned in (t,u,v). Check answer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetLocalSurfaceIntersection(RMA.OpenNURBS.IOnBezierSurface,System.Double,System.Double,System.Double,System.Double@,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a local curve-surface intersection point.</summary>
            <param name="bezsrf">[in]</param>
            <param name="seed_t">[in] curve paramter</param>
            <param name="seed_u">[in] surface parameter</param>
            <param name="seed_v">[in] surface parameter</param>
            <param name="t">[out] curve paramter</param>
            <param name="u">[out] surface parameter</param>
            <param name="v">[out] surface parameter</param>
            <param name="tdomain">[in] optional curve domain restriction</param>
            <returns>True if something is returned in (t,u,v). Check answer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetLocalSurfaceIntersection(RMA.OpenNURBS.IOnBezierSurface,System.Double,System.Double,System.Double,System.Double@,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a local curve-surface intersection point.</summary>
            <param name="bezsrf">[in]</param>
            <param name="seed_t">[in] curve paramter</param>
            <param name="seed_u">[in] surface parameter</param>
            <param name="seed_v">[in] surface parameter</param>
            <param name="t">[out] curve paramter</param>
            <param name="u">[out] surface parameter</param>
            <param name="v">[out] surface parameter</param>
            <param name="tdomain">[in] optional curve domain restriction</param>
            <param name="udomain">[in] optional surface domain restriction</param>
            <returns>True if something is returned in (t,u,v). Check answer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetLocalSurfaceIntersection(RMA.OpenNURBS.IOnBezierSurface,System.Double,System.Double,System.Double,System.Double@,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a local curve-surface intersection point.</summary>
            <param name="bezsrf">[in]</param>
            <param name="seed_t">[in] curve paramter</param>
            <param name="seed_u">[in] surface parameter</param>
            <param name="seed_v">[in] surface parameter</param>
            <param name="t">[out] curve paramter</param>
            <param name="u">[out] surface parameter</param>
            <param name="v">[out] surface parameter</param>
            <param name="tdomain">[in] optional curve domain restriction</param>
            <param name="udomain">[in] optional surface domain restriction</param>
            <param name="vdomain">[in] optional surface domain restriction</param>
            <returns>True if something is returned in (t,u,v). Check answer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.IntersectCurve(RMA.OpenNURBS.IOnBezierCurve,RMA.OpenNURBS.ArrayOnX_EVENT@)">
            <summary>Intersect this bezier with bezierB.</summary>
            <param name="bezierB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve trees
and intersect them. See the IntersectBezierCurve code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.IntersectCurve(RMA.OpenNURBS.IOnBezierCurve,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double)">
            <summary>Intersect this bezier with bezierB.</summary>
            <param name="bezierB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to curveB is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve trees
and intersect them. See the IntersectBezierCurve code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.IntersectCurve(RMA.OpenNURBS.IOnBezierCurve,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double)">
            <summary>Intersect this bezier with bezierB.</summary>
            <param name="bezierB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to curveB is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are parameters of this curve's intersection events and the distance
from curve(t) to curveB is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then the
event will be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0, then
intersection_tolerance*2.0 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve trees
and intersect them. See the IntersectBezierCurve code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.IntersectCurve(RMA.OpenNURBS.IOnBezierCurve,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this bezier with bezierB.</summary>
            <param name="bezierB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to curveB is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are parameters of this curve's intersection events and the distance
from curve(t) to curveB is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then the
event will be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0, then
intersection_tolerance*2.0 is used.
</param>
            <param name="bezierA_domain">[in] optional restriction on this bezier's domain</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve trees
and intersect them. See the IntersectBezierCurve code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.IntersectCurve(RMA.OpenNURBS.IOnBezierCurve,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this bezier with bezierB.</summary>
            <param name="bezierB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to curveB is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are parameters of this curve's intersection events and the distance
from curve(t) to curveB is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then the
event will be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0, then
intersection_tolerance*2.0 is used.
</param>
            <param name="bezierA_domain">[in] optional restriction on this bezier's domain</param>
            <param name="bezierB_domain">[in] optional restriction on bezierB domain</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve trees
and intersect them. See the IntersectBezierCurve code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.IntersectSelf(RMA.OpenNURBS.ArrayOnX_EVENT@)">
            <summary>Find bezier self intersection points.</summary>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.IntersectSelf(RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double)">
            <summary>Find bezier self intersection points.</summary>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">[in]</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetLocalCurveIntersection(RMA.OpenNURBS.IOnBezierCurve,System.Double,System.Double,System.Double@,System.Double@)">
            <summary>Get a local curve-curve intersection point.</summary>
            <param name="other_bezcrv">[in] other curve</param>
            <param name="this_seed_t">[in] this curve seed paramter</param>
            <param name="other_seed_t">[in] other curve seed paramter</param>
            <param name="this_t">[out] this curve paramter</param>
            <param name="other_t">[out] other curve paramter</param>
            <returns>True if something is returned in (t,u,v). Check answer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetLocalCurveIntersection(RMA.OpenNURBS.IOnBezierCurve,System.Double,System.Double,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a local curve-curve intersection point.</summary>
            <param name="other_bezcrv">[in] other curve</param>
            <param name="this_seed_t">[in] this curve seed paramter</param>
            <param name="other_seed_t">[in] other curve seed paramter</param>
            <param name="this_t">[out] this curve paramter</param>
            <param name="other_t">[out] other curve paramter</param>
            <param name="this_domain">[in] optional this curve domain restriction</param>
            <returns>True if something is returned in (t,u,v). Check answer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetLocalCurveIntersection(RMA.OpenNURBS.IOnBezierCurve,System.Double,System.Double,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a local curve-curve intersection point.</summary>
            <param name="other_bezcrv">[in] other curve</param>
            <param name="this_seed_t">[in] this curve seed paramter</param>
            <param name="other_seed_t">[in] other curve seed paramter</param>
            <param name="this_t">[out] this curve paramter</param>
            <param name="other_t">[out] other curve paramter</param>
            <param name="this_domain">[in] optional this curve domain restriction</param>
            <param name="other_domain">[in] optional other curve domain restriction</param>
            <returns>True if something is returned in (t,u,v). Check answer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double@)">
            <summary>
Get the parameter of the point on the bezier curve that is locally closest
to the point P when the search begins at seed_parameter.
</summary>
            <param name="P">[in]</param>
            <param name="seed_parameter">[in] Parameter where the search begins.</param>
            <param name="t">[out] Closest point parameter.</param>
            <returns>True if a point is found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double@,RMA.OpenNURBS.IOnInterval)">
            <summary>
Get the parameter of the point on the bezier curve that is locally closest
to the point P when the search begins at seed_parameter.
</summary>
            <param name="P">[in]</param>
            <param name="seed_parameter">[in] Parameter where the search begins.</param>
            <param name="t">[out] Closest point parameter.</param>
            <param name="sub_domain">
[in] If not NULL, the search is confined to the intersection of the sub_domain interval and (0,1).
</param>
            <returns>True if a point is found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>
Get the parameter of the point on the bezier curve that is closest to the point P.
</summary>
            <param name="P">[in]</param>
            <param name="t">[out] Closest point parameter.</param>
            <returns>
True if a point is found.
See Also: ON_CurveTreeNode::GetClosestPoint
</returns>
            <remarks>
This function is not efficient if you will be finding multiple closest points to
the same bezier. To efficiently find multiple closest points, make a curve tree
and use it.
See the ON_BezierCurve::GetClosestPoint code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double)">
            <summary>
Get the parameter of the point on the bezier curve that is closest to the point P.
</summary>
            <param name="P">[in]</param>
            <param name="t">[out] Closest point parameter.</param>
            <param name="maximum_distance">
[in] If maximum_distance &gt; 0.0, then an answer is returned only if the distance
then maximum_distance is ignored.
</param>
            <returns>
True if a point is found.
See Also: ON_CurveTreeNode::GetClosestPoint
</returns>
            <remarks>
This function is not efficient if you will be finding multiple closest points to
the same bezier. To efficiently find multiple closest points, make a curve tree
and use it.
See the ON_BezierCurve::GetClosestPoint code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>
Get the parameter of the point on the bezier curve that is closest to the point P.
</summary>
            <param name="P">[in]</param>
            <param name="t">[out] Closest point parameter.</param>
            <param name="maximum_distance">
[in] If maximum_distance &gt; 0.0, then an answer is returned only if the distance
then maximum_distance is ignored.
</param>
            <param name="sub_domain">
[in] If not NULL, the search is confined to the intersection of the sub_domain interval and (0,1).
</param>
            <returns>
True if a point is found.
See Also: ON_CurveTreeNode::GetClosestPoint
</returns>
            <remarks>
This function is not efficient if you will be finding multiple closest points to
the same bezier. To efficiently find multiple closest points, make a curve tree
and use it.
See the ON_BezierCurve::GetClosestPoint code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.ControlPolygonLength">
            <summary>returns the length of the control polygon</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.Split(System.Double,RMA.OpenNURBS.OnBezierCurve@,RMA.OpenNURBS.OnBezierCurve@)">
            <summary>
Split() divides the Bezier curve at the specified parameter.
The parameter must satisfy 0 &lt; t &lt; 1.  You may pass *this as
one of the curves to be returned.
</summary>
            <param name="t">[in] (0 &lt; t &lt; 1 ) parameter to split at</param>
            <param name="left_side">[out]</param>
            <param name="right_side">[out]</param>
            <example>
ON_BezierCurve crv = ...;
ON_BezierCurve right_side;
crv.Split( 0.5, crv, right_side );
would split crv at the 1/2, put the left side in crv,
and return the right side in right_side.
</example>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetCV(System.Int32,RMA.OpenNURBS.On4dPoint@)">
            <summary>Get value of a control vertex.</summary>
            <param name="cv_index">[in] control vertex index (0 &lt;= cv_index &lt; m_order)</param>
            <param name="point">
[out] Homogenous value of control vertex.
If the bezier is not rational, the weight is 1.
</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetCV(System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>Get location of a control vertex.</summary>
            <param name="cv_index">[in] control vertex index (0 &lt;= cv_index &lt; m_order)</param>
            <param name="point">
[out] Location of control vertex.  If the bezier
is rational, the euclidean location is returned.
</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.Weight(System.Int32)">
            <param name="cv_index">[in] control vertex index (0&lt;=i&lt;m_order)</param>
            <returns>Weight of the i-th control vertex.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.CVStyle">
            <summary>
Description: Expert user function to get a pointer to control vertex memory. If you are not an expert user, please use ON_BezierCurve::GetCV( ON_3dPoint&amp; ) or ON_BezierCurve::GetCV( ON_4dPoint&amp; ). Parameters: cv_index - [in] (0 &lt;= cv_index &lt; m_order) Returns: Pointer to control vertex. Remarks: If the Bezier curve is rational, the format of the returned array is a homogeneos rational point with length m_dim+1. If the Bezier curve is not rational, the format of the returned array is a nonrational euclidean point with length m_dim. See Also ON_BezierCurve::CVStyle ON_BezierCurve::GetCV ON_BezierCurve::Weight
</summary>
            <summary>Returns the style of control vertices in the m_cv array.</summary>
            <returns>
ON::not_rational m_is_rat is FALSE
ON::homogeneous_rational m_is_rat is TRUE
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.Degree">
            <summary>
Degree of the bezier. (degree=order-1)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.Order">
            <summary>
Order of the bezier. (order=degree+1)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.CVCount">
            <summary>
Number of control vertices in the bezier.
This is always the same as the order of the bezier.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.CVSize">
            <summary>
Number of doubles per control vertex.
(= IsRational() ? Dim()+1 : Dim())
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.IsRational">
            <summary>TRUE if bezier is rational.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetNurbForm(RMA.OpenNURBS.OnNurbsCurve@)">
            <summary>Get ON_NurbsCurve form of a bezier.</summary>
            <param name="nurbs_curve">
[out] NURBS curve form of a bezier.
The domain is [0,1].
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.EvCurvature(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate unit tangent and curvature at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="tangent">[out] value of unit tangent</param>
            <param name="kappa">[out] value of curvature vector</param>
            <returns>FALSE if unable to evaluate.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.EvTangent(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate unit tangent at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="tangent">[out] value of unit tangent</param>
            <returns>
FALSE if unable to evaluate.
See Also:
ON_Curve::TangentAt
ON_Curve::Ev1Der
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.Ev2Der(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate second derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="first_derivative">[out] value of first derivative at t</param>
            <param name="second_derivative">[out] value of second derivative at t</param>
            <returns>FALSE if unable to evaluate.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.Ev1Der(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate first derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="first_derivative">[out] value of first derivative at t</param>
            <returns>FALSE if unable to evaluate.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.EvPoint(System.Double,RMA.OpenNURBS.On3dPoint@)">
            <summary>Evaluate point at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <returns>FALSE if unable to evaluate.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.CurvatureAt(System.Double)">
            <summary>Evaluate the curvature vector at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <returns>curvature vector of the curve at the parameter t.</returns>
            <remarks>
No error handling.
See Also: ON_Curve::EvCurvature
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.TangentAt(System.Double)">
            <summary>Evaluate unit tangent vector at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <returns>Unit tangent vector of the curve at the parameter t.</returns>
            <remarks>
No error handling.
See Also: ON_Curve::EvTangent
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.DerivativeAt(System.Double)">
            <summary>Evaluate first derivative at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <returns>First derivative of the curve at the parameter t.</returns>
            <remarks>
No error handling.
See Also: ON_Curve::Ev1Der
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.PointAt(System.Double)">
            <summary>Evaluate point at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <returns>Point (location of curve at the parameter t).</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.Domain">
            <summary>
Domain of bezier (always [0,1])
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>Get tight bounding box of the bezier.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>Get tight bounding box of the bezier.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true and the input tight_bbox is valid,
then returned tight_bbox is the union of the input tight_bbox
and the tight bounding box of the bezier curve.
</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32,RMA.OpenNURBS.IOnXform)">
            <summary>Get tight bounding box of the bezier.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true and the input tight_bbox is valid,
then returned tight_bbox is the union of the input tight_bbox
and the tight bounding box of the bezier curve.
</param>
            <param name="xform">
[in] (default=NULL) If not NULL, the tight bounding box of the
transformed bezier is calculated. The bezier curve is not modified.
</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.BoundingBox">
            <summary>Gets bounding box.</summary>
            <returns>Axis aligned bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>Gets bounding box.</summary>
            <param name="bbox">[out] axis aligned bounding box returned here.</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>Gets bounding box.</summary>
            <param name="bbox">[out] axis aligned bounding box returned here.</param>
            <param name="bGrowBox">
[in] if TRUE, input bbox must be a valid bounding box and this box is enlarged to
be the union of the input box and the bezier's bounding box.
</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.Dimension">
            <summary>
Dimension of bezier.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.Dump(RMA.OpenNURBS.OnTextLog@)">
            <summary>
for debugging
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBezierCurve.m_cv_capacity">
            <value>
Number of doubles in m_cv array.  If m_cv_capacity is zero
and m_cv is not NULL, an expert user is managing the m_cv
memory.  ~ON_BezierCurve will not deallocate m_cv unless
m_cv_capacity is greater than zero.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBezierCurve.m_cv_stride">
            <value>
Number of doubles per cv ( &gt;= ((m_is_rat)?m_dim+1:m_dim) )
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBezierCurve.m_order">
            <value>
order = degree+1
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBezierCurve.m_is_rat">
            <value>
1 if bezier is rational, 0 if bezier is not rational
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBezierCurve.m_dim">
            <value>
NOTE: These members are left "public" so that expert users may efficiently
     create bezier curves using the default constructor and borrow the
     knot and CV arrays from their native NURBS representation.
     No technical support will be provided for users who access these
     members directly.  If you can't get your stuff to work, then use
     the constructor with the arguments and the SetKnot() and SetCV()
     functions to fill in the arrays.
dimension of bezier (&gt;=1)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnPolynomialSurface.m_cv">
            <value>
coefficients ( m_C.Length() = m_order[0]*m_order[1]
coefficient of s^m*t^n = m_cv[m_order[1]*m+n]
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnPolynomialSurface.m_is_rat">
            <value>
1 if rational, 0 if not rational
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnPolynomialSurface.m_dim">
            <value>
1,2, or 3
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPolynomialSurface.m_cv">
            <value>
coefficients ( m_C.Length() = m_order[0]*m_order[1]
coefficient of s^m*t^n = m_cv[m_order[1]*m+n]
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPolynomialSurface.m_is_rat">
            <value>
1 if rational, 0 if not rational
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPolynomialSurface.m_dim">
            <value>
1,2, or 3
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolynomialCurve.Destroy">
            <summary>
Deallocates the m_cv array and sets fields to zero.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolynomialCurve.Create(System.Int32,System.Boolean,System.Int32)">
            <summary>Initializes fields and allocates the m_cv array.</summary>
            <param name="dim">[in] dimension of the curve</param>
            <param name="bIsRational">[in] TRUE if rational</param>
            <param name="order">[in] (&gt;=2) order = degree+1</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolynomialCurve.#ctor(System.Int32,System.Boolean,System.Int32)">
            <summary>See ON_PolynomialCurve::Create.</summary>
            <param name="dim">[in] dimension of the curve</param>
            <param name="bIsRational">[in] TRUE if rational</param>
            <param name="order">[in] (&gt;=2) order = degree+1</param>
        </member>
        <member name="P:RMA.OpenNURBS.OnPolynomialCurve.m_domain">
            <value>
domain of polynomial
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnPolynomialCurve.m_cv">
            <value>
coefficients ( m_cv.Count() = order of monomial )
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnPolynomialCurve.m_order">
            <value>
order (=degree+1) of polynomial
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnPolynomialCurve.m_is_rat">
            <value>
1 if polynomial curve is rational, 0 if polynomial curve is not rational
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnPolynomialCurve.m_dim">
            <value>
dimension of polynomial curve (1,2, or 3)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPolynomialCurve.m_domain">
            <value>
domain of polynomial
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPolynomialCurve.m_cv">
            <value>
coefficients ( m_cv.Count() = order of monomial )
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPolynomialCurve.m_order">
            <value>
order (=degree+1) of polynomial
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPolynomialCurve.m_is_rat">
            <value>
1 if polynomial curve is rational, 0 if polynomial curve is not rational
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPolynomialCurve.m_dim">
            <value>
dimension of polynomial curve (1,2, or 3)
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnTorus.RevSurfaceForm">
            <summary>Creates a surface of revolution definition of the torus.</summary>
            <returns>A surface of revolution or NULL if the torus is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTorus.RevSurfaceForm(RMA.OpenNURBS.OnRevSurface)">
            <summary>Creates a surface of revolution definition of the torus.</summary>
            <param name="srf">[in] if not NULL, then this srf is used.</param>
            <returns>A surface of revolution or NULL if the torus is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTorus.GetNurbForm(RMA.OpenNURBS.OnNurbsSurface@)">
            <summary>parameterization of NURBS surface does not match torus's transcendental paramaterization</summary>
            <returns>0=failure, 2=success</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTorus.Rotate(System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>rotate torus about a point and axis</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTorus.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>rotate torus about a point and axis</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTorus.Rotate(System.Double,RMA.OpenNURBS.IOn3dVector)">
            <summary>rotate torus about its origin</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTorus.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector)">
            <summary>rotate torus about its origin</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTorus.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
returns point on torus that is closest to test_point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTorus.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@)">
            <summary>
returns parameters of point on torus that is closest to test_point.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTorus.MinorCircleDegrees(System.Double)">
            <summary>Get the minor circle that is the isocurve on the torus at a specified major angle.</summary>
            <param name="major_angle_degrees">[in]</param>
            <returns>
A circle with radius = minor_radis, center = major_circle.PointAt(major_angle_degrees*ON_PI/180.0),
and starting point PointAt( major_angle_degrees*ON_PI/180.0, 0.0 ).
See Also:
ON_Torus::MajorCircleRadians
ON_Torus::MajorCircleDegrees
ON_Torus::MinorCircleRadians
ON_Torus::MinorCircleDegrees
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTorus.MinorCircleRadians(System.Double)">
            <summary>Get the minor circle that is the isocurve on the torus at a specified major angle.</summary>
            <param name="major_angle_radians">[in]</param>
            <returns>
A circle with radius = minor_radis, center = major_circle.PointAt(major_angle_radians),
and starting point PointAt( major_angle_radians, 0.0 ).
See Also:
ON_Torus::MajorCircleRadians
ON_Torus::MajorCircleDegrees
ON_Torus::MinorCircleRadians
ON_Torus::MinorCircleDegrees
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTorus.MajorCircleDegrees(System.Double)">
            <summary>Get the circle that is the isocurve on the torus at a specified minor angle.</summary>
            <param name="minor_angle_degrees">[in]</param>
            <returns>
A circle with normal major_circle.plane.zaxis that starts at
PointAt( 0.0, minor_angle_degrees*ON_PI/180.0 ).
See Also:
ON_Torus::MajorCircleRadians
ON_Torus::MajorCircleDegrees
ON_Torus::MinorCircleRadians
ON_Torus::MinorCircleDegrees
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTorus.MajorCircleRadians(System.Double)">
            <summary>Get the circle that is the isocurve on the torus at a specified minor angle.</summary>
            <param name="minor_angle_radians">[in]</param>
            <returns>
A circle with normal major_circle.plane.zaxis that starts at PointAt( 0.0, minor_angle_radians ).
See Also:
ON_Torus::MajorCircleRadians
ON_Torus::MajorCircleDegrees
ON_Torus::MinorCircleRadians
ON_Torus::MinorCircleDegrees
</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnTorus.minor_radius">
            <value>
&gt; 0
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnTorus.major_radius">
            <value>
&gt; minor_radius
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnTorus.plane">
            <value>
major circle plane
</value>
        </member>
        <member name="T:RMA.OpenNURBS.OnTorus">
            <summary>
The torus is defined by a major circle and minor radius.  The
torus is parameterized by (major_angle,minor_angle).  The angles
are specified in radians.  The domain of both parameters is (0,2pi).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTorus.RevSurfaceForm">
            <summary>Creates a surface of revolution definition of the torus.</summary>
            <returns>A surface of revolution or NULL if the torus is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTorus.RevSurfaceForm(RMA.OpenNURBS.OnRevSurface)">
            <summary>Creates a surface of revolution definition of the torus.</summary>
            <param name="srf">[in] if not NULL, then this srf is used.</param>
            <returns>A surface of revolution or NULL if the torus is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTorus.GetNurbForm(RMA.OpenNURBS.OnNurbsSurface@)">
            <summary>
returns 0=failure, 2=success
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTorus.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
returns point on torus that is closest to test_point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTorus.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@)">
            <summary>
returns parameters of point on torus that is closest to test_point.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTorus.MinorCircleDegrees(System.Double)">
            <summary>Get the minor circle that is the isocurve on the torus at a specified major angle.</summary>
            <param name="major_angle_degrees">[in]</param>
            <returns>
A circle with radius = minor_radis, center = major_circle.PointAt(major_angle_degrees*ON_PI/180.0),
and starting point PointAt( major_angle_degrees*ON_PI/180.0, 0.0 ).
See Also:
ON_Torus::MajorCircleRadians
ON_Torus::MajorCircleDegrees
ON_Torus::MinorCircleRadians
ON_Torus::MinorCircleDegrees
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTorus.MinorCircleRadians(System.Double)">
            <summary>Get the minor circle that is the isocurve on the torus at a specified major angle.</summary>
            <param name="major_angle_radians">[in]</param>
            <returns>
A circle with radius = minor_radis, center = major_circle.PointAt(major_angle_radians),
and starting point PointAt( major_angle_radians, 0.0 ).
See Also:
ON_Torus::MajorCircleRadians
ON_Torus::MajorCircleDegrees
ON_Torus::MinorCircleRadians
ON_Torus::MinorCircleDegrees
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTorus.MajorCircleDegrees(System.Double)">
            <summary>Get the circle that is the isocurve on the torus at a specified minor angle.</summary>
            <param name="minor_angle_degrees">[in]</param>
            <returns>
A circle with normal major_circle.plane.zaxis that starts at
PointAt( 0.0, minor_angle_degrees*ON_PI/180.0 ).
See Also:
ON_Torus::MajorCircleRadians
ON_Torus::MajorCircleDegrees
ON_Torus::MinorCircleRadians
ON_Torus::MinorCircleDegrees
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTorus.MajorCircleRadians(System.Double)">
            <summary>Get the circle that is the isocurve on the torus at a specified minor angle.</summary>
            <param name="minor_angle_radians">[in]</param>
            <returns>
A circle with normal major_circle.plane.zaxis that starts at PointAt( 0.0, minor_angle_radians ).
See Also:
ON_Torus::MajorCircleRadians
ON_Torus::MajorCircleDegrees
ON_Torus::MinorCircleRadians
ON_Torus::MinorCircleDegrees
</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTorus.minor_radius">
            <value>
&gt; 0
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTorus.major_radius">
            <value>
&gt; minor_radius
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTorus.plane">
            <value>
major circle plane
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnTorus">
            <summary>
The torus is defined by a major circle and minor radius.  The
torus is parameterized by (major_angle,minor_angle).  The angles
are specified in radians.  The domain of both parameters is (0,2pi).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSphere.RevSurfaceForm">
            <summary>Creates a surface of revolution definition of the sphere.</summary>
            <returns>A surface of revolution or NULL if the sphere is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSphere.RevSurfaceForm(RMA.OpenNURBS.OnRevSurface)">
            <summary>Creates a surface of revolution definition of the sphere.</summary>
            <param name="srf">[in] if not NULL, then this srf is used.</param>
            <returns>A surface of revolution or NULL if the sphere is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSphere.GetNurbForm(RMA.OpenNURBS.OnNurbsSurface@)">
            <summary>
parameterization of NURBS surface does not match sphere's transcendental paramaterization
</summary>
            <returns>0=failure, 2=success</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSphere.Rotate(System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>rotate sphere about a point and axis</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSphere.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>rotate sphere about a point and axis</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSphere.Rotate(System.Double,RMA.OpenNURBS.IOn3dVector)">
            <summary>rotate sphere about its origin</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSphere.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector)">
            <summary>rotate sphere about its origin</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSphere.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
returns point on sphere that is closest to given point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSphere.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@)">
            <summary>returns parameters of point on sphere that is closest to given point</summary>
            <param name="longitude_radians">longitude  [0,2pi)</param>
            <param name="latitude_radians">latitude   [-pi/2,pi/2]</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSphere.NormalAt(System.Double,System.Double)">
            <summary>longitude [0,2pi], latitude [-pi/2,pi/2] in radians</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSphere.PointAt(System.Double,System.Double)">
            <summary>longitude [0,2pi], latitude [-pi/2,pi/2] in radians</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSphere.Create(RMA.OpenNURBS.IOn3dPoint,System.Double)">
            <summary>
center radius
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSphere.#ctor(RMA.OpenNURBS.IOn3dPoint,System.Double)">
            <summary>
center, radius
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnSphere.radius">
            <value>
&gt; 0
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnSphere.plane">
            <value>
equitorial plane
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSphere.RevSurfaceForm">
            <summary>Creates a surface of revolution definition of the sphere.</summary>
            <returns>A surface of revolution or NULL if the sphere is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSphere.RevSurfaceForm(RMA.OpenNURBS.OnRevSurface)">
            <summary>Creates a surface of revolution definition of the sphere.</summary>
            <param name="srf">[in] if not NULL, then this srf is used.</param>
            <returns>A surface of revolution or NULL if the sphere is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSphere.GetNurbForm(RMA.OpenNURBS.OnNurbsSurface@)">
            <summary>
parameterization of NURBS surface does not match sphere's transcendental paramaterization
</summary>
            <returns>0=failure, 2=success</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSphere.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
returns point on sphere that is closest to given point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSphere.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@)">
            <summary>returns parameters of point on sphere that is closest to given point</summary>
            <param name="longitude_radians">longitude  [0,2pi)</param>
            <param name="latitude_radians">latitude   [-pi/2,pi/2]</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSphere.NormalAt(System.Double,System.Double)">
            <summary>longitude [0,2pi], latitude [-pi/2,pi/2] in radians</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSphere.PointAt(System.Double,System.Double)">
            <summary>longitude [0,2pi], latitude [-pi/2,pi/2] in radians</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnSphere.radius">
            <value>
&gt; 0
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnSphere.plane">
            <value>
equitorial plane
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.RevSurfaceForm">
            <summary>Creates a surface of revolution definition of the cylinder.</summary>
            <returns>A surface of revolution or NULL if the cylinder is not valid or is infinite.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.RevSurfaceForm(RMA.OpenNURBS.OnRevSurface)">
            <summary>Creates a surface of revolution definition of the cylinder.</summary>
            <param name="srf">[in] if not NULL, then this srf is used.</param>
            <returns>A surface of revolution or NULL if the cylinder is not valid or is infinite.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.Rotate(System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
rotate cone about a point and axis
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
rotate cone about a point and axis
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.Rotate(System.Double,RMA.OpenNURBS.IOn3dVector)">
            <summary>
rotate cone about its origin
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector)">
            <summary>
rotate cone about its origin
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
returns point on cone that is closest to given point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@)">
            <summary>
returns parameters of point on cone that is closest to given point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.LineAt(System.Double)">
            <summary>Get iso curve line segment at a specified angle.</summary>
            <param name="radial_parameter">[in] (in radians) 0.0 to 2.0*ON_PI</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.CircleAt(System.Double)">
            <summary>Get iso curve circle at a specified height.</summary>
            <param name="height_parameter">[in] 0 = apex, height = base</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.NormalAt(System.Double,System.Double)">
            <param name="radial_parameter">[in] (in radians) 0.0 to 2.0*ON_PI</param>
            <param name="height_parameter">[in] 0 = apex, height = base</param>
            <remarks>
If radius&gt;0 and height&gt;0, then the normal points "out"
when height_parameter &gt;= 0.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.PointAt(System.Double,System.Double)">
            <summary>evaluate parameters and return point</summary>
            <param name="radial_parameter">[in] 0.0 to 2.0*ON_PI</param>
            <param name="height_parameter">[in] 0 = apex, height = base</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.AngleInDegrees">
            <summary>
The angle (in degrees) between the axis and the side.
The angle and the height have the same sign.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.AngleInRadians">
            <summary>
The angle (in radians) between the axis and the 
side of the cone.
The angle and the height have the same sign.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.Axis">
            <summary>
Returns: Unit vector axis of cone.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.ApexPoint">
            <summary>Point at the tip of the cone.</summary>
            <remarks>The apex point is plane.origin.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.BasePoint">
            <summary>
Returns: Center of base circle.
</summary>
            <remarks>The base point is plane.origin + height*plane.zaxis.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.IsValid">
            <summary>
Returns TRUE if plane is valid, height is not zero, and
radius is not zero.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.Create(RMA.OpenNURBS.IOnPlane,System.Double,System.Double)">
            <summary>
Creates a right circular cone from a plane, height, and radius.
</summary>
            <param name="plane">[in] The apex of cone is at plane.origin and the axis of the cone is plane.zaxis.</param>
            <param name="height">[in] The center of the base is height*plane.zaxis.</param>
            <param name="radius">[in] tan(cone angle) = radius/height</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.#ctor(RMA.OpenNURBS.IOnPlane,System.Double,System.Double)">
            <summary>See ON_Cone::Create.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.#ctor">
            <summary>
Creates a cone with world XY plane as the base plane,
center = (0,0,0), radius = 0.0, height = 0.0.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnCone.radius">
            <value>
not zero
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnCone.height">
            <value>
not zero
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnCone.plane">
            <value>
apex = plane.origin, axis = plane.zaxis
</value>
        </member>
        <member name="T:RMA.OpenNURBS.OnCone">
            <summary>
Lightweight right circular cone.  Use ON_ConeSurface if
you need ON_Cone geometry as a virtual ON_Surface.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCone.RevSurfaceForm">
            <summary>Creates a surface of revolution definition of the cylinder.</summary>
            <returns>A surface of revolution or NULL if the cylinder is not valid or is infinite.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCone.RevSurfaceForm(RMA.OpenNURBS.OnRevSurface)">
            <summary>Creates a surface of revolution definition of the cylinder.</summary>
            <param name="srf">[in] if not NULL, then this srf is used.</param>
            <returns>A surface of revolution or NULL if the cylinder is not valid or is infinite.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCone.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
returns point on cone that is closest to given point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCone.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@)">
            <summary>
returns parameters of point on cone that is closest to given point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCone.LineAt(System.Double)">
            <summary>Get iso curve line segment at a specified angle.</summary>
            <param name="radial_parameter">[in] (in radians) 0.0 to 2.0*ON_PI</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCone.CircleAt(System.Double)">
            <summary>Get iso curve circle at a specified height.</summary>
            <param name="height_parameter">[in] 0 = apex, height = base</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCone.NormalAt(System.Double,System.Double)">
            <param name="radial_parameter">[in] (in radians) 0.0 to 2.0*ON_PI</param>
            <param name="height_parameter">[in] 0 = apex, height = base</param>
            <remarks>
If radius&gt;0 and height&gt;0, then the normal points "out"
when height_parameter &gt;= 0.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCone.PointAt(System.Double,System.Double)">
            <summary>evaluate parameters and return point</summary>
            <param name="radial_parameter">[in] 0.0 to 2.0*ON_PI</param>
            <param name="height_parameter">[in] 0 = apex, height = base</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCone.AngleInDegrees">
            <summary>
The angle in degrees) between the axis and the side.
The angle and the height have the same sign.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCone.AngleInRadians">
            <summary>
The angle (in radians) between the axis and the 
side of the cone.
The angle and the height have the same sign.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCone.Axis">
            <summary>
Returns: Unit vector axis of cone.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCone.ApexPoint">
            <summary>Point at the tip of the cone.</summary>
            <remarks>The apex point is plane.origin.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCone.BasePoint">
            <summary>
Returns: Center of base circle.
</summary>
            <remarks>The base point is plane.origin + height*plane.zaxis.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCone.IsValid">
            <summary>
Returns TRUE if plane is valid, height is not zero, and
radius is not zero.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnCone.radius">
            <value>
not zero
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnCone.height">
            <value>
not zero
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnCone.plane">
            <value>
apex = plane.origin, axis = plane.zaxis
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnCone">
            <summary>
Lightweight right circular cone.  Use ON_ConeSurface if
you need ON_Cone geometry as a virtual ON_Surface.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCylinder.RevSurfaceForm">
            <summary>Creates a surface of revolution definition of the cylinder.</summary>
            <returns>A surface of revolution or NULL if the cylinder is not valid or is infinite.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCylinder.RevSurfaceForm(RMA.OpenNURBS.OnRevSurface)">
            <summary>Creates a surface of revolution definition of the cylinder.</summary>
            <param name="srf">[in] if not NULL, then this srf is used.</param>
            <returns>A surface of revolution or NULL if the cylinder is not valid or is infinite.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCylinder.GetNurbForm(RMA.OpenNURBS.OnNurbsSurface@)">
            <summary>
parameterization of NURBS surface does not match cylinder's transcendental paramaterization
</summary>
            <returns>
0=failure, 2=success
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCylinder.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
rotate cylinder about a point and axis
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCylinder.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector)">
            <summary>
For intersections see ON_Intersect();
rotate cylinder about its origin
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCylinder.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
returns point on cylinder that is closest to given point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCylinder.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@)">
            <summary>
returns parameters of point on cylinder that is closest to given point
</summary>
            <param name="arg2">angular parameter [0,2pi]</param>
            <param name="arg3">linear parameter (height from base circle's plane)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCylinder.NormalAt(System.Double,System.Double)">
            <summary>
evaluate parameters and return point
</summary>
            <param name="arg1">angular parameter [0,2pi]</param>
            <param name="arg2">linear parameter (height from base circle's plane)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCylinder.PointAt(System.Double,System.Double)">
            <summary>
evaluate parameters and return point
</summary>
            <param name="arg1">angular parameter [0,2pi]</param>
            <param name="arg2">linear parameter (height from base circle's plane)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCylinder.GetHeight">
            <summary>
returns 0 for infinite cylinder
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCylinder.IsFinite">
            <summary>
returns TRUE if the cylinder is finite (height[0] != height[1]) and
FALSE if the cylinder is infinite.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCylinder.IsValid">
            <summary>
returns TRUE if all fields contain reasonable information and equation jibes with point and Z.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCylinder.Create(RMA.OpenNURBS.IOnCircle,System.Double)">
            <param name="arg1">point on the bottom plane</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCylinder.Create(RMA.OpenNURBS.IOnCircle)">
            <param name="arg1">point on the bottom plane</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCylinder.#ctor(RMA.OpenNURBS.IOnCircle,System.Double)">
            <summary>infinte cylinder</summary>
            <param name="arg1">point on the bottom plane</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCylinder.#ctor(RMA.OpenNURBS.IOnCircle)">
            <summary>infinte cylinder</summary>
            <param name="arg1">point on the bottom plane</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCylinder.#ctor">
            <summary>
zeros all fields - cylinder is invalid
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnCylinder.circle">
            <value>
base circle
</value>
        </member>
        <member name="T:RMA.OpenNURBS.OnCylinder">
            <summary>ON_Cylinder is a right circular cylinder.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCylinder.RevSurfaceForm">
            <summary>Creates a surface of revolution definition of the cylinder.</summary>
            <returns>A surface of revolution or NULL if the cylinder is not valid or is infinite.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCylinder.RevSurfaceForm(RMA.OpenNURBS.OnRevSurface)">
            <summary>Creates a surface of revolution definition of the cylinder.</summary>
            <param name="srf">[in] if not NULL, then this srf is used.</param>
            <returns>A surface of revolution or NULL if the cylinder is not valid or is infinite.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCylinder.GetNurbForm(RMA.OpenNURBS.OnNurbsSurface@)">
            <summary>
parameterization of NURBS surface does not match cylinder's transcendental paramaterization
</summary>
            <returns>
0=failure, 2=success
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCylinder.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
returns point on cylinder that is closest to given point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCylinder.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@)">
            <summary>
returns parameters of point on cylinder that is closest to given point
</summary>
            <param name="arg2">angular parameter [0,2pi]</param>
            <param name="arg3">linear parameter (height from base circle's plane)</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCylinder.NormalAt(System.Double,System.Double)">
            <summary>
evaluate parameters and return point
</summary>
            <param name="arg1">angular parameter [0,2pi]</param>
            <param name="arg2">linear parameter (height from base circle's plane)</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCylinder.PointAt(System.Double,System.Double)">
            <summary>
evaluate parameters and return point
</summary>
            <param name="arg1">angular parameter [0,2pi]</param>
            <param name="arg2">linear parameter (height from base circle's plane)</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCylinder.GetHeight">
            <summary>
returns 0 for infinite cylinder
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCylinder.IsFinite">
            <summary>
returns TRUE if the cylinder is finite (height[0] != height[1]) and
FALSE if the cylinder is infinite.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCylinder.IsValid">
            <summary>
returns TRUE if all fields contain reasonable information and equation jibes with point and Z.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnCylinder.circle">
            <value>
base circle
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnCylinder">
            <summary>ON_Cylinder is a right circular cylinder.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Find a point on the polyline that is closest to test_point.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Int32,System.Int32)">
            <summary>Find a point on the polyline that is closest to test_point.</summary>
            <param name="test_point">[in]</param>
            <param name="t">
[out] parameter for a point on the polyline that is closest to
test_point.  If mulitple solutions exist, then the smallest solution is returned.
</param>
            <param name="segment_index0">[in] index of segment where search begins</param>
            <param name="segment_index1">
[in] index of segment where search ends
This segment is NOT searched.
</param>
            <example>
Search segments 3,4, and 5 for the point closest to (0,0,0).
double t;
ClosestPointTo( ON_3dPoint(0,0,0), t, 3, 6 );
</example>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>Find a point on the polyline that is closest to test_point.</summary>
            <param name="test_point">[in]</param>
            <param name="t">
[out] parameter for a point on the polyline that
is closest to test_point.  If mulitple solutions
exist, then the smallest solution is returned.
</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.TangentAt(System.Double)">
            <summary>Evaluate the polyline unit tangent at a parameter.</summary>
            <param name="t">[in] the i-th segment goes from i &lt;= t &lt; i+1</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.DerivativeAt(System.Double)">
            <summary>Evaluate the polyline first derivative at a parameter.</summary>
            <param name="t">[in] the i-th segment goes from i &lt;= t &lt; i+1</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.PointAt(System.Double)">
            <summary>Evaluate the polyline location at a parameter.</summary>
            <param name="t">[in] the i-th segment goes from i &lt;= t &lt; i+1</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.SegmentTangent(System.Int32)">
            <param name="segment_index">[in] zero based segment index</param>
            <returns>Unit vector in the direction of the segment</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.SegmentDirection(System.Int32)">
            <param name="segment_index">[in] zero based segment index</param>
            <returns>vector = point[segment_index+1] - point[segment_index].</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.Length">
            <summary>
Returns: Length of the polyline.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.IsClosed">
            <summary>Test a polyline to see if it is closed.</summary>
            <returns>
TRUE if polyline has 4 or more points, the distance between the
start and end points is &lt;= tolerance, and there is a
point in the polyline whose distance from the start and end
points is &gt; tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.IsClosed(System.Double)">
            <summary>Test a polyline to see if it is closed.</summary>
            <returns>
TRUE if polyline has 4 or more points, the distance between the
start and end points is &lt;= tolerance, and there is a
point in the polyline whose distance from the start and end
points is &gt; tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.SegmentCount">
            <summary>
Returns: Number of segments in the polyline.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.PointCount">
            <summary>
Returns: Number of points in the polyline.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.Clean">
            <summary>Removes duplicate points that result in zero length segments.</summary>
            <returns>Number of points removed.</returns>
            <remarks>
If the distance between points polyline[i] and polyline[i+1]
is &lt;= tolerance, then the point with index (i+1) is removed.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.Clean(System.Double)">
            <summary>Removes duplicate points that result in zero length segments.</summary>
            <param name="tolerance">[in] tolerance used to check for duplicate points.</param>
            <returns>Number of points removed.</returns>
            <remarks>
If the distance between points polyline[i] and polyline[i+1]
is &lt;= tolerance, then the point with index (i+1) is removed.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.IsValid">
            <summary>
Checks that polyline has at least two points
and that sequential points are distinct.  If the
polyline has 2 or 3 points, then the start and end
point must be distinct.
</summary>
            <returns>
TRUE if polyline is valid.
See Also: ON_Polyline::Clean.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.IsValid(System.Double)">
            <summary>
Checks that polyline has at least two points
and that sequential points are distinct.  If the
polyline has 2 or 3 points, then the start and end
point must be distinct.
</summary>
            <param name="tolerance">[in] tolerance used to check for duplicate points.</param>
            <returns>
TRUE if polyline is valid.
See Also: ON_Polyline::Clean.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.CreateStarPolygon(RMA.OpenNURBS.IOnCircle,System.Double,System.Int32)">
            <summary>
Create a regular star polygon.
The star begins at circle.PointAt(0) and the vertices alternate
between being on circle and begin on a concentric circle of other_radius.
</summary>
            <param name="circle">[in] circle star polygon starts on</param>
            <param name="other_radius">[in] radius of other circle</param>
            <param name="corner_count">
[in] (&gt;=3) number of corners on circle
There will be 2*corner_count sides and 2*corner_count vertices.
</param>
            <returns>
TRUE if successful.  FALSE if circle is invalid, other_radius &lt; 0.0,
or side_count &lt; 3.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.CreateCircumscribedPolygon(RMA.OpenNURBS.IOnCircle,System.Int32)">
            <summary>
Create a regular polygon circumscribe about a circle.
The midpoints of the polygon's edges will be tanget to the circle.
</summary>
            <param name="circle">[in]</param>
            <param name="side_count">[in] (&gt;=3) number of sides</param>
            <returns>
TRUE if successful.  FALSE if circle is invalid or side_count &lt; 3.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.CreateInscribedPolygon(RMA.OpenNURBS.IOnCircle,System.Int32)">
            <summary>
Create a regular polygon inscribed in a circle.
The vertices of the polygon will be on the circle.
</summary>
            <param name="circle">[in]</param>
            <param name="side_count">[in] (&gt;=3) number of sides</param>
            <returns>
TRUE if successful.  FALSE if circle is invalid or side_count &lt; 3.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyline.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Find a point on the polyline that is closest to test_point.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyline.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Int32,System.Int32)">
            <summary>Find a point on the polyline that is closest to test_point.</summary>
            <param name="test_point">[in]</param>
            <param name="t">
[out] parameter for a point on the polyline that is closest to
test_point.  If mulitple solutions exist, then the smallest solution is returned.
</param>
            <param name="segment_index0">[in] index of segment where search begins</param>
            <param name="segment_index1">
[in] index of segment where search ends
This segment is NOT searched.
</param>
            <example>
Search segments 3,4, and 5 for the point closest to (0,0,0).
double t;
ClosestPointTo( ON_3dPoint(0,0,0), t, 3, 6 );
</example>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyline.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>Find a point on the polyline that is closest to test_point.</summary>
            <param name="test_point">[in]</param>
            <param name="t">
[out] parameter for a point on the polyline that
is closest to test_point.  If mulitple solutions
exist, then the smallest solution is returned.
</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyline.TangentAt(System.Double)">
            <summary>Evaluate the polyline unit tangent at a parameter.</summary>
            <param name="t">[in] the i-th segment goes from i &lt;= t &lt; i+1</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyline.DerivativeAt(System.Double)">
            <summary>Evaluate the polyline first derivative at a parameter.</summary>
            <param name="t">[in] the i-th segment goes from i &lt;= t &lt; i+1</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyline.PointAt(System.Double)">
            <summary>Evaluate the polyline location at a parameter.</summary>
            <param name="t">[in] the i-th segment goes from i &lt;= t &lt; i+1</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyline.SegmentTangent(System.Int32)">
            <param name="segment_index">[in] zero based segment index</param>
            <returns>Unit vector in the direction of the segment</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyline.SegmentDirection(System.Int32)">
            <param name="segment_index">[in] zero based segment index</param>
            <returns>vector = point[segment_index+1] - point[segment_index].</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyline.Length">
            <summary>
Returns: Length of the polyline.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyline.IsClosed">
            <summary>Test a polyline to see if it is closed.</summary>
            <returns>
TRUE if polyline has 4 or more points, the distance between the
start and end points is &lt;= tolerance, and there is a
point in the polyline whose distance from the start and end
points is &gt; tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyline.IsClosed(System.Double)">
            <summary>Test a polyline to see if it is closed.</summary>
            <returns>
TRUE if polyline has 4 or more points, the distance between the
start and end points is &lt;= tolerance, and there is a
point in the polyline whose distance from the start and end
points is &gt; tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyline.SegmentCount">
            <summary>
Returns: Number of segments in the polyline.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyline.PointCount">
            <summary>
Returns: Number of points in the polyline.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyline.IsValid">
            <summary>
Checks that polyline has at least two points
and that sequential points are distinct.  If the
polyline has 2 or 3 points, then the start and end
point must be distinct.
</summary>
            <returns>
TRUE if polyline is valid.
See Also: ON_Polyline::Clean.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyline.IsValid(System.Double)">
            <summary>
Checks that polyline has at least two points
and that sequential points are distinct.  If the
polyline has 2 or 3 points, then the start and end
point must be distinct.
</summary>
            <param name="tolerance">[in] tolerance used to check for duplicate points.</param>
            <returns>
TRUE if polyline is valid.
See Also: ON_Polyline::Clean.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@)">
            <summary>Intersect infinite line with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double)">
            <summary>Intersect infinite line with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this line to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double)">
            <summary>Intersect infinite line with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this line to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and
the distance from line(t) to the surface is &lt;= overlap_tolerance
for every t1 &lt;= t &lt;= t2, then the event will be returened as an
overlap event. If the input overlap_tolerance &lt;= 0.0, then intersection_tolerance*2.0 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect infinite line with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this line to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and
the distance from line(t) to the surface is &lt;= overlap_tolerance
for every t1 &lt;= t &lt;= t2, then the event will be returened as an
overlap event. If the input overlap_tolerance &lt;= 0.0, then intersection_tolerance*2.0 is used.
</param>
            <param name="line_domain">
[in] optional restriction on line's domain If you want a finite intersection,
then specify a line_domain. If you want a ray intersection, then specify a line
domain like (0.0, ON_DBL_MAX).
</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect infinite line with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this line to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and
the distance from line(t) to the surface is &lt;= overlap_tolerance
for every t1 &lt;= t &lt;= t2, then the event will be returened as an
overlap event. If the input overlap_tolerance &lt;= 0.0, then intersection_tolerance*2.0 is used.
</param>
            <param name="line_domain">
[in] optional restriction on line's domain If you want a finite intersection,
then specify a line_domain. If you want a ray intersection, then specify a line
domain like (0.0, ON_DBL_MAX).
</param>
            <param name="surfaceB_udomain">[in] optional restriction on surfaceB u domain</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect infinite line with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this line to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and
the distance from line(t) to the surface is &lt;= overlap_tolerance
for every t1 &lt;= t &lt;= t2, then the event will be returened as an
overlap event. If the input overlap_tolerance &lt;= 0.0, then intersection_tolerance*2.0 is used.
</param>
            <param name="line_domain">
[in] optional restriction on line's domain If you want a finite intersection,
then specify a line_domain. If you want a ray intersection, then specify a line
domain like (0.0, ON_DBL_MAX).
</param>
            <param name="surfaceB_udomain">[in] optional restriction on surfaceB u domain</param>
            <param name="surfaceB_vdomain">[in] optional restriction on surfaceB v domain</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
rotate line about a point and axis
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.Reverse">
            <summary>
Reverse line by swapping from and to.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.IsFartherThan(System.Double,RMA.OpenNURBS.IOnLine)">
            <summary>
Quickly determine if the shortest distance from this line to the other object is greater than d.
</summary>
            <param name="d">[in] distance (&gt; 0.0)</param>
            <returns>True if if the shortest distance from this line to the other object is greater than d.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.IsFartherThan(System.Double,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Quickly determine if the shortest distance from this line to the other object is greater than d.
</summary>
            <param name="d">[in] distance (&gt; 0.0)</param>
            <returns>True if if the shortest distance from this line to the other object is greater than d.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.MaximumDistanceTo(RMA.OpenNURBS.IOnLine)">
            <summary>
Finds the longest distance between the line as a finite chord and the other object.
</summary>
            <param name="L">[in] (another finite chord)</param>
            <returns>
A value d such that if Q is any point on this line and P is any point
on the other object, then d &gt;= Q.DistanceTo(P).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.MaximumDistanceTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Finds the longest distance between the line as a finite chord and the other object.
</summary>
            <param name="P">[in]</param>
            <returns>
A value d such that if Q is any point on this line and P is any point
on the other object, then d &gt;= Q.DistanceTo(P).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.MinimumDistanceTo(RMA.OpenNURBS.IOnLine)">
            <summary>
Finds the shortest distance between the line as a finite chord and the other object.
</summary>
            <param name="L">[in] (another finite chord)</param>
            <returns>
A value d such that if Q is any point on this line and P is any point
on the other object, then d &lt;= Q.DistanceTo(P).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.MinimumDistanceTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Finds the shortest distance between the line as a finite chord and the other object.
</summary>
            <param name="P">[in]</param>
            <returns>
A value d such that if Q is any point on this line and P is any point
on the other object, then d &lt;= Q.DistanceTo(P).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.DistanceTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Find the point on the (infinite) line that is closest to the test_point.</summary>
            <param name="test_point">[in]</param>
            <returns>
distance from the point on the line that is closest to test_point.
See Also: ON_3dPoint::DistanceTo ON_Line::ClosestPointTo
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Find the point on the (infinite) line that is closest to the test_point.</summary>
            <param name="test_point">[in]</param>
            <returns>The point on the line that is closest to test_point.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>Find the point on the (infinite) line that is closest to the test_point.</summary>
            <param name="test_point">[in]</param>
            <param name="t">[out] line.PointAt(*t) is the point on the line that is closest to test_point.</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.PointAt(System.Double)">
            <summary>Evaluate point on (infinite) line.</summary>
            <param name="t">
[in] evaluation parameter.
t=0 returns line.from and t=1 returns line.to.
</param>
            <returns>
(1-t)*line.from + t*line.to.
See Also: ON_Line::Direction ON_Line::Tangent
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.Tangent">
            <summary>
Returns: Unit tangent vector.
See Also: ON_Line::Direction
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.Direction">
            <summary>
Returns: direction vector = line.to - line.from
See Also: ON_Line::Tangent
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.Length">
            <summary>
Returns: Length of line
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.InPlane(RMA.OpenNURBS.OnPlane@)">
            <summary>Get a plane that contains the line.</summary>
            <param name="plane">
[out] a plane that contains the line.
The orgin of the plane is at the start of the line.
The distance from the end of the line to the plane is &lt;= tolerance.
If possible a plane parallel to the world xy, yz or zx plane is returned.
</param>
            <returns>true if a coordinate of the line's direction vector is larger than tolerance.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.InPlane(RMA.OpenNURBS.OnPlane@,System.Double)">
            <summary>Get a plane that contains the line.</summary>
            <param name="plane">
[out] a plane that contains the line.
The orgin of the plane is at the start of the line.
The distance from the end of the line to the plane is &lt;= tolerance.
If possible a plane parallel to the world xy, yz or zx plane is returned.
</param>
            <param name="tolerance">[in]</param>
            <returns>true if a coordinate of the line's direction vector is larger than tolerance.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false)
If true and the input tight_bbox is valid, then returned tight_bbox is
the union of the input tight_bbox and the line's tight bounding box.
</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32,RMA.OpenNURBS.IOnXform)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false)
If true and the input tight_bbox is valid, then returned tight_bbox is
the union of the input tight_bbox and the line's tight bounding box.
</param>
            <param name="xform">
[in] (default=NULL)
If not NULL, the tight bounding box of the transformed line is calculated.
The line is not modified.
</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>
Get line's 3d axis aligned bounding box or the union of the input box
with the object's bounding box.
</summary>
            <param name="bbox">[in/out] 3d axis aligned bounding box</param>
            <returns>true if object has bounding box and calculation was successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>
Get line's 3d axis aligned bounding box or the union of the input box
with the object's bounding box.
</summary>
            <param name="bbox">[in/out] 3d axis aligned bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true, then the union of the input bbox and the
object's bounding box is returned in bbox.
If false, the object's bounding box is returned in bbox.
</param>
            <returns>true if object has bounding box and calculation was successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.BoundingBox">
            <summary>Get line's 3d axis aligned bounding box.</summary>
            <returns>3d bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.Create(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Create a line from two points.</summary>
            <param name="start">[in] point at start of line segment</param>
            <param name="end">[in] point at end of line segment</param>
            <returns>true if start and end are distinct points.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.IsValid">
            <summary>
Returns: True if from != to.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnLine.to">
            <value>
end point
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnLine.from">
            <value>
start point
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@)">
            <summary>Intersect infinite line with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double)">
            <summary>Intersect infinite line with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this line to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double)">
            <summary>Intersect infinite line with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this line to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and
the distance from line(t) to the surface is &lt;= overlap_tolerance
for every t1 &lt;= t &lt;= t2, then the event will be returened as an
overlap event. If the input overlap_tolerance &lt;= 0.0, then intersection_tolerance*2.0 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect infinite line with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this line to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and
the distance from line(t) to the surface is &lt;= overlap_tolerance
for every t1 &lt;= t &lt;= t2, then the event will be returened as an
overlap event. If the input overlap_tolerance &lt;= 0.0, then intersection_tolerance*2.0 is used.
</param>
            <param name="line_domain">
[in] optional restriction on line's domain If you want a finite intersection,
then specify a line_domain. If you want a ray intersection, then specify a line
domain like (0.0, ON_DBL_MAX).
</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect infinite line with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this line to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and
the distance from line(t) to the surface is &lt;= overlap_tolerance
for every t1 &lt;= t &lt;= t2, then the event will be returened as an
overlap event. If the input overlap_tolerance &lt;= 0.0, then intersection_tolerance*2.0 is used.
</param>
            <param name="line_domain">
[in] optional restriction on line's domain If you want a finite intersection,
then specify a line_domain. If you want a ray intersection, then specify a line
domain like (0.0, ON_DBL_MAX).
</param>
            <param name="surfaceB_udomain">[in] optional restriction on surfaceB u domain</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect infinite line with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this line to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and
the distance from line(t) to the surface is &lt;= overlap_tolerance
for every t1 &lt;= t &lt;= t2, then the event will be returened as an
overlap event. If the input overlap_tolerance &lt;= 0.0, then intersection_tolerance*2.0 is used.
</param>
            <param name="line_domain">
[in] optional restriction on line's domain If you want a finite intersection,
then specify a line_domain. If you want a ray intersection, then specify a line
domain like (0.0, ON_DBL_MAX).
</param>
            <param name="surfaceB_udomain">[in] optional restriction on surfaceB u domain</param>
            <param name="surfaceB_vdomain">[in] optional restriction on surfaceB v domain</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.IsFartherThan(System.Double,RMA.OpenNURBS.IOnLine)">
            <summary>
Quickly determine if the shortest distance from this line to the other object is greater than d.
</summary>
            <param name="d">[in] distance (&gt; 0.0)</param>
            <returns>True if if the shortest distance from this line to the other object is greater than d.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.IsFartherThan(System.Double,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Quickly determine if the shortest distance from this line to the other object is greater than d.
</summary>
            <param name="d">[in] distance (&gt; 0.0)</param>
            <returns>True if if the shortest distance from this line to the other object is greater than d.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.MaximumDistanceTo(RMA.OpenNURBS.IOnLine)">
            <summary>
Finds the longest distance between the line as a finite chord and the other object.
</summary>
            <param name="L">[in] (another finite chord)</param>
            <returns>
A value d such that if Q is any point on this line and P is any point
on the other object, then d &gt;= Q.DistanceTo(P).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.MaximumDistanceTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Finds the longest distance between the line as a finite chord and the other object.
</summary>
            <param name="P">[in]</param>
            <returns>
A value d such that if Q is any point on this line and P is any point
on the other object, then d &gt;= Q.DistanceTo(P).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.MinimumDistanceTo(RMA.OpenNURBS.IOnLine)">
            <summary>
Finds the shortest distance between the line as a finite chord and the other object.
</summary>
            <param name="L">[in] (another finite chord)</param>
            <returns>
A value d such that if Q is any point on this line and P is any point
on the other object, then d &lt;= Q.DistanceTo(P).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.MinimumDistanceTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Finds the shortest distance between the line as a finite chord and the other object.
</summary>
            <param name="P">[in]</param>
            <returns>
A value d such that if Q is any point on this line and P is any point
on the other object, then d &lt;= Q.DistanceTo(P).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.DistanceTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Find the point on the (infinite) line that is closest to the test_point.</summary>
            <param name="test_point">[in]</param>
            <returns>
distance from the point on the line that is closest to test_point.
See Also: ON_3dPoint::DistanceTo ON_Line::ClosestPointTo
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Find the point on the (infinite) line that is closest to the test_point.</summary>
            <param name="test_point">[in]</param>
            <returns>The point on the line that is closest to test_point.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>Find the point on the (infinite) line that is closest to the test_point.</summary>
            <param name="test_point">[in]</param>
            <param name="t">[out] line.PointAt(*t) is the point on the line that is closest to test_point.</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.PointAt(System.Double)">
            <summary>Evaluate point on (infinite) line.</summary>
            <param name="t">
[in] evaluation parameter.
t=0 returns line.from and t=1 returns line.to.
</param>
            <returns>
(1-t)*line.from + t*line.to.
See Also: ON_Line::Direction ON_Line::Tangent
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.Tangent">
            <summary>
Returns: Unit tangent vector.
See Also: ON_Line::Direction
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.Direction">
            <summary>
Returns: direction vector = line.to - line.from
See Also: ON_Line::Tangent
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.Length">
            <summary>
Returns: Length of line
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.InPlane(RMA.OpenNURBS.OnPlane@)">
            <summary>Get a plane that contains the line.</summary>
            <param name="plane">
[out] a plane that contains the line.
The orgin of the plane is at the start of the line.
The distance from the end of the line to the plane is &lt;= tolerance.
If possible a plane parallel to the world xy, yz or zx plane is returned.
</param>
            <returns>true if a coordinate of the line's direction vector is larger than tolerance.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.InPlane(RMA.OpenNURBS.OnPlane@,System.Double)">
            <summary>Get a plane that contains the line.</summary>
            <param name="plane">
[out] a plane that contains the line.
The orgin of the plane is at the start of the line.
The distance from the end of the line to the plane is &lt;= tolerance.
If possible a plane parallel to the world xy, yz or zx plane is returned.
</param>
            <param name="tolerance">[in]</param>
            <returns>true if a coordinate of the line's direction vector is larger than tolerance.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false)
If true and the input tight_bbox is valid, then returned tight_bbox is
the union of the input tight_bbox and the line's tight bounding box.
</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32,RMA.OpenNURBS.IOnXform)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false)
If true and the input tight_bbox is valid, then returned tight_bbox is
the union of the input tight_bbox and the line's tight bounding box.
</param>
            <param name="xform">
[in] (default=NULL)
If not NULL, the tight bounding box of the transformed line is calculated.
The line is not modified.
</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>
Get line's 3d axis aligned bounding box or the union of the input box
with the object's bounding box.
</summary>
            <param name="bbox">[in/out] 3d axis aligned bounding box</param>
            <returns>true if object has bounding box and calculation was successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>
Get line's 3d axis aligned bounding box or the union of the input box
with the object's bounding box.
</summary>
            <param name="bbox">[in/out] 3d axis aligned bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true, then the union of the input bbox and the
object's bounding box is returned in bbox.
If false, the object's bounding box is returned in bbox.
</param>
            <returns>true if object has bounding box and calculation was successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.BoundingBox">
            <summary>Get line's 3d axis aligned bounding box.</summary>
            <returns>3d bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.IsValid">
            <summary>
Returns: True if from != to.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLine.to">
            <value>
end point
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLine.from">
            <value>
start point
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnX_EVENT.IsCSXEvent">
            <summary>
Returns: True if m_type is csx_point or csx_overlap
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnX_EVENT.IsCCXEvent">
            <summary>
Returns: True if m_type is ccx_point or ccx_overlap
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnX_EVENT.IsOverlapEvent">
            <summary>
Returns: True if m_type is ccx_overlap or csx_overlap.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnX_EVENT.IsPointEvent">
            <summary>
Returns: True if m_type is ccx_point or csx_point.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnX_EVENT.OverlapTolerance(System.Double,System.Double)">
            <summary>Convert input intersection tolerance to value used in calculations.</summary>
            <param name="intersection_tolerance">[in]</param>
            <returns>Value use in intersection calculations.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnX_EVENT.IntersectionTolerance(System.Double)">
            <summary>Convert input intersection tolerance to value used in calculations.</summary>
            <param name="intersection_tolerance">[in]</param>
            <returns>Value use in intersection calculations.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnX_EVENT.IsValidCurveSurfaceOverlap(RMA.OpenNURBS.IOnInterval,System.Int32,System.Double,RMA.OpenNURBS.IOnCurveTreeNode,RMA.OpenNURBS.IOnSurfaceTreeNode)">
            <summary>Do a quick and simple test to see if this curve lies on the surface.</summary>
            <param name="curveA_domain">[in]  non empty interval</param>
            <param name="sample_count">[in] minimum number of test points</param>
            <param name="overlap_tolerance">[in]</param>
            <param name="cnodeA">[in]</param>
            <param name="snodeB">[in]</param>
            <returns>True if sections overlap.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnX_EVENT.IsValidCurveSurfaceOverlap(RMA.OpenNURBS.IOnInterval,System.Int32,System.Double,RMA.OpenNURBS.IOnCurveTreeNode,RMA.OpenNURBS.IOnSurfaceTreeNode,RMA.OpenNURBS.IOnInterval)">
            <summary>Do a quick and simple test to see if this curve lies on the surface.</summary>
            <param name="curveA_domain">[in]  non empty interval</param>
            <param name="sample_count">[in] minimum number of test points</param>
            <param name="overlap_tolerance">[in]</param>
            <param name="cnodeA">[in]</param>
            <param name="snodeB">[in]</param>
            <param name="surfaceB_udomain">[in] optional domain restriction</param>
            <returns>True if sections overlap.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnX_EVENT.IsValidCurveSurfaceOverlap(RMA.OpenNURBS.IOnInterval,System.Int32,System.Double,RMA.OpenNURBS.IOnCurveTreeNode,RMA.OpenNURBS.IOnSurfaceTreeNode,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Do a quick and simple test to see if this curve lies on the surface.</summary>
            <param name="curveA_domain">[in]  non empty interval</param>
            <param name="sample_count">[in] minimum number of test points</param>
            <param name="overlap_tolerance">[in]</param>
            <param name="cnodeA">[in]</param>
            <param name="snodeB">[in]</param>
            <param name="surfaceB_udomain">[in] optional domain restriction</param>
            <param name="surfaceB_vdomain">[in] optional domain restriction</param>
            <returns>True if sections overlap.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnX_EVENT.IsValidCurvePlaneOverlap(RMA.OpenNURBS.IOnInterval,System.Int32,System.Double,System.Double,RMA.OpenNURBS.IOnCurveTreeNode,RMA.OpenNURBS.IOnPlaneEquation)">
            <summary>Do a quick and simple test to see if this curve lies on the plane.</summary>
            <param name="curveA_domain">[in]  non empty interval</param>
            <param name="sample_count">[in] minimum number of test points</param>
            <param name="endpoint_tolerance">[in] tolerance to use when checking ends</param>
            <param name="overlap_tolerance">[in] tolerance to use when checking interior</param>
            <param name="cnodeA">[in]</param>
            <param name="plane_equation">[in]</param>
            <returns>True if curve lies on the plane</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnX_EVENT.IsValidCurveCurveOverlap(RMA.OpenNURBS.IOnInterval,System.Int32,System.Double,RMA.OpenNURBS.IOnCurveTreeNode,RMA.OpenNURBS.IOnCurveTreeNode)">
            <summary>Do a quick and simple test to see if this curve lies on some portion of curveB.</summary>
            <param name="curveA_domain">[in] non empty interval</param>
            <param name="sample_count">[in] minimum number of test points</param>
            <param name="overlap_tolerance">[in]</param>
            <param name="cnodeA">[in]</param>
            <param name="cnodeB">[in]</param>
            <returns>True if sections overlap.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnX_EVENT.IsValidCurveCurveOverlap(RMA.OpenNURBS.IOnInterval,System.Int32,System.Double,RMA.OpenNURBS.IOnCurveTreeNode,RMA.OpenNURBS.IOnCurveTreeNode,RMA.OpenNURBS.IOnInterval)">
            <summary>Do a quick and simple test to see if this curve lies on some portion of curveB.</summary>
            <param name="curveA_domain">[in] non empty interval</param>
            <param name="sample_count">[in] minimum number of test points</param>
            <param name="overlap_tolerance">[in]</param>
            <param name="cnodeA">[in]</param>
            <param name="cnodeB">[in]</param>
            <param name="curveB_domain">[in] optional domain restriction</param>
            <returns>True if sections overlap.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnX_EVENT.CopyEventPart(RMA.OpenNURBS.IOnX_EVENT,System.Int32,RMA.OpenNURBS.OnX_EVENT@,System.Int32)">
            <summary>
Expert user tool to copy portions of the itersection event information
from one event to another. If src.m_type is ON_X_EVENT::csx_*, then the
m_b[] and m_nodeB_t[] values are treated as surface parameters,
otherwise the values are treated as curve parameters.  The m_type field
is not copied.
</summary>
            <param name="src">[in]</param>
            <param name="src_end">[in] 0 or 1 (m_A[] source index)</param>
            <param name="dst">[out]</param>
            <param name="dst_end">[in] 0 or 1 (m_A[] destination index)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnX_EVENT.IsValid(RMA.OpenNURBS.OnTextLog,System.Double,System.Double,RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Check intersection event values to make sure they are valid.</summary>
            <param name="text_log">
[in] If not null and an error is found, then a description of the error is printed to text_log.
</param>
            <param name="intersection_tolerance">[in] 0.0 or value used in intersection calculation.</param>
            <param name="overlap_tolerance">[in] 0.0 or value used in intersection calculation.</param>
            <param name="curveA">[in] NULL or curveA passed to intersection calculation.</param>
            <param name="curveA_domain">[in] NULL or curveA domain used in intersection calculation.</param>
            <param name="curveB">[in] NULL or curveB passed to intersection calculation.</param>
            <param name="curveB_domain">[in] NULL or curveB domain used in intersection calculation.</param>
            <param name="surfaceB">[in] NULL or surfaceB passed to intersection calculation.</param>
            <param name="surfaceB_domain0">[in] NULL or surfaceB "u" domain used in intersection calculation.</param>
            <param name="surfaceB_domain1">[in] NULL or surfaceB "v" domain used in intersection calculation.</param>
            <returns>True if event is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnX_EVENT.Compare(RMA.OpenNURBS.IOnX_EVENT,RMA.OpenNURBS.IOnX_EVENT)">
            <summary>Compares intersection events and sorts them in the canonical order.</summary>
            <returns>
-1    this  &lt; other
0    this == other
+1    this  &gt; other
</returns>
            <remarks>ON_CX_EVENT::Compare is used to sort intersection events into canonical order.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnX_EVENT.#ctor">
            <summary>
Default construction sets everything to zero.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnX_EVENT.m_x_eventsn">
            <value>
There are cases when it is valuable to have direction
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnX_EVENT.m_nodeB_t(System.Int32)">
            <value>
nodeB bezier paramters corresponding to b[] values.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnX_EVENT.m_cnodeB(System.Int32)">
            <summary>tree nodes where the intersection events occured.</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnX_EVENT.m_nodeA_t(System.Int32)">
            <value>
nodeA bezier paramters corresponding to a[] values
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnX_EVENT.m_cnodeA(System.Int32)">
            <summary>tree nodes where the intersection events occured.</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnX_EVENT.m_dirB(System.Int32)">
            <value>
There are cases when it is valuable to have direction
flags on intersection events.  The m_dirA[] and m_dirB[]
fields provide a place to store these flags.  Because this
information is rarely used, it is not computed by the
intersection routines.  You can use
 ON_SetCurveCurveIntersectionDir 
or
 ON_SetCurveSurfaceIntersectionDir
to fill in these fields.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnX_EVENT.m_dirA(System.Int32)">
            <value>
There are cases when it is valuable to have direction
flags on intersection events.  The m_dirA[] and m_dirB[]
fields provide a place to store these flags.  Because this
information is rarely used, it is not computed by the
intersection routines.  You can use
 ON_SetCurveCurveIntersectionDir 
or
 ON_SetCurveSurfaceIntersectionDir
to fill in these fields.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnX_EVENT.m_b(System.Int32)">
            <value>
intersection parameters on second curve or surface
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnX_EVENT.m_a(System.Int32)">
            <value>
intersection parameters on first curve
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnX_EVENT.m_pointB(System.Int32)">
            <value>
intersection points on second curve or surface
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnX_EVENT.m_pointA(System.Int32)">
            <value>
intersection points on first curve
</value>
        </member>
        <member name="T:RMA.OpenNURBS.OnX_EVENT">
            <summary>
The ON_X_EVENT class is used to report curve-curve and curve-surface
intersection events.
The m_type field determines how the values in the other
fields are interpreted.  See the detailed comment below
for complete informtion

The m_type field determines how the values in the other
fields are interpreted.

 ccx_point events:
   a[0] = a[1] = first curve parameter
   pointA[0] = pointA[1] = intersection point on first curve
   b[0] = b[1] = second curve parmeter
   pointB[0] = pointB[1] = intersection point on second curve
   b[2] = b[3] = not used
   cnodeA[0] = cnodeA[1] = pointer to first curve's tree node
   cnodeB[0] = cnodeB[1] = pointer to second curve's tree node
   snodeB[0] = snodeB[1] = 0

 ccx_overlap events:
   (a[0],a[1]) = first curve parameter range (a[0] &lt; a[1])
   pointA[0] = intersection start point on first curve
   pointA[1] = intersection end point on first curve
   (b[0],b[1]) = second curve parameter range (b[0] != b[1])
   pointB[0] = intersection start point on second curve
   pointB[1] = intersection end point on second curve
   b[2] = b[3] = not used
   cnodeA[0] = pointer to first curve's tree node for start point
   cnodeA[1] = pointer to first curve's tree node for end point
   cnodeB[0] = pointer to second curve's tree node for start point
   cnodeB[1] = pointer to second curve's tree node for end point
   snodeB[0] = snodeB[1] = 0

csx_point events:
   a[0] = a[1] = curve parameter
   pointA[0] = pointA[1] = intersection point on curve
   (b[0],b[1]) = (b[2],b[3]) = surface parameter
   pointB[0] = pointB[1] intersection point on surface
   cnodeA[0] = cnodeA[1] = pointer to curve's tree node
   cnodeB[0] = cnodeB[1] = 0;
   snodeB[0] = snodeB[1] = pointer to surface's tree node

 csx_overlap events:
   (a[0],a[1]) = curve parmamter range (a[0] &lt; a[1])
   pointA[0] = intersection start point on first curve
   pointA[1] = intersection end point on first curve
   (b[0],b[1]) = surface parameter for curve(a[0]).
   pointB[0] = intersection start point on surface
   (b[2],b[3]) = surface parameter for curve(a[1]).
   pointB[1] = intersection end point on surface
   cnodeA[0] = pointer to curve's tree node for start point
   cnodeA[1] = pointer to curve's tree node for end point
   snodeB[0] = pointer to surface's tree node for start point
   snodeB[1] = pointer to surface's tree node for end point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnX_EVENT.IsCSXEvent">
            <summary>
Returns: True if m_type is csx_point or csx_overlap
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnX_EVENT.IsCCXEvent">
            <summary>
Returns: True if m_type is ccx_point or ccx_overlap
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnX_EVENT.IsOverlapEvent">
            <summary>
Returns: True if m_type is ccx_overlap or csx_overlap.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnX_EVENT.IsPointEvent">
            <summary>
Returns: True if m_type is ccx_point or csx_point.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnX_EVENT.IsValid(RMA.OpenNURBS.OnTextLog,System.Double,System.Double,RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Check intersection event values to make sure they are valid.</summary>
            <param name="text_log">
[in] If not null and an error is found, then a description of the error is printed to text_log.
</param>
            <param name="intersection_tolerance">[in] 0.0 or value used in intersection calculation.</param>
            <param name="overlap_tolerance">[in] 0.0 or value used in intersection calculation.</param>
            <param name="curveA">[in] NULL or curveA passed to intersection calculation.</param>
            <param name="curveA_domain">[in] NULL or curveA domain used in intersection calculation.</param>
            <param name="curveB">[in] NULL or curveB passed to intersection calculation.</param>
            <param name="curveB_domain">[in] NULL or curveB domain used in intersection calculation.</param>
            <param name="surfaceB">[in] NULL or surfaceB passed to intersection calculation.</param>
            <param name="surfaceB_domain0">[in] NULL or surfaceB "u" domain used in intersection calculation.</param>
            <param name="surfaceB_domain1">[in] NULL or surfaceB "v" domain used in intersection calculation.</param>
            <returns>True if event is valid.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnX_EVENT.m_x_eventsn">
            <value>
There are cases when it is valuable to have direction
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnX_EVENT.m_nodeB_t(System.Int32)">
            <value>
nodeB bezier paramters corresponding to b[] values.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnX_EVENT.m_cnodeB(System.Int32)">
            <summary>tree nodes where the intersection events occured.</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnX_EVENT.m_nodeA_t(System.Int32)">
            <value>
nodeA bezier paramters corresponding to a[] values
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnX_EVENT.m_cnodeA(System.Int32)">
            <summary>tree nodes where the intersection events occured.</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnX_EVENT.m_dirB(System.Int32)">
            <value>
There are cases when it is valuable to have direction
flags on intersection events.  The m_dirA[] and m_dirB[]
fields provide a place to store these flags.  Because this
information is rarely used, it is not computed by the
intersection routines.  You can use
 ON_SetCurveCurveIntersectionDir 
or
 ON_SetCurveSurfaceIntersectionDir
to fill in these fields.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnX_EVENT.m_dirA(System.Int32)">
            <value>
There are cases when it is valuable to have direction
flags on intersection events.  The m_dirA[] and m_dirB[]
fields provide a place to store these flags.  Because this
information is rarely used, it is not computed by the
intersection routines.  You can use
 ON_SetCurveCurveIntersectionDir 
or
 ON_SetCurveSurfaceIntersectionDir
to fill in these fields.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnX_EVENT.m_b(System.Int32)">
            <value>
intersection parameters on second curve or surface
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnX_EVENT.m_a(System.Int32)">
            <value>
intersection parameters on first curve
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnX_EVENT.m_pointB(System.Int32)">
            <value>
intersection points on second curve or surface
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnX_EVENT.m_pointA(System.Int32)">
            <value>
intersection points on first curve
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnX_EVENT.DIRECTION">
            <summary>
Event directions for use in the m_dirA[] and m_dirB[]
fields. The "x_from_*" values are used to report the 
behavior of the curve as it enters the intersection 
event. The "x_to_*" values are used to report the 
behavior of the curve as it leaves the intersection
event.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnX_EVENT">
            <summary>
The ON_X_EVENT class is used to report curve-curve and curve-surface
intersection events.
The m_type field determines how the values in the other
fields are interpreted.  See the detailed comment below
for complete informtion

The m_type field determines how the values in the other
fields are interpreted.

 ccx_point events:
   a[0] = a[1] = first curve parameter
   pointA[0] = pointA[1] = intersection point on first curve
   b[0] = b[1] = second curve parmeter
   pointB[0] = pointB[1] = intersection point on second curve
   b[2] = b[3] = not used
   cnodeA[0] = cnodeA[1] = pointer to first curve's tree node
   cnodeB[0] = cnodeB[1] = pointer to second curve's tree node
   snodeB[0] = snodeB[1] = 0

 ccx_overlap events:
   (a[0],a[1]) = first curve parameter range (a[0] &lt; a[1])
   pointA[0] = intersection start point on first curve
   pointA[1] = intersection end point on first curve
   (b[0],b[1]) = second curve parameter range (b[0] != b[1])
   pointB[0] = intersection start point on second curve
   pointB[1] = intersection end point on second curve
   b[2] = b[3] = not used
   cnodeA[0] = pointer to first curve's tree node for start point
   cnodeA[1] = pointer to first curve's tree node for end point
   cnodeB[0] = pointer to second curve's tree node for start point
   cnodeB[1] = pointer to second curve's tree node for end point
   snodeB[0] = snodeB[1] = 0

csx_point events:
   a[0] = a[1] = curve parameter
   pointA[0] = pointA[1] = intersection point on curve
   (b[0],b[1]) = (b[2],b[3]) = surface parameter
   pointB[0] = pointB[1] intersection point on surface
   cnodeA[0] = cnodeA[1] = pointer to curve's tree node
   cnodeB[0] = cnodeB[1] = 0;
   snodeB[0] = snodeB[1] = pointer to surface's tree node

 csx_overlap events:
   (a[0],a[1]) = curve parmamter range (a[0] &lt; a[1])
   pointA[0] = intersection start point on first curve
   pointA[1] = intersection end point on first curve
   (b[0],b[1]) = surface parameter for curve(a[0]).
   pointB[0] = intersection start point on surface
   (b[2],b[3]) = surface parameter for curve(a[1]).
   pointB[1] = intersection end point on surface
   cnodeA[0] = pointer to curve's tree node for start point
   cnodeA[1] = pointer to curve's tree node for end point
   snodeB[0] = pointer to surface's tree node for start point
   snodeB[1] = pointer to surface's tree node for end point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnEllipse.GetNurbForm(RMA.OpenNURBS.OnNurbsCurve@)">
            <summary>
parameterization of NURBS curve does not match ellipse's transcendental paramaterization
</summary>
            <returns>0=failure, 2=success</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnEllipse.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
rotate ellipse about a point and axis
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnEllipse.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector)">
            <summary>
rotate ellipse about its center
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnEllipse.EquationAt(RMA.OpenNURBS.IOn2dPoint)">
            <summary>
evaluate ellipse's implicit equation in plane
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnEllipse.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
returns point on ellipse that is closest to given point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnEllipse.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>
returns parameters of point on ellipse that is closest to given point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnEllipse.CurvatureAt(System.Double)">
            <summary>
returns curvature vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnEllipse.TangentAt(System.Double)">
            <summary>
returns unit tangent
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnEllipse.DerivativeAt(System.Int32,System.Double)">
            <summary>
Evaluation uses the trigonometrix parameterization
t -&gt; plane.origin + cos(t)*radius[0]*plane.xaxis + sin(t)*radius[1]*plane.yaxis
evaluate parameters and return point
</summary>
            <param name="derivative">desired derivative ( &gt;= 0 )</param>
            <param name="t">parameter</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnEllipse.PointAt(System.Double)">
            <summary>
Evaluation uses the trigonometrix parameterization
t -&gt; plane.origin + cos(t)*radius[0]*plane.xaxis + sin(t)*radius[1]*plane.yaxis
evaluate parameters and return point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnEllipse.FocalDistance">
            <summary>
Returns: Distance between foci, commanly called "2c".
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnEllipse.GetPlane">
            <summary>
plane containing ellipse
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnEllipse.GetRadius(System.Int32)">
            <param name="axis">0 = x axis radius, 1 = y axis radius</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnEllipse.IsCircle">
            <summary>
returns TRUE is ellipse is a circle
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnEllipse.IsValid">
            <summary>
returns TRUE if all fields contain reasonable information and equation jibes with point and Z.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnEllipse.#ctor(RMA.OpenNURBS.IOnPlane,System.Double,System.Double)">
            <param name="x">radius for x vector</param>
            <param name="y">radius for y vector</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnEllipse.#ctor">
            <summary>
zeros all fields - plane is invalid
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnEllipse.radius(System.Int32)">
            <value>
radii for x and y axes (both must be &gt; 0)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnEllipse.plane">
            <value>
The center of the ellipse is at the plane's origin.  The axes of the
ellipse are the plane's x and y axes. The equation of the ellipse
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEllipse.GetNurbForm(RMA.OpenNURBS.OnNurbsCurve@)">
            <summary>
parameterization of NURBS curve does not match ellipse's transcendental paramaterization
</summary>
            <returns>0=failure, 2=success</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEllipse.EquationAt(RMA.OpenNURBS.IOn2dPoint)">
            <summary>
evaluate ellipse's implicit equation in plane
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEllipse.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
returns point on ellipse that is closest to given point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEllipse.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>
returns parameters of point on ellipse that is closest to given point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEllipse.CurvatureAt(System.Double)">
            <summary>
returns curvature vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEllipse.TangentAt(System.Double)">
            <summary>
returns unit tangent
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEllipse.DerivativeAt(System.Int32,System.Double)">
            <summary>
Evaluation uses the trigonometrix parameterization
t -&gt; plane.origin + cos(t)*radius[0]*plane.xaxis + sin(t)*radius[1]*plane.yaxis
evaluate parameters and return point
</summary>
            <param name="derivative">desired derivative ( &gt;= 0 )</param>
            <param name="t">parameter</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEllipse.PointAt(System.Double)">
            <summary>
Evaluation uses the trigonometrix parameterization
t -&gt; plane.origin + cos(t)*radius[0]*plane.xaxis + sin(t)*radius[1]*plane.yaxis
evaluate parameters and return point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEllipse.FocalDistance">
            <summary>
Returns: Distance between foci, commanly called "2c".
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEllipse.GetPlane">
            <summary>
plane containing ellipse
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEllipse.GetRadius(System.Int32)">
            <param name="axis">0 = x axis radius, 1 = y axis radius</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEllipse.IsCircle">
            <summary>
returns TRUE is ellipse is a circle
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEllipse.IsValid">
            <summary>
returns TRUE if all fields contain reasonable information and equation jibes with point and Z.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnEllipse.radius(System.Int32)">
            <value>
radii for x and y axes (both must be &gt; 0)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnEllipse.plane">
            <value>
The center of the ellipse is at the plane's origin.  The axes of the
ellipse are the plane's x and y axes. The equation of the ellipse
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.GetNurbFormParameterFromRadian(System.Double,System.Double@)">
            <summary>
Convert a circle radians parameter to a NURBS curve circle parameter.
</summary>
            <param name="circle_radians_parameter">[in] 0.0 to 2.0*ON_PI</param>
            <param name="nurbs_parameter">[out]</param>
            <example>
ON_Circle circle = ...;
double circle_t = 1.2345; // some number in interval (0,2.0*ON_PI). 
double nurbs_t;
circle.GetNurbFormParameterFromRadian( circle_t, &amp;nurbs_t );
ON_NurbsCurve nurbs_curve;
circle.GetNurbsForm( nurbs_curve );
circle_pt = circle.PointAt(circle_t);
nurbs_pt = nurbs_curve.PointAt(nurbs_t); // circle_pt and nurbs_pt will be the same
</example>
            <remarks>
The NURBS curve parameter is with respect to the NURBS curve created by ON_Circle::GetNurbForm.
At radian values of 0.0, 0.5*ON_PI, ON_PI, 1.5*ON_PI, and 2.0*ON_PI, the nurbs parameter and
radian parameter are the same. At all other values the nurbs and radian parameter values are
different.
See Also: ON_Circle::GetNurbFormParameterFromRadian
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.GetRadianFromNurbFormParameter(System.Double,System.Double@)">
            <summary>
Convert a NURBS curve circle parameter to a circle radians parameter.
</summary>
            <param name="nurbs_parameter">[in]</param>
            <param name="circle_radians_parameter">[out]</param>
            <example>
ON_Circle circle = ...;
double nurbs_t = 1.2345; // some number in interval (0,2.0*ON_PI).
double circle_t;
circle.GetRadianFromNurbFormParameter( nurbs_t, &amp;circle_t );
ON_NurbsCurve nurbs_curve; circle.GetNurbsForm( nurbs_curve );
circle_pt = circle.PointAt(circle_t);
nurbs_pt = nurbs_curve.PointAt(nurbs_t); // circle_pt and nurbs_pt will be the same
</example>
            <remarks>
The NURBS curve parameter is with respect to the NURBS curve created by ON_Circle::GetNurbForm.
At nurbs parameter values of 0.0, 0.5*ON_PI, ON_PI, 1.5*ON_PI, and 2.0*ON_PI, the nurbs
parameter and radian parameter are the same. At all other values the nurbs and radian parameter
values are different.
See Also: ON_Circle::GetNurbFormParameterFromRadian
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.GetNurbForm(RMA.OpenNURBS.OnNurbsCurve@)">
            <summary>
Get a four span rational degree 2 NURBS circle representation
of the circle.
</summary>
            <returns>2 for success, 0 for failure</returns>
            <remarks>
Note that the parameterization of NURBS curve
does not match  circle's transcendental paramaterization.  
Use ON_Circle::GetRadianFromNurbFormParameter() and
ON_Circle::GetParameterFromRadian() to convert between 
the NURBS curve parameter and the transcendental parameter.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.Rotate(System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>rotate circle about a point and axis</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>rotate circle about a point and axis</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.Rotate(System.Double,RMA.OpenNURBS.IOn3dVector)">
            <summary>rotate circle about its center</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector)">
            <summary>rotate circle about its center</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.EquationAt(RMA.OpenNURBS.IOn2dPoint)">
            <summary>
evaluate circle's implicit equation in plane
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
returns point on circle that is closest to given point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>
returns parameters of point on circle that is closest to given point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.TangentAt(System.Double)">
            <summary>
Circles use trigonometric parameterization
t -&gt; center + cos(t)*radius*xaxis + sin(t)*radius*yaxis
</summary>
            <param name="t">evaluation parameter</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.DerivativeAt(System.Int32,System.Double)">
            <summary>
Circles use trigonometric parameterization
t -&gt; center + cos(t)*radius*xaxis + sin(t)*radius*yaxis
</summary>
            <param name="derivative">&gt;=0</param>
            <param name="t">evaluation parameter</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.PointAt(System.Double)">
            <summary>
Circles use trigonometric parameterization
t -&gt; center + cos(t)*radius*xaxis + sin(t)*radius*yaxis
</summary>
            <param name="t">evaluation parameter</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true and the input tight_bbox is valid,
then returned tight_bbox is the union of the input tight_bbox and
the arc's tight bounding box.
</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32,RMA.OpenNURBS.IOnXform)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true and the input tight_bbox is valid,
then returned tight_bbox is the union of the input tight_bbox and
the arc's tight bounding box.
</param>
            <param name="xform">
[in] (default=NULL) If not NULL, the tight bounding box of the transformed arc is calculated.
The arc is not modified.
</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.IsValid">
            <summary>
A Valid circle has m_radius&gt;0 and m_plane.IsValid().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.Create(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Create a circle from two 3d points and a 
tangent at the first point.
The start/end of the circle is at point P.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.Create(RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOn2dVector,RMA.OpenNURBS.IOn2dPoint)">
            <summary>
Create a circle from two 2d points and a 
tangent at the first point.
The start/end of the circle is at point P.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.Create(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Create a circle through three 3d points.
The start/end of the circle is at point P.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.Create(RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOn2dPoint)">
            <summary>
circle through 3 2d points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.Create(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.IOn3dPoint,System.Double)">
            <summary>
Creates a circle parallel to the plane
with given centr and radius.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.Create(RMA.OpenNURBS.IOn3dPoint,System.Double)">
            <summary>
Creates a circle parallel to the world XY plane
with given center and radius
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.Create(RMA.OpenNURBS.IOnPlane,System.Double)">
            <summary>
Creates a circle in the plane with center at
plane.origin.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.#ctor(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Create a circle through three 3d points.
The start/end of the circle is at point P.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.#ctor(RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOn2dPoint)">
            <summary>
Create a circle through three 2d points.
The start/end of the circle is at point P.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.#ctor(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.IOn3dPoint,System.Double)">
            <summary>
Creates a circle parallel to the plane
with given center and radius.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.#ctor(RMA.OpenNURBS.IOn3dPoint,System.Double)">
            <summary>
Creates a circle parallel to the world XY plane
with given center and radius
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.#ctor(RMA.OpenNURBS.IOnPlane,System.Double)">
            <summary>
Creates a circle in the plane with center at
plane.origin.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.#ctor">
            <summary>
Creates a radius one circle with center (0,0,0)
in the world XY plane
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnCircle.radius">
            <value>
radius
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnCircle.plane">
            <value>
circle is in the plane with center at plane.m_origin.
</value>
        </member>
        <member name="T:RMA.OpenNURBS.OnCircle">
            <summary>
ON_Circle is a circle in 3d.  The cirle is represented by a radius and an 
orthonormal frame	of the plane containing the circle, with origin at the center.

An Is_Valid() circle has positive radius and an Is_ Valid() plane defining the frame.

The circle is parameterized by radians from 0 to 2 Pi given by 
t -&gt; center + cos(t)*radius*xaxis + sin(t)*radius*yaxis	
where center, xaxis and yaxis define the orthonormal frame of the circle's plane.  
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCircle.GetNurbFormParameterFromRadian(System.Double,System.Double@)">
            <summary>
Convert a circle radians parameter to a NURBS curve circle parameter.
</summary>
            <param name="circle_radians_parameter">[in] 0.0 to 2.0*ON_PI</param>
            <param name="nurbs_parameter">[out]</param>
            <example>
ON_Circle circle = ...;
double circle_t = 1.2345; // some number in interval (0,2.0*ON_PI). 
double nurbs_t;
circle.GetNurbFormParameterFromRadian( circle_t, &amp;nurbs_t );
ON_NurbsCurve nurbs_curve;
circle.GetNurbsForm( nurbs_curve );
circle_pt = circle.PointAt(circle_t);
nurbs_pt = nurbs_curve.PointAt(nurbs_t); // circle_pt and nurbs_pt will be the same
</example>
            <remarks>
The NURBS curve parameter is with respect to the NURBS curve created by ON_Circle::GetNurbForm.
At radian values of 0.0, 0.5*ON_PI, ON_PI, 1.5*ON_PI, and 2.0*ON_PI, the nurbs parameter and
radian parameter are the same. At all other values the nurbs and radian parameter values are
different.
See Also: ON_Circle::GetNurbFormParameterFromRadian
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCircle.GetRadianFromNurbFormParameter(System.Double,System.Double@)">
            <summary>
Convert a NURBS curve circle parameter to a circle radians parameter.
</summary>
            <param name="nurbs_parameter">[in]</param>
            <param name="circle_radians_parameter">[out]</param>
            <example>
ON_Circle circle = ...;
double nurbs_t = 1.2345; // some number in interval (0,2.0*ON_PI).
double circle_t;
circle.GetRadianFromNurbFormParameter( nurbs_t, &amp;circle_t );
ON_NurbsCurve nurbs_curve; circle.GetNurbsForm( nurbs_curve );
circle_pt = circle.PointAt(circle_t);
nurbs_pt = nurbs_curve.PointAt(nurbs_t); // circle_pt and nurbs_pt will be the same
</example>
            <remarks>
The NURBS curve parameter is with respect to the NURBS curve created by ON_Circle::GetNurbForm.
At nurbs parameter values of 0.0, 0.5*ON_PI, ON_PI, 1.5*ON_PI, and 2.0*ON_PI, the nurbs
parameter and radian parameter are the same. At all other values the nurbs and radian parameter
values are different.
See Also: ON_Circle::GetNurbFormParameterFromRadian
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCircle.GetNurbForm(RMA.OpenNURBS.OnNurbsCurve@)">
            <summary>
Get a four span rational degree 2 NURBS circle representation
of the circle.
</summary>
            <returns>2 for success, 0 for failure</returns>
            <remarks>
Note that the parameterization of NURBS curve
does not match  circle's transcendental paramaterization.  
Use ON_Circle::GetRadianFromNurbFormParameter() and
ON_Circle::GetParameterFromRadian() to convert between 
the NURBS curve parameter and the transcendental parameter.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCircle.EquationAt(RMA.OpenNURBS.IOn2dPoint)">
            <summary>
evaluate circle's implicit equation in plane
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCircle.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
returns point on circle that is closest to given point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCircle.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>
returns parameters of point on circle that is closest to given point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCircle.TangentAt(System.Double)">
            <summary>
Circles use trigonometric parameterization
t -&gt; center + cos(t)*radius*xaxis + sin(t)*radius*yaxis
</summary>
            <param name="t">evaluation parameter</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCircle.DerivativeAt(System.Int32,System.Double)">
            <summary>
Circles use trigonometric parameterization
t -&gt; center + cos(t)*radius*xaxis + sin(t)*radius*yaxis
</summary>
            <param name="derivative">&gt;=0</param>
            <param name="t">evaluation parameter</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCircle.PointAt(System.Double)">
            <summary>
Circles use trigonometric parameterization
t -&gt; center + cos(t)*radius*xaxis + sin(t)*radius*yaxis
</summary>
            <param name="t">evaluation parameter</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCircle.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCircle.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true and the input tight_bbox is valid,
then returned tight_bbox is the union of the input tight_bbox and
the arc's tight bounding box.
</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCircle.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32,RMA.OpenNURBS.IOnXform)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true and the input tight_bbox is valid,
then returned tight_bbox is the union of the input tight_bbox and
the arc's tight bounding box.
</param>
            <param name="xform">
[in] (default=NULL) If not NULL, the tight bounding box of the transformed arc is calculated.
The arc is not modified.
</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCircle.IsValid">
            <summary>
A Valid circle has m_radius&gt;0 and m_plane.IsValid().
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnCircle.radius">
            <value>
radius
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnCircle.plane">
            <value>
circle is in the plane with center at plane.m_origin.
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnCircle">
            <summary>
ON_Circle is a circle in 3d.  The cirle is represented by a radius and an 
orthonormal frame	of the plane containing the circle, with origin at the center.

An Is_Valid() circle has positive radius and an Is_ Valid() plane defining the frame.

The circle is parameterized by radians from 0 to 2 Pi given by 
t -&gt; center + cos(t)*radius*xaxis + sin(t)*radius*yaxis	
where center, xaxis and yaxis define the orthonormal frame of the circle's plane.  
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnClippingPlane.m_bEnabled">
            <value>
true if this clipping plane is active
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnClippingPlane.m_bEnabled">
            <value>
true if this clipping plane is active
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.Flip">
            <summary>
Flip plane orientation by swapping x and y axes, reversing the zaxis, and updating the equation.
</summary>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.Translate(RMA.OpenNURBS.IOn3dVector)">
            <summary>Translate a plane.</summary>
            <param name="delta">[in] translation vector</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.Rotate(System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Rotate a plane about a point.</summary>
            <param name="angle">[in] rotation angle in radians</param>
            <param name="axis">[in] axis of rotation</param>
            <param name="center">[in] center of rotation</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Rotate a plane about a point.</summary>
            <param name="sin_angle">[in] sine of rotation angle</param>
            <param name="cos_angle">[in] cosine of rotation angle</param>
            <param name="axis">[in] axis of rotation</param>
            <param name="center">[in] center of rotation</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.Rotate(System.Double,RMA.OpenNURBS.IOn3dVector)">
            <summary>Rotate a plane about its origin.</summary>
            <param name="angle">[in] rotation angle in radians</param>
            <param name="axis">[in] axis of rotation</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector)">
            <summary>Rotate a plane about its origin.</summary>
            <param name="sin_angle">[in] sine of rotation angle</param>
            <param name="cos_angle">[in] cosine of rotation angle</param>
            <param name="axis">[in] axis of rotation</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.SwapCoordinates(System.Int32,System.Int32)">
            <summary>Transform a plane by swapping coordinates.</summary>
            <param name="i">
[in] indices of coordinates to swap.
0 = x coordinate, 1 = y coordinate, 2 = z coordinate.
</param>
            <param name="j">
[in] indices of coordinates to swap.
0 = x coordinate, 1 = y coordinate, 2 = z coordinate.
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.Morph(RMA.OpenNURBS.IOnSpaceMorph)">
            <summary>Morph plane.</summary>
            <param name="morph">[in] morph to apply to plane</param>
            <returns>TRUE if successful</returns>
            <remarks>The resulting plane still has an orthonormal frame</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>Transform plane.</summary>
            <param name="xform">[in] transformation to apply to plane</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Get point on plane that is closest to a given point.</summary>
            <param name="point">[in]</param>
            <returns>A 3d point on the plane that is closest to world_point.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@)">
            <summary>Get point on plane that is closest to a given point.</summary>
            <param name="world_point">[in] 3d point</param>
            <param name="u">[out] The point ON_Plane::PointAt(*u,*v) is the point on the plane that is closest to world_point.</param>
            <param name="v">[out] The point ON_Plane::PointAt(*u,*v) is the point on the plane that is closest to world_point.</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.UpdateEquation">
            <summary>Update the plane equation based on the current values of the origin and zaxis.</summary>
            <returns>TRUE if successful. FALSE if zaxis is zero.</returns>
            <remarks>If you modify a plane's origin or zaxis, call UpdateEquation() to set equation[].</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.GetDistanceToBoundingBox(RMA.OpenNURBS.IOnBoundingBox,System.Double@,System.Double@)">
            <returns>false if plane has zero length normal</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.DistanceTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Get signed distance from the plane to a point.</summary>
            <param name="point">[in]</param>
            <returns>Signed distance from a point to a plane.</returns>
            <remarks>
If the point is on the plane, the distance is 0.
If the point is above the plane, the distance is &gt; 0.
If the point is below the plane the distance is &lt; 0.
The zaxis determines the plane's orientation.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.IsoLine(System.Int32,System.Double)">
            <summary>Get an isoparameteric line on the plane.</summary>
            <param name="dir">
[in] direction of iso-parametric line
0: first parameter varies and second parameter is constant e.g., line(t) = plane(t,c)
1: first parameter is constant and second parameter varies e.g., line(t) = plane(c,t)
</param>
            <param name="c">[in] value of constant parameter</param>
            <returns>iso-parametric line</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.PointAt(System.Double,System.Double,System.Double)">
            <summary>Evaluate a point on the plane</summary>
            <param name="u">[in] evaulation parameters</param>
            <param name="v">[in] evaulation parameters</param>
            <param name="w">[in] elevation parameter</param>
            <returns>plane.origin + u*plane.xaxis + v*plane.yaxis + z*plane.zaxis</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.PointAt(System.Double,System.Double)">
            <summary>Evaluate a point on the plane</summary>
            <param name="u">[in] evaulation parameters</param>
            <param name="v">[in] evaulation parameters</param>
            <returns>plane.origin + u*plane.xaxis + v*plane.yaxis</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.SetOrigin(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Set the origin and update the plane equation</summary>
            <param name="origin">[in] the new origin</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.Normal">
            <summary>
Returns: Plane unit normal.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.GetYaxis">
            <summary>
Returns: Plane unit y-axis.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.GetXaxis">
            <summary>
Returns: Plane unit x-axis.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.GetOrigin">
            <summary>
Returns: Plane origin.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.IsValid">
            <summary>Test plane to see if it is valid.</summary>
            <returns>TRUE if all fields contain reasonable information and equation jibes with point and zaxis.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.CreateFromEquation(System.Double[])">
            <summary>Construct a plane from an equation.</summary>
            <param name="equation">
[in] an array of 4 doubles with one of equation[0], equation[1], or equation[2] being non-zero.
</param>
            <remarks>
points on the plane will satisfy x*equation[0] +y*equation[1] + z*equation[2] + equation[3] = 0
</remarks>
            <returns>TRUE if valid plane is created.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.CreateFromPoints(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Construct a plane from three non-colinear points.</summary>
            <param name="origin">[in] point on the plane</param>
            <param name="point_on_x">[in] second point in the plane. The xaxis will be parallel to x_point-origin.</param>
            <param name="point_on">
[in] third point on the plane that is not colinear with the first two points.
yaxis*(y_point-origin) will be &gt; 0.
</param>
            <returns>TRUE if valid plane is created.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.CreateFromFrame(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector)">
            <summary>Construct a plane from a point, and two vectors in the plane.</summary>
            <param name="origin">[in] point on the plane</param>
            <param name="x_dir">[in] non-zero vector in the plane that determines the xaxis direction.</param>
            <param name="y_dir">
[in] non-zero vector not parallel to x_dir that is used to determine the yaxis direction.
y_dir does not have to be perpindicular to x_dir.
</param>
            <returns>TRUE if valid plane is created.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.CreateFromNormal(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector)">
            <summary>Create a plane from a point and normal vector.</summary>
            <param name="origin">[in] point on the plane</param>
            <param name="normal">[in] non-zero normal to the plane</param>
            <remarks>
origin = point, zaxis = unitized normal, xaxis
xaxis set with xaxis.PerpindicularTo(zaxis).
</remarks>
            <returns>TRUE if valid plane is created.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.#ctor(System.Double[])">
            <summary>Construct a plane from an equation.</summary>
            <param name="equation">
[in] an array of 4 doubles with one of equation[0], equation[1], or equation[2] being non-zero.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.#ctor(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Construct a plane from three non-colinear points.</summary>
            <param name="origin">[in] point on the plane</param>
            <param name="x_point">[in] second point in the plane. The xaxis will be parallel to x_point-origin.</param>
            <param name="y_point">
[in] third point on the plane that is not colinear with the first two points.
yaxis*(y_point-origin) will be &gt; 0.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.#ctor(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector)">
            <summary>Construct a plane from a point, and two vectors in the plane.</summary>
            <param name="origin">[in] point on the plane</param>
            <param name="x_dir">[in] non-zero vector in the plane that determines the xaxis direction.</param>
            <param name="y_dir">
[in] non-zero vector not parallel to x_dir that is used to determine the yaxis direction.
y_dir does not have to be perpindicular to x_dir.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.#ctor(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector)">
            <summary>Construct a plane from a point and normal vector.</summary>
            <param name="origin">[in] point on the plane</param>
            <param name="normal">[in] non-zero normal to the plane</param>
            <remarks>
origin = point, zaxis = unitized normal, xaxis
xaxis set with xaxis.PerpindicularTo(zaxis).
See Also:
ON_Plane::CreateFromNormal
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.#ctor">
            <summary>
The default constructor creates a plane with orgin=(0,0,0), xaxis=(1,0,0),
yaxis=(0,1,0) zaxis=(0,0,1), and equation=(0,0,1,0).
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnPlane.plane_equation">
            <value>
equation of plane
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnPlane.zaxis">
            <value>
unit Z axis of plane
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnPlane.yaxis">
            <value>
unit Y axis of plane
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnPlane.xaxis">
            <value>
unit X axis of plane
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnPlane.origin">
            <value>
origin of plane
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnPlane.World_xy">
            <value>
world plane coordinate system ON_Plane(ON_origin, ON_xaxis, ON_yaxis);
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlane.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Get point on plane that is closest to a given point.</summary>
            <param name="point">[in]</param>
            <returns>A 3d point on the plane that is closest to world_point.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlane.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@)">
            <summary>Get point on plane that is closest to a given point.</summary>
            <param name="world_point">[in] 3d point</param>
            <param name="u">[out] The point ON_Plane::PointAt(*u,*v) is the point on the plane that is closest to world_point.</param>
            <param name="v">[out] The point ON_Plane::PointAt(*u,*v) is the point on the plane that is closest to world_point.</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlane.GetDistanceToBoundingBox(RMA.OpenNURBS.IOnBoundingBox,System.Double@,System.Double@)">
            <returns>false if plane has zero length normal</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlane.DistanceTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Get signed distance from the plane to a point.</summary>
            <param name="point">[in]</param>
            <returns>Signed distance from a point to a plane.</returns>
            <remarks>
If the point is on the plane, the distance is 0.
If the point is above the plane, the distance is &gt; 0.
If the point is below the plane the distance is &lt; 0.
The zaxis determines the plane's orientation.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlane.IsoLine(System.Int32,System.Double)">
            <summary>Get an isoparameteric line on the plane.</summary>
            <param name="dir">
[in] direction of iso-parametric line
0: first parameter varies and second parameter is constant e.g., line(t) = plane(t,c)
1: first parameter is constant and second parameter varies e.g., line(t) = plane(c,t)
</param>
            <param name="c">[in] value of constant parameter</param>
            <returns>iso-parametric line</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlane.PointAt(System.Double,System.Double,System.Double)">
            <summary>Evaluate a point on the plane</summary>
            <param name="u">[in] evaulation parameters</param>
            <param name="v">[in] evaulation parameters</param>
            <param name="w">[in] elevation parameter</param>
            <returns>plane.origin + u*plane.xaxis + v*plane.yaxis + z*plane.zaxis</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlane.PointAt(System.Double,System.Double)">
            <summary>Evaluate a point on the plane</summary>
            <param name="u">[in] evaulation parameters</param>
            <param name="v">[in] evaulation parameters</param>
            <returns>plane.origin + u*plane.xaxis + v*plane.yaxis</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlane.Normal">
            <summary>
Returns: Plane unit normal.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlane.GetYaxis">
            <summary>
Returns: Plane unit y-axis.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlane.GetXaxis">
            <summary>
Returns: Plane unit x-axis.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlane.GetOrigin">
            <summary>
Returns: Plane origin.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlane.IsValid">
            <summary>Test plane to see if it is valid.</summary>
            <returns>TRUE if all fields contain reasonable information and equation jibes with point and zaxis.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPlane.plane_equation">
            <value>
equation of plane
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPlane.zaxis">
            <value>
unit Z axis of plane
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPlane.yaxis">
            <value>
unit Y axis of plane
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPlane.xaxis">
            <value>
unit X axis of plane
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPlane.origin">
            <value>
origin of plane
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnSpaceMorph.SetPreserveStructure(System.Boolean)">
            <summary>
Set the preserve structure value.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSpaceMorph.PreserveStructure">
            <returns>
True if the morph should be done in a way that preserves the structure of the geometry.
In particular, for NURBS objects, true means that only the control points are moved.
</returns>
            <remarks>
The value returned by PreserveStructure() does not affect the way meshes and
points are morphed. The default is false.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSpaceMorph.SetQuickPreview(System.Boolean)">
            <summary>
Set the quick preview value.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSpaceMorph.QuickPreview">
            <summary>
True if the morph should be done as quickly as possible because the result
is being used for some type of dynamic preview. If QuickPreview is true,
the tolerance may be ignored.
</summary>
            <remarks>
The value returned by QuickPreview() does not affect the way meshes and points are morphed.
The default is false.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSpaceMorph.SetTolerance(System.Double)">
            <summary>Set the 3d fitting tolerance used when morphing surfaces and breps.</summary>
            <param name="tolerance">[in] values &lt; 0.0 are treated as 0.0.</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSpaceMorph.Tolerance">
            <summary>
Returns the desired accuracy of the morph. This value is primarily used for deforming surfaces and breps.
</summary>
            <returns>3d fitting tolerance.</returns>
            <remarks>
The default is 0.0 and any value &lt;= 0.0 is ignored by morphing functions.
The value returned by Tolerance() does not affect the way meshes and points are morphed.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSpaceMorph.MorphVector(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector)">
            <summary>Morphs vector.</summary>
            <param name="tail_point">[in] tail point</param>
            <param name="vector">[in]</param>
            <returns>Morphed vector.</returns>
            <remarks>Default returns difference of morphed tail+vector and tail.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSpaceMorph.MorphPoint(RMA.OpenNURBS.IOn4dPoint)">
            <summary>Morphs rational point.</summary>
            <param name="point">[in]</param>
            <returns>Morphed point.</returns>
            <remarks>Default morphs euclidean location and preserves weight.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSpaceMorph.IsIdentity(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Provides a quick way to determine if a morph function is the identity
(doesn't move the points) on a region of space.
</summary>
            <param name="bbox">[in] region of space to test.</param>
            <returns>
The default always returns false. If you override this function,
then return true when every point in the bounding box is fixed by the morph.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSpaceMorph.Ev1Der(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>Get the first derivative of the morph function.</summary>
            <param name="rst">[in] evalation parameters</param>
            <param name="Dr">[out] (dx/dr, dy/dr, dz/dr)</param>
            <param name="Ds">[out] (dx/ds, dy/ds, dz/ds)</param>
            <param name="Dt">[out] (dx/dt, dy/dt, dz/dt)</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSpaceMorph.MorphPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Morphs euclidean point.</summary>
            <param name="point">[in]</param>
            <returns>Morphed point.</returns>
            <remarks>
If you are morphing simple objects like points and meshes, then you can simply morph the locations.
If you are morphing more complicated objects like NURBS geometry, then your override should pay
attention to the values of m_bQuickPreview, m_bPreserveStructure, and m_tolerance.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSpaceMorph.PreserveStructure">
            <returns>
True if the morph should be done in a way that preserves the structure of the geometry.
In particular, for NURBS objects, true means that only the control points are moved.
</returns>
            <remarks>
The value returned by PreserveStructure() does not affect the way meshes and
points are morphed. The default is false.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSpaceMorph.QuickPreview">
            <summary>
True if the morph should be done as quickly as possible because the result
is being used for some type of dynamic preview. If QuickPreview is true,
the tolerance may be ignored.
</summary>
            <remarks>
The value returned by QuickPreview() does not affect the way meshes and points are morphed.
The default is false.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSpaceMorph.Tolerance">
            <summary>
Returns the desired accuracy of the morph. This value is primarily used for deforming surfaces and breps.
</summary>
            <returns>3d fitting tolerance.</returns>
            <remarks>
The default is 0.0 and any value &lt;= 0.0 is ignored by morphing functions.
The value returned by Tolerance() does not affect the way meshes and points are morphed.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSpaceMorph.MorphVector(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector)">
            <summary>Morphs vector.</summary>
            <param name="tail_point">[in] tail point</param>
            <param name="vector">[in]</param>
            <returns>Morphed vector.</returns>
            <remarks>Default returns difference of morphed tail+vector and tail.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSpaceMorph.MorphPoint(RMA.OpenNURBS.IOn4dPoint)">
            <summary>Morphs rational point.</summary>
            <param name="point">[in]</param>
            <returns>Morphed point.</returns>
            <remarks>Default morphs euclidean location and preserves weight.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSpaceMorph.IsIdentity(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Provides a quick way to determine if a morph function is the identity
(doesn't move the points) on a region of space.
</summary>
            <param name="bbox">[in] region of space to test.</param>
            <returns>
The default always returns false. If you override this function,
then return true when every point in the bounding box is fixed by the morph.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSpaceMorph.Ev1Der(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>Get the first derivative of the morph function.</summary>
            <param name="rst">[in] evalation parameters</param>
            <param name="Dr">[out] (dx/dr, dy/dr, dz/dr)</param>
            <param name="Ds">[out] (dx/ds, dy/ds, dz/ds)</param>
            <param name="Dt">[out] (dx/dt, dy/dt, dz/dt)</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSpaceMorph.MorphPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Morphs euclidean point.</summary>
            <param name="point">[in]</param>
            <returns>Morphed point.</returns>
            <remarks>
If you are morphing simple objects like points and meshes, then you can simply morph the locations.
If you are morphing more complicated objects like NURBS geometry, then your override should pay
attention to the values of m_bQuickPreview, m_bPreserveStructure, and m_tolerance.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnLocalizer.IsZero(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Returns: True if localizer is identically zero inside bbox.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLocalizer.Value(System.Double)">
            <summary>Evaluators</summary>
            <param name="distance">[in] Evaluation distance</param>
            <returns>Value of the localizer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLocalizer.Value(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Evaluators</summary>
            <param name="P">[in] Evaluation point</param>
            <returns>Value of the localizer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLocalizer.CreateSphereLocalizer(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double)">
            <summary>
Creates a spherical localizer. If d = distance from the point to the center of the sphere,
then the localizer has the following behavior: 
point distance                    localizer value
d &lt;= r0 &lt; r1 or d &gt;= r0 &gt; r1 0
d &gt;= r1 &gt; r0 or d &lt;= r1 &lt; r0 1 
For values of d between r0 and r1, the localizer smoothly transitions between 0 to 1.
</summary>
            <param name="P">[in] center of sphere</param>
            <param name="r0">[in]see r1</param>
            <param name="r1">
[in] r0 and r1 are radii that control where the localizer is nonzero.
Both r0 and r1 must be postive and the cannot be equal.
If 0 &lt; r0 &lt; r1, then the localizer is zero for points inside the
cylinder of radius r0 and one for points outside the cylinder of radius r1.
If 0 &lt; r1 &lt; r0, then the localizer is one for points inside the
cylinder of radius r1 and zero for points outside the cylinder of radius r0.
</param>
            <returns>True if the input is value and the localizer is initialized.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLocalizer.CreatePlaneLocalizer(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,System.Double,System.Double)">
            <summary>
Creates a planar localizer. If d = signed distance from the point to the plane,
then the localizer has the following behavior:
point distance                    localizer value
d &lt;= h0 &lt; h1 or d &gt;= h0 &gt; h1 0
d &gt;= h1 &gt; h0 or d &lt;= h1 &lt; h0 1
For values of d between h0 and h1, the localizer smoothly transitions between 0 to 1.
</summary>
            <param name="P">[in] point on plane</param>
            <param name="N">[in] normal to plane</param>
            <param name="h0">[in] h0 and h1 are signed distances that control where the localizer is nonzero.</param>
            <param name="h1">[in] h0 and h1 are signed distances that control where the localizer is nonzero.</param>
            <returns>True if the input is value and the localizer is initialized.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLocalizer.CreateCylinderLocalizer(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,System.Double,System.Double)">
            <summary>
Creates a cylindrical localizer. If d = distance from the point to the line, then the
localizer has the following behavior:
point distance                    localizer value
d &lt;= r0 &lt; r1 or d &gt;= r0 &gt; r1 0
d &gt;= r1 &gt; r0 or d &lt;= r1 &lt; r0 1
For values of d between r0 and r1, the localizer smoothly transitions between 0 to 1.
</summary>
            <param name="P">[in] cylinder axis point</param>
            <param name="D">[in] cylinder axis direction</param>
            <param name="r0">[in] see r1</param>
            <param name="r1">
[in] r0 and r1 are radii that control where the localizer is nonzero.
Both r0 and r1 must be postive and the cannot be equal. If 0 &lt; r0 &lt; r1,
then the localizer is zero for points inside the cylinder of radius r0
and one for points outside the cylinder of radius r1. If 0 &lt; r1 &lt; r0,
then the localizer is one for points inside the cylinder of radius r1 and
zero for points outside the cylinder of radius r0.
</param>
            <returns>True if the input is value and the localizer is initialized.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLocalizer.IsZero(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Returns: True if localizer is identically zero inside bbox.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLocalizer.Value(System.Double)">
            <summary>Evaluators</summary>
            <param name="distance">[in] Evaluation distance</param>
            <returns>Value of the localizer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLocalizer.Value(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Evaluators</summary>
            <param name="P">[in] Evaluation point</param>
            <returns>Value of the localizer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.GetLineClipPlaneParamters(RMA.OpenNURBS.IOn4dPoint,RMA.OpenNURBS.IOn4dPoint,System.Double@,System.Double@)">
            <summary>Calculate the interval for the segment of a line that is in the clip plane region.</summary>
            <param name="P0">[in] start point</param>
            <param name="P1">[in] end point</param>
            <param name="t0">[out] start parameter</param>
            <param name="t1">[out] end parameter</param>
            <returns>
True if some portion of the line is visible and
0.0 &lt;= *t0 &lt;= *t1 &lt;= 1.0.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.TransformPoint(RMA.OpenNURBS.IOn3fPoint,RMA.OpenNURBS.On3dPoint@)">
            <summary>Transform a pont and return the clipping information.</summary>
            <param name="P">[in] point ot transform</param>
            <param name="Q">[out] transformed point</param>
            <returns>
0 when the point is in the visible region.
Otherwise the bits are set to indicate which planes clip the intput point.
0x01 left of the view frusturm
0x02 right of the view frustum
0x04 below the view frustum
0x08 above the view frustum
0x10 behind the view frustum (too far)
0x20 in front of the view frustum (too near)
0x10 below m_clip_plane[0]
0x20 below m_clip_plane[1]
...
0x40000000 below m_clip_plane[24]
0x80000000 transformation created a non-positive weight
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.TransformPoint(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.On3dPoint@)">
            <summary>Transform a pont and return the clipping information.</summary>
            <param name="P">[in] point ot transform</param>
            <param name="Q">[out] transformed point</param>
            <returns>
0 when the point is in the visible region.
Otherwise the bits are set to indicate which planes clip the intput point.
0x01 left of the view frusturm
0x02 right of the view frustum
0x04 below the view frustum
0x08 above the view frustum
0x10 behind the view frustum (too far)
0x20 in front of the view frustum (too near)
0x10 below m_clip_plane[0]
0x20 below m_clip_plane[1]
...
0x40000000 below m_clip_plane[24]
0x80000000 transformation created a non-positive weight
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.TransformPoint(RMA.OpenNURBS.IOn4dPoint,RMA.OpenNURBS.On4dPoint@)">
            <summary>Transform a pont and return the clipping information.</summary>
            <param name="P">[in] point ot transform</param>
            <param name="Q">[out] transformed point</param>
            <returns>
0 when the point is in the visible region.
Otherwise the bits are set to indicate which planes clip the intput point.
0x01 left of the view frusturm
0x02 right of the view frustum
0x04 below the view frustum
0x08 above the view frustum
0x10 behind the view frustum (too far)
0x20 in front of the view frustum (too near)
0x10 below m_clip_plane[0]
0x20 below m_clip_plane[1]
...
0x40000000 below m_clip_plane[24]
0x80000000 transformation created a non-positive weight
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.IsVisible(RMA.OpenNURBS.IArrayOn4dPoint)">
            <summary>
The "visible area" is the intersection of the view frustum, defined by m_xform,
and the clipping region, defined by the m_clip_plane[] array. These functions determing
if some portion of the convex hull of the test points is visible.
</summary>
            <returns>
0 = no part of the object is in the region.
1 = a portion of the object is in the region
2 = entire object is in clipping region
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.IsVisible(RMA.OpenNURBS.IArrayOn3dPoint)">
            <summary>
The "visible area" is the intersection of the view frustum, defined by m_xform,
and the clipping region, defined by the m_clip_plane[] array. These functions determing
if some portion of the convex hull of the test points is visible.
</summary>
            <returns>
0 = no part of the object is in the region.
1 = a portion of the object is in the region
2 = entire object is in clipping region
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.IsVisible(RMA.OpenNURBS.IArrayOn3fPoint)">
            <summary>
The "visible area" is the intersection of the view frustum, defined by m_xform,
and the clipping region, defined by the m_clip_plane[] array. These functions determing
if some portion of the convex hull of the test points is visible.
</summary>
            <returns>
0 = no part of the object is in the region.
1 = a portion of the object is in the region
2 = entire object is in clipping region
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.IsVisible(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
The "visible area" is the intersection of the view frustum, defined by m_xform,
and the clipping region, defined by the m_clip_plane[] array. These functions determing
if some portion of the convex hull of the test points is visible.
</summary>
            <param name="bbox">[in] bounding box</param>
            <returns>
0 = no part of the object is in the region.
1 = a portion of the object is in the region
2 = entire object is in clipping region
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.IsVisible(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
The "visible area" is the intersection of the view frustum, defined by m_xform,
and the clipping region, defined by the m_clip_plane[] array. These functions determing
if some portion of the convex hull of the test points is visible.
</summary>
            <param name="P">[in] point</param>
            <returns>
0 = no part of the object is in the region.
1 = a portion of the object is in the region
2 = entire object is in clipping region
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.InClipPlaneRegion(RMA.OpenNURBS.IArrayOn4dPoint)">
            <summary>
The "clip plane region" is the convex hull of the planes in the m_clip_plane[] array.
These functions determine if some portion of the convex hull of the test points is inside the
clip plane region.
</summary>
            <returns>
0 = No part of the of the convex hull of the tested points is in the clip plane region.
1 = A portion of the convex hull of the tested points may be in the clip plane region.
2 = The entire convex hull of the tested points is in the clip plane region.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.InClipPlaneRegion(RMA.OpenNURBS.IArrayOn3dPoint)">
            <summary>
The "clip plane region" is the convex hull of the planes in the m_clip_plane[] array.
These functions determine if some portion of the convex hull of the test points is inside the
clip plane region.
</summary>
            <returns>
0 = No part of the of the convex hull of the tested points is in the clip plane region.
1 = A portion of the convex hull of the tested points may be in the clip plane region.
2 = The entire convex hull of the tested points is in the clip plane region.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.InClipPlaneRegion(RMA.OpenNURBS.IArrayOn3fPoint)">
            <summary>
The "clip plane region" is the convex hull of the planes in the m_clip_plane[] array.
These functions determine if some portion of the convex hull of the test points is inside the
clip plane region.
</summary>
            <returns>
0 = No part of the of the convex hull of the tested points is in the clip plane region.
1 = A portion of the convex hull of the tested points may be in the clip plane region.
2 = The entire convex hull of the tested points is in the clip plane region.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.InClipPlaneRegion(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
The "clip plane region" is the convex hull of the planes in the m_clip_plane[] array.
These functions determine if some portion of the convex hull of the test points is inside the
clip plane region.
</summary>
            <param name="bbox">[in] bounding box</param>
            <returns>
0 = No part of the of the convex hull of the tested points is in the clip plane region.
1 = A portion of the convex hull of the tested points may be in the clip plane region.
2 = The entire convex hull of the tested points is in the clip plane region.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.InClipPlaneRegion(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
The "clip plane region" is the convex hull of the planes in the m_clip_plane[] array.
These functions determine if some portion of the convex hull of the test points is inside the
clip plane region.
</summary>
            <param name="P">[in] point</param>
            <returns>
0 = No part of the of the convex hull of the tested points is in the clip plane region.
1 = A portion of the convex hull of the tested points may be in the clip plane region.
2 = The entire convex hull of the tested points is in the clip plane region.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.InViewFrustum(RMA.OpenNURBS.IArrayOn4dPoint)">
            <summary>
The "view frustum" is the frustum the m_xform transformation maps to clipping
coordinate box (-1,+1)^3. These functions determine if some portion of the convex hull
of the test points is inside the view frustum.
</summary>
            <returns>
0 = No part of the of the convex hull of the tested points is in the view frustum.
1 = A portion of the convex hull of the otested points may be in the view frustum.
2 = The entire convex hull of the tested points is in the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.InViewFrustum(RMA.OpenNURBS.IArrayOn3dPoint)">
            <summary>
The "view frustum" is the frustum the m_xform transformation maps to clipping
coordinate box (-1,+1)^3. These functions determine if some portion of the convex hull
of the test points is inside the view frustum.
</summary>
            <returns>
0 = No part of the of the convex hull of the tested points is in the view frustum.
1 = A portion of the convex hull of the otested points may be in the view frustum.
2 = The entire convex hull of the tested points is in the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.InViewFrustum(RMA.OpenNURBS.IArrayOn3fPoint)">
            <summary>
The "view frustum" is the frustum the m_xform transformation maps to clipping
coordinate box (-1,+1)^3. These functions determine if some portion of the convex hull
of the test points is inside the view frustum.
</summary>
            <returns>
0 = No part of the of the convex hull of the tested points is in the view frustum.
1 = A portion of the convex hull of the otested points may be in the view frustum.
2 = The entire convex hull of the tested points is in the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.InViewFrustum(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
The "view frustum" is the frustum the m_xform transformation maps to clipping
coordinate box (-1,+1)^3. These functions determine if some portion of the convex hull
of the test points is inside the view frustum.
</summary>
            <param name="bbox">[in] bounding box</param>
            <returns>
0 = No part of the of the convex hull of the tested points is in the view frustum.
1 = A portion of the convex hull of the otested points may be in the view frustum.
2 = The entire convex hull of the tested points is in the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.InViewFrustum(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
The "view frustum" is the frustum the m_xform transformation maps to clipping
coordinate box (-1,+1)^3. These functions determine if some portion of the convex hull
of the test points is inside the view frustum.
</summary>
            <param name="P">[in] point</param>
            <returns>
0 = No part of the of the convex hull of the tested points is in the view frustum.
1 = A portion of the convex hull of the otested points may be in the view frustum.
2 = The entire convex hull of the tested points is in the view frustum.
</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnClippingRegion.m_clip_plane_count">
            <value>
Up to 25 additional clipping planes in object coordinates.
The convex region that is the intersection of the positive 
side of these planes is the active region.
(0 &lt;= m_clip_plane_count &lt;= max_clip_plane_count)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnClippingRegion.m_xform">
            <value>
The transformation m_xform transforms the view frustum,
in object coordinates to the (-1,+1)^3 clipping 
coordinate box.
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.GetLineClipPlaneParamters(RMA.OpenNURBS.IOn4dPoint,RMA.OpenNURBS.IOn4dPoint,System.Double@,System.Double@)">
            <summary>Calculate the interval for the segment of a line that is in the clip plane region.</summary>
            <param name="P0">[in] start point</param>
            <param name="P1">[in] end point</param>
            <param name="t0">[out] start parameter</param>
            <param name="t1">[out] end parameter</param>
            <returns>
True if some portion of the line is visible and
0.0 &lt;= *t0 &lt;= *t1 &lt;= 1.0.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.TransformPoint(RMA.OpenNURBS.IOn3fPoint,RMA.OpenNURBS.On3dPoint@)">
            <summary>Transform a pont and return the clipping information.</summary>
            <param name="P">[in] point ot transform</param>
            <param name="Q">[out] transformed point</param>
            <returns>
0 when the point is in the visible region.
Otherwise the bits are set to indicate which planes clip the intput point.
0x01 left of the view frusturm
0x02 right of the view frustum
0x04 below the view frustum
0x08 above the view frustum
0x10 behind the view frustum (too far)
0x20 in front of the view frustum (too near)
0x10 below m_clip_plane[0]
0x20 below m_clip_plane[1]
...
0x40000000 below m_clip_plane[24]
0x80000000 transformation created a non-positive weight
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.TransformPoint(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.On3dPoint@)">
            <summary>Transform a pont and return the clipping information.</summary>
            <param name="P">[in] point ot transform</param>
            <param name="Q">[out] transformed point</param>
            <returns>
0 when the point is in the visible region.
Otherwise the bits are set to indicate which planes clip the intput point.
0x01 left of the view frusturm
0x02 right of the view frustum
0x04 below the view frustum
0x08 above the view frustum
0x10 behind the view frustum (too far)
0x20 in front of the view frustum (too near)
0x10 below m_clip_plane[0]
0x20 below m_clip_plane[1]
...
0x40000000 below m_clip_plane[24]
0x80000000 transformation created a non-positive weight
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.TransformPoint(RMA.OpenNURBS.IOn4dPoint,RMA.OpenNURBS.On4dPoint@)">
            <summary>Transform a pont and return the clipping information.</summary>
            <param name="P">[in] point ot transform</param>
            <param name="Q">[out] transformed point</param>
            <returns>
0 when the point is in the visible region.
Otherwise the bits are set to indicate which planes clip the intput point.
0x01 left of the view frusturm
0x02 right of the view frustum
0x04 below the view frustum
0x08 above the view frustum
0x10 behind the view frustum (too far)
0x20 in front of the view frustum (too near)
0x10 below m_clip_plane[0]
0x20 below m_clip_plane[1]
...
0x40000000 below m_clip_plane[24]
0x80000000 transformation created a non-positive weight
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.IsVisible(RMA.OpenNURBS.IArrayOn4dPoint)">
            <summary>
The "visible area" is the intersection of the view frustum, defined by m_xform,
and the clipping region, defined by the m_clip_plane[] array. These functions determing
if some portion of the convex hull of the test points is visible.
</summary>
            <returns>
0 = no part of the object is in the region.
1 = a portion of the object is in the region
2 = entire object is in clipping region
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.IsVisible(RMA.OpenNURBS.IArrayOn3dPoint)">
            <summary>
The "visible area" is the intersection of the view frustum, defined by m_xform,
and the clipping region, defined by the m_clip_plane[] array. These functions determing
if some portion of the convex hull of the test points is visible.
</summary>
            <returns>
0 = no part of the object is in the region.
1 = a portion of the object is in the region
2 = entire object is in clipping region
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.IsVisible(RMA.OpenNURBS.IArrayOn3fPoint)">
            <summary>
The "visible area" is the intersection of the view frustum, defined by m_xform,
and the clipping region, defined by the m_clip_plane[] array. These functions determing
if some portion of the convex hull of the test points is visible.
</summary>
            <returns>
0 = no part of the object is in the region.
1 = a portion of the object is in the region
2 = entire object is in clipping region
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.IsVisible(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
The "visible area" is the intersection of the view frustum, defined by m_xform,
and the clipping region, defined by the m_clip_plane[] array. These functions determing
if some portion of the convex hull of the test points is visible.
</summary>
            <param name="bbox">[in] bounding box</param>
            <returns>
0 = no part of the object is in the region.
1 = a portion of the object is in the region
2 = entire object is in clipping region
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.IsVisible(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
The "visible area" is the intersection of the view frustum, defined by m_xform,
and the clipping region, defined by the m_clip_plane[] array. These functions determing
if some portion of the convex hull of the test points is visible.
</summary>
            <param name="P">[in] point</param>
            <returns>
0 = no part of the object is in the region.
1 = a portion of the object is in the region
2 = entire object is in clipping region
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.InClipPlaneRegion(RMA.OpenNURBS.IArrayOn4dPoint)">
            <summary>
The "clip plane region" is the convex hull of the planes in the m_clip_plane[] array.
These functions determine if some portion of the convex hull of the test points is inside the
clip plane region.
</summary>
            <returns>
0 = No part of the of the convex hull of the tested points is in the clip plane region.
1 = A portion of the convex hull of the tested points may be in the clip plane region.
2 = The entire convex hull of the tested points is in the clip plane region.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.InClipPlaneRegion(RMA.OpenNURBS.IArrayOn3dPoint)">
            <summary>
The "clip plane region" is the convex hull of the planes in the m_clip_plane[] array.
These functions determine if some portion of the convex hull of the test points is inside the
clip plane region.
</summary>
            <returns>
0 = No part of the of the convex hull of the tested points is in the clip plane region.
1 = A portion of the convex hull of the tested points may be in the clip plane region.
2 = The entire convex hull of the tested points is in the clip plane region.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.InClipPlaneRegion(RMA.OpenNURBS.IArrayOn3fPoint)">
            <summary>
The "clip plane region" is the convex hull of the planes in the m_clip_plane[] array.
These functions determine if some portion of the convex hull of the test points is inside the
clip plane region.
</summary>
            <returns>
0 = No part of the of the convex hull of the tested points is in the clip plane region.
1 = A portion of the convex hull of the tested points may be in the clip plane region.
2 = The entire convex hull of the tested points is in the clip plane region.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.InClipPlaneRegion(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
The "clip plane region" is the convex hull of the planes in the m_clip_plane[] array.
These functions determine if some portion of the convex hull of the test points is inside the
clip plane region.
</summary>
            <param name="bbox">[in] bounding box</param>
            <returns>
0 = No part of the of the convex hull of the tested points is in the clip plane region.
1 = A portion of the convex hull of the tested points may be in the clip plane region.
2 = The entire convex hull of the tested points is in the clip plane region.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.InClipPlaneRegion(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
The "clip plane region" is the convex hull of the planes in the m_clip_plane[] array.
These functions determine if some portion of the convex hull of the test points is inside the
clip plane region.
</summary>
            <param name="P">[in] point</param>
            <returns>
0 = No part of the of the convex hull of the tested points is in the clip plane region.
1 = A portion of the convex hull of the tested points may be in the clip plane region.
2 = The entire convex hull of the tested points is in the clip plane region.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.InViewFrustum(RMA.OpenNURBS.IArrayOn4dPoint)">
            <summary>
The "view frustum" is the frustum the m_xform transformation maps to clipping
coordinate box (-1,+1)^3. These functions determine if some portion of the convex hull
of the test points is inside the view frustum.
</summary>
            <returns>
0 = No part of the of the convex hull of the tested points is in the view frustum.
1 = A portion of the convex hull of the otested points may be in the view frustum.
2 = The entire convex hull of the tested points is in the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.InViewFrustum(RMA.OpenNURBS.IArrayOn3dPoint)">
            <summary>
The "view frustum" is the frustum the m_xform transformation maps to clipping
coordinate box (-1,+1)^3. These functions determine if some portion of the convex hull
of the test points is inside the view frustum.
</summary>
            <returns>
0 = No part of the of the convex hull of the tested points is in the view frustum.
1 = A portion of the convex hull of the otested points may be in the view frustum.
2 = The entire convex hull of the tested points is in the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.InViewFrustum(RMA.OpenNURBS.IArrayOn3fPoint)">
            <summary>
The "view frustum" is the frustum the m_xform transformation maps to clipping
coordinate box (-1,+1)^3. These functions determine if some portion of the convex hull
of the test points is inside the view frustum.
</summary>
            <returns>
0 = No part of the of the convex hull of the tested points is in the view frustum.
1 = A portion of the convex hull of the otested points may be in the view frustum.
2 = The entire convex hull of the tested points is in the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.InViewFrustum(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
The "view frustum" is the frustum the m_xform transformation maps to clipping
coordinate box (-1,+1)^3. These functions determine if some portion of the convex hull
of the test points is inside the view frustum.
</summary>
            <param name="bbox">[in] bounding box</param>
            <returns>
0 = No part of the of the convex hull of the tested points is in the view frustum.
1 = A portion of the convex hull of the otested points may be in the view frustum.
2 = The entire convex hull of the tested points is in the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.InViewFrustum(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
The "view frustum" is the frustum the m_xform transformation maps to clipping
coordinate box (-1,+1)^3. These functions determine if some portion of the convex hull
of the test points is inside the view frustum.
</summary>
            <param name="P">[in] point</param>
            <returns>
0 = No part of the of the convex hull of the tested points is in the view frustum.
1 = A portion of the convex hull of the otested points may be in the view frustum.
2 = The entire convex hull of the tested points is in the view frustum.
</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnClippingRegion.m_clip_plane_count">
            <value>
Up to 25 additional clipping planes in object coordinates.
The convex region that is the intersection of the positive 
side of these planes is the active region.
(0 &lt;= m_clip_plane_count &lt;= max_clip_plane_count)
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnClippingRegion.m_xform">
            <value>
The transformation m_xform transforms the view frustum,
in object coordinates to the (-1,+1)^3 clipping 
coordinate box.
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.IntervalChange(System.Int32,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Calculates the transformation that linearly maps old_interval to new_interval.</summary>
            <param name="dir">[in] 0 = x, 1 = y, 2= z;</param>
            <param name="old_interval">[in]</param>
            <param name="new_interval">[in]</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.ScreenToClip(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
Computes transform that maps the screen box
   (left,right) X (bottom,top) X (near,far)

to the clipping box 
   -1&lt;x&lt;1,-1&lt;y&lt;1,-1&lt;z&lt;1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.ClipToScreen(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
Computes transform that maps the clipping box 
    -1&lt;x&lt;1,-1&lt;y&lt;1,-1&lt;z&lt;1 
to the screen box
    (left,right) X (bottom,top) X (near,far)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.ClipToCamera(System.Boolean,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
maps -1 &lt;= x,y,z &lt;= 1 box to viewport frustum
</summary>
            <param name="perspective">true for perspective, false for orthographic</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.CameraToClip(System.Boolean,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
maps viewport frustum to -1 &lt;= x,y,z &lt;= 1 box
</summary>
            <param name="perspective">true for perspective, false for orthographic</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.CameraToWorld(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector)">
            <summary>standard viewing transformations</summary>
            <param name="cam_x">unit CameraX vector (right)</param>
            <param name="cam_y">unit CameraY vector (up)</param>
            <param name="cam_z">unit CameraZ vector (from screen to camera)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.WorldToCamera(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector)">
            <summary>standard viewing transformations</summary>
            <param name="cam_x">unit CameraX vector (right)</param>
            <param name="cam_y">unit CameraY vector (up)</param>
            <param name="cam_z">unit CameraZ vector (from screen to camera)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.ChangeBasis(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector)">
            <summary>Get a change of basis transformation.</summary>
            <param name="P0">initial center</param>
            <param name="X0">initial basis X (X0,Y0,Z0 can be any 3d basis)</param>
            <param name="Y0">initial basis Y</param>
            <param name="Z0">initial basis Z</param>
            <param name="P1">final center</param>
            <param name="X1">final basis X (X1,Y1,Z1 can be any 3d basis)</param>
            <param name="Y1">final basis Y</param>
            <param name="Z1">final basis Z</param>
            <remarks>
Change of basis transformations and rotation transformations
are often confused.  This is a change of basis transformation.
If Q = P0 + a0*X0 + b0*Y0 + c0*Z0 = P1 + a1*X1 + b1*Y1 + c1*Z1
then this transform will map the point (a0,b0,c0) to (a1,b1,c1)
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.ChangeBasis(RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector)">
            <summary>Get a change of basis transformation.</summary>
            <param name="X0">initial basis X (X0,Y0,Z0 can be any 3d basis)</param>
            <param name="Y0">initial basis Y</param>
            <param name="Z0">initial basis Z</param>
            <param name="X1">final basis X (X1,Y1,Z1 can be any 3d basis)</param>
            <param name="Y1">final basis Y</param>
            <param name="Z1">final basis Z</param>
            <remarks>
Change of basis transformations and rotation transformations
are often confused.  This is a change of basis transformation.
If Q = a0*X0 + b0*Y0 + c0*Z0 = a1*X1 + b1*Y1 + c1*Z1
then this transform will map the point (a0,b0,c0) to (a1,b1,c1)
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.ChangeBasis(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.IOnPlane)">
            <summary>compute a change of basis transformation.</summary>
            <param name="plane0">inital plane</param>
            <param name="plane1">final plane</param>
            <returns>
 true    success
 false   vectors for initial frame are not a basis
</returns>
            <remarks>
If you have points defined with respect to planes, the
version of ChangeBasis() that takes two planes computes
the transformation to change coordinates from one plane to 
another.  The predefined world plane ON_world_plane can
be used as an argument.
If P = plane0.Evaluate( a0,b0,c0 ) and 
(a1,b1,c1) = ChangeBasis(plane0,plane1)*ON_3dPoint(a0,b0,c0),
then P = plane1.Evaluate( a1, b1, c1 )
        
The version of ChangeBasis() that takes six vectors
maps (a0,b0,c0) to (a1,b1,c1) where
a0*X0 + b0*Y0 + c0*Z0 = a1*X1 + b1*Y1 + c1*Z1
The version of ChangeBasis() that takes six vectors
with center points
maps (a0,b0,c0) to (a1,b1,c1) where
P0 + a0*X0 + b0*Y0 + c0*Z0 = P1 + a1*X1 + b1*Y1 + c1*Z1
The change of basis transformation is not the same as
the rotation transformation that rotates one orthonormal
frame to another.  See ON_Xform::Rotation().
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Mirror(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector)">
            <summary>Create mirror transformation matrix.</summary>
            <param name="point_on_mirror_plane">[in] point on mirror plane</param>
            <param name="normal_to_mirror_plane">[in] normal to mirror plane</param>
            <remarks>
The mirror transform maps a point Q to
Q - (2*(Q-P)oN)*N, where
P = point_on_mirror_plane and N = normal_to_mirror_plane.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Rotation(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.IOnPlane)">
            <summary>Create rotation transformation that maps plane0 to plane1.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Rotation(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector)">
            <param name="P0">initial frame center</param>
            <param name="X0">initial frame X</param>
            <param name="Y0">initial frame Y</param>
            <param name="Z0">initial frame Z</param>
            <param name="P1">initial frame center</param>
            <param name="X1">final frame X</param>
            <param name="Y1">final frame Y</param>
            <param name="Z1">final frame Z</param>
            <remarks>
In the overloads that take frames, the frames should 
be right hand orthonormal frames 
(unit vectors with Z = X x Y).  
The resulting rotation fixes
the origin (0,0,0), maps initial X to 
final X, initial Y to final Y, and initial Z to final Z.

In the overload that takes frames with center points, 
if the initial and final center are equal, then that 
center point is the fixed point of the rotation.  If 
the initial and final point differ, then the resulting
transform is the composition of a rotation fixing P0
and translation from P0 to P1.  The resulting 
transformation maps P0 to P1, P0+X0 to P1+X1, ...
The rotation transformations that map frames to frames
are not the same as the change of basis transformations
for those frames.  See ON_Xform::ChangeBasis().
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Rotation(RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector)">
            <param name="X0">initial frame X</param>
            <param name="Y0">initial frame Y</param>
            <param name="Z0">initial frame Z</param>
            <param name="X1">final frame X</param>
            <param name="Y1">final frame Y</param>
            <param name="Z1">final frame Z</param>
            <remarks>
In the overloads that take frames, the frames should 
be right hand orthonormal frames 
(unit vectors with Z = X x Y).  
The resulting rotation fixes
the origin (0,0,0), maps initial X to 
final X, initial Y to final Y, and initial Z to final Z.

In the overload that takes frames with center points, 
if the initial and final center are equal, then that 
center point is the fixed point of the rotation.  If 
the initial and final point differ, then the resulting
transform is the composition of a rotation fixing P0
and translation from P0 to P1.  The resulting 
transformation maps P0 to P1, P0+X0 to P1+X1, ...
The rotation transformations that map frames to frames
are not the same as the change of basis transformations
for those frames.  See ON_Xform::ChangeBasis().
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Rotation(RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Calculate the minimal transformation that rotates start_dir to end_dir while fixing rotation_center.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Rotation(System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
The Rotation() function is overloaded and provides several
ways to compute a rotation transformation.  A positive
rotation angle indicates a counter-clockwise (right hand rule)
rotation about the axis of rotation.
</summary>
            <param name="angle_radians">rotation angle in radians</param>
            <param name="rotation_axis">3d unit axis of rotation</param>
            <param name="rotation_center">3d center of rotation</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Rotation(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
The Rotation() function is overloaded and provides several
ways to compute a rotation transformation.  A positive
rotation angle indicates a counter-clockwise (right hand rule)
rotation about the axis of rotation.
</summary>
            <param name="sin_angle">sin(rotation angle)</param>
            <param name="cos_angle">cos(rotation angle)</param>
            <param name="rotation_axis">3d unit axis of rotation</param>
            <param name="rotation_center">3d center of rotation</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.PlanarProjection(RMA.OpenNURBS.IOnPlane)">
            <summary>Get transformation that projects to a plane</summary>
            <remarks>
This transformaton maps a 3d point P to the
point plane.ClosestPointTo(Q).
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Translation(System.Double,System.Double,System.Double)">
            <summary>
Right column is (dx, dy, dz, 1).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Translation(RMA.OpenNURBS.IOn3dVector)">
            <summary>
Right column is (d.x, d.y,d.z, 1).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Shear(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector)">
            <summary>Create shear transformation.</summary>
            <param name="plane">[in] plane.origin is the fixed point</param>
            <param name="x1">[in] plane.xaxis scale factor</param>
            <param name="y1">[in] plane.yaxis scale factor</param>
            <param name="z1">[in] plane.zaxis scale factor</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Scale(RMA.OpenNURBS.IOnPlane,System.Double,System.Double,System.Double)">
            <summary>Create non-uniform scale transformation with a specified fixed point.</summary>
            <param name="plane">[in] plane.origin is the fixed point</param>
            <param name="x_scale_factor">[in] plane.xaxis scale factor</param>
            <param name="y_scale_factor">[in] plane.yaxis scale factor</param>
            <param name="z_scale_factor">[in] plane.zaxis scale factor</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Scale(RMA.OpenNURBS.IOn3dPoint,System.Double)">
            <summary>Create uniform scale transformation with a specified fixed point.</summary>
            <param name="fixed_point">[in]</param>
            <param name="scale_factor">[in]</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Scale(RMA.OpenNURBS.IOn3dVector)">
            <summary>Create non-uniform scale transformation with the origin as a fixed point.</summary>
            <param name="scale_vector">[in]</param>
            <remarks>The diagonal is (x_scale_factor, y_scale_factor, z_scale_factor, 1)</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Scale(System.Double,System.Double,System.Double)">
            <summary>Create non-uniform scale transformation with the origin as a fixed point.</summary>
            <param name="x_scale_factor">[in]</param>
            <param name="y_scale_factor">[in]</param>
            <param name="z_scale_factor">[in]</param>
            <remarks>The diagonal is (x_scale_factor, y_scale_factor, z_scale_factor, 1)</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Diagonal(System.Double)">
            <summary>
diagonal 3x3 with bottom row = 0,0,0,1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Identity">
            <summary>
diagonal is (1,1,1,1)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Zero">
            <summary>All zeros including the bottom row.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.ActOnRight(System.Double,System.Double,System.Double,System.Double,RMA.OpenNURBS.On4dPoint@)">
            <summary>
Computes [x,y,z,w] * matrix.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.ActOnLeft(System.Double,System.Double,System.Double,System.Double,RMA.OpenNURBS.On4dPoint@)">
            <summary>
Computes matrix * transpose([x,y,z,w]).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.GetMappingXforms(RMA.OpenNURBS.OnXform@,RMA.OpenNURBS.OnXform@)">
            <summary>
If a texture mapping is applied to an object, the object is subsequently transformed by T,
and the texture mapping needs to be recalculated, then two transforms are required to
recalcalculate the texture mapping.
</summary>
            <param name="P_xform">[out] Transform to apply to points before applying the texture mapping transformation.</param>
            <param name="N_xform">[out] Transform to apply to surface normals before applying the texture mapping transformation.</param>
            <returns>
The determinant of the "this" transformation. If non-zero, "this" is
invertable and P_xform and N_xform were calculated. False if "this" is not invertable,
in which case the returned P_xform and N_xform are the identity.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.GetSurfaceNormalXform(RMA.OpenNURBS.OnXform@)">
            <summary>
When transforming 3d point and surface or mesh normals two different transforms must be used.
If P_xform transforms the point, then the inverse transpose of P_xform must be used to tranform
normal vectors.
</summary>
            <param name="N_xform">[out]</param>
            <returns>
The determinant of the transformation. If non-zero, "this" is invertable
and N_xform can be calculated. False if "this" is not invertable,
in which case the returned N_xform = this with the right hand column and bottom row zeroed out.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Inverse">
            <summary>
If matrix is non-singular, returns inverse, otherwise returns pseudo inverse.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Inverse(System.Double@)">
            <summary>
If matrix is non-singular, returns inverse, otherwise returns pseudo inverse.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Invert">
            <summary>
If matrix is non-singular, returns true, otherwise returns false
and sets matrix to pseudo inverse.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Invert(System.Double@)">
            <summary>
If matrix is non-singular, returns true, otherwise returns false
and sets matrix to pseudo inverse.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Determinant">
            <returns>returns determinant of 4x4 matrix</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Determinant(System.Double@)">
            <returns>returns determinant of 4x4 matrix</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Rank">
            <returns>0 to 4</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Rank(System.Double@)">
            <returns>0 to 4</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Transpose">
            <summary>
transposes 4x4 matrix
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.IsSimilarity">
            <summary>
A similarity transformation can be broken into a sequence of dialations,
translations, rotations, and reflections.
</summary>
            <returns>
+1: This transformation is an orientation preserving similarity.
-1: This transformation is an orientation preserving similarity.
0: This transformation is not a similarity.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.IsZero">
            <returns>
true if matrix is the zero transformation
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 *
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.IsIdentity">
            <returns>
true if matrix is the identity transformation
1 0 0 0
0 1 0 0
0 0 1 0
0 0 0 1
</returns>
            <remarks>
The test for zero is fabs(x) &lt;= zero_tolerance.
The test for one is fabs(x-1) &lt;= zero_tolerance.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.IsIdentity(System.Double)">
            <returns>
true if matrix is the identity transformation
1 0 0 0
0 1 0 0
0 0 1 0
0 0 0 1
</returns>
            <remarks>
The test for zero is fabs(x) &lt;= zero_tolerance.
The test for one is fabs(x-1) &lt;= zero_tolerance.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.IsValid">
            <summary>Test the entries of the transformation matrix to see if they are valid number.</summary>
            <returns>True if ON_IsValid() is true for every number in the transformation matrix.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.op_Multiply(RMA.OpenNURBS.OnXform,RMA.OpenNURBS.IOn2dPoint)">
            <summary>
All non-commutative operations have "this" as left hand side and
argument as right hand side.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.op_Implicit(RMA.OpenNURBS.IOnMatrix)~RMA.OpenNURBS.OnXform">
            <summary>
from upper left 4x4 of an
arbitrary matrix.  Any missing
rows/columns are set to identity.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.#ctor(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector)">
            <summary>
as a frame.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.#ctor(RMA.OpenNURBS.IOnMatrix)">
            <summary>
from standard double m[4][4]
</summary>
            <summary>
from standard float m[4][4]
</summary>
            <summary>
from upper left 4x4 of an arbitrary matrix.  Any missing rows/columns are set to identity. 
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.#ctor(System.Single[])">
            <summary>
from standard float m[4][4]
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.#ctor(System.Double[])">
            <summary>
from standard double m[4][4]
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.#ctor(System.Double)">
            <summary>
diagonal matrix (d,d,d,1)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.#ctor(System.Int32)">
            <summary>
diagonal matrix (d,d,d,1)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.#ctor">
            <summary>
zero matrix
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnXform.m_xform(System.Int32,System.Int32)">
            <value>
[i][j] = row i, column j.  I.e.,
        [0][0] [0][1] [0][2] [0][3]
        [1][0] [1][1] [1][2] [1][3]
        [2][0] [2][1] [2][2] [2][3]
        [3][0] [3][1] [3][2] [3][3]
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXform.ActOnRight(System.Double,System.Double,System.Double,System.Double,RMA.OpenNURBS.On4dPoint@)">
            <summary>
Computes [x,y,z,w] * matrix.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXform.ActOnLeft(System.Double,System.Double,System.Double,System.Double,RMA.OpenNURBS.On4dPoint@)">
            <summary>
Computes matrix * transpose([x,y,z,w]).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXform.GetMappingXforms(RMA.OpenNURBS.OnXform@,RMA.OpenNURBS.OnXform@)">
            <summary>
If a texture mapping is applied to an object, the object is subsequently transformed by T,
and the texture mapping needs to be recalculated, then two transforms are required to
recalcalculate the texture mapping.
</summary>
            <param name="P_xform">[out] Transform to apply to points before applying the texture mapping transformation.</param>
            <param name="N_xform">[out] Transform to apply to surface normals before applying the texture mapping transformation.</param>
            <returns>
The determinant of the "this" transformation. If non-zero, "this" is
invertable and P_xform and N_xform were calculated. False if "this" is not invertable,
in which case the returned P_xform and N_xform are the identity.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXform.GetSurfaceNormalXform(RMA.OpenNURBS.OnXform@)">
            <summary>
When transforming 3d point and surface or mesh normals two different transforms must be used.
If P_xform transforms the point, then the inverse transpose of P_xform must be used to tranform
normal vectors.
</summary>
            <param name="N_xform">[out]</param>
            <returns>
The determinant of the transformation. If non-zero, "this" is invertable
and N_xform can be calculated. False if "this" is not invertable,
in which case the returned N_xform = this with the right hand column and bottom row zeroed out.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXform.Inverse">
            <summary>
If matrix is non-singular, returns inverse, otherwise returns pseudo inverse.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXform.Inverse(System.Double@)">
            <summary>
If matrix is non-singular, returns inverse, otherwise returns pseudo inverse.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXform.Determinant">
            <returns>returns determinant of 4x4 matrix</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXform.Determinant(System.Double@)">
            <returns>returns determinant of 4x4 matrix</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXform.Rank">
            <returns>0 to 4</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXform.Rank(System.Double@)">
            <returns>0 to 4</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXform.IsSimilarity">
            <summary>
A similarity transformation can be broken into a sequence of dialations,
translations, rotations, and reflections.
</summary>
            <returns>
+1: This transformation is an orientation preserving similarity.
-1: This transformation is an orientation preserving similarity.
0: This transformation is not a similarity.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXform.IsZero">
            <returns>
true if matrix is the zero transformation
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 *
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXform.IsIdentity">
            <returns>
true if matrix is the identity transformation
1 0 0 0
0 1 0 0
0 0 1 0
0 0 0 1
</returns>
            <remarks>
The test for zero is fabs(x) &lt;= zero_tolerance.
The test for one is fabs(x-1) &lt;= zero_tolerance.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXform.IsIdentity(System.Double)">
            <returns>
true if matrix is the identity transformation
1 0 0 0
0 1 0 0
0 0 1 0
0 0 0 1
</returns>
            <remarks>
The test for zero is fabs(x) &lt;= zero_tolerance.
The test for one is fabs(x-1) &lt;= zero_tolerance.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXform.IsValid">
            <summary>Test the entries of the transformation matrix to see if they are valid number.</summary>
            <returns>True if ON_IsValid() is true for every number in the transformation matrix.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnXform.m_xform(System.Int32,System.Int32)">
            <value>
[i][j] = row i, column j.  I.e.,
        [0][0] [0][1] [0][2] [0][3]
        [1][0] [1][1] [1][2] [1][3]
        [2][0] [2][1] [2][2] [2][3]
        [3][0] [3][1] [3][2] [3][3]
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.BackSolve(System.Double,System.Int32,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[]@)">
            <summary>
Solve M*X=B where M is upper triangular with a unit diagonal and B is a column of points
</summary>
            <param name="zero_tolerance">
[in] (&gt;=0.0) used to test for "zero" values in B in under determined systems of equations.
</param>
            <param name="pt_dim">[in] dimension of points</param>
            <param name="Bsize">
[in] (&gt;=m_row_count) number of points in B[]. The points correspoinding to indices
m_row_count, ..., (Bsize-1) are tested to make sure they are "zero".
</param>
            <param name="Bpt_stride">[in] stride between B points (&gt;=pt_dim)</param>
            <param name="Bpt">
[in/out] array of m_row_count*Bpt_stride values.
The i-th B point is (Bpt[i*Bpt_stride],...,Bpt[i*Bpt_stride+pt_dim-1]).
</param>
            <param name="Xpt_stride">[in] stride between X points (&gt;=pt_dim)</param>
            <param name="Xpt">
[out] array of m_col_count*Xpt_stride values.
The i-th X point is (Xpt[i*Xpt_stride],...,Xpt[i*Xpt_stride+pt_dim-1]).
</param>
            <remarks>
Actual values M[i][j] with i &lt;= j are ignored. 
M[i][i] is assumed to be one and M[i][j] i&lt;j is assumed to be zero.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.BackSolve(System.Double,System.Int32,RMA.OpenNURBS.ArrayOn3dPoint,RMA.OpenNURBS.ArrayOn3dPoint@)">
            <summary>
Solve M*X=B where M is upper triangular with a unit diagonal and B is a column of 3d points.
</summary>
            <param name="zero_tolerance">
[in] (&gt;=0.0) used to test for "zero" values in B in under determined systems of equations.
</param>
            <param name="Bsize">
[in] (&gt;=m_row_count) length of B.  The values in B[m_row_count],...,B[Bsize-1] are
tested to make sure they are "zero".
</param>
            <param name="B">[in] array of length Bsize.</param>
            <param name="X">[out] array of length m_col_count.  Solutions returned here.</param>
            <remarks>
Actual values M[i][j] with i &lt;= j are ignored. 
M[i][i] is assumed to be one and M[i][j] i&lt;j is assumed to be zero.
For square M, B and X can point to the same memory.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.BackSolve(System.Double,System.Int32,System.Double[],System.Double[]@)">
            <summary>
Solve M*X=B where M is upper triangular with a unit diagonal and B is a column of values.
</summary>
            <param name="zero_tolerance">
[in] (&gt;=0.0) used to test for "zero" values in B in under determined systems of equations.
</param>
            <param name="Bsize">
[in] (&gt;=m_row_count) length of B.  The values in B[m_row_count],...,B[Bsize-1] are
tested to make sure they are "zero".
</param>
            <param name="B">[in] array of length Bsize.</param>
            <param name="X">[out] array of length m_col_count.  Solutions returned here.</param>
            <remarks>
Actual values M[i][j] with i &lt;= j are ignored. 
M[i][i] is assumed to be one and M[i][j] i&lt;j is assumed to be zero.
For square M, B and X can point to the same memory.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.RowReduce(System.Double,System.Int32,System.Int32,System.Double[]@,System.Double@)">
            <summary>
Row reduce a matrix as the first step in solving M*X=B where B is a column arbitrary dimension points.
</summary>
            <param name="zero_tolerance">
[in] (&gt;=0.0) zero tolerance for pivot test
If a the absolute value of a pivot is &lt;= zero_tolerance, then the pivoit is assumed to be zero.
</param>
            <param name="pt_dim">[in] dimension of points</param>
            <param name="pt_stride">[in] stride between points (&gt;=pt_dim)</param>
            <param name="pt">
[in/out] array of m_row_count*pt_stride values.
The i-th point is (pt[i*pt_stride],...,pt[i*pt_stride+pt_dim-1]).
This array of points is row reduced along with the matrix.
</param>
            <param name="pivot">[out] the value of the smallest pivot is returned here</param>
            <returns>Rank of the matrix.</returns>
            <remarks>
The matrix itself is row reduced so that the result is
an upper triangular matrix with 1's on the diagonal.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.RowReduce(System.Double,RMA.OpenNURBS.ArrayOn3dPoint@,System.Double@)">
            <summary>
Row reduce a matrix as the first step in solving M*X=B where B is a column of 3d points
</summary>
            <param name="zero_tolerance">
[in] (&gt;=0.0) zero tolerance for pivot test
If a the absolute value of a pivot is &lt;= zero_tolerance, then the pivot is assumed to be zero.
</param>
            <param name="B">[in/out] an array of m_row_count 3d points that is row reduced with the matrix.</param>
            <param name="pivot">[out] the value of the smallest pivot is returned here</param>
            <returns>Rank of the matrix.</returns>
            <remarks>
The matrix itself is row reduced so that the result is
an upper triangular matrix with 1's on the diagonal.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.RowReduce(System.Double,System.Double[]@,System.Double@)">
            <summary>
Row reduce a matrix as the first step in solving M*X=B where B is a column of values.
</summary>
            <param name="zero_tolerance">
[in] (&gt;=0.0) zero tolerance for pivot test
If a the absolute value of a pivot is &lt;= zero_tolerance, then the pivoit is assumed to be zero.
</param>
            <param name="B">[in/out] an array of m_row_count values that is row reduced with the matrix.</param>
            <param name="pivot">[out] The value of the smallest pivot is returned here</param>
            <returns>Rank of the matrix.</returns>
            <remarks>
The matrix itself is row reduced so that the result is
an upper triangular matrix with 1's on the diagonal.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.RowReduce(System.Double,System.Double@,System.Double@)">
            <summary>Row reduce a matrix to calculate rank and determinant.</summary>
            <param name="zero_tolerance">
[in] (&gt;=0.0) zero tolerance for pivot test
If the absolute value of a pivot is &lt;= zero_tolerance,
then the pivot is assumed to be zero.
</param>
            <param name="determinant">[out] value of determinant is returned here.</param>
            <param name="pivot">[out] value of the smallest pivot is returned here</param>
            <returns>Rank of the matrix.</returns>
            <remarks>
The matrix itself is row reduced so that the result is
an upper triangular matrix with 1's on the diagonal.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.Scale(System.Double)">
            <summary>safe arithmetic</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.Add(RMA.OpenNURBS.IOnMatrix,RMA.OpenNURBS.IOnMatrix)">
            <summary>safe arithmetic</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.Multiply(RMA.OpenNURBS.IOnMatrix,RMA.OpenNURBS.IOnMatrix)">
            <summary>safe arithmetic</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.SwapCols(System.Int32,System.Int32)">
            <summary>
ints are col indices to swap
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.SwapRows(System.Int32,System.Int32)">
            <summary>
ints are row indices to swap
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.SetDiagonal(RMA.OpenNURBS.IArraydouble)">
            <summary>
sets size to length X lengthdiagonal values and zeros off diagonal values
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.SetDiagonal(System.Int32,System.Double[])">
            <summary>sets size to count x count and diagonal values and zeros off diagonal values</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.SetDiagonal(System.Double[])">
            <summary>sets diagonal value and zeros off diagonal values</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.SetDiagonal(System.Double)">
            <summary>sets diagonal value and zeros off diagonal values</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.Create(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
E.g., Create(1,5,1,7) creates a 5x7 sized matrix that with
"top" row = m[1][1],...,m[1][7] and "bottom" row
</summary>
            <param name="row_index0">first valid row index</param>
            <param name="row_index1">last valid row index</param>
            <param name="col_index0">first valid column index</param>
            <param name="col_index1">last valid column index</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.Create(System.Int32,System.Int32)">
            <param name="rows">number of rows</param>
            <param name="columns">number of columns</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.MaxCount">
            <summary>
largest of row and column count
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.MinCount">
            <summary>
smallest of row and column count
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.IsSquare">
            <summary>
returns 0 for no and m_row_count (= m_col_count) for yes
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.EmergencyDestroy">
            <summary>
call if memory pool used matrix by becomes invalid
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>see ON_Matrix::Create(int,int,int,int) for details</summary>
            <param name="row_index0">first valid row index</param>
            <param name="row_index1">last valid row index</param>
            <param name="col_index0">first valid column index</param>
            <param name="col_index1">last valid column index</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.#ctor(System.Int32,System.Int32)">
            <param name="rows">number of rows</param>
            <param name="columns">number of columns</param>
        </member>
        <member name="P:RMA.OpenNURBS.OnMatrix.m(System.Int32,System.Int32)">
            <value>
OnMatrix[i][j] = value at row i and column j
  0 &lt;= i &lt; RowCount()
  0 &lt;= j &lt; ColCount()
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMatrix.BackSolve(System.Double,System.Int32,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[]@)">
            <summary>
Solve M*X=B where M is upper triangular with a unit diagonal and B is a column of points
</summary>
            <param name="zero_tolerance">
[in] (&gt;=0.0) used to test for "zero" values in B in under determined systems of equations.
</param>
            <param name="pt_dim">[in] dimension of points</param>
            <param name="Bsize">
[in] (&gt;=m_row_count) number of points in B[]. The points correspoinding to indices
m_row_count, ..., (Bsize-1) are tested to make sure they are "zero".
</param>
            <param name="Bpt_stride">[in] stride between B points (&gt;=pt_dim)</param>
            <param name="Bpt">
[in/out] array of m_row_count*Bpt_stride values.
The i-th B point is (Bpt[i*Bpt_stride],...,Bpt[i*Bpt_stride+pt_dim-1]).
</param>
            <param name="Xpt_stride">[in] stride between X points (&gt;=pt_dim)</param>
            <param name="Xpt">
[out] array of m_col_count*Xpt_stride values.
The i-th X point is (Xpt[i*Xpt_stride],...,Xpt[i*Xpt_stride+pt_dim-1]).
</param>
            <remarks>
Actual values M[i][j] with i &lt;= j are ignored. 
M[i][i] is assumed to be one and M[i][j] i&lt;j is assumed to be zero.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMatrix.BackSolve(System.Double,System.Int32,RMA.OpenNURBS.ArrayOn3dPoint,RMA.OpenNURBS.ArrayOn3dPoint@)">
            <summary>
Solve M*X=B where M is upper triangular with a unit diagonal and B is a column of 3d points.
</summary>
            <param name="zero_tolerance">
[in] (&gt;=0.0) used to test for "zero" values in B in under determined systems of equations.
</param>
            <param name="Bsize">
[in] (&gt;=m_row_count) length of B.  The values in B[m_row_count],...,B[Bsize-1] are
tested to make sure they are "zero".
</param>
            <param name="B">[in] array of length Bsize.</param>
            <param name="X">[out] array of length m_col_count.  Solutions returned here.</param>
            <remarks>
Actual values M[i][j] with i &lt;= j are ignored. 
M[i][i] is assumed to be one and M[i][j] i&lt;j is assumed to be zero.
For square M, B and X can point to the same memory.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMatrix.BackSolve(System.Double,System.Int32,System.Double[],System.Double[]@)">
            <summary>
Solve M*X=B where M is upper triangular with a unit diagonal and B is a column of values.
</summary>
            <param name="zero_tolerance">
[in] (&gt;=0.0) used to test for "zero" values in B in under determined systems of equations.
</param>
            <param name="Bsize">
[in] (&gt;=m_row_count) length of B.  The values in B[m_row_count],...,B[Bsize-1] are
tested to make sure they are "zero".
</param>
            <param name="B">[in] array of length Bsize.</param>
            <param name="X">[out] array of length m_col_count.  Solutions returned here.</param>
            <remarks>
Actual values M[i][j] with i &lt;= j are ignored. 
M[i][i] is assumed to be one and M[i][j] i&lt;j is assumed to be zero.
For square M, B and X can point to the same memory.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMatrix.MaxCount">
            <summary>
largest of row and column count
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMatrix.MinCount">
            <summary>
smallest of row and column count
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMatrix.IsSquare">
            <summary>
returns 0 for no and m_row_count (= m_col_count) for yes
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMatrix.m(System.Int32,System.Int32)">
            <value>
OnMatrix[i][j] = value at row i and column j
  0 &lt;= i &lt; RowCount()
  0 &lt;= j &lt; ColCount()
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.IsDisjoint(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Test to see if "this" and other_bbox are disjoint (do not intersect).
</summary>
            <param name="other_bbox">[in]</param>
            <returns>True if "this" and other_bbox are disjoint.</returns>
            <remarks>If "this" or other_bbox is invalid, then true is returned.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Union(RMA.OpenNURBS.IOnBoundingBox,RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Union() returns TRUE if union is not empty.
Invalid boxes are treated as the empty set.
this = union of two args
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Union(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Union() returns TRUE if union is not empty.
Invalid boxes are treated as the empty set.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Includes(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>Test a box to see if it is contained in this box</summary>
            <param name="other">[in] box to test</param>
            <returns>
If bProperSubSet is false, then the result is true when
this-&gt;m_min[i] &lt;= other.m_min[i] and other.m_max[i] &lt;= this-&gt;m_max[i]. for i=0,1 and 2.
If bProperSubSet is true, then the result is true when
the above condition is true and at least one of the inequalities is strict.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Includes(RMA.OpenNURBS.IOnBoundingBox,System.Boolean)">
            <summary>Test a box to see if it is contained in this box</summary>
            <param name="other">[in] box to test</param>
            <param name="bProperSubSet">
[in] if true, then the test is for a proper inclusion.
</param>
            <returns>
If bProperSubSet is false, then the result is true when
this-&gt;m_min[i] &lt;= other.m_min[i] and other.m_max[i] &lt;= this-&gt;m_max[i]. for i=0,1 and 2.
If bProperSubSet is true, then the result is true when
the above condition is true and at least one of the inequalities is strict.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Intersection(RMA.OpenNURBS.IOnLine)">
            <summary>Returns TRUE when intersect is non-empty.</summary>
            <param name="line">Infinite Line segment to intersect with </param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Intersection(RMA.OpenNURBS.IOnLine,System.Double@)">
            <summary>Returns TRUE when intersect is non-empty.</summary>
            <param name="line">Infinite Line segment to intersect with </param>
            <param name="t0">parameter of first intersection point</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Intersection(RMA.OpenNURBS.IOnLine,System.Double@,System.Double@)">
            <summary>Returns TRUE when intersect is non-empty.</summary>
            <param name="line">Infinite Line segment to intersect with </param>
            <param name="t0">parameter of first intersection point</param>
            <param name="t1">parameter of last intersection point (t0&lt;=t1)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Intersection(RMA.OpenNURBS.IOnBoundingBox,RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Set "this" to the intersection of bbox_A and bbox_B.
</summary>
            <param name="bbox_A">[in]</param>
            <param name="bbox_B">[in]</param>
            <returns>
True if the "this" is a non-empty valid bounding box.
False if the intersection is empty, in which case "this"
is set to an invalid bounding box.
</returns>
            <remarks>If bbox_A or bbox_B is invalid, they are treated as the empty set, and false is returned.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Intersection(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Intersect this with other_bbox and save intersection in this.
</summary>
            <param name="other_bbox">[in]</param>
            <returns>
True if this-intesect-other_bbox is a non-empty valid bounding box and this is set.
False if the intersection is empty, in which case "this" is set to an invalid bounding box.
</returns>
            <remarks>
If "this" or other_bbox is invalid, they are treated as the empty set, and false is returned.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.GetFarPoint(RMA.OpenNURBS.IOnBoundingBox,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@)">
            <summary>
Get points on bounding boxes that are farthest from each other.
</summary>
            <param name="arg1">other bounding box</param>
            <param name="arg2">point on this box that is farthest from other box</param>
            <param name="arg3">point on other box that is farthest from this box</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.FarPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Point on the box that is farthest from the test_point.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.GetClosestPoint(RMA.OpenNURBS.IOnBoundingBox,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@)">
            <summary>
Get points on bounding boxes that are closest to each other.
If the boxes intersect, then the point at the centroid of the
intersection is returned for both points.
</summary>
            <param name="arg1">other bounding box</param>
            <param name="arg2">point on this box that is closest to other box</param>
            <param name="arg3">point on other box that is closest to this box</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.GetClosestPoint(RMA.OpenNURBS.IOnLine,RMA.OpenNURBS.On3dPoint@,System.Double@,System.Double@)">
            <summary>
Get point in a bounding box that is closest to a line segment.
</summary>
            <param name="line">[in] line segment</param>
            <param name="box_point">[out] point in box that is closest to line segment point at t0.</param>
            <param name="t0">[out] parameter of point on line that is closest to the box.</param>
            <param name="t1">[out] parameter of point on line that is closest to the box.</param>
            <returns>
3 success - line segments intersects box in a segment
           from line(t0) to line(t1) (t0 &lt; t1)
2 success - line segments intersects box in a single point
           at line(t0) (t0==t1)
1 success - line segment does not intersect box.  Closest
           point on the line is at line(t0) (t0==t1)
0 failure - box is invalid.
</returns>
            <remarks>
The box is treated as a solid box.  If the intersection
of the line segment, then 3 is returned.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.IsFartherThan(System.Double,RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Quickly determine if the shortest distance this bounding box to another bounding box is greater than d.
</summary>
            <param name="d">[in] distance (&gt; 0.0)</param>
            <param name="other">[in] other bounding box</param>
            <returns>
True if if the shortest distance from this bounding box to the other bounding box is greater than d.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.IsFartherThan(System.Double,RMA.OpenNURBS.IOnPlaneEquation)">
            <summary>
Quickly determine if the shortest distance from the plane to the bounding box is greater than d.
</summary>
            <param name="d">[in] distance (&gt; 0.0)</param>
            <param name="plane_equation">
[in] (the first three coefficients are assumed to be a unit vector. If not, adjust your d accordingly.)
</param>
            <returns>
True if the shortest distance from the plane to the bounding box is greater than d,
and false if the shortest distance is less than or equal to d.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.IsFartherThan(System.Double,RMA.OpenNURBS.IOnPlane)">
            <summary>
Quickly determine if the shortest distance from the plane to the bounding box is greater than d.
</summary>
            <param name="d">[in] distance (&gt; 0.0)</param>
            <param name="plane">[in]</param>
            <returns>
True if the shortest distance from the plane to the bounding box is greater than d,
and false if the shortest distance is less than or equal to d.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.IsFartherThan(System.Double,RMA.OpenNURBS.IOnLine)">
            <summary>
Quickly determine if the shortest distance from the line to the bounding box is greater than d.
</summary>
            <param name="d">[in] distance (&gt; 0.0)</param>
            <param name="line">[in]</param>
            <returns>
True if the shortest distance from the line to the bounding box is greater than d.
It is not the case that false means that the shortest distance is less than or equal to d.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.IsFartherThan(System.Double,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Quickly determine if the shortest distance from the point P to the bounding box is greater than d.
</summary>
            <param name="d">[in] distance (&gt; 0.0)</param>
            <param name="P">[in]</param>
            <returns>True if if the shortest distance from the point P to the bounding box is greater than d.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.MaximumDistanceTo(RMA.OpenNURBS.IOnPlane)">
            <summary>
Quickly find a tight upper bound on the distance between the plane and this bounding box.
</summary>
            <param name="plane">[in]</param>
            <returns>
A distance that is equal to the longest distance from the plane to this bounding box.
Put another way, if Q is any point on the plane and P is any point in this
bounding box, then P.DistanceTo(Q) &lt;= MaximumDistanceTo(bbox) and there is
at least one point on the bounding box where the distance is equal to the returned value.
See Also: ON_PlaneEquation::MaximumValueAt
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.MaximumDistanceTo(RMA.OpenNURBS.IOnLine)">
            <summary>
Quickly find an upper bound on the distance between the line segment and this bounding box.
</summary>
            <param name="line">[in]</param>
            <returns>
A distance that is greater than or equal to the longest distance from the line to this bounding box.
Put another way, if Q is any point on the line and P is any point in this bounding box,
then P.DistanceTo(Q) &lt;= MaximumDistanceTo(bbox).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.MinimumDistanceTo(RMA.OpenNURBS.IOnPlane)">
            <summary>
Quickly find a tight lower bound on the distance between the plane and this bounding box.
</summary>
            <param name="plane">[in]</param>
            <returns>
The minimum distance between a point on the plane and a point on the bounding box.
See Also: ON_PlaneEquation::MimimumValueAt ON_PlaneEquation::MaximumValueAt
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.MinimumDistanceTo(RMA.OpenNURBS.IOnLine)">
            <summary>
Quickly find a lower bound on the distance between the line segment and this bounding box.
</summary>
            <param name="line">[in]</param>
            <returns>
A distance that is less than or equal to the shortest distance from the line to this bounding box.
Put another way, if Q is any point on line and P is any point in this bounding box,
then P.DistanceTo(Q) &gt;= MinimumDistanceTo(bbox).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.MaximumDistanceTo(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Quickly find an upper bound on the distance between this and the other bounding box.
</summary>
            <param name="other">[in]</param>
            <returns>
A distance that is greater than or equal to the longest distance between the bounding boxes.
Put another way, if Q is any point in this bounding box and P is any point in the other
bounding box, then P.DistanceTo(Q) &lt;= MaximumDistanceTo(bbox).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.MinimumDistanceTo(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Quickly find a lower bound on the distance between this and the other bounding box.
</summary>
            <param name="other">[in]</param>
            <returns>
A distance that is less than or equal to the shortest distance between the bounding boxes.
Put another way, if Q is any point in this bounding box and P is any point in the other
bounding box, then P.DistanceTo(Q) &gt;= MinimumDistanceTo(bbox).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.MaximumDistanceTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Quickly find an upper bound on the distance between the point and this bounding box.
</summary>
            <param name="P">[in]</param>
            <returns>
A distance that is greater than or equal to the longest distance from the point P
to this bounding box. Put another way, if Q is any point in this bounding box,
then P.DistanceTo(Q) &lt;= MaximumDistanceTo(bbox).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.MinimumDistanceTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Quickly find a lower bound on the distance between the point and this bounding box.
</summary>
            <param name="P">[in]</param>
            <returns>
A distance that is less than or equal to the shortest distance from the line to
this bounding box. Put another way, if Q is any point in this bounding box,
then P.DistanceTo(Q) &gt;= MinimumDistanceTo(bbox).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.ClosestPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Point on or in the box that is closest to test_point.
If test_point is in or on the box, the test_point is returned.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.IsPointIn(RMA.OpenNURBS.IOn3dPoint,System.Boolean)">
            <param name="bStrictlyIn">
TRUE to test for strict ( min &lt; point &lt; max )
FALSE to test for (min &lt;= point &lt;= max)
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Set(RMA.OpenNURBS.IArrayOn2dPoint,System.Boolean)">
            <param name="bGrowBox">
If bGrowBox is TRUE, the existing box is expanded, otherwise it is only set to the current point list
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Set(RMA.OpenNURBS.IArrayOn3dPoint,System.Boolean)">
            <param name="bGrowBox">
If bGrowBox is TRUE, the existing box is expanded, otherwise it is only set to the current point list
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Set(RMA.OpenNURBS.IArrayOn4dPoint,System.Boolean)">
            <param name="bGrowBox">
If bGrowBox is TRUE, the existing box is expanded, otherwise it is only set to the current point list
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Set(RMA.OpenNURBS.IOn3dPoint,System.Boolean)">
            <param name="bGrowBox">
If bGrowBox is TRUE, the existing box is expanded, otherwise it is only set to the current point list
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Tolerance">
            <summary>
rough guess at a tolerance to use for comparing objects in this bounding box
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>
ON_BoundingBox::Transform() updates the bounding box
to be the smallest axis aligned bounding box that contains
the transform of the eight corner points of the input
bounding box.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.IsDegenerate">
            <summary>
Test a bounding box to see if it is degenerate (flat) in one or more directions.
</summary>
            <returns>
0 box is not degenerate
1 box is a rectangle (degenerate in one direction)
2 box is a line (degenerate in two directions)
3 box is a point (degenerate in three directions)
4 box is not valid
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.IsDegenerate(System.Double)">
            <summary>
Test a bounding box to see if it is degenerate (flat) in one or more directions.
</summary>
            <param name="tolerance">
[in] Distances &lt;= tolerance will be considered to be zero.
If tolerance is negative (default), then a scale invarient tolerance is used.
</param>
            <returns>
0 box is not degenerate
1 box is a rectangle (degenerate in one direction)
2 box is a line (degenerate in two directions)
3 box is a point (degenerate in three directions)
4 box is not valid
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.IsValid">
            <summary>
empty boxes are not valid
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.GetCorners(RMA.OpenNURBS.On3dPointArray@)">
            <summary>returns list of 8 corner points</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Corner(System.Int32,System.Int32,System.Int32)">
            <summary>8 corners of box</summary>
            <param name="x_index">0 = Min().x, 1 = Max().x</param>
            <param name="y_index">0 = Min().y, 1 = Max().y</param>
            <param name="z_index">0 = Min().z, 1 = Max().z</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Diagonal">
            <summary>
max corner - min corner
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Destroy">
            <summary>
invalidates bounding box
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.IsVisible(RMA.OpenNURBS.IOnXform)">
            <summary>
temporary - use ON_ClippingRegion - this function will be removed soon.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.#ctor(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <param name="min">min corner of axis aligned bounding box</param>
            <param name="max">max corner of axis aligned bounding box</param>
        </member>
        <member name="T:RMA.OpenNURBS.OnBoundingBox">
            <summary>axis aligned bounding box</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.IsDisjoint(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Test to see if "this" and other_bbox are disjoint (do not intersect).
</summary>
            <param name="other_bbox">[in]</param>
            <returns>True if "this" and other_bbox are disjoint.</returns>
            <remarks>If "this" or other_bbox is invalid, then true is returned.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.Includes(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>Test a box to see if it is contained in this box</summary>
            <param name="other">[in] box to test</param>
            <returns>
If bProperSubSet is false, then the result is true when
this-&gt;m_min[i] &lt;= other.m_min[i] and other.m_max[i] &lt;= this-&gt;m_max[i]. for i=0,1 and 2.
If bProperSubSet is true, then the result is true when
the above condition is true and at least one of the inequalities is strict.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.Includes(RMA.OpenNURBS.IOnBoundingBox,System.Boolean)">
            <summary>Test a box to see if it is contained in this box</summary>
            <param name="other">[in] box to test</param>
            <param name="bProperSubSet">
[in] if true, then the test is for a proper inclusion.
</param>
            <returns>
If bProperSubSet is false, then the result is true when
this-&gt;m_min[i] &lt;= other.m_min[i] and other.m_max[i] &lt;= this-&gt;m_max[i]. for i=0,1 and 2.
If bProperSubSet is true, then the result is true when
the above condition is true and at least one of the inequalities is strict.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.Intersection(RMA.OpenNURBS.IOnLine)">
            <summary>Returns TRUE when intersect is non-empty.</summary>
            <param name="line">Infinite Line segment to intersect with </param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.Intersection(RMA.OpenNURBS.IOnLine,System.Double@)">
            <summary>Returns TRUE when intersect is non-empty.</summary>
            <param name="line">Infinite Line segment to intersect with </param>
            <param name="t0">parameter of first intersection point</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.Intersection(RMA.OpenNURBS.IOnLine,System.Double@,System.Double@)">
            <summary>Returns TRUE when intersect is non-empty.</summary>
            <param name="line">Infinite Line segment to intersect with </param>
            <param name="t0">parameter of first intersection point</param>
            <param name="t1">parameter of last intersection point (t0&lt;=t1)</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.GetFarPoint(RMA.OpenNURBS.IOnBoundingBox,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@)">
            <summary>
Get points on bounding boxes that are farthest from each other.
</summary>
            <param name="arg1">other bounding box</param>
            <param name="arg2">point on this box that is farthest from other box</param>
            <param name="arg3">point on other box that is farthest from this box</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.FarPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Point on the box that is farthest from the test_point.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.GetClosestPoint(RMA.OpenNURBS.IOnBoundingBox,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@)">
            <summary>
Get points on bounding boxes that are closest to each other.
If the boxes intersect, then the point at the centroid of the
intersection is returned for both points.
</summary>
            <param name="arg1">other bounding box</param>
            <param name="arg2">point on this box that is closest to other box</param>
            <param name="arg3">point on other box that is closest to this box</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.GetClosestPoint(RMA.OpenNURBS.IOnLine,RMA.OpenNURBS.On3dPoint@,System.Double@,System.Double@)">
            <summary>
Get point in a bounding box that is closest to a line segment.
</summary>
            <param name="line">[in] line segment</param>
            <param name="box_point">[out] point in box that is closest to line segment point at t0.</param>
            <param name="t0">[out] parameter of point on line that is closest to the box.</param>
            <param name="t1">[out] parameter of point on line that is closest to the box.</param>
            <returns>
3 success - line segments intersects box in a segment
           from line(t0) to line(t1) (t0 &lt; t1)
2 success - line segments intersects box in a single point
           at line(t0) (t0==t1)
1 success - line segment does not intersect box.  Closest
           point on the line is at line(t0) (t0==t1)
0 failure - box is invalid.
</returns>
            <remarks>
The box is treated as a solid box.  If the intersection
of the line segment, then 3 is returned.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.IsFartherThan(System.Double,RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Quickly determine if the shortest distance this bounding box to another bounding box is greater than d.
</summary>
            <param name="d">[in] distance (&gt; 0.0)</param>
            <param name="other">[in] other bounding box</param>
            <returns>
True if if the shortest distance from this bounding box to the other bounding box is greater than d.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.IsFartherThan(System.Double,RMA.OpenNURBS.IOnPlaneEquation)">
            <summary>
Quickly determine if the shortest distance from the plane to the bounding box is greater than d.
</summary>
            <param name="d">[in] distance (&gt; 0.0)</param>
            <param name="plane_equation">
[in] (the first three coefficients are assumed to be a unit vector. If not, adjust your d accordingly.)
</param>
            <returns>
True if the shortest distance from the plane to the bounding box is greater than d,
and false if the shortest distance is less than or equal to d.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.IsFartherThan(System.Double,RMA.OpenNURBS.IOnPlane)">
            <summary>
Quickly determine if the shortest distance from the plane to the bounding box is greater than d.
</summary>
            <param name="d">[in] distance (&gt; 0.0)</param>
            <param name="plane">[in]</param>
            <returns>
True if the shortest distance from the plane to the bounding box is greater than d,
and false if the shortest distance is less than or equal to d.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.IsFartherThan(System.Double,RMA.OpenNURBS.IOnLine)">
            <summary>
Quickly determine if the shortest distance from the line to the bounding box is greater than d.
</summary>
            <param name="d">[in] distance (&gt; 0.0)</param>
            <param name="line">[in]</param>
            <returns>
True if the shortest distance from the line to the bounding box is greater than d.
It is not the case that false means that the shortest distance is less than or equal to d.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.IsFartherThan(System.Double,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Quickly determine if the shortest distance from the point P to the bounding box is greater than d.
</summary>
            <param name="d">[in] distance (&gt; 0.0)</param>
            <param name="P">[in]</param>
            <returns>True if if the shortest distance from the point P to the bounding box is greater than d.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.MaximumDistanceTo(RMA.OpenNURBS.IOnPlane)">
            <summary>
Quickly find a tight upper bound on the distance between the plane and this bounding box.
</summary>
            <param name="plane">[in]</param>
            <returns>
A distance that is equal to the longest distance from the plane to this bounding box.
Put another way, if Q is any point on the plane and P is any point in this
bounding box, then P.DistanceTo(Q) &lt;= MaximumDistanceTo(bbox) and there is
at least one point on the bounding box where the distance is equal to the returned value.
See Also: ON_PlaneEquation::MaximumValueAt
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.MaximumDistanceTo(RMA.OpenNURBS.IOnLine)">
            <summary>
Quickly find an upper bound on the distance between the line segment and this bounding box.
</summary>
            <param name="line">[in]</param>
            <returns>
A distance that is greater than or equal to the longest distance from the line to this bounding box.
Put another way, if Q is any point on the line and P is any point in this bounding box,
then P.DistanceTo(Q) &lt;= MaximumDistanceTo(bbox).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.MinimumDistanceTo(RMA.OpenNURBS.IOnPlane)">
            <summary>
Quickly find a tight lower bound on the distance between the plane and this bounding box.
</summary>
            <param name="plane">[in]</param>
            <returns>
The minimum distance between a point on the plane and a point on the bounding box.
See Also: ON_PlaneEquation::MimimumValueAt ON_PlaneEquation::MaximumValueAt
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.MinimumDistanceTo(RMA.OpenNURBS.IOnLine)">
            <summary>
Quickly find a lower bound on the distance between the line segment and this bounding box.
</summary>
            <param name="line">[in]</param>
            <returns>
A distance that is less than or equal to the shortest distance from the line to this bounding box.
Put another way, if Q is any point on line and P is any point in this bounding box,
then P.DistanceTo(Q) &gt;= MinimumDistanceTo(bbox).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.MaximumDistanceTo(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Quickly find an upper bound on the distance between this and the other bounding box.
</summary>
            <param name="other">[in]</param>
            <returns>
A distance that is greater than or equal to the longest distance between the bounding boxes.
Put another way, if Q is any point in this bounding box and P is any point in the other
bounding box, then P.DistanceTo(Q) &lt;= MaximumDistanceTo(bbox).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.MinimumDistanceTo(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Quickly find a lower bound on the distance between this and the other bounding box.
</summary>
            <param name="other">[in]</param>
            <returns>
A distance that is less than or equal to the shortest distance between the bounding boxes.
Put another way, if Q is any point in this bounding box and P is any point in the other
bounding box, then P.DistanceTo(Q) &gt;= MinimumDistanceTo(bbox).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.MaximumDistanceTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Quickly find an upper bound on the distance between the point and this bounding box.
</summary>
            <param name="P">[in]</param>
            <returns>
A distance that is greater than or equal to the longest distance from the point P
to this bounding box. Put another way, if Q is any point in this bounding box,
then P.DistanceTo(Q) &lt;= MaximumDistanceTo(bbox).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.MinimumDistanceTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Quickly find a lower bound on the distance between the point and this bounding box.
</summary>
            <param name="P">[in]</param>
            <returns>
A distance that is less than or equal to the shortest distance from the line to
this bounding box. Put another way, if Q is any point in this bounding box,
then P.DistanceTo(Q) &gt;= MinimumDistanceTo(bbox).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.ClosestPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Point on or in the box that is closest to test_point.
If test_point is in or on the box, the test_point is returned.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.IsPointIn(RMA.OpenNURBS.IOn3dPoint,System.Boolean)">
            <param name="bStrictlyIn">
TRUE to test for strict ( min &lt; point &lt; max )
FALSE to test for (min &lt;= point &lt;= max)
</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.Tolerance">
            <summary>
rough guess at a tolerance to use for comparing objects in this bounding box
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.IsDegenerate">
            <summary>
Test a bounding box to see if it is degenerate (flat) in one or more directions.
</summary>
            <returns>
0 box is not degenerate
1 box is a rectangle (degenerate in one direction)
2 box is a line (degenerate in two directions)
3 box is a point (degenerate in three directions)
4 box is not valid
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.IsDegenerate(System.Double)">
            <summary>
Test a bounding box to see if it is degenerate (flat) in one or more directions.
</summary>
            <param name="tolerance">
[in] Distances &lt;= tolerance will be considered to be zero.
If tolerance is negative (default), then a scale invarient tolerance is used.
</param>
            <returns>
0 box is not degenerate
1 box is a rectangle (degenerate in one direction)
2 box is a line (degenerate in two directions)
3 box is a point (degenerate in three directions)
4 box is not valid
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.IsValid">
            <summary>
empty boxes are not valid
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.GetCorners(RMA.OpenNURBS.On3dPointArray@)">
            <summary>returns list of 8 corner points</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.Corner(System.Int32,System.Int32,System.Int32)">
            <summary>8 corners of box</summary>
            <param name="x_index">0 = Min().x, 1 = Max().x</param>
            <param name="y_index">0 = Min().y, 1 = Max().y</param>
            <param name="z_index">0 = Min().z, 1 = Max().z</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.Diagonal">
            <summary>
max corner - min corner
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.IsVisible(RMA.OpenNURBS.IOnXform)">
            <summary>
temporary - use ON_ClippingRegion - this function will be removed soon.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnBoundingBox">
            <summary>axis aligned bounding box</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnPlugInRef.m_developer_organization">
            <value>
developer contact information
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnPlugInRef.m_plugin_filename">
            <value>
name of executable file
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnPlugInRef.m_plugin_platform">
            <value>0 = unknown, 1 = C++, 2 = .NET</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnPlugInRef.m_plugin_type">
            <value>CRhinoPlugIn::plugin_type enum value</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnPlugInRef.m_plugin_id">
            <value>
executable informtion
</value>
        </member>
        <member name="T:RMA.OpenNURBS.OnPlugInRef">
            <summary>
The ON_PluginRef class is used to store a list of
application plug-ins that may have saved user data
in a 3dm file so they can be loaded as needed for
reading their user data.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPlugInRef.m_developer_organization">
            <value>
developer contact information
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPlugInRef.m_plugin_filename">
            <value>
name of executable file
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPlugInRef.m_plugin_platform">
            <value>0 = unknown, 1 = C++, 2 = .NET</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPlugInRef.m_plugin_type">
            <value>CRhinoPlugIn::plugin_type enum value</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPlugInRef.m_plugin_id">
            <value>
executable informtion
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnPlugInRef">
            <summary>
The ON_PluginRef class is used to store a list of
application plug-ins that may have saved user data
in a 3dm file so they can be loaded as needed for
reading their user data.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidIndexList.FindUuidIndex(System.Guid,System.Int32)">
            <summary>Determine if a uuid-index pair is in the list.</summary>
            <returns>True if the uuid-index pair is in the list. False if the uuid-index pair is not in the list.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidIndexList.FindUuid(System.Guid,System.Int32@)">
            <summary>Determine if an element with a uuid is in the list.</summary>
            <param name="index">[out] if a matching uuid is found, then index is set to the value of the index.</param>
            <returns>True if an element was found. Returns false if the uuid is not in the list.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidIndexList.RemoveUuid(System.Guid)">
            <summary>Removes an element with a matching uuid from the list.</summary>
            <param name="uuid">[in] id to remove</param>
            <returns>True if an element was removed. False if the uuid was not in the list.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidIndexList.AddUuidIndex(System.Guid,System.Int32,System.Boolean)">
            <summary>Adds a uuid-index pair to the list.</summary>
            <param name="uuid">[in] id to add.</param>
            <param name="bCheckForDuplicates">
[in] if true, then the uuid is not added if it is already in the list.
If you are certain that the uuid is not in the list and you have a have
a large collection of uuids, then setting bCheckForDuplicates=false will
speed up the addition of uuids.
</param>
            <returns>True if uuid was added. False if uuid was not added because it is already in the collection.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidIndexList.Empty">
            <summary>Provides an efficient way to empty a list so that it can be used again.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidIndexList.Count">
            <returns>Number of active uuids in the list.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnUuidIndexList.FindUuidIndex(System.Guid,System.Int32)">
            <summary>Determine if a uuid-index pair is in the list.</summary>
            <returns>True if the uuid-index pair is in the list. False if the uuid-index pair is not in the list.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnUuidIndexList.FindUuid(System.Guid,System.Int32@)">
            <summary>Determine if an element with a uuid is in the list.</summary>
            <param name="index">[out] if a matching uuid is found, then index is set to the value of the index.</param>
            <returns>True if an element was found. Returns false if the uuid is not in the list.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnUuidIndexList.Count">
            <returns>Number of active uuids in the list.</returns>
        </member>
        <member name="T:RMA.OpenNURBS.IOnUuidIndexList">
            <summary>
The ON_UuidIndexList class provides a tool to efficiently maintain a list of uuid-index
pairs and determine if a uuid is in the list. This class is based on the premise
that there are no duplicate uuids in the list.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidList.Read(RMA.OpenNURBS.OnBinaryArchive@)">
            <summary>Read the uuid list from an archive.</summary>
            <param name="archive">[in] archive to read from.</param>
            <returns>true if the read was successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidList.Write(RMA.OpenNURBS.OnBinaryArchive@)">
            <summary>Saves the uuid list in an archive.</summary>
            <param name="archive">[in] archive to write to.</param>
            <returns>true if write was successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidList.FindUuid(System.Guid)">
            <summary>Determine if a uuid is in the list.</summary>
            <returns>True if uuid is in the list.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidList.RemoveUuid(System.Guid)">
            <summary>Removes a uuid from the list.</summary>
            <param name="uuid">[in] id to remove</param>
            <returns>True if uuid was in the list and was removed. False if uuid was not in the list.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidList.AddUuid(System.Guid,System.Boolean)">
            <summary>Adds a uuid to the list.</summary>
            <param name="uuid">[in] id to add.</param>
            <param name="bCheckForDuplicates">
[in] if true, then the uuid is not added if it is already in the list.
have a large list of uuids, then setting bCheckForDupicates=false will
speed up the addition of uuids.
</param>
            <returns>True if uuid was added. False if uuid was not added because it is already in the collection.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidList.Compact">
            <summary>
Makes the uuid list as efficent as possible in both search speed and memory usage.
Use Compact() when a uuid list will be in use but is not likely to be modifed.
A list that has been compacted can still be modified.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidList.Destroy">
            <summary>Destroy list. If list will be reused, Empty() is more efficient.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidList.Empty">
            <summary>Provides an efficient way to empty a list so that it can be used again.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidList.Array">
            <returns>Array of uuids in the list. Sorted with respect to ON_UuidList::CompareUuid().</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidList.Count">
            <returns>Number of active uuids in the list.</returns>
        </member>
        <member name="T:RMA.OpenNURBS.OnUuidList">
            <summary>
The ON_UuidList class provides a tool to efficiently maintain a list of
uuids and determine if a uuid is in the list. This class is based on the
premise that there are no duplicate uuids in the list.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnUuidList.Write(RMA.OpenNURBS.OnBinaryArchive@)">
            <summary>Saves the uuid list in an archive.</summary>
            <param name="archive">[in] archive to write to.</param>
            <returns>true if write was successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnUuidList.FindUuid(System.Guid)">
            <summary>Determine if a uuid is in the list.</summary>
            <returns>True if uuid is in the list.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnUuidList.Array">
            <returns>Array of uuids in the list. Sorted with respect to ON_UuidList::CompareUuid().</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnUuidList.Count">
            <returns>Number of active uuids in the list.</returns>
        </member>
        <member name="T:RMA.OpenNURBS.IOnUuidList">
            <summary>
The ON_UuidList class provides a tool to efficiently maintain a list of
uuids and determine if a uuid is in the list. This class is based on the
premise that there are no duplicate uuids in the list.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidPair.Compare(RMA.OpenNURBS.IOnUuidPair,RMA.OpenNURBS.IOnUuidPair)">
            <summary>Compares m_uuid[0] first and then m_uuid[1].</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidPair.CompareSecondUuid(RMA.OpenNURBS.IOnUuidPair,RMA.OpenNURBS.IOnUuidPair)">
            <summary>Compares m_uuid[1] and ignores m_uuid[0]</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidPair.CompareFirstUuid(RMA.OpenNURBS.IOnUuidPair,RMA.OpenNURBS.IOnUuidPair)">
            <summary>Compares m_uuid[0] and ignores m_uuid[1]</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVectorArray.GetBBox(System.Single[],System.Single[])">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVectorArray.GetBBox(System.Single[],System.Single[],System.Int32)">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3fVectorArray.GetBBox(System.Single[],System.Single[])">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3fVectorArray.GetBBox(System.Single[],System.Single[],System.Int32)">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVectorArray.#ctor">
            <summary>
see ON_SimpleArray class definition comments for constructor documentation
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVectorArray.GetBBox(System.Double[],System.Double[])">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVectorArray.GetBBox(System.Double[],System.Double[],System.Int32)">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVectorArray.#ctor">
            <summary>
see ON_SimpleArray class definition comments for constructor documentation
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2dVectorArray.GetBBox(System.Double[],System.Double[])">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2dVectorArray.GetBBox(System.Double[],System.Double[],System.Int32)">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4fPointArray.#ctor">
            <summary>
see ON_SimpleArray class definition comments for constructor documentation
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPointArray.#ctor">
            <summary>
see ON_SimpleArray class definition comments for constructor documentation
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPointArray.GetBBox(System.Single[],System.Single[])">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPointArray.GetBBox(System.Single[],System.Single[],System.Int32)">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPointArray.#ctor">
            <summary>
see ON_SimpleArray class definition comments for constructor documentation
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3fPointArray.GetBBox(System.Single[],System.Single[])">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3fPointArray.GetBBox(System.Single[],System.Single[],System.Int32)">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPointArray.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Int32@)">
            <summary>Get the index of the point in the array that is closest to P.</summary>
            <param name="P">[in]</param>
            <param name="closest_point_index">[out]</param>
            <returns>
True if a point is found; in which case *closest_point_index is the index of the point.
False if no point is found or the input is not valid.
See Also: ON_GetClosestPointInPointList ON_PointCloud::GetClosestPoint
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPointArray.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Int32@,System.Double)">
            <summary>Get the index of the point in the array that is closest to P.</summary>
            <param name="P">[in]</param>
            <param name="closest_point_index">[out]</param>
            <param name="maximum_distance">
[in] optional distance constraint. If maximum_distance &gt; 0, then only points Q with
|P-Q| &lt;= maximum_distance are returned.
</param>
            <returns>
True if a point is found; in which case *closest_point_index is the index of the point.
False if no point is found or the input is not valid.
See Also: ON_GetClosestPointInPointList ON_PointCloud::GetClosestPoint
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPointArray.Translate(RMA.OpenNURBS.IOn3dVector)">
            <summary>Translate a polyline</summary>
            <param name="delta">[in] translation vectorsine of rotation angle</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPointArray.Rotate(System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Rotate points about a center and axis.  A positive angle results in a counter-clockwise rotation about the axis of rotation.
</summary>
            <param name="angle_in_radians">[in] angle in radians.  Polsine of rotation angle</param>
            <param name="axis_of_rotation">[in] axis of rotation</param>
            <param name="center_of_rotation">[in] center (fixed point) of rotation</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPointArray.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Rotate points about a center and axis.  A positive angle results in a counter-clockwise rotation about the axis of rotation.
</summary>
            <param name="sin_angle">[in] sine of rotation angle</param>
            <param name="cos_angle">[in] cosine of rotation angle</param>
            <param name="axis_of_rotation">[in] axis of rotation</param>
            <param name="center_of_rotation">[in] center (fixed point) of rotation</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPointArray.SwapCoordinates(System.Int32,System.Int32)">
            <summary>Swaps point coordinate values with indices i and j.</summary>
            <param name="i">[in] coordinate index</param>
            <param name="j">[in] coordinate index</param>
            <returns>true if successful.</returns>
            <remarks>
The call SwapCoordinates(0,2) would swap the x and z coordinates of each point in the array.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPointArray.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>Transform points by applying xform to each point.</summary>
            <param name="xform">[in] transformation matrix</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPointArray.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>Get tight bounding box of the point list.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPointArray.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>Get tight bounding box of the point list.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] default=0 (false)
If 1 (true) and the input tight_bbox is valid, then returned tight_bbox is the union of the input tight_bbox and the tight bounding box of the point list.
</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPointArray.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32,RMA.OpenNURBS.IOnXform)">
            <summary>Get tight bounding box of the point list.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] default=0 (false)
If 1 (true) and the input tight_bbox is valid, then returned tight_bbox is the union of the input tight_bbox and the tight bounding box of the point list.
</param>
            <param name="xform">
[in] (default=NULL) If not NULL, the tight bounding box of the transformed point list is calculated.
The point list is not modified.
</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPointArray.GetBBox(System.Double[],System.Double[])">
            <summary>Get axis aligned bounding box.</summary>
            <param name="boxmin">[in/out] array of 3 doubles</param>
            <param name="boxmax">[in/out] array of 3 doubles</param>
            <returns>
the object's bounding box is returned in boxmin,boxmax
true if object has bounding box and calculation was successful
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPointArray.GetBBox(System.Double[],System.Double[],System.Int32)">
            <summary>Get axis aligned bounding box.</summary>
            <param name="boxmin">[in/out] array of 3 doubles</param>
            <param name="boxmax">[in/out] array of 3 doubles</param>
            <param name="bGrowBox">
[in] default=0 (false) 
If 1 (true), then the union of the input bounding box and the object's bounding box is returned.
If 0 (false), the object's bounding box is returned.
</param>
            <returns>true if object has bounding box and calculation was successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPointArray.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>
Get 3d axis aligned bounding box or the union of the input box with the point list's bounding box.
</summary>
            <param name="bbox">
[in/out] 3d axis aligned bounding box
the point list's bounding box is returned in bbox.
</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPointArray.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>
Get 3d axis aligned bounding box or the union of the input box with the point list's bounding box.
</summary>
            <param name="bbox">[in/out] 3d axis aligned bounding box</param>
            <param name="bGrowBox">
[in] default=0 (false) 
If 1 (true), then the union of the input bbox and the point list's bounding box is returned in bbox.  
If 0 (false), the point list's bounding box is returned in bbox.
</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPointArray.BoundingBox">
            <summary>Get 3d axis aligned bounding box.</summary>
            <returns>3d bounding box of point list.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPointArray.Create(System.Int32,System.Boolean,System.Int32,System.Single[])">
            <summary>Create 3d point list by copying an array of floats</summary>
            <param name="point_dimension">
[in] dimension of input points
must be 2 or 3
</param>
            <param name="bRational">[in] true if points are in homogenous rational form</param>
            <param name="point_stride">[in] number of doubles to skip between points</param>
            <param name="points">[in] array of point coordinates</param>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPointArray.Create(System.Int32,System.Boolean,System.Int32,System.Double[])">
            <summary>Create 3d point list by copying an array of doubles</summary>
            <param name="point_dimension">
[in] dimension of input points
must be 2 or 3
</param>
            <param name="bRational">[in] true if points are in homogenous rational form</param>
            <param name="point_stride">[in] number of doubles to skip between points</param>
            <param name="points">[in] array of point coordinates</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dPointArray.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Int32@)">
            <summary>Get the index of the point in the array that is closest to P.</summary>
            <param name="P">[in]</param>
            <param name="closest_point_index">[out]</param>
            <returns>
True if a point is found; in which case *closest_point_index is the index of the point.
False if no point is found or the input is not valid.
See Also: ON_GetClosestPointInPointList ON_PointCloud::GetClosestPoint
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dPointArray.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Int32@,System.Double)">
            <summary>Get the index of the point in the array that is closest to P.</summary>
            <param name="P">[in]</param>
            <param name="closest_point_index">[out]</param>
            <param name="maximum_distance">
[in] optional distance constraint. If maximum_distance &gt; 0, then only points Q with
|P-Q| &lt;= maximum_distance are returned.
</param>
            <returns>
True if a point is found; in which case *closest_point_index is the index of the point.
False if no point is found or the input is not valid.
See Also: ON_GetClosestPointInPointList ON_PointCloud::GetClosestPoint
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dPointArray.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>Get tight bounding box of the point list.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dPointArray.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>Get tight bounding box of the point list.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] default=0 (false)
If 1 (true) and the input tight_bbox is valid, then returned tight_bbox is the union of the input tight_bbox and the tight bounding box of the point list.
</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dPointArray.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32,RMA.OpenNURBS.IOnXform)">
            <summary>Get tight bounding box of the point list.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] default=0 (false)
If 1 (true) and the input tight_bbox is valid, then returned tight_bbox is the union of the input tight_bbox and the tight bounding box of the point list.
</param>
            <param name="xform">
[in] (default=NULL) If not NULL, the tight bounding box of the transformed point list is calculated.
The point list is not modified.
</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dPointArray.GetBBox(System.Double[],System.Double[])">
            <summary>Get axis aligned bounding box.</summary>
            <param name="boxmin">[in/out] array of 3 doubles</param>
            <param name="boxmax">[in/out] array of 3 doubles</param>
            <returns>
the object's bounding box is returned in boxmin,boxmax
true if object has bounding box and calculation was successful
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dPointArray.GetBBox(System.Double[],System.Double[],System.Int32)">
            <summary>Get axis aligned bounding box.</summary>
            <param name="boxmin">[in/out] array of 3 doubles</param>
            <param name="boxmax">[in/out] array of 3 doubles</param>
            <param name="bGrowBox">
[in] default=0 (false) 
If 1 (true), then the union of the input bounding box and the object's bounding box is returned.
If 0 (false), the object's bounding box is returned.
</param>
            <returns>true if object has bounding box and calculation was successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dPointArray.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>
Get 3d axis aligned bounding box or the union of the input box with the point list's bounding box.
</summary>
            <param name="bbox">
[in/out] 3d axis aligned bounding box
the point list's bounding box is returned in bbox.
</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dPointArray.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>
Get 3d axis aligned bounding box or the union of the input box with the point list's bounding box.
</summary>
            <param name="bbox">[in/out] 3d axis aligned bounding box</param>
            <param name="bGrowBox">
[in] default=0 (false) 
If 1 (true), then the union of the input bbox and the point list's bounding box is returned in bbox.  
If 0 (false), the point list's bounding box is returned in bbox.
</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dPointArray.BoundingBox">
            <summary>Get 3d axis aligned bounding box.</summary>
            <returns>3d bounding box of point list.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On2fPointArray.GetBBox(System.Single[],System.Single[])">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fPointArray.GetBBox(System.Single[],System.Single[],System.Int32)">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fPointArray.#ctor">
            <summary>
see ON_SimpleArray class definition comments for constructor documentation
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2fPointArray.GetBBox(System.Single[],System.Single[])">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2fPointArray.GetBBox(System.Single[],System.Single[],System.Int32)">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPointArray.GetBBox(System.Double[],System.Double[])">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPointArray.GetBBox(System.Double[],System.Double[],System.Int32)">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPointArray.#ctor">
            <summary>
see ON_SimpleArray class definition comments for constructor documentation
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2dPointArray.GetBBox(System.Double[],System.Double[])">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2dPointArray.GetBBox(System.Double[],System.Double[],System.Int32)">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>
These transform the vector in place. The transformation matrix acts on
the left of the vector; i.e., result = transformation*vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.PerpendicularTo(RMA.OpenNURBS.IOn3fVector)">
            <summary>
set this vector to be perpendicular to another vector
Result is not unitized.
</summary>
            <returns>false if input vector is zero</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.IsZero">
            <summary>
Returns: true if vector is the zero vector.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.IsTiny">
            <summary>Test a vector to see if it is very short</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.IsTiny(System.Double)">
            <summary>Test a vector to see if it is very short</summary>
            <param name="tiny_tol">
[in] (default = ON_ZERO_TOLERANCE) a nonzero value used as the coordinate zero tolerance.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.Unitize">
            <summary>
returns false if vector has zero length
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.Reverse">
            <summary>
negate all coordinates
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.Zero">
            <summary>
set all coordinates to zero
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.Fuzz">
            <summary>
tolerance to use when comparing 3d vectors
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.Fuzz(System.Double)">
            <summary>
tolerance to use when comparing 3d vectors
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.IsPerpendicularTo(RMA.OpenNURBS.IOn3fVector)">
            <returns>
true:  this and other vectors are perpendicular
false: this and other vectors are not perpendicular or at least one of the vectors is zero
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.IsPerpendicularTo(RMA.OpenNURBS.IOn3fVector,System.Double)">
            <returns>
true:  this and other vectors are perpendicular
false: this and other vectors are not perpendicular or at least one of the vectors is zero
</returns>
            <param name="angle_tolerance">optional angle tolerance (radians)</param>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.op_LessThanOrEqual(RMA.OpenNURBS.On3fVector,RMA.OpenNURBS.IOn3fVector)">
            <summary>
dictionary order comparisons
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.op_Multiply(RMA.OpenNURBS.On3fVector,RMA.OpenNURBS.IOn3dVector)">
            <summary>
inner (dot) product
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.op_Multiply(RMA.OpenNURBS.On3fVector,RMA.OpenNURBS.IOn3fPoint)">
            <summary>
inner (dot) product (point acting as a vector)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.op_Multiply(RMA.OpenNURBS.On3fVector,RMA.OpenNURBS.IOn3fVector)">
            <summary>
inner (dot) product
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.op_Implicit(RMA.OpenNURBS.IOn2fVector)~RMA.OpenNURBS.On3fVector">
            <summary>
use implicit operator=(const ON_3fVector&amp;)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.#ctor(RMA.OpenNURBS.IOn3fPoint)">
            <summary>
from 3d point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.#ctor(RMA.OpenNURBS.IOn2fVector)">
            <summary>
from 2d vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.#ctor">
            <summary>
not initialized
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.UnitVector(System.Int32)">
            <summary>A index driven function to get unit axis vectors.</summary>
            <param name="index">
[in] 0 returns (1,0,0), 1 returns (0,1,0), 2 returns (0,0,1)
</param>
            <returns>Unit 3d vector with vector[i] = (i==index)?1:0;</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3fVector.IsZero">
            <summary>
Returns:
 true if vector is the zero vector.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3fVector.IsTiny">
            <summary>Test a vector to see if it is very short</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3fVector.IsTiny(System.Double)">
            <summary>Test a vector to see if it is very short</summary>
            <param name="tiny_tol">
[in] (default = ON_ZERO_TOLERANCE) a nonzero value used as the coordinate zero tolerance.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3fVector.Fuzz">
            <summary>
tolerance to use when comparing 3d vectors
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3fVector.Fuzz(System.Double)">
            <summary>
tolerance to use when comparing 3d vectors
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3fVector.IsPerpendicularTo(RMA.OpenNURBS.IOn3fVector)">
            <returns>
true:  this and other vectors are perpendicular
false: this and other vectors are not perpendicular or at least one of the vectors is zero
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3fVector.IsPerpendicularTo(RMA.OpenNURBS.IOn3fVector,System.Double)">
            <returns>
true:  this and other vectors are perpendicular
false: this and other vectors are not perpendicular or at least one of the vectors is zero
</returns>
            <param name="angle_tolerance">optional angle tolerance (radians)</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3fVector.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.PerpendicularTo(RMA.OpenNURBS.IOn2fPoint,RMA.OpenNURBS.IOn2fPoint)">
            <summary>
set this vector to be perpendicular to a line defined by 2 points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.PerpendicularTo(RMA.OpenNURBS.IOn2fVector)">
            <summary>
set this vector to be perpendicular to another vector
Result is not unitized.
</summary>
            <returns>returns false if input vector is zero</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.IsZero">
            <summary>
Returns: true if vector is the zero vector.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.IsTiny">
            <summary>Test a vector to see if it is very short</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.IsTiny(System.Double)">
            <summary>Test a vector to see if it is very short</summary>
            <param name="tiny_tol">
[in] (default = ON_ZERO_TOLERANCE) a nonzero value used as the coordinate zero tolerance.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.Unitize">
            <summary>
returns false if vector has zero length
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.Reverse">
            <summary>
negate all coordinates
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.Zero">
            <summary>
set all coordinates to zero;
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.IsPerpendicularTo(RMA.OpenNURBS.IOn2fVector)">
            <returns>
true:  this and other vectors are perpendicular
false: this and other vectors are not perpendicular or at least one of the vectors is zero
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.IsPerpendicularTo(RMA.OpenNURBS.IOn2fVector,System.Double)">
            <returns>
true:  this and other vectors are perpendicular
false: this and other vectors are not perpendicular or at least one of the vectors is zero
</returns>
            <param name="angle_tolerance">radians</param>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.IsParallelTo(RMA.OpenNURBS.IOn2fVector)">
            <returns>
1: this and other vectors are parallel
-1: this and other vectors are anti-parallel
0: this and other vectors are not parallel or at least one of the vectors is zero
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.IsParallelTo(RMA.OpenNURBS.IOn2fVector,System.Double)">
            <returns>
1: this and other vectors are parallel
-1: this and other vectors are anti-parallel
0: this and other vectors are not parallel or at least one of the vectors is zero
</returns>
            <param name="angle_tolerance">radians</param>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.Decompose(RMA.OpenNURBS.IOn2fVector,RMA.OpenNURBS.IOn2fVector,System.Double@,System.Double@)">
            <summary>Computes a, b such that this vector = a*X + b*Y</summary>
            <returns>
false if unable to solve for a,b.  This happens
when X,Y is not really a basis.

If X,Y is known to be an orthonormal frame,
then a = V*X, b = V*Y will compute
the same result more quickly.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.op_LessThanOrEqual(RMA.OpenNURBS.On2fVector,RMA.OpenNURBS.IOn2fVector)">
            <summary>
dictionary order comparisons
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.op_Multiply(RMA.OpenNURBS.On2fVector,RMA.OpenNURBS.IOn2dVector)">
            <summary>
inner (dot) product
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.op_Multiply(RMA.OpenNURBS.On2fVector,RMA.OpenNURBS.IOn2fPoint)">
            <summary>
inner (dot) product point acting as a vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.op_Multiply(RMA.OpenNURBS.On2fVector,RMA.OpenNURBS.IOn2fVector)">
            <summary>
inner (dot) product
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.op_Implicit(RMA.OpenNURBS.IOn3fVector)~RMA.OpenNURBS.On2fVector">
            <summary>
use implicit operator=(const ON_2fVector&amp;)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.#ctor(RMA.OpenNURBS.IOn2fPoint)">
            <summary>
from 2d point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.#ctor(RMA.OpenNURBS.IOn3fVector)">
            <summary>
from 3d vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.#ctor">
            <summary>
not initialized
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.UnitVector(System.Int32)">
            <summary>A index driven function to get unit axis vectors.</summary>
            <param name="index">[in] 0 returns (1,0), 1 returns (0,1)</param>
            <returns>Unit 3d vector with vector[i] = (i==index)?1:0;</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2fVector.IsZero">
            <summary>
Returns: true if vector is the zero vector.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2fVector.IsTiny">
            <summary>Test a vector to see if it is very short</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2fVector.IsTiny(System.Double)">
            <summary>Test a vector to see if it is very short</summary>
            <param name="tiny_tol">
[in] (default = ON_ZERO_TOLERANCE) a nonzero value used as the coordinate zero tolerance.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2fVector.IsPerpendicularTo(RMA.OpenNURBS.IOn2fVector)">
            <returns>
true:  this and other vectors are perpendicular
false: this and other vectors are not perpendicular or at least one of the vectors is zero
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2fVector.IsPerpendicularTo(RMA.OpenNURBS.IOn2fVector,System.Double)">
            <returns>
true:  this and other vectors are perpendicular
false: this and other vectors are not perpendicular or at least one of the vectors is zero
</returns>
            <param name="angle_tolerance">radians</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2fVector.IsParallelTo(RMA.OpenNURBS.IOn2fVector)">
            <returns>
1: this and other vectors are parallel
-1: this and other vectors are anti-parallel
0: this and other vectors are not parallel or at least one of the vectors is zero
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2fVector.IsParallelTo(RMA.OpenNURBS.IOn2fVector,System.Double)">
            <returns>
1: this and other vectors are parallel
-1: this and other vectors are anti-parallel
0: this and other vectors are not parallel or at least one of the vectors is zero
</returns>
            <param name="angle_tolerance">radians</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2fVector.Decompose(RMA.OpenNURBS.IOn2fVector,RMA.OpenNURBS.IOn2fVector,System.Double@,System.Double@)">
            <summary>Computes a, b such that this vector = a*X + b*Y</summary>
            <returns>
false if unable to solve for a,b.  This happens
when X,Y is not really a basis.

If X,Y is known to be an orthonormal frame,
then a = V*X, b = V*Y will compute
the same result more quickly.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2fVector.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4fPoint.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>
These transform the point in place. The transformation matrix acts on
the left of the point; i.e., result = transformation*point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4fPoint.Normalize">
            <summary>
set so x^2 + y^2 + z^2 + w^2 = 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4fPoint.Zero">
            <summary>
set all 4 coordinates to zero;
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4fPoint.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4fPoint.op_Equality(RMA.OpenNURBS.On4fPoint,RMA.OpenNURBS.IOn4fPoint)">
            <summary>
projective comparison
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4fPoint.op_Subtraction(RMA.OpenNURBS.On4fPoint,RMA.OpenNURBS.IOn4fPoint)">
            <summary>
difference w = sqrt(w1*w2)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4fPoint.op_Addition(RMA.OpenNURBS.On4fPoint,RMA.OpenNURBS.IOn4fPoint)">
            <summary>
sum w = sqrt(w1*w2)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4fPoint.op_Implicit(RMA.OpenNURBS.IOn2fPoint)~RMA.OpenNURBS.On4fPoint">
            <summary>
use implicit operator=(const ON_4fPoint&amp;)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4fPoint.#ctor(RMA.OpenNURBS.IOn3fVector)">
            <summary>
from 3d vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4fPoint.#ctor(RMA.OpenNURBS.IOn2fVector)">
            <summary>
from 2d vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4fPoint.#ctor(RMA.OpenNURBS.IOn3fPoint)">
            <summary>
from 3d point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4fPoint.#ctor(RMA.OpenNURBS.IOn2fPoint)">
            <summary>
from 2d point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4fPoint.#ctor">
            <summary>
not initialized
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn4fPoint.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPoint.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>
These transform the point in place. The transformation matrix acts on
the left of the point; i.e., result = transformation*point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPoint.Zero">
            <summary>
set all coordinates to zero;
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPoint.Fuzz">
            <summary>
tolerance to use when comparing 3d points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPoint.Fuzz(System.Double)">
            <summary>
tolerance to use when comparing 3d points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPoint.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPoint.op_LessThanOrEqual(RMA.OpenNURBS.On3fPoint,RMA.OpenNURBS.IOn3fPoint)">
            <summary>
dictionary order comparisons
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPoint.op_Multiply(RMA.OpenNURBS.On3fPoint,RMA.OpenNURBS.IOn3fVector)">
            <summary>
for points acting as vectors
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPoint.op_Multiply(RMA.OpenNURBS.On3fPoint,RMA.OpenNURBS.IOn3fPoint)">
            <summary>
for points acting as vectors
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPoint.op_Implicit(RMA.OpenNURBS.IOn2fPoint)~RMA.OpenNURBS.On3fPoint">
            <summary>
use implicit operator=(const ON_3fPoint&amp;)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPoint.#ctor(RMA.OpenNURBS.IOn3fVector)">
            <summary>
from 3d vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPoint.#ctor(RMA.OpenNURBS.IOn4fPoint)">
            <summary>
from homogeneous 4d point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPoint.#ctor(RMA.OpenNURBS.IOn2fPoint)">
            <summary>
from 2d point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPoint.#ctor(System.Single,System.Single,System.Single)">
            <summary>
:x(xx),y(yy),z(zz)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPoint.#ctor">
            <summary>
not initialized
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3fPoint.Fuzz">
            <summary>
tolerance to use when comparing 3d points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3fPoint.Fuzz(System.Double)">
            <summary>
tolerance to use when comparing 3d points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3fPoint.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fPoint.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn2fPoint)">
            <summary>
rotatation in XY plane
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fPoint.Rotate(System.Double,RMA.OpenNURBS.IOn2fPoint)">
            <summary>
rotatation in XY plane
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fPoint.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>
These transform the point in place. The transformation matrix acts on
the left of the point; i.e., result = transformation*point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fPoint.Zero">
            <summary>
set all coordinates to zero;
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fPoint.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fPoint.op_LessThanOrEqual(RMA.OpenNURBS.On2fPoint,RMA.OpenNURBS.IOn2fPoint)">
            <summary>
dictionary order comparisons
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fPoint.op_Multiply(RMA.OpenNURBS.On2fPoint,RMA.OpenNURBS.IOn2fVector)">
            <summary>
for points acting as vectors
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fPoint.op_Multiply(RMA.OpenNURBS.On2fPoint,RMA.OpenNURBS.IOn2fPoint)">
            <summary>
for points acting as vectors
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fPoint.op_Implicit(RMA.OpenNURBS.IOn3fPoint)~RMA.OpenNURBS.On2fPoint">
            <summary>
use implicit operator=(const ON_2fPoint&amp;)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fPoint.#ctor(RMA.OpenNURBS.IOn2fVector)">
            <summary>
from 2d vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fPoint.#ctor(RMA.OpenNURBS.IOn4fPoint)">
            <summary>
from homogeneous 4d point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fPoint.#ctor(RMA.OpenNURBS.IOn3fPoint)">
            <summary>
from 3d point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fPoint.#ctor">
            <summary>
not initialized
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2fPoint.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnSurfaceCurvature.k2">
            <value>
principal curvatures
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnSurfaceCurvature.k1">
            <value>
principal curvatures
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnSurfaceCurvature.k2">
            <value>
principal curvatures
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnSurfaceCurvature.k1">
            <value>
principal curvatures
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlaneEquation.MaximumValueAt(RMA.OpenNURBS.IOnSurfaceLeafBox)">
            <summary>
Description: Get the maximum value of the plane equation on a bounding box. Parameters: bbox - [in] Returns: Maximum value of the plane equation on the bounding box.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlaneEquation.MinimumValueAt(RMA.OpenNURBS.IOnSurfaceLeafBox)">
            <summary>
Description: Get the minimum value of the plane equation on a bounding box. Parameters: bbox - [in] Returns: Minimum value of the plane equation on the bounding box.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlaneEquation.MaximumValueAt(RMA.OpenNURBS.IOnCurveLeafBox)">
            <summary>
Description: Get the maximum value of the plane equation on a bounding box. Parameters: crvleafbox - [in] Returns: Maximum value of the plane equation on the curve leaf box.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlaneEquation.MinimumValueAt(RMA.OpenNURBS.IOnCurveLeafBox)">
            <summary>
Description: Get the minimum value of the plane equation on a bounding box. Parameters: crvleafbox - [in] Returns: Minimum value of the plane equation on the curve leaf box.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlaneEquation.MaximumValueAt(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Description: Get the maximum value of the plane equation on a bounding box. Parameters: bbox - [in] Returns: Maximum value of the plane equation on the bounding box.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlaneEquation.MinimumValueAt(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Description: Get the minimum value of the plane equation on a bounding box. Parameters: bbox - [in] Returns: Minimum value of the plane equation on the bounding box.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlaneEquation.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Get point on plane that is closest to a given point. Parameters: point - [in] Returns: A 3d point on the plane that is closest to the input point.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlaneEquation.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>
Description: Transform the plane equation so that, if e0 is the initial equation, e1 is transformed equation and P is a point, then e0.ValueAt(P) = e1.ValueAt(xform*P). Parameters: xform - [in] Invertable transformation. Returns: True if the plane equation was successfully transformed. False if xform is not invertable or the equation is not valid. Remarks: This function has to invert xform. If you have apply the same transformation to a bunch of planes, then it will be more efficient to calculate xform's inverse transpose and apply the resultingt transformation to the equation's coefficients as if they were 4d point coordinates.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlaneEquation.ValueAt(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Evaluate the plane at a point. Parameters: P - [in] Returns: x*P.x + y*P.y + z*P.z + d;
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlaneEquation.Create(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector)">
            <summary>
Description: Sets (x,y,z) to a unitized N and then sets d = -(x*P.x + y*P.y + z*P.z). Parameters: P - [in] point on the plane N - [in] vector perpindicular to the plane Returns: true if input is valid.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlaneEquation.IsValid">
            <summary>
C++ defaults for construction, destruction, copys, and operator=
work fine.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnPlaneEquation.d">
            <value>
4th coefficient of the plane equation.
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlaneEquation.MaximumValueAt(RMA.OpenNURBS.IOnSurfaceLeafBox)">
            <summary>
Description: Get the maximum value of the plane equation on a bounding box. Parameters: bbox - [in] Returns: Maximum value of the plane equation on the bounding box.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlaneEquation.MinimumValueAt(RMA.OpenNURBS.IOnSurfaceLeafBox)">
            <summary>
Description: Get the minimum value of the plane equation on a bounding box. Parameters: bbox - [in] Returns: Minimum value of the plane equation on the bounding box.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlaneEquation.MaximumValueAt(RMA.OpenNURBS.IOnCurveLeafBox)">
            <summary>
Description: Get the maximum value of the plane equation on a bounding box. Parameters: crvleafbox - [in] Returns: Maximum value of the plane equation on the curve leaf box.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlaneEquation.MinimumValueAt(RMA.OpenNURBS.IOnCurveLeafBox)">
            <summary>
Description: Get the minimum value of the plane equation on a bounding box. Parameters: crvleafbox - [in] Returns: Minimum value of the plane equation on the curve leaf box.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlaneEquation.MaximumValueAt(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Description: Get the maximum value of the plane equation on a bounding box. Parameters: bbox - [in] Returns: Maximum value of the plane equation on the bounding box.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlaneEquation.MinimumValueAt(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Description: Get the minimum value of the plane equation on a bounding box. Parameters: bbox - [in] Returns: Minimum value of the plane equation on the bounding box.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlaneEquation.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Get point on plane that is closest to a given point. Parameters: point - [in] Returns: A 3d point on the plane that is closest to the input point.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlaneEquation.ValueAt(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Evaluate the plane at a point. Parameters: P - [in] Returns: x*P.x + y*P.y + z*P.z + d;
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlaneEquation.IsValid">
            <summary>
C++ defaults for construction, destruction, copys, and operator=
work fine.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPlaneEquation.d">
            <value>
4th coefficient of the plane equation.
</value>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>
These transform the vector in place. The transformation matrix acts on
the left of the vector; i.e., result = transformation*vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.PerpendicularTo(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
set this vector to be perpendicular to a plane defined by 3 points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.PerpendicularTo(RMA.OpenNURBS.IOn3dVector)">
            <summary>
Result is not unitized.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.IsZero">
            <summary>
Returns:
 true if vector is the zero vector.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.IsTiny">
            <summary>
Description:
 Test a vector to see if it is very short
Parameters:
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.IsTiny(System.Double)">
            <summary>
Description:
 Test a vector to see if it is very short
Parameters:
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.Unitize">
            <summary>
returns false if vector has zero length
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.Reverse">
            <summary>
negate all coordinates
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.Zero">
            <summary>
set all coordinates to zero;
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.Fuzz">
            <summary>
tolerance to use when comparing 3d vectors
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.Fuzz(System.Double)">
            <summary>
tolerance to use when comparing 3d vectors
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.MinimumCoordinate">
            <summary>
absolute value of minimum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.Set(System.Double,System.Double,System.Double)">
            <summary>
set 3d vector value
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.IsValid">
            <summary>
If any coordinate of a point is ON_UNSET_VALUE, then the point is not valid. Returns: true if the point is valid.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.op_LessThanOrEqual(RMA.OpenNURBS.On3dVector,RMA.OpenNURBS.IOn3dVector)">
            <summary>
dictionary order comparisons
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.op_Multiply(RMA.OpenNURBS.On3dVector,RMA.OpenNURBS.IOn3fVector)">
            <summary>
inner (dot) product
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.op_Multiply(RMA.OpenNURBS.On3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
inner (dot) product
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.op_Multiply(RMA.OpenNURBS.On3dVector,RMA.OpenNURBS.IOn3dVector)">
            <summary>
inner (dot) product
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.op_Implicit(RMA.OpenNURBS.IOn2dVector)~RMA.OpenNURBS.On3dVector">
            <summary>
use implicit operator=(const ON_3dVector&amp;)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.#ctor(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
from 3d point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.#ctor(RMA.OpenNURBS.IOn2dVector)">
            <summary>
from 2d vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.#ctor">
            <summary>
not initialized
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.UnitVector(System.Int32)">
            <summary>
Description:
 A index driven function to get unit axis vectors.
Parameters:
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dVector.IsZero">
            <summary>
Returns:
 true if vector is the zero vector.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dVector.IsTiny">
            <summary>
Description:
 Test a vector to see if it is very short
Parameters:
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dVector.IsTiny(System.Double)">
            <summary>
Description:
 Test a vector to see if it is very short
Parameters:
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dVector.Fuzz">
            <summary>
tolerance to use when comparing 3d vectors
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dVector.Fuzz(System.Double)">
            <summary>
tolerance to use when comparing 3d vectors
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dVector.MinimumCoordinate">
            <summary>
absolute value of minimum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dVector.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dVector.IsValid">
            <summary>
If any coordinate of a point is ON_UNSET_VALUE, then the point is not valid. Returns: true if the point is valid.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>
These transform the vector in place. The transformation matrix acts on
the left of the vector; i.e., result = transformation*vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.PerpendicularTo(RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOn2dPoint)">
            <summary>
set this vector to be perpendicular to a line defined by 2 points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.PerpendicularTo(RMA.OpenNURBS.IOn2dVector)">
            <summary>
Result is not unitized.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.IsZero">
            <summary>
Returns:
 true if vector is the zero vector.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.IsTiny">
            <summary>
Description:
 Test a vector to see if it is very short
Parameters:
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.IsTiny(System.Double)">
            <summary>
Description:
 Test a vector to see if it is very short
Parameters:
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.Unitize">
            <summary>
returns false if vector has zero length
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.Reverse">
            <summary>
negate all coordinates
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.Zero">
            <summary>
set all coordinates to zero;
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.WedgeProduct(RMA.OpenNURBS.IOn2dVector)">
            <summary>
Signed area of the parallelagram.  The volume element.
returns x*B.y - y*B.x
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.MinimumCoordinate">
            <summary>
absolute value of minimum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.Set(System.Double,System.Double)">
            <summary>
set 2d vector value
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.IsValid">
            <summary>
If any coordinate of a point is ON_UNSET_VALUE, then the point is not valid. Returns: true if the point is valid.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.op_LessThanOrEqual(RMA.OpenNURBS.On2dVector,RMA.OpenNURBS.IOn2dVector)">
            <summary>
dictionary order comparisons
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.op_Multiply(RMA.OpenNURBS.On2dVector,RMA.OpenNURBS.IOn2fVector)">
            <summary>
inner (dot) product
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.op_Multiply(RMA.OpenNURBS.On2dVector,RMA.OpenNURBS.IOn2dPoint)">
            <summary>
inner (dot) product (point acting as vector)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.op_Multiply(RMA.OpenNURBS.On2dVector,RMA.OpenNURBS.IOn2dVector)">
            <summary>
inner (dot) product
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.op_Implicit(RMA.OpenNURBS.IOn3dVector)~RMA.OpenNURBS.On2dVector">
            <summary>
use implicit operator=(const ON_2dVector&amp;)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.#ctor(RMA.OpenNURBS.IOn2dPoint)">
            <summary>
from 2d point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.#ctor(RMA.OpenNURBS.IOn3dVector)">
            <summary>
from 3d vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.#ctor">
            <summary>
not initialized
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.UnitVector(System.Int32)">
            <summary>A index driven function to get unit axis vectors.</summary>
            <param name="index">[in] 0 returns (1,0), 1 returns (0,1)</param>
            <returns>Unit 2d vector with vector[i] = (i==index)?1:0;</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2dVector.IsZero">
            <summary>
Returns:
 true if vector is the zero vector.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2dVector.IsTiny">
            <summary>
Description:
 Test a vector to see if it is very short
Parameters:
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2dVector.IsTiny(System.Double)">
            <summary>
Description:
 Test a vector to see if it is very short
Parameters:
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2dVector.WedgeProduct(RMA.OpenNURBS.IOn2dVector)">
            <summary>
Signed area of the parallelagram.  The volume element.
returns x*B.y - y*B.x
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2dVector.MinimumCoordinate">
            <summary>
absolute value of minimum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2dVector.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2dVector.IsValid">
            <summary>
If any coordinate of a point is ON_UNSET_VALUE, then the point is not valid. Returns: true if the point is valid.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>
These transform the point in place. The transformation matrix acts on
the left of the point; i.e., result = transformation*point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.Normalize">
            <summary>
set so x^2 + y^2 + z^2 + w^2 = 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.Zero">
            <summary>
set all 4 coordinates to zero;
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.MinimumCoordinate">
            <summary>
absolute value of minimum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.Set(System.Double,System.Double,System.Double,System.Double)">
            <summary>
set 4d point value
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.IsValid">
            <summary>
Description If any coordinate of a point is ON_UNSET_VALUE, then the point is not valid. Returns: true if the point is valid.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.op_Equality(RMA.OpenNURBS.On4dPoint,RMA.OpenNURBS.IOn4dPoint)">
            <summary>
projective comparison
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.op_Subtraction(RMA.OpenNURBS.On4dPoint,RMA.OpenNURBS.IOn4dPoint)">
            <summary>
difference w = sqrt(|w1*w2|)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.op_Addition(RMA.OpenNURBS.On4dPoint,RMA.OpenNURBS.IOn4dPoint)">
            <summary>
sum w = sqrt(|w1*w2|)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.op_SubtractionAssignment(RMA.OpenNURBS.On4dPoint,RMA.OpenNURBS.IOn4dPoint)">
            <summary>
difference w = sqrt(|w1*w2|)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.op_AdditionAssignment(RMA.OpenNURBS.On4dPoint,RMA.OpenNURBS.IOn4dPoint)">
            <summary>
sum w = sqrt(|w1*w2|)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.op_Implicit(RMA.OpenNURBS.IOn2fPoint)~RMA.OpenNURBS.On4dPoint">
            <summary>
use implicit operator=(const ON_4dPoint&amp;)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.#ctor(RMA.OpenNURBS.IOn3dVector)">
            <summary>
from 3d vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.#ctor(RMA.OpenNURBS.IOn2dVector)">
            <summary>
from 2d vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.#ctor(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
from 3d point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.#ctor(RMA.OpenNURBS.IOn2dPoint)">
            <summary>
from 2d point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.#ctor">
            <summary>
not initialized
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn4dPoint.MinimumCoordinate">
            <summary>
absolute value of minimum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn4dPoint.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn4dPoint.IsValid">
            <summary>
Description If any coordinate of a point is ON_UNSET_VALUE, then the point is not valid. Returns: true if the point is valid.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>
These transform the point in place. The transformation matrix acts on
the left of the point; i.e., result = transformation*point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.Zero">
            <summary>
set all coordinates to zero;
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.Fuzz">
            <summary>
tolerance to use when comparing 3d points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.Fuzz(System.Double)">
            <summary>
tolerance to use when comparing 3d points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.MinimumCoordinate">
            <summary>
absolute value of minimum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.Set(RMA.OpenNURBS.IOn3dVector)">
            <summary>set value from existing vector</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.Set(RMA.OpenNURBS.IOn3fPoint)">
            <summary>set value from existing point</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.Set(RMA.OpenNURBS.IOn3dPoint)">
            <summary>set value from existing point</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.Set(System.Double,System.Double,System.Double)">
            <summary>set 3d point value</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.IsValid">
            <summary>
If any coordinate of a point is ON_UNSET_VALUE, then the point is not valid.
</summary>
            <returns>true if the point is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.op_LessThanOrEqual(RMA.OpenNURBS.On3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
dictionary order comparisons
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.op_Multiply(RMA.OpenNURBS.On3dPoint,RMA.OpenNURBS.IOn3dVector)">
            <summary>
dot product for points acting as vectors
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.op_Multiply(RMA.OpenNURBS.On3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
dot product for points acting as vectors
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.op_Implicit(RMA.OpenNURBS.IOn2dPoint)~RMA.OpenNURBS.On3dPoint">
            <summary>
use implicit operator=(const ON_3dPoint&amp;)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.#ctor(RMA.OpenNURBS.IOn3dVector)">
            <summary>
from 3d vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.#ctor(RMA.OpenNURBS.IOn4dPoint)">
            <summary>
from homogeneous 4d point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.#ctor(RMA.OpenNURBS.IOn2dPoint)">
            <summary>
from 2d point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.#ctor(System.Double,System.Double,System.Double)">
            <summary>
:x(xx),y(yy),z(zz)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.#ctor">
            <summary>
not initialized
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dPoint.Fuzz">
            <summary>
tolerance to use when comparing 3d points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dPoint.Fuzz(System.Double)">
            <summary>
tolerance to use when comparing 3d points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dPoint.MinimumCoordinate">
            <summary>
absolute value of minimum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dPoint.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dPoint.IsValid">
            <summary>
If any coordinate of a point is ON_UNSET_VALUE, then the point is not valid.
</summary>
            <returns>true if the point is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPoint.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn2dPoint)">
            <summary>rotatation in XY plane</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPoint.Rotate(System.Double,RMA.OpenNURBS.IOn2dPoint)">
            <summary>rotatation in XY plane</summary>
            <param name="angle">angle in radians</param>
            <param name="center">center of rotation</param>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPoint.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>
These transform the point in place. The transformation matrix acts on
the left of the point; i.e., result = transformation*point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPoint.Zero">
            <summary>
set all coordinates to zero;
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPoint.MinimumCoordinate">
            <summary>
absolute value of minimum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPoint.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPoint.Set(System.Double,System.Double)">
            <summary>
set 2d point value
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPoint.IsValid">
            <summary>
If any coordinate of a point is ON_UNSET_VALUE, then the point is not valid.
</summary>
            <returns>true if the point is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPoint.op_LessThanOrEqual(RMA.OpenNURBS.On2dPoint,RMA.OpenNURBS.IOn2dPoint)">
            <summary>
dictionary order comparisons
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPoint.op_Multiply(RMA.OpenNURBS.On2dPoint,RMA.OpenNURBS.IOn2dVector)">
            <summary>
dot product for points acting as vectors
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPoint.op_Multiply(RMA.OpenNURBS.On2dPoint,RMA.OpenNURBS.IOn2dPoint)">
            <summary>
dot product for points acting as vectors
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPoint.op_Implicit(RMA.OpenNURBS.IOn3dPoint)~RMA.OpenNURBS.On2dPoint">
            <summary>
use implicit operator=(const ON_2dPoint&amp;)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPoint.#ctor(RMA.OpenNURBS.IOn2dVector)">
            <summary>
from 2d vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPoint.#ctor(RMA.OpenNURBS.IOn4dPoint)">
            <summary>
from homogeneous 4d point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPoint.#ctor(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
from 3d point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPoint.#ctor">
            <summary>
not initialized
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2dPoint.MinimumCoordinate">
            <summary>
absolute value of minimum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2dPoint.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2dPoint.IsValid">
            <summary>
If any coordinate of a point is ON_UNSET_VALUE, then the point is not valid.
</summary>
            <returns>true if the point is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.Union(RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>
The union of an empty set and an increasing interval is the increasing
interval.  The union of two empty sets is empty. The union of an empty
set an a non-empty interval is the non-empty interval.
The union of two non-empty intervals is
union = [min(argA.Min(),argB.Min()), max(argA.Max(),argB.Max()),]
Union() returns true if the union is not empty.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.Union(RMA.OpenNURBS.IOnInterval)">
            <summary>
The union of an empty set and an increasing interval is the increasing
interval.  The union of two empty sets is empty. The union of an empty
set an a non-empty interval is the non-empty interval.
The union of two non-empty intervals is
union = [min(this.Min(),arg.Min()), max(this.Max(),arg.Max()),]
Union() returns true if the union is not empty.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.Intersection(RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>
If the intersection is not empty, then 
intersection = [max(argA.Min(),argB.Min()), min(argA.Max(),argB.Max())]
Intersection() returns true if the intersection is not empty.
The interval [ON_UNSET_VALUE,ON_UNSET_VALUE] is considered to be
the empty set interval.  The result of any intersection involving an
empty set interval or disjoint intervals is the empty set interval.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.Intersection(RMA.OpenNURBS.IOnInterval)">
            <summary>
If the intersection is not empty, then 
intersection = [max(this.Min(),arg.Min()), min(this.Max(),arg.Max())]
Intersection() returns true if the intersection is not empty.
The interval [ON_UNSET_VALUE,ON_UNSET_VALUE] is considered to be
the empty set interval.  The result of any intersection involving an
empty set interval or disjoint intervals is the empty set interval.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.Swap">
            <summary>
Swaps m_t[0] and m_t[1].
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.Reverse">
            <summary>
Changes interval to [-m_t[1],-m_t[0]].
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.Includes(RMA.OpenNURBS.IOnInterval)">
            <summary>Test an interval to see if it is contained in this interval.</summary>
            <param name="other">[in] interval to test</param>
            <returns>
If bProperSubSet is false, then the result is true when this-&gt;Min() &lt;= other.Min() and other.Max() &lt;= this-&gt;Max().
If bProperSubSet is true, then the result is true when this-&gt;Min() &lt;= other.Min() and other.Max() &lt;= this-&gt;Max() and at least one of the inequalites is strict.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.Includes(RMA.OpenNURBS.IOnInterval,System.Boolean)">
            <summary>Test an interval to see if it is contained in this interval.</summary>
            <param name="other">[in] interval to test</param>
            <param name="bProperSubSet">[in] if true, then the test is for a proper subinterval.</param>
            <returns>
If bProperSubSet is false, then the result is true when this-&gt;Min() &lt;= other.Min() and other.Max() &lt;= this-&gt;Max().
If bProperSubSet is true, then the result is true when this-&gt;Min() &lt;= other.Min() and other.Max() &lt;= this-&gt;Max() and at least one of the inequalites is strict.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.Includes(System.Double)">
            <summary>Test a value t to see if it is inside the interval.</summary>
            <param name="t">[in] value to test</param>
            <returns>true if t is in the interval and false if t is not in the interval.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.Includes(System.Double,System.Boolean)">
            <summary>Test a value t to see if it is inside the interval.</summary>
            <param name="t">[in] value to test</param>
            <param name="bTestOpenInterval">
[in] If false, t is tested to see if it satisfies min &lt;= t &lt;= max.
If true, t is tested to see if it satisfies min &lt; t &lt; max.
</param>
            <returns>true if t is in the interval and false if t is not in the interval.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.Compare(RMA.OpenNURBS.IOnInterval)">
            <returns>
0 this is idential to other
-1 this[0] &lt; other[0]
+1 this[0] &gt; other[0]
-1 this[0] == other[0] and this[1] &lt; other[1]
+1 this[0] == other[0] and this[1] &gt; other[1]
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.MakeIncreasing">
            <summary>
returns true if resulting interval IsIncreasing()
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.IsValid">
            <summary>
returns ON_IsValid(m_t[0]) &amp;&amp; ON_IsValid(m_t[1])
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.IsEmptySet">
            <summary>
returns true if m_t[0] == m_t[1] == ON_UNSET_VALUE
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.IsSingleton">
            <summary>
returns true if m_t[0] == m_t[1] != ON_UNSET_VALUE
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.IsInterval">
            <summary>
returns truc if m_t[0] != m_t[1]
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.IsDecreasing">
            <summary>
returns true if m_t[0] &gt; m_t[0];
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.IsIncreasing">
            <summary>
returns true if m_t[0] &lt; m_t[1]
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.Mid">
            <summary>
returns 0.5*(m_t[0] + m_t[1])
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.Max">
            <summary>
returns larger of m_t[0] and m_t[1]
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.Min">
            <summary>
returns smaller of m_t[0] and m_t[1]
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.NormalizedParameterAt(RMA.OpenNURBS.IOnInterval)">
            <summary>Convert interval value, or pair of values, to normalized parameter.</summary>
            <returns>
Normalized parameter x so that min*(1.0-x) + max*x = interval_parameter.
See Also: ON_Interval::ParameterAt
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.NormalizedParameterAt(System.Double)">
            <summary>Convert interval value, or pair of values, to normalized parameter.</summary>
            <returns>
Normalized parameter x so that min*(1.0-x) + max*x = interval_parameter.
See Also: ON_Interval::ParameterAt
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.ParameterAt(RMA.OpenNURBS.IOnInterval)">
            <summary>Convert normalized parameter to interval value, or pair of values.</summary>
            <returns>
Interval parameter min*(1.0-normalized_parameter) + max*normalized_parameter
See Also: ON_Interval::NormalizedParameterAt
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.ParameterAt(System.Double)">
            <summary>Convert normalized parameter to interval value, or pair of values.</summary>
            <returns>
Interval parameter min*(1.0-normalized_parameter) + max*normalized_parameter
See Also: ON_Interval::NormalizedParameterAt
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.Set(System.Double,System.Double)">
            <summary>Sets interval to [t0,t1]</summary>
            <param name="t0">[in]</param>
            <param name="t1">[in]</param>
            <remarks>
See Also: ON_Interval::ON_Interval( double, double )
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.Destroy">
            <summary>
Sets interval to (ON_UNSET_VALUE,ON_UNSET_VALUE)
See Also: ON_Interval::Set
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnInterval.m_t(System.Int32)">
            <value>
Interval = [m_t[0], m_t[1]]
</value>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.Includes(RMA.OpenNURBS.IOnInterval)">
            <summary>Test an interval to see if it is contained in this interval.</summary>
            <param name="other">[in] interval to test</param>
            <returns>
If bProperSubSet is false, then the result is true when this-&gt;Min() &lt;= other.Min() and other.Max() &lt;= this-&gt;Max().
If bProperSubSet is true, then the result is true when this-&gt;Min() &lt;= other.Min() and other.Max() &lt;= this-&gt;Max() and at least one of the inequalites is strict.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.Includes(RMA.OpenNURBS.IOnInterval,System.Boolean)">
            <summary>Test an interval to see if it is contained in this interval.</summary>
            <param name="other">[in] interval to test</param>
            <param name="bProperSubSet">[in] if true, then the test is for a proper subinterval.</param>
            <returns>
If bProperSubSet is false, then the result is true when this-&gt;Min() &lt;= other.Min() and other.Max() &lt;= this-&gt;Max().
If bProperSubSet is true, then the result is true when this-&gt;Min() &lt;= other.Min() and other.Max() &lt;= this-&gt;Max() and at least one of the inequalites is strict.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.Includes(System.Double)">
            <summary>Test a value t to see if it is inside the interval.</summary>
            <param name="t">[in] value to test</param>
            <returns>true if t is in the interval and false if t is not in the interval.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.Includes(System.Double,System.Boolean)">
            <summary>Test a value t to see if it is inside the interval.</summary>
            <param name="t">[in] value to test</param>
            <param name="bTestOpenInterval">
[in] If false, t is tested to see if it satisfies min &lt;= t &lt;= max.
If true, t is tested to see if it satisfies min &lt; t &lt; max.
</param>
            <returns>true if t is in the interval and false if t is not in the interval.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.Compare(RMA.OpenNURBS.IOnInterval)">
            <returns>
0 this is idential to other
-1 this[0] &lt; other[0]
+1 this[0] &gt; other[0]
-1 this[0] == other[0] and this[1] &lt; other[1]
+1 this[0] == other[0] and this[1] &gt; other[1]
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.IsValid">
            <summary>
returns ON_IsValid(m_t[0]) &amp;&amp; ON_IsValid(m_t[1])
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.IsEmptySet">
            <summary>
returns true if m_t[0] == m_t[1] == ON_UNSET_VALUE
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.IsSingleton">
            <summary>
returns true if m_t[0] == m_t[1] != ON_UNSET_VALUE
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.IsInterval">
            <summary>
returns truc if m_t[0] != m_t[1]
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.IsDecreasing">
            <summary>
returns true if m_t[0] &gt; m_t[0];
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.IsIncreasing">
            <summary>
returns true if m_t[0] &lt; m_t[1]
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.Mid">
            <summary>
returns 0.5*(m_t[0] + m_t[1])
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.Max">
            <summary>
returns larger of m_t[0] and m_t[1]
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.Min">
            <summary>
returns smaller of m_t[0] and m_t[1]
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.NormalizedParameterAt(RMA.OpenNURBS.IOnInterval)">
            <summary>Convert interval value, or pair of values, to normalized parameter.</summary>
            <returns>
Normalized parameter x so that min*(1.0-x) + max*x = interval_parameter.
See Also: ON_Interval::ParameterAt
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.NormalizedParameterAt(System.Double)">
            <summary>Convert interval value, or pair of values, to normalized parameter.</summary>
            <returns>
Normalized parameter x so that min*(1.0-x) + max*x = interval_parameter.
See Also: ON_Interval::ParameterAt
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.ParameterAt(RMA.OpenNURBS.IOnInterval)">
            <summary>Convert normalized parameter to interval value, or pair of values.</summary>
            <returns>
Interval parameter min*(1.0-normalized_parameter) + max*normalized_parameter
See Also: ON_Interval::NormalizedParameterAt
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.ParameterAt(System.Double)">
            <summary>Convert normalized parameter to interval value, or pair of values.</summary>
            <returns>
Interval parameter min*(1.0-normalized_parameter) + max*normalized_parameter
See Also: ON_Interval::NormalizedParameterAt
</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnInterval.m_t(System.Int32)">
            <value>
Interval = [m_t[0], m_t[1]]
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnLinetypeSegment.m_length">
            <value>
length in millimeters on printed output
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLinetypeSegment.m_length">
            <value>
length in millimeters on printed output
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnLinetypeSegment.eSegType">
            <summary>
For a curve to be drawn starting at the start point
and ending at the endpoint, the first segment
in the pattern must be a stLine type
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnDisplayMaterialRef.#ctor">
            <summary>
Description: Default constructor sets both ids to nil.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDisplayMaterialRef.m_invisible_in_detail_id">
            <value>
For Rhino V4 the per detail visibility attribute is implemented through a
display material reference on an object. This is ONLY for for detail viewports
and only for V4. Keep this uuid around so the per detail attributes in future
versions of Rhino can be implemented a different way
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnDisplayMaterialRef.m_display_material_id">
            <value>
identifies the ON_DisplayMaterial
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnDisplayMaterialRef.m_viewport_id">
            <value>
identifies the ON_Viewport
If nil, then the display material will be used in all viewports
that are not explictly referenced in other ON_DisplayMaterialRefs.
</value>
        </member>
        <member name="T:RMA.OpenNURBS.OnDisplayMaterialRef">
            <summary>
Objects can have per viewport display properties that override a viewport's default display
properties.  These overrides are stored on ON_3dmObjectAttributes as a list of ON_DisplayMaterialRefs.
 
For example, by default a viewport might display objects using a wireframe, but
one special object may need to be shaded. In this case the special object would have
a display material ref with the "wireframe" viewport's id and the id of a display material
that specified shading.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDisplayMaterialRef.m_display_material_id">
            <value>
identifies the ON_DisplayMaterial
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDisplayMaterialRef.m_viewport_id">
            <value>
identifies the ON_Viewport
If nil, then the display material will be used in all viewports
that are not explictly referenced in other ON_DisplayMaterialRefs.
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnDisplayMaterialRef">
            <summary>
Objects can have per viewport display properties that override a viewport's default display
properties.  These overrides are stored on ON_3dmObjectAttributes as a list of ON_DisplayMaterialRefs.
 
For example, by default a viewport might display objects using a wireframe, but
one special object may need to be shaded. In this case the special object would have
a display material ref with the "wireframe" viewport's id and the id of a display material
that specified shading.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.Value">
            <summary>
Returns 0.0 (black) to 1.0 (white)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.Saturation">
            <summary>
Returns 0.0 (gray) to 1.0 (saturated)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.Hue">
            <summary>
returns an angle in the range 0 to 2*pi 
0 = red, pi/3 = yellow, 2*pi/3 = green, 
pi = cyan, 4*pi/3 = blue,5*pi/3 = magenta,
2*pi = red
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.SetFractionalRGBA(System.Double,System.Double,System.Double,System.Double)">
            <summary>
input args
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.SetRGB(System.Int32,System.Int32,System.Int32)">
            <summary>
0 to 255
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.FractionAlpha">
            <summary>
( 0.0 to 1.0 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.FractionBlue">
            <summary>
( 0.0 to 1.0 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.FractionGreen">
            <summary>
( 0.0 to 1.0 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.FractionRed">
            <summary>
( 0.0 to 1.0 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.Alpha">
            <summary>
( 0 to 255 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.Blue">
            <summary>
( 0 to 255 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.Green">
            <summary>
( 0 to 255 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.Red">
            <summary>
( 0 to 255 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.Compare(RMA.OpenNURBS.IOnColor)">
            <summary>
&lt; 0 if this &lt; arg, 0 ir this==arg, &gt; 0 if this &gt; arg
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.op_Implicit(RMA.OpenNURBS.OnColor)~System.UInt32">
            <summary>
Conversion to COLORREF
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.#ctor(System.UInt32)">
            <summary>
Construct from COLORREF
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
( 0 to 255 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
( 0 to 255 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.#ctor">
            <summary>
Default is black
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnColor.Value">
            <summary>
Returns 0.0 (black) to 1.0 (white)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnColor.Saturation">
            <summary>
Returns 0.0 (gray) to 1.0 (saturated)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnColor.Hue">
            <summary>
returns an angle in the range 0 to 2*pi 
0 = red, pi/3 = yellow, 2*pi/3 = green, 
pi = cyan, 4*pi/3 = blue,5*pi/3 = magenta,
2*pi = red
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnColor.FractionAlpha">
            <summary>
( 0.0 to 1.0 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnColor.FractionBlue">
            <summary>
( 0.0 to 1.0 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnColor.FractionGreen">
            <summary>
( 0.0 to 1.0 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnColor.FractionRed">
            <summary>
( 0.0 to 1.0 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnColor.Alpha">
            <summary>
( 0 to 255 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnColor.Blue">
            <summary>
( 0 to 255 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnColor.Green">
            <summary>
( 0 to 255 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnColor.Red">
            <summary>
( 0 to 255 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnColor.Compare(RMA.OpenNURBS.IOnColor)">
            <summary>
&lt; 0 if this &lt; arg, 0 ir this==arg, &gt; 0 if this &gt; arg
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUnitSystem.Default">
            <summary>
millimeters = default unit system
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUnitSystem.#ctor">
            <summary>
default constructor units are millimeters.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnUnitSystem.m_custom_unit_name">
            <value>
name of custom units
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnUnitSystem.m_custom_unit_scale">
            <value>
The m_custom_unit_... settings apply when m_unit_system = ON::custom_unit_system
1 meter = m_custom_unit_scale custom units
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnUnitSystem.m_custom_unit_name">
            <value>
name of custom units
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnUnitSystem.m_custom_unit_scale">
            <value>
The m_custom_unit_... settings apply when m_unit_system = ON::custom_unit_system
1 meter = m_custom_unit_scale custom units
</value>
        </member>
        <member name="M:RMA.OpenNURBS.OnCheckSum.CheckFile(System.String)">
            <summary>Test buffer to see if it has a matching checksum.</summary>
            <param name="filename">[in]</param>
            <returns>True if the file has a matching checksum.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCheckSum.CheckFile(System.String,System.Boolean)">
            <summary>Test buffer to see if it has a matching checksum.</summary>
            <param name="filename">[in]</param>
            <param name="bSkipTimeCheck">[in] if true, the time of last modification is not checked.</param>
            <returns>True if the file has a matching checksum.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCheckSum.CheckFile(RMA.OpenNURBS.OnFileHandle)">
            <summary>Test buffer to see if it has a matching checksum.</summary>
            <param name="fp">[in] pointer to file opened with ON::OpenFile(...,L"rb")</param>
            <returns>True if the file has a matching checksum.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCheckSum.CheckFile(RMA.OpenNURBS.OnFileHandle,System.Boolean)">
            <summary>Test buffer to see if it has a matching checksum.</summary>
            <param name="fp">[in] pointer to file opened with ON::OpenFile(...,L"rb")</param>
            <param name="bSkipTimeCheck">[in] if true, the time of last modification is not checked.</param>
            <returns>True if the file has a matching checksum.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCheckSum.SetFileCheckSum(System.String)">
            <summary>Set check sum values for a file.</summary>
            <param name="filename">[in] name of file.</param>
            <returns>True if checksum is set.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCheckSum.SetFileCheckSum(RMA.OpenNURBS.OnFileHandle)">
            <summary>Set check sum values for a file.</summary>
            <param name="fp">[in] pointer to a file opened with ON:FileOpen(...,L"rb")</param>
            <returns>True if checksum is set.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCheckSum.IsSet">
            <summary>
Returns: True if checksum is set.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCheckSum.Zero">
            <summary>
zeros all fields.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnCheckSum.m_crc(System.Int32)">
            <value>
crc's
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnCheckSum.m_time">
            <value>
UCT seconds since Jan 1, 1970
</value>
        </member>
        <member name="T:RMA.OpenNURBS.OnCheckSum">
            <summary>
This class is intended to be used to determine if a file's
contents have changed.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCheckSum.CheckFile(System.String)">
            <summary>Test buffer to see if it has a matching checksum.</summary>
            <param name="filename">[in]</param>
            <returns>True if the file has a matching checksum.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCheckSum.CheckFile(System.String,System.Boolean)">
            <summary>Test buffer to see if it has a matching checksum.</summary>
            <param name="filename">[in]</param>
            <param name="bSkipTimeCheck">[in] if true, the time of last modification is not checked.</param>
            <returns>True if the file has a matching checksum.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCheckSum.CheckFile(RMA.OpenNURBS.OnFileHandle)">
            <summary>Test buffer to see if it has a matching checksum.</summary>
            <param name="fp">[in] pointer to file opened with ON::OpenFile(...,L"rb")</param>
            <returns>True if the file has a matching checksum.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCheckSum.CheckFile(RMA.OpenNURBS.OnFileHandle,System.Boolean)">
            <summary>Test buffer to see if it has a matching checksum.</summary>
            <param name="fp">[in] pointer to file opened with ON::OpenFile(...,L"rb")</param>
            <param name="bSkipTimeCheck">[in] if true, the time of last modification is not checked.</param>
            <returns>True if the file has a matching checksum.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCheckSum.IsSet">
            <summary>
Returns: True if checksum is set.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnCheckSum.m_crc(System.Int32)">
            <value>
crc's
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnCheckSum.m_time">
            <value>
UCT seconds since Jan 1, 1970
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnCheckSum">
            <summary>
This class is intended to be used to determine if a file's
contents have changed.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnFileHandle">
            <summary>Wraps a FILE* for opening and closing OpenNURBS model files</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidIndex.CompareIndex(RMA.OpenNURBS.IOnUuidIndex,RMA.OpenNURBS.IOnUuidIndex)">
            <summary>Compare m_i and ignore m_id.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidIndex.CompareId(RMA.OpenNURBS.IOnUuidIndex,RMA.OpenNURBS.IOnUuidIndex)">
            <summary>Compare m_id and ignore m_i.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidIndex.CompareIndexAndId(RMA.OpenNURBS.IOnUuidIndex,RMA.OpenNURBS.IOnUuidIndex)">
            <summary>Dictionary compare m_id and then m_i.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidIndex.CompareIdAndIndex(RMA.OpenNURBS.IOnUuidIndex,RMA.OpenNURBS.IOnUuidIndex)">
            <summary>Dictionary compare m_id and then m_i.</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnUuidIndex.m_i">
            <value>
In cases when there is a discrepancy between the m_id and
m_i, m_id is assumed to be valid unless comments where this
class is used indicate otherwise.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.OnUuidIndex.m_id">
            <value>
In cases when there is a discrepancy between the m_id and
m_i, m_id is assumed to be valid unless comments where this
class is used indicate otherwise.
</value>
        </member>
        <member name="T:RMA.OpenNURBS.OnUuidIndex">
            <summary>
This class is used by ON_UuidIndexList.  It is used when
uuids are used to search for items that can be found by
an integer index.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnUuidIndex.m_i">
            <value>
In cases when there is a discrepancy between the m_id and
m_i, m_id is assumed to be valid unless comments where this
class is used indicate otherwise.
</value>
        </member>
        <member name="P:RMA.OpenNURBS.IOnUuidIndex.m_id">
            <value>
In cases when there is a discrepancy between the m_id and
m_i, m_id is assumed to be valid unless comments where this
class is used indicate otherwise.
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnUuidIndex">
            <summary>
This class is used by ON_UuidIndexList.  It is used when
uuids are used to search for items that can be found by
an integer index.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCOMPONENT_INDEX.IsAnnotationComponentIndex">
            <summary>
Returns: True if m_type = dim_... and m_index &gt;= 0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCOMPONENT_INDEX.IsPointCloudComponentIndex">
            <summary>
Returns: True if m_type = pointcloud_point and m_index &gt;= 0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCOMPONENT_INDEX.IsGroupMemberComponentIndex">
            <summary>
Returns: True if m_type = group_member and m_index &gt;= 0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCOMPONENT_INDEX.IsPolyCurveComponentIndex">
            <summary>
Returns: True if m_type = polycurve_segment and m_index &gt;= 0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCOMPONENT_INDEX.IsIDefComponentIndex">
            <summary>
Returns: True if m_type = idef_part and m_index &gt;= 0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCOMPONENT_INDEX.IsBrepComponentIndex">
            <summary>
Returns: True if m_type is set to one of the brep TYPE enum values and m_index &gt;= 0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCOMPONENT_INDEX.IsMeshComponentIndex">
            <summary>
Returns: True if m_type is set to one of the mesh or meshtop TYPE enum values and m_index &gt;= 0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCOMPONENT_INDEX.IsSet">
            <summary>
Returns: True if m_type is set to a TYPE enum value between brep_vertex and polycurve_segment.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCOMPONENT_INDEX.UnSet">
            <summary>
Sets m_type = invalid_type and m_index = -1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCOMPONENT_INDEX.#ctor(RMA.OpenNURBS.IOnCOMPONENT_INDEX.TYPE,System.Int32)">
            <summary>
Sets m_type = type and m_index = index.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCOMPONENT_INDEX.#ctor">
            <summary>
Sets m_type = invalid_type and m_index = -1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCOMPONENT_INDEX.Compare(RMA.OpenNURBS.IOnCOMPONENT_INDEX,RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Dictionary compare on m_type, m_index as ints.</summary>
            <returns>
&lt; 0: a &lt; b
= 0: a = b
&gt; 0: a &gt; b
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCOMPONENT_INDEX.Type(System.Int32)">
            <summary>Safe conversion of integer value to TYPE enum.</summary>
            <param name="i">[in] integer with value equal to one of the TYPE enums.</param>
            <returns>
The TYPE enum with the same numeric value or
ON_COMPONENT_INDEX::invalid_type if no corresponding enum exists.
</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnCOMPONENT_INDEX.m_index">
            <value>
The interpretation of m_index depends on the m_type value. m_type m_index interpretation (0 based indices) no_type used when context makes it clear what array is being index brep_vertex ON_Brep.m_V[] array index brep_edge ON_Brep.m_E[] array index brep_face ON_Brep.m_F[] array index brep_trim ON_Brep.m_T[] array index brep_loop ON_Brep.m_L[] array index mesh_vertex ON_Mesh.m_V[] array index meshtop_vertex ON_MeshTopology.m_topv[] array index meshtop_edge ON_MeshTopology.m_tope[] array index mesh_face ON_Mesh.m_F[] array index idef_part ON_InstanceDefinition.m_object_uuid[] array index polycurve_segment ON_PolyCurve::m_segment[] array index dim_linear_point ON_LinearDimension2::POINT_INDEX dim_radial_point ON_RadialDimension2::POINT_INDEX dim_angular_point ON_AngularDimension2::POINT_INDEX dim_ordinate_point ON_OrdinateDimension2::POINT_INDEX dim_text_point ON_TextEntity2 origin point
</value>
        </member>
        <member name="T:RMA.OpenNURBS.OnCOMPONENT_INDEX">
            <summary>
Component indices are used to provide a persistent way
to identify portions of complex objects.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCOMPONENT_INDEX.IsAnnotationComponentIndex">
            <summary>
Returns: True if m_type = dim_... and m_index &gt;= 0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCOMPONENT_INDEX.IsPointCloudComponentIndex">
            <summary>
Returns: True if m_type = pointcloud_point and m_index &gt;= 0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCOMPONENT_INDEX.IsGroupMemberComponentIndex">
            <summary>
Returns: True if m_type = group_member and m_index &gt;= 0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCOMPONENT_INDEX.IsPolyCurveComponentIndex">
            <summary>
Returns: True if m_type = polycurve_segment and m_index &gt;= 0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCOMPONENT_INDEX.IsIDefComponentIndex">
            <summary>
Returns: True if m_type = idef_part and m_index &gt;= 0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCOMPONENT_INDEX.IsBrepComponentIndex">
            <summary>
Returns: True if m_type is set to one of the brep TYPE enum values and m_index &gt;= 0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCOMPONENT_INDEX.IsMeshComponentIndex">
            <summary>
Returns: True if m_type is set to one of the mesh or meshtop TYPE enum values and m_index &gt;= 0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCOMPONENT_INDEX.IsSet">
            <summary>
Returns: True if m_type is set to a TYPE enum value between brep_vertex and polycurve_segment.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnCOMPONENT_INDEX.m_index">
            <value>
The interpretation of m_index depends on the m_type value. m_type m_index interpretation (0 based indices) no_type used when context makes it clear what array is being index brep_vertex ON_Brep.m_V[] array index brep_edge ON_Brep.m_E[] array index brep_face ON_Brep.m_F[] array index brep_trim ON_Brep.m_T[] array index brep_loop ON_Brep.m_L[] array index mesh_vertex ON_Mesh.m_V[] array index meshtop_vertex ON_MeshTopology.m_topv[] array index meshtop_edge ON_MeshTopology.m_tope[] array index mesh_face ON_Mesh.m_F[] array index idef_part ON_InstanceDefinition.m_object_uuid[] array index polycurve_segment ON_PolyCurve::m_segment[] array index dim_linear_point ON_LinearDimension2::POINT_INDEX dim_radial_point ON_RadialDimension2::POINT_INDEX dim_angular_point ON_AngularDimension2::POINT_INDEX dim_ordinate_point ON_OrdinateDimension2::POINT_INDEX dim_text_point ON_TextEntity2 origin point
</value>
        </member>
        <member name="T:RMA.OpenNURBS.IOnCOMPONENT_INDEX">
            <summary>
Component indices are used to provide a persistent way
to identify portions of complex objects.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.TypeCodes.TC_COMMENTBLOCK">
            <value>
The TCODE_COMMENTBLOCK is the first chunk in the file, starts 32 bytes into
the file, and contains text information terminated with a ^Z.  This ^Z and
contents of this chunk were expanded in February 2000.  Files written with
code released earlier than this will not have the ^Z.

The TCODE_ENDOFFILE is the last chunk in the file and the first 4 bytes
of information in this chunk is an integer that contains the file length.
This chunk was added in February 2000 and files written with code released
earlier than this will not have this termination block.
</value>
        </member>
        <member name="T:RMA.OpenNURBS.TypeCodes">
            <summary>
Typecode format 4 bytes long
x xxxxxxxxxxxxxxx,x xxx xxxx xxxx x x xx
| |               | |               | |  |
|        |        |                 |
|        |        |         |       +---  "stuff" bit
|        |        |         |
|        |        |         +-- specific codes
|        |        |
|        |        +-- RESERVED - DO NOT USE (should be 0) (will be used to control CRC on/off)
|        |
|        +-- category:_000 0000 0000 0001  Legacy geometry    TCODE_LEGACY_GEOMETRY
|                     _000 0000 0000 0010  openNURBS object   TCODE_OPENNURBS_OBJECT
|                     _000 0000 0000 0100  -- RESERVED - DO NOT USE (should be 0 in any typecode) -- 
|                     _000 0000 0000 1000  -- RESERVED - DO NOT USE (should be 0 in any typecode) --                     
|                     _000 0000 0001 0000  Geometry           TCODE_GEOMETRY
|                     _000 0000 0010 0000  Annotation
|                     _000 0000 0100 0000  Display Attributes TCODE_DISPLAY
|                     _000 0000 1000 0000  Rendering          TCODE_RENDER     
|                     _000 0001 0000 0000                         
|                     _000 0010 0000 0000  Interface          TCODE_INTERFACE 
|                     _000 0100 0000 0000  -- RESERVED - DO NOT USE (should be 0 in any typecode) --
|                     _000 1000 0000 0000  Tolerances         TCODE_TOLERANCE
|                     _001 0000 0000 0000  Tables             TCODE_TABLE    
|                     _010 0000 0000 0000  Table record       TCODE_TABLEREC
|                     _100 0000 0000 0000  User information   TCODE_USER
| 
+-- format: 0 - data size in header  - data block follows    TCODE_SHORT
           1 - data in header - no data block follows
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn4fPoint.CopyToArray">
            <summary>
Create an array of floats[count*4] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(0).z
array[3] = At(0).w
array[4] = At(1).x
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn4fPoint.TryFastGet(System.Int32,System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn4fPoint.W(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn4fPoint.Z(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn4fPoint.Y(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn4fPoint.X(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn4fPoint.CopyToArray">
            <summary>
Create an array of floats[count*4] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(0).z
array[3] = At(0).w
array[4] = At(1).x
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn4fPoint.TryFastGet(System.Int32,System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn4fPoint.W(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn4fPoint.Z(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn4fPoint.Y(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn4fPoint.X(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn4dPoint.CopyToArray">
            <summary>
Create an array of doubles[count*4] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(0).z
array[3] = At(0).w
array[4] = At(1).x
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn4dPoint.TryFastGet(System.Int32,System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn4dPoint.W(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn4dPoint.Z(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn4dPoint.Y(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn4dPoint.X(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn4dPoint.CopyToArray">
            <summary>
Create an array of doubles[count*4] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(0).z
array[3] = At(0).w
array[4] = At(1).x
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn4dPoint.TryFastGet(System.Int32,System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn4dPoint.W(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn4dPoint.Z(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn4dPoint.Y(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn4dPoint.X(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn3fVector.CopyToArray">
            <summary>
Create an array of floats[count*3] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(0).z
array[3] = At(1).x
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn3fVector.TryFastGet(System.Int32,System.Single@,System.Single@,System.Single@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn3fVector.Z(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn3fVector.Y(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn3fVector.X(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn3fVector.CopyToArray">
            <summary>
Create an array of floats[count*3] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(0).z
array[3] = At(1).x
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn3fVector.TryFastGet(System.Int32,System.Single@,System.Single@,System.Single@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn3fVector.Z(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn3fVector.Y(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn3fVector.X(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn3fPoint.CopyToArray">
            <summary>
Create an array of floats[count*3] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(0).z
array[3] = At(1).x
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn3fPoint.TryFastGet(System.Int32,System.Single@,System.Single@,System.Single@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn3fPoint.Z(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn3fPoint.Y(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn3fPoint.X(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn3fPoint.CopyToArray">
            <summary>
Create an array of floats[count*3] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(0).z
array[3] = At(1).x
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn3fPoint.TryFastGet(System.Int32,System.Single@,System.Single@,System.Single@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn3fPoint.Z(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn3fPoint.Y(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn3fPoint.X(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn3dVector.CopyToArray">
            <summary>
Create an array of doubles[count*3] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(0).z
array[3] = At(1).x
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn3dVector.TryFastGet(System.Int32,System.Double@,System.Double@,System.Double@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn3dVector.Z(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn3dVector.Y(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn3dVector.X(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn3dVector.CopyToArray">
            <summary>
Create an array of doubles[count*3] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(0).z
array[3] = At(1).x
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn3dVector.TryFastGet(System.Int32,System.Double@,System.Double@,System.Double@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn3dVector.Z(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn3dVector.Y(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn3dVector.X(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn3dPoint.CopyToArray">
            <summary>
Create an array of doubles[count*3] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(0).z
array[3] = At(1).x
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn3dPoint.TryFastGet(System.Int32,System.Double@,System.Double@,System.Double@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn3dPoint.Z(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn3dPoint.Y(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn3dPoint.X(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn3dPoint.CopyToArray">
            <summary>
Create an array of doubles[count*3] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(0).z
array[3] = At(1).x
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn3dPoint.TryFastGet(System.Int32,System.Double@,System.Double@,System.Double@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn3dPoint.Z(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn3dPoint.Y(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn3dPoint.X(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn2fVector.CopyToArray">
            <summary>
Create an array of floats[count*2] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(1).x
array[3] = At(1).y
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn2fVector.TryFastGet(System.Int32,System.Single@,System.Single@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn2fVector.Y(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn2fVector.X(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn2fVector.CopyToArray">
            <summary>
Create an array of floats[count*2] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(1).x
array[3] = At(1).y
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn2fVector.TryFastGet(System.Int32,System.Single@,System.Single@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn2fVector.Y(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn2fVector.X(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn2fPoint.CopyToArray">
            <summary>
Create an array of floats[count*2] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(1).x
array[3] = At(1).y
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn2fPoint.TryFastGet(System.Int32,System.Single@,System.Single@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn2fPoint.Y(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn2fPoint.X(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn2fPoint.CopyToArray">
            <summary>
Create an array of floats[count*2] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(1).x
array[3] = At(1).y
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn2fPoint.TryFastGet(System.Int32,System.Single@,System.Single@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn2fPoint.Y(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn2fPoint.X(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn2dVector.CopyToArray">
            <summary>
Create an array of doubles[count*2] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(1).x
array[3] = At(1).y
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn2dVector.TryFastGet(System.Int32,System.Double@,System.Double@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn2dVector.Y(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn2dVector.X(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn2dVector.CopyToArray">
            <summary>
Create an array of doubles[count*2] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(1).x
array[3] = At(1).y
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn2dVector.TryFastGet(System.Int32,System.Double@,System.Double@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn2dVector.Y(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn2dVector.X(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn2dPoint.CopyToArray">
            <summary>
Create an array of doubles[count*2] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(1).x
array[3] = At(1).y
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn2dPoint.TryFastGet(System.Int32,System.Double@,System.Double@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn2dPoint.Y(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn2dPoint.X(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn2dPoint.CopyToArray">
            <summary>
Create an array of doubles[count*2] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(1).x
array[3] = At(1).y
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn2dPoint.TryFastGet(System.Int32,System.Double@,System.Double@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn2dPoint.Y(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn2dPoint.X(System.Int32)">
            <value>Fast access to internal value in array</value>
        </member>
        <member name="M:CRhinoDisplayConduit.Disable">
 custom drawing activity.
</member>
        <member name="M:CRhinoViewport.Flush">
void SetZBufferRange( ON_Interval zbuffer_range );
</member>
        <member name="M:CRhinoUiOptionsListCtrlItem.SetIsFullRowItem(System.Boolean)">
 text in the enitre row.
</member>
        <member name="M:CRhinoUiOptionsListCtrlItem.IsFullRowItem">
 text in the enitre row.
</member>
        <member name="M:CRhinoUiDockBarManager.LockDockingLocation(System.Boolean)">
 be moved and any floating dock bar may be moved around but not docked.  This
</member>
        <member name="M:CRhinoUiDockBarManager.DockingLocationLocked">
 be moved and any floating dock bar may be moved around but not docked.  This
</member>
        <member name="M:CRhinoUiDockBar.OnToggleDocking(System.Boolean)">
 toggled.
</member>
        <member name="M:CRhinoObject.EnableAnalysisMode(_GUID,System.Boolean)">
*
</member>
        <member name="D:HTHEME">
DO NOT USE //// pragma once
</member>
        <member name="M:TL_GetClosestPoint(ON_BezierCurve!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double*,System.Double)">
  Closest Point Computations  ////////////////////////////////////// */
</member>
        <member name="M:TL_PickLine(ON_ClippingRegion!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,TL_PICK_STYLE!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
*
</member>
        <member name="M:TL_DebugWriteObject(ON_Object!System.Runtime.CompilerServices.IsConst*)">
C structure typedefs ***************************************************
</member>
        <member name="T:tagTL_USERDATA">
generic user data container used in various structures ****************
</member>
        <member name="M:TL_UserBreak">
CPU endianess *********************************************************
INPUT CHECKING, WARNINGS and ERRORS ************************************
</member>
        <member name="T:RMA.SubClasser">
            <summary>
Empty value class used for internal purposes when subclassing managed class.
The only time that this may be useful from a plug-in is for C++ extension DLLs.
Expert Level Tool: DO NOT use this class unless you absolutely know what you are doing with it.
</summary>
        </member>
        <member name="T:RMA.ConstException">
            <summary>
Rhino.NET wraps unmanaged C++ classes. const versions of classes are exposed as interfaces
to .NET. If a developer attempts to cast a const interface up to its non-const class implementation,
the .NET framework will allow this. When the user later tries to call a non-const function on this
const wrapped class, a ConstException will be thrown.
</summary>
        </member>
        <member name="M:ON_NurbsCurve.GetSpanVector(System.Double*)">
     (m_knot[m_order-2],...,m_knot[m_cv_count-1)
</member>
    </members>
</doc>